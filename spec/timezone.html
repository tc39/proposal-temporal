<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-timezone-objects">
  <h1>Temporal.TimeZone Objects</h1>
  <p>A Temporal.TimeZone object is an Object referencing a time zone.</p>

  <emu-clause id="sec-temporal-timezone-constructor">
    <h1>The Temporal.TimeZone Constructor</h1>
    <p>The Temporal.TimeZone constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.TimeZone object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.TimeZone behaviour must
        include a super call to the %Temporal.TimeZone% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.timezone">
      <h1>Temporal.TimeZone ( _identifier_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If _identifier_ is not a String, throw a *TypeError* exception.
        1. Let _parseResult_ be ? ParseTimeZoneIdentifier(_identifier_).
        1. If _parseResult_.[[OffsetMinutes]] is not ~empty~, then
          1. Set _identifier_ to FormatOffsetTimeZoneIdentifier(_parseResult_.[[OffsetMinutes]]).
        1. Else,
          1. Let _timeZoneIdentifierRecord_ be GetAvailableNamedTimeZoneIdentifier(_identifier_).
          1. If _timeZoneIdentifierRecord_ is ~empty~, throw a *RangeError* exception.
          1. Set _identifier_ to _timeZoneIdentifierRecord_.[[Identifier]].
        1. Return ? CreateTemporalTimeZone(_identifier_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-timezone-constructor">
    <h1>Properties of the Temporal.TimeZone Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.TimeZone constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.TimeZone constructor has the following properties:</p>

    <emu-clause id="sec-temporal.timezone.prototype">
      <h1>Temporal.TimeZone.prototype</h1>
      <p>The initial value of `Temporal.TimeZone.prototype` is %Temporal.TimeZone.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.from">
      <h1>Temporal.TimeZone.from ( _item_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _slotValue_ be ? ToTemporalTimeZoneSlotValue(_item_).
        1. Return ToTemporalTimeZoneObject(_slotValue_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-timezone-prototype-object">
    <h1>Properties of the Temporal.TimeZone Prototype Object</h1>

    <p>The Temporal.TimeZone prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.TimeZone instance and does not have a [[InitializedTemporalTimeZone]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.timezone.prototype.constructor">
      <h1>Temporal.TimeZone.prototype.constructor</h1>
      <p>The initial value of `Temporal.TimeZone.prototype.constructor` is %Temporal.TimeZone%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype-@@tostringtag">
      <h1>Temporal.TimeZone.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the String value *"Temporal.TimeZone"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.timezone.prototype.id">
      <h1>get Temporal.TimeZone.prototype.id</h1>
      <p>
        `Temporal.TimeZone.prototype.id` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. If _timeZone_.[[OffsetMinutes]] is not ~empty~, return FormatOffsetTimeZoneIdentifier(_timeZone_.[[OffsetMinutes]]).
        1. Return _timeZone_.[[Identifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.equals">
      <h1>Temporal.TimeZone.prototype.equals ( _timeZoneLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. Let _other_ be ? ToTemporalTimeZoneSlotValue(_timeZoneLike_).
        1. Return ? TimeZoneEquals(_timeZone_, _other_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.getoffsetnanosecondsfor">
      <h1>Temporal.TimeZone.prototype.getOffsetNanosecondsFor ( _instant_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. Set _instant_ to ? ToTemporalInstant(_instant_).
        1. If _timeZone_.[[OffsetMinutes]] is not ~empty~, return ùîΩ(_timeZone_.[[OffsetMinutes]] √ó (60 √ó 10<sup>9</sup>)).
        1. Return ùîΩ(GetNamedTimeZoneOffsetNanoseconds(_timeZone_.[[Identifier]], _instant_.[[Nanoseconds]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.getoffsetstringfor">
      <h1>Temporal.TimeZone.prototype.getOffsetStringFor ( _instant_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. Set _instant_ to ? ToTemporalInstant(_instant_).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_timeZone_, ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Return ? GetOffsetStringFor(_timeZoneRec_, _instant_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.getplaindatetimefor">
      <h1>Temporal.TimeZone.prototype.getPlainDateTimeFor ( _instant_ [ , _calendarLike_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. Set _instant_ to ? ToTemporalInstant(_instant_).
        1. Let _calendar_ be ? ToTemporalCalendarSlotValue(_calendarLike_, *"iso8601"*).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_timeZone_, ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Return ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.getinstantfor">
      <h1>Temporal.TimeZone.prototype.getInstantFor ( _dateTime_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. Set _dateTime_ to ? ToTemporalDateTime(_dateTime_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_timeZone_, ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Return ? GetInstantFor(_timeZoneRec_, _dateTime_, _disambiguation_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.getpossibleinstantsfor">
      <h1>Temporal.TimeZone.prototype.getPossibleInstantsFor ( _dateTime_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. Set _dateTime_ to ? ToTemporalDateTime(_dateTime_).
        1. If _timeZone_.[[OffsetMinutes]] is not ~empty~, then
          1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _timeZone_.[[OffsetMinutes]] √ó (60 √ó 10<sup>9</sup>)).
          1. Let _possibleEpochNanoseconds_ be ¬´ _epochNanoseconds_ ¬ª.
        1. Else,
          1. Let _possibleEpochNanoseconds_ be GetNamedTimeZoneEpochNanoseconds(_timeZone_.[[Identifier]], _dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]]).
        1. Let _possibleInstants_ be a new empty List.
        1. For each value _epochNanoseconds_ in _possibleEpochNanoseconds_, do
          1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
          1. Let _instant_ be ! CreateTemporalInstant(_epochNanoseconds_).
          1. Append _instant_ to _possibleInstants_.
        1. Return CreateArrayFromList(_possibleInstants_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.getnexttransition">
      <h1>Temporal.TimeZone.prototype.getNextTransition ( _startingPoint_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. Set _startingPoint_ to ? ToTemporalInstant(_startingPoint_).
        1. If _timeZone_.[[OffsetMinutes]] is not ~empty~, return *null*.
        1. Let _transition_ be GetNamedTimeZoneNextTransition(_timeZone_.[[Identifier]], _startingPoint_.[[Nanoseconds]]).
        1. If _transition_ is *null*, return *null*.
        1. Return ! CreateTemporalInstant(_transition_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.getprevioustransition">
      <h1>Temporal.TimeZone.prototype.getPreviousTransition ( _startingPoint_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. Set _startingPoint_ to ? ToTemporalInstant(_startingPoint_).
        1. If _timeZone_.[[OffsetMinutes]] is not ~empty~, return *null*.
        1. Let _transition_ be GetNamedTimeZonePreviousTransition(_timeZone_.[[Identifier]], _startingPoint_.[[Nanoseconds]]).
        1. If _transition_ is *null*, return *null*.
        1. Return ! CreateTemporalInstant(_transition_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.tostring">
      <h1>Temporal.TimeZone.prototype.toString ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. If _timeZone_.[[OffsetMinutes]] is not ~empty~, return FormatOffsetTimeZoneIdentifier(_timeZone_.[[OffsetMinutes]]).
        1. Return _timeZone_.[[Identifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.timezone.prototype.tojson">
      <h1>Temporal.TimeZone.prototype.toJSON ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _timeZone_ be the *this* value.
        1. Perform ? RequireInternalSlot(_timeZone_, [[InitializedTemporalTimeZone]]).
        1. If _timeZone_.[[OffsetMinutes]] is not ~empty~, return FormatOffsetTimeZoneIdentifier(_timeZone_.[[OffsetMinutes]]).
        1. Return _timeZone_.[[Identifier]].
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-timezone-instances">
    <h1>Properties of Temporal.TimeZone Instances</h1>

    <p>
      Temporal.TimeZone instances are ordinary objects that inherit properties from the %Temporal.TimeZone.prototype% intrinsic object.
      Temporal.TimeZone instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaltimezone-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaltimezone-instances" caption="Internal Slots of Temporal.TimeZone Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalTimeZone]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.TimeZone instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[Identifier]]
            </td>
            <td>
              A String value representing the identifier of an available named time zone, or ~empty~ if the instance represents an offset time zone.
            </td>
          </tr>
          <tr>
            <td>
              [[OffsetMinutes]]
            </td>
            <td>
              An integer for minutes representing the constant offset of this time zone relative to UTC, or ~empty~ if the instance represents a named time zone.
              If not ~empty~, this value must be in the interval from -1440 (exclusive) to 1440 (exclusive) (i.e., strictly less than 24 hours in magnitude).
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-timezone-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-note type="editor">
      In ECMA-262, many time-zone-related sections and abstract operations are contained in the <a href="https://tc39.es/ecma262/#sec-date-objects">Date Objects</a> section of the specification.
      Now that ECMAScript has a built-in %Temporal.TimeZone% object, it may be appropriate to move those sections here, for example:
      <ul>
        <li><a href="https://tc39.es/ecma262/#sec-time-zone-identifiers">Time Zone Identifiers</a></li>
        <li>AvailableNamedTimeZoneIdentifiers</li>
        <li>SystemTimeZoneIdentifier</li>
        <li>IsTimeZoneOffsetString</li>
        <li>GetNamedTimeZoneEpochNanoseconds</li>
        <li>GetNamedTimeZoneOffsetNanoseconds</li>
      </ul>
    </emu-note>

    <emu-clause id="sec-temporal-time-zone-methods-records">
      <h1>Time Zone Methods Records</h1>
      <p>
        A <dfn variants="Time Zone Methods Records">Time Zone Methods Record</dfn> is a Record value used to store a Temporal.TimeZone object, or an Object implementing the time zone protocol, along with any methods that have been observably looked up on that object during the current operation.
        Time Zone Methods Records are produced by the abstract operation CreateTimeZoneMethodsRecord.
      </p>
      <p>
        Time Zone Methods Records have the fields listed in <emu-xref href="#table-temporal-time-zone-methods-record-fields"></emu-xref>.
      </p>
      <emu-table id="table-temporal-time-zone-methods-record-fields" caption="Time Zone Methods Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Receiver]]</td>
            <td>a String or Object</td>
            <td>
              The time zone object, or a string indicating a built-in time zone.
            </td>
          </tr>
          <tr>
            <td>[[GetOffsetNanosecondsFor]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The time zone's `getOffsetNanosecondsFor` method.
              For a built-in time zone this is always %Temporal.TimeZone.prototype.getOffsetNanosecondsFor%.
            </td>
          </tr>
          <tr>
            <td>[[GetPossibleInstantsFor]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The time zone's `getPossibleInstantsFor` method.
              For a built-in time zone this is always %Temporal.TimeZone.prototype.getPossibleInstantsFor%.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-createtimezonemethodsrecord" type="abstract operation">
      <h1>
        CreateTimeZoneMethodsRecord (
          _timeZone_: a String or Object,
          _methods_: a List of either ~get-offset-nanoseconds-for~ or ~get-possible-instants-for~,
        ): either a normal completion containing a Time Zone Methods Record, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Time Zone Methods Record from the given _timeZone_, looking up the methods given in _methods_.</dd>
      </dl>
      <emu-alg>
        1. Let _record_ be the Time Zone Methods Record {
            [[Receiver]]: _timeZone_,
            [[GetOffsetNanosecondsFor]]: *undefined*,
            [[GetPossibleInstantsFor]]: *undefined*
          }.
        1. For each element _methodName_ in _methods_, do
          1. Perform ? TimeZoneMethodsRecordLookup(_record_, _methodName_).
        1. Return _record_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-timezonemethodsrecordlookup" type="abstract operation">
      <h1>
        TimeZoneMethodsRecordLookup (
          _timeZoneRec_: a Time Zone Methods Record,
          _methodName_: ~get-offset-nanoseconds-for~ or ~get-possible-instants-for~,
        ): either a normal completion containing ~unused~, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It looks up the given method on the given time zone.
          For a built-in time zone, this lookup is unobservable and results in the intrinsic method.
          If the time zone is an Object, the lookup is observable and may result in a user-code method.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, _methodName_) is *false*.
        1. If _methodName_ is ~get-offset-nanoseconds-for~, then
          1. If _timeZoneRec_.[[Receiver]] is a String, then
            1. Set _timeZoneRec_.[[GetOffsetNanosecondsFor]] to %Temporal.TimeZone.prototype.getOffsetNanosecondsFor%.
          1. Else,
            1. Set _timeZoneRec_.[[GetOffsetNanosecondsFor]] to ? GetMethod(_timeZoneRec_.[[Receiver]], *"getOffsetNanosecondsFor"*).
            1. If _timeZoneRec_.[[GetOffsetNanosecondsFor]] is *undefined*, throw a *TypeError* exception.
        1. Else if _methodName_ is ~get-possible-instants-for~, then
          1. If _timeZoneRec_.[[Receiver]] is a String, then
            1. Set _timeZoneRec_.[[GetPossibleInstantsFor]] to %Temporal.TimeZone.prototype.getPossibleInstantsFor%.
          1. Else,
            1. Set _timeZoneRec_.[[GetPossibleInstantsFor]] to ? GetMethod(_timeZoneRec_.[[Receiver]], *"getPossibleInstantsFor"*).
            1. If _timeZoneRec_.[[GetPossibleInstantsFor]] is *undefined*, throw a *TypeError* exception.
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-timezonemethodsrecordhaslookedup" type="abstract operation">
      <h1>
        TimeZoneMethodsRecordHasLookedUp (
          _timeZoneRec_: a Time Zone Methods Record,
          _methodName_: ~get-offset-nanoseconds-for~ or ~get-possible-instants-for~,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines whether the given Time Zone Methods Record has already looked up the given method.</dd>
      </dl>
      <emu-alg>
        1. If _methodName_ is ~get-offset-nanoseconds-for~, then
          1. Let _method_ be _timeZoneRec_.[[GetOffsetNanosecondsFor]].
        1. Else if _methodName_ is ~get-possible-instants-for~, then
          1. Let _method_ be _timeZoneRec_.[[GetPossibleInstantsFor]].
        1. If _method_ is *undefined*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-timezonemethodsrecordisbuiltin" type="abstract operation">
      <h1>
        TimeZoneMethodsRecordIsBuiltin (
          _timeZoneRec_: a Time Zone Methods Record,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines whether the given Time Zone Methods Record represents a built-in time zone (that is never exposed to user code.)</dd>
      </dl>
      <emu-alg>
        1. If _timeZoneRec_.[[Receiver]] is a String, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-timezonemethodsrecordcall" type="abstract operation">
      <h1>
        TimeZoneMethodsRecordCall (
          _timeZoneRec_: a Time Zone Methods Record,
          _methodName_: ~get-offset-nanoseconds-for~ or ~get-possible-instants-for~,
          _arguments_: a List of ECMAScript language values,
        ): either a normal completion containing an ECMAScript language value, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the method _methodName_ stored in the Time Zone Methods Record, with the stored receiver as the receiver, and the given _arguments_, and returns the result.</dd>
      </dl>
      <emu-alg>
        1. Assert: TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, _methodName_) is *true*.
        1. Let _receiver_ be _timeZoneRec_.[[Receiver]].
        1. If TimeZoneMethodsRecordIsBuiltin(_timeZoneRec_) is *true*, then
          1. Set _receiver_ to ! CreateTemporalTimeZone(_timeZoneRec_.[[Receiver]]).
        1. If _methodName_ is ~get-offset-nanoseconds-for~, then
          1. Return ? Call(_timeZoneRec_.[[GetOffsetNanosecondsFor]], _receiver_, _arguments_).
        1. If _methodName_ is ~get-possible-instants-for~, then
          1. Return ? Call(_timeZoneRec_.[[GetPossibleInstantsFor]], _receiver_, _arguments_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaltimezone" type="abstract operation">
      <h1>
        CreateTemporalTimeZone (
          _identifier_: a String,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.TimeZone or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a new Temporal.TimeZone instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.TimeZone%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.TimeZone.prototype%"*, ¬´ [[InitializedTemporalTimeZone]], [[Identifier]], [[OffsetMinutes]] ¬ª).
        1. Assert: _identifier_ is an available named time zone identifier or an offset time zone identifier.
        1. Let _parseResult_ be ! ParseTimeZoneIdentifier(_identifier_).
        1. If _parseResult_.[[OffsetMinutes]] is not ~empty~, then
          1. Set _object_.[[Identifier]] to ~empty~.
          1. Set _object_.[[OffsetMinutes]] to _parseResult_.[[OffsetMinutes]].
        1. Else,
          1. Assert: _parseResult_.[[Name]] is not ~empty~.
          1. Assert: GetAvailableNamedTimeZoneIdentifier(_identifier_).[[Identifier]] is _identifier_.
          1. Set _object_.[[Identifier]] to _identifier_.
          1. Set _object_.[[OffsetMinutes]] to ~empty~.
        1. Return _object_.
      </emu-alg>

      <emu-note>
        <p>
          Most implementations support only a short, fixed list of available named time zone identifiers.
          For example, the IANA Time Zone Database in 2022 contained fewer than 600 identifiers.
          Although the [[Identifier]] internal slot is a String in this specification, implementations may choose to store named time zone identifiers it in any other form (for example as an enumeration or index into a List of identifier strings) as long as the String can be regenerated when needed.
        </p>
        <p>
          Similar flexibility exists for the storage of the [[OffsetMinutes]] internal slot, which can be interchangeably represented as a 12-bit signed integer or as a 6-character ¬±HH:MM String value.
          ParseTimeZoneIdentifier and FormatOffsetTimeZoneIdentifier may be used to losslessly convert one representation to the other.
          Implementations are free to store either or both representations.
        </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-getavailablenamedtimezoneidentifier" type="abstract operation">
      <h1>
        GetAvailableNamedTimeZoneIdentifier (
          _timeZoneIdentifier_: a String,
        ): either a Time Zone Identifier Record or ~empty~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          If _timeZoneIdentifier_ is an available named time zone identifier, then it returns one of the records in the List returned by AvailableNamedTimeZoneIdentifiers.
          Otherwise, ~empty~ will be returned.
        </dd>
      </dl>
      <emu-alg>
        1. For each element _record_ of AvailableNamedTimeZoneIdentifiers(), do
          1. If _record_.[[Identifier]] is an ASCII-case-insensitive match for _timeZoneIdentifier_, return _record_.
        1. Return ~empty~.
      </emu-alg>
      <emu-note>
        <p>
          For any _timeZoneIdentifier_, or any value that is an ASCII-case-insensitive match for it, the result of this operation must remain the same for the lifetime of the surrounding agent.
          Specifically, if that result is a Time Zone Identifier Record, its fields must contain the same values.
        </p>
        <p>
          Furthermore, time zone identifiers must not dynamically change from primary to non-primary or vice versa during the lifetime of the surrounding agent, meaning that if _timeZoneIdentifier_ is an ASCII-case-insensitive match for the [[PrimaryIdentifier]] field of the result of a previous call to GetAvailableNamedTimeZoneIdentifier, then GetAvailableNamedTimeZoneIdentifier(_timeZoneIdentifier_) must return a record where [[Identifier]] is [[PrimaryIdentifier]].
        </p>
        <p>
          Due to the complexity of supporting these requirements, it is recommended that the result of AvailableNamedTimeZoneIdentifiers (and therefore GetAvailableNamedTimeZoneIdentifier) remains the same for the lifetime of the surrounding agent.
        </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-getisopartsfromepoch" type="abstract operation">
      <h1>
        GetISOPartsFromEpoch (
          _epochNanoseconds_: an integer,
        )
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the components of a date in UTC corresponding to the given number of nanoseconds since the epoch.</dd>
      </dl>
      <emu-alg>
        1. Assert: ! IsValidEpochNanoseconds(‚Ñ§(_epochNanoseconds_)) is *true*.
        1. Let _remainderNs_ be _epochNanoseconds_ modulo 10<sup>6</sup>.
        1. Let _epochMilliseconds_ be ùîΩ((_epochNanoseconds_ - _remainderNs_) / 10<sup>6</sup>).
        1. Let _year_ be EpochTimeToEpochYear(_epochMilliseconds_).
        1. Let _month_ be EpochTimeToMonthInYear(_epochMilliseconds_) + 1.
        1. Let _day_ be EpochTimeToDate(_epochMilliseconds_).
        1. Let _hour_ be ‚Ñù(HourFromTime(_epochMilliseconds_)).
        1. Let _minute_ be ‚Ñù(MinFromTime(_epochMilliseconds_)).
        1. Let _second_ be ‚Ñù(SecFromTime(_epochMilliseconds_)).
        1. Let _millisecond_ be ‚Ñù(msFromTime(_epochMilliseconds_)).
        1. Let _microsecond_ be floor(_remainderNs_ / 1000).
        1. Assert: _microsecond_ &lt; 1000.
        1. Let _nanosecond_ be _remainderNs_ modulo 1000.
        1. Return ISO Date-Time Record {
          [[Year]]: _year_,
          [[Month]]: _month_,
          [[Day]]: _day_,
          [[Hour]]: _hour_,
          [[Minute]]: _minute_,
          [[Second]]: _second_,
          [[Millisecond]]: _millisecond_,
          [[Microsecond]]: _microsecond_,
          [[Nanosecond]]: _nanosecond_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getianatimezonenexttransition" type="implementation-defined abstract operation">
      <h1>
        GetNamedTimeZoneNextTransition (
          _timeZoneIdentifier_: a String,
          _epochNanoseconds_: a BigInt,
        ): a BigInt or *null*
      </h1>
      <dl class="header">
      </dl>
      <p>
        The returned value _t_ represents the number of nanoseconds since the epoch that corresponds to the first time zone transition after _epochNanoseconds_ in the IANA time zone identified by _timeZoneIdentifier_.
        The operation returns *null* if no such transition exists for which _t_ &le; ‚Ñ§(nsMaxInstant).
      </p>
      <p>
        A transition is a point in time where the UTC offset of a time zone changes, for example when Daylight Saving Time starts or stops.
        The returned value _t_ represents the first nanosecond where the new UTC offset is used in this time zone, not the last nanosecond where the previous UTC offset is used.
      </p>
      <p>
        Given the same values of _timeZoneIdentifier_ and _epochNanoseconds_, the result must be the same for the lifetime of the surrounding agent.
      </p>
      <p>
        The minimum implementation of GetNamedTimeZoneNextTransition for ECMAScript implementations that do not include local political rules for any time zones performs the following steps when called:
      </p>
      <emu-alg>
        1. Assert: _timeZoneIdentifier_ is *"UTC"*.
        1. Return *null*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getianatimezoneprevioustransition" type="implementation-defined abstract operation">
      <h1>
        GetNamedTimeZonePreviousTransition (
          _timeZoneIdentifier_: a String,
          _epochNanoseconds_: a BigInt,
        ): a BigInt or *null*
      </h1>
      <dl class="header">
      </dl>
      <p>
        The returned value _t_ represents the number of nanoseconds since the epoch that corresponds to the last time zone transition before _epochNanoseconds_ in the IANA time zone identified by _timeZoneIdentifier_.
        The operation returns *null* if no such transition exists for which _t_ &ge; ‚Ñ§(nsMinInstant).
      </p>
      <p>
        A transition is a point in time where the UTC offset of a time zone changes, for example when Daylight Saving Time starts or stops.
        The returned value _t_ represents the first nanosecond where the new UTC offset is used in this time zone, not the last nanosecond where the previous UTC offset is used.
      </p>
      <p>
        Given the same values of _timeZoneIdentifier_ and _epochNanoseconds_, the result must be the same for the lifetime of the surrounding agent.
      </p>
      <p>
        The minimum implementation of GetNamedTimeZonePreviousTransition for ECMAScript implementations that do not include local political rules for any time zones performs the following steps when called:
      </p>
      <emu-alg>
        1. Assert: _timeZoneIdentifier_ is *"UTC"*.
        1. Return *null*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatoffsettimezoneidentifier" type="abstract operation">
      <h1>
        FormatOffsetTimeZoneIdentifier (
          _offsetMinutes_: an integer,
          optional _style_: ~separated~ or ~unseparated~,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It formats a UTC offset, in minutes, into a UTC offset string.
          If _style_ is ~separated~ or not present, then the output will be formatted like ¬±HH:MM.
          If _style_ is ~unseparated~, then the output will be formatted like ¬±HHMM.
        </dd>
      </dl>
      <emu-alg>
        1. If _offsetMinutes_ &ge; 0, let _sign_ be the code unit 0x002B (PLUS SIGN); otherwise, let _sign_ be the code unit 0x002D (HYPHEN-MINUS).
        1. Let _absoluteMinutes_ be abs(_offsetMinutes_).
        1. Let _hour_ be floor(_absoluteMinutes_ / 60).
        1. Let _minute_ be _absoluteMinutes_ modulo 60.
        1. Let _timeString_ be FormatTimeString(_hour_, _minute_, 0, 0, *"minute"*, _style_).
        1. Return the string-concatenation of _sign_ and _timeString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatutcoffsetnanoseconds" type="abstract operation">
      <h1>
        FormatUTCOffsetNanoseconds (
          _offsetNanoseconds_: an integer,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          If the offset represents an integer number of minutes, then the output will be formatted like ¬±HH:MM.
          Otherwise, the output will be formatted like ¬±HH:MM:SS or (if the offset does not evenly divide into seconds) ¬±HH:MM:SS.fff‚Ä¶ where the "fff" part is a sequence of at least 1 and at most 9 fractional seconds digits with no trailing zeroes.
        </dd>
      </dl>
      <emu-alg>
        1. If _offsetNanoseconds_ &ge; 0, let _sign_ be the code unit 0x002B (PLUS SIGN); otherwise, let _sign_ be the code unit 0x002D (HYPHEN-MINUS).
        1. Let _absoluteNanoseconds_ be abs(_offsetNanoseconds_).
        1. Let _hour_ be floor(_absoluteNanoseconds_ / (3600 √ó 10<sup>9</sup>)).
        1. Let _minute_ be floor(_absoluteNanoseconds_ / (60 √ó 10<sup>9</sup>)) modulo 60.
        1. Let _second_ be floor(_absoluteNanoseconds_ / 10<sup>9</sup>) modulo 60.
        1. Let _subSecondNanoseconds_ be _absoluteNanoseconds_ modulo 10<sup>9</sup>.
        1. If _second_ = 0 and _subSecondNanoseconds_ = 0, let _precision_ be *"minute"*; otherwise, let _precision_ be *"auto"*.
        1. Let _timeString_ be FormatTimeString(_hour_, _minute_, _second_, _subSecondNanoseconds_, _precision_).
        1. Return the string-concatenation of _sign_ and _timeString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatdatetimeutcoffsetrounded" type="abstract operation">
      <h1>
        FormatDateTimeUTCOffsetRounded (
          _offsetNanoseconds_: an integer,
        ) : a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It rounds _offsetNanoseconds_ to the nearest minute boundary and formats the rounded value into a ¬±HH:MM format, to support available named time zones that may have sub-minute offsets.</dd>
      </dl>
      <emu-alg>
        1. Set _offsetNanoseconds_ to RoundNumberToIncrement(_offsetNanoseconds_, 60 √ó 10<sup>9</sup>, *"halfExpand"*).
        1. Let _offsetMinutes_ be _offsetNanoseconds_ / (60 √ó 10<sup>9</sup>).
        1. Assert: _offsetMinutes_ is an integer.
        1. Return FormatOffsetTimeZoneIdentifier(_offsetMinutes_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-objectimplementstemporaltimezoneprotocol" type="abstract operation">
      <h1>
        ObjectImplementsTemporalTimeZoneProtocol (
          _object_: an Object,
        ): either a normal completion containing a Boolean, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines whether the given _object_ is a Temporal.TimeZone instance or implements the required methods from the Temporal.TimeZone protocol.
          For ordinary objects, and some exotic objects, this operation is infallible and will always return a normal completion.
          However, if _object_ is a Proxy or has one in its prototype chain, user code may be called.
        </dd>
      </dl>
      <emu-alg>
        1. If _object_ has an [[InitializedTemporalTimeZone]] internal slot, return *true*.
        1. For each property key _key_ of ¬´ *"getOffsetNanosecondsFor"*, *"getPossibleInstantsFor"*, *"id"* ¬ª, do
          1. If ? HasProperty(_object_, _key_) is *false*, return *false*.
        1. Return *true*.
      </emu-alg>
      <emu-note>
        This operation is a convenience which makes it easier to catch bugs in custom time zones.
        For web compatibility reasons, the list of required property keys will not be extended in future editions, even if the Temporal.TimeZone protocol gains more methods.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltimezoneslotvalue" type="abstract operation">
      <h1>
        ToTemporalTimeZoneSlotValue (
          _temporalTimeZoneLike_: an ECMAScript value,
        ): either a normal completion containing either a String or an Object, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It attempts to derive a value from _temporalTimeZoneLike_ that is suitable for storing in a Temporal.ZonedDateTime's [[TimeZone]] internal slot, and returns that value if found or throws an exception if not.</dd>
      </dl>
      <emu-alg>
        1. If Type(_temporalTimeZoneLike_) is Object, then
          1. If _temporalTimeZoneLike_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _temporalTimeZoneLike_.[[TimeZone]].
          1. If ? ObjectImplementsTemporalTimeZoneProtocol(_temporalTimeZoneLike_) is *false*, throw a *TypeError* exception.
          1. Return _temporalTimeZoneLike_.
        1. If _temporalTimeZoneLike_ is not a String, throw a *TypeError* exception.
        1. Let _parseResult_ be ? ParseTemporalTimeZoneString(_temporalTimeZoneLike_).
        1. Let _offsetMinutes_ be _parseResult_.[[OffsetMinutes]].
        1. If _offsetMinutes_ is not ~empty~, return FormatOffsetTimeZoneIdentifier(_offsetMinutes_).
        1. Let _name_ be _parseResult_.[[Name]].
        1. Let _timeZoneIdentifierRecord_ be GetAvailableNamedTimeZoneIdentifier(_name_).
        1. If _timeZoneIdentifierRecord_ is ~empty~, throw a *RangeError* exception.
        1. Return _timeZoneIdentifierRecord_.[[Identifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltimezoneidentifier" type="abstract operation">
      <h1>
        ToTemporalTimeZoneIdentifier (
          _timeZoneSlotValue_: a String or Object,
        ): either a normal completion containing a String, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It obtains the identifier string for a value _timeZoneSlotValue_ stored in a Temporal.ZonedDateTime's [[TimeZone]] internal slot.</dd>
      </dl>
      <emu-alg>
        1. If _timeZoneSlotValue_ is a String, then
          1. Assert: Either IsOffsetTimeZoneIdentifier(_timeZoneSlotValue_) is *true*, or GetAvailableNamedTimeZoneIdentifier(_timeZoneSlotValue_) is not ~empty~.
          1. Return _timeZoneSlotValue_.
        1. Let _identifier_ be ? Get(_timeZoneSlotValue_, *"id"*).
        1. If _identifier_ is not a String, throw a *TypeError* exception.
        1. Return _identifier_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltimezoneobject" type="abstract operation">
      <h1>
        ToTemporalTimeZoneObject (
          _timeZoneSlotValue_: a String or Object,
        ): an Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It obtains a time zone object for a value _timeZoneSlotValue_ stored in a Temporal.ZonedDateTime's [[TimeZone]] internal slot.</dd>
      </dl>
      <emu-alg>
        1. If _timeZoneSlotValue_ is an Object, return _timeZoneSlotValue_.
        1. Return ! CreateTemporalTimeZone(_timeZoneSlotValue_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getoffsetnanosecondsfor" type="abstract operation">
      <h1>
        GetOffsetNanosecondsFor (
          _timeZoneRec_: a Time Zone Methods Record,
          _instant_: a Temporal.Instant,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines the UTC offset of an _instant_, in nanoseconds, by calling the `getOffsetNanosecondsFor` method of the given time zone.
        </dd>
      </dl>
      <emu-alg>
        1. Let _offsetNanoseconds_ be ? TimeZoneMethodsRecordCall(_timeZoneRec_, ~get-offset-nanoseconds-for~, ¬´ _instant_ ¬ª).
        1. If TimeZoneMethodsRecordIsBuiltin(_timeZoneRec_), return ‚Ñù(_offsetNanoseconds_).
        1. If Type(_offsetNanoseconds_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_offsetNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Set _offsetNanoseconds_ to ‚Ñù(_offsetNanoseconds_).
        1. If abs(_offsetNanoseconds_) &ge; nsPerDay, throw a *RangeError* exception.
        1. Return _offsetNanoseconds_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getoffsetstringfor" type="abstract operation">
      <h1>
        GetOffsetStringFor (
          _timeZoneRec_: a Time Zone Methods Record,
          _instant_: a Temporal.Instant,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          This operation is the internal implementation of the `Temporal.TimeZone.prototype.getOffsetStringFor` method.
          If the given time zone is not built-in, it observably calls the time zone's `getOffsetNanosecondsFor` method.
        </dd>
      </dl>
      <emu-alg>
        1. Let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _instant_).
        1. Return FormatUTCOffsetNanoseconds(_offsetNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getplaindatetimefor" type="abstract operation">
      <h1>
        GetPlainDateTimeFor (
          _timeZoneRec_: a Time Zone Methods Record,
          _instant_: a Temporal.Instant,
          _calendar_: a String or Object,
          optional _precalculatedOffsetNanoseconds_: an integer,
        ): either a normal completion containing a Temporal.PlainDateTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          This operation is the internal implementation of the `Temporal.TimeZone.prototype.getPlainDateTimeFor` method.
          If the given time zone is not built-in, it observably calls _timeZone_'s `getOffsetNanosecondsFor` method unless _precalculatedOffsetNanoseconds_ is supplied.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: If _precalculatedOffsetNanoseconds_ is not present, TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-offset-nanoseconds-for~) is *true*.
        1. If _precalculatedOffsetNanoseconds_ is present, let _offsetNanoseconds_ be _precalculatedOffsetNanoseconds_.
        1. Else, let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _instant_).
        1. Assert: abs(_offsetNanoseconds_) &lt; nsPerDay.
        1. Let _result_ be ! GetISOPartsFromEpoch(‚Ñù(_instant_.[[Nanoseconds]])).
        1. Set _result_ to BalanceISODateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]] + _offsetNanoseconds_).
        1. Return ! CreateTemporalDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getinstantfor" type="abstract operation">
      <h1>
        GetInstantFor (
          _timeZoneRec_: a Time Zone Methods Record,
          _dateTime_: a Temporal.PlainDateTime,
          _disambiguation_: *"compatible"*, *"earlier"*, *"later"*, or *"reject"*,
        ): either a normal completion containing a Temporal.Instant or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It is the internal implementation of the `Temporal.TimeZone.prototype.getInstantFor` method.
          It calls the _timeZoneRec_'s `getPossibleInstantsFor` method at least once.
          If that call returns an empty array and _disambiguation_ is not *"reject"*, it calls _timeZoneRec_'s `getOffsetNanosecondsFor` method twice, and `getPossibleInstantsFor` an additional time.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-offset-nanoseconds-for~) is *true*.
        1. Assert: TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-possible-instants-for~) is *true*.
        1. Let _possibleInstants_ be ? GetPossibleInstantsFor(_timeZoneRec_, _dateTime_).
        1. Return ? DisambiguatePossibleInstants(_possibleInstants_, _timeZoneRec_, _dateTime_, _disambiguation_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-disambiguatepossibleinstants" type="abstract operation">
      <h1>
        DisambiguatePossibleInstants (
          _possibleInstants_: a List of Temporal.Instant objects,
          _timeZoneRec_: a Time Zone Methods Record,
          _dateTime_: a Temporal.PlainDateTime,
          _disambiguation_: *"compatible"*, *"earlier"*, *"later"*, or *"reject"*,
        ): either a normal completion containing a Temporal.Instant or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It chooses from a List of possible `Temporal.Instant` instances the one indicated by the _disambiguation_ parameter.</dd>
      </dl>
      <p>
        The _possibleInstants_ List may be empty, in which case it calls the time zone's `getOffsetNanosecondsFor` method twice, and `getPossibleInstantsFor` once, if _disambiguation_ is not *"reject"*.
      </p>
      <emu-alg>
        1. Assert: TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-possible-instants-for~) is *true*.
        1. Assert: If _possibleInstants_ is empty, and _disambiguation_ is not *"reject"*, TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-offset-nanoseconds-for~) is *true*.
        1. Let _n_ be _possibleInstants_'s length.
        1. If _n_ = 1, then
          1. Return _possibleInstants_[0].
        1. If _n_ &ne; 0, then
          1. If _disambiguation_ is *"earlier"* or *"compatible"*, then
            1. Return _possibleInstants_[0].
          1. If _disambiguation_ is *"later"*, then
            1. Return _possibleInstants_[_n_ - 1].
          1. Assert: _disambiguation_ is *"reject"*.
          1. Throw a *RangeError* exception.
        1. Assert: _n_ = 0.
        1. If _disambiguation_ is *"reject"*, then
          1. Throw a *RangeError* exception.
        1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]]).
        1. Let _dayBeforeNs_ be _epochNanoseconds_ - ‚Ñ§(nsPerDay).
        1. If IsValidEpochNanoseconds(_dayBeforeNs_) is *false*, throw a *RangeError* exception.
        1. Let _dayBefore_ be ! CreateTemporalInstant(_dayBeforeNs_).
        1. Let _dayAfterNs_ be _epochNanoseconds_ + ‚Ñ§(nsPerDay).
        1. If IsValidEpochNanoseconds(_dayAfterNs_) is *false*, throw a *RangeError* exception.
        1. Let _dayAfter_ be ! CreateTemporalInstant(_dayAfterNs_).
        1. Let _offsetBefore_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _dayBefore_).
        1. Let _offsetAfter_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _dayAfter_).
        1. Let _nanoseconds_ be _offsetAfter_ - _offsetBefore_.
        1. If abs(_nanoseconds_) > nsPerDay, throw a *RangeError* exception.
        1. If _disambiguation_ is *"earlier"*, then
          1. Let _norm_ be NormalizeTimeDuration(0, 0, 0, 0, 0, -_nanoseconds_).
          1. Let _earlierTime_ be AddTime(_dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _norm_).
          1. Let _earlierDate_ be BalanceISODate(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]] + _earlierTime_.[[Days]]).
          1. Let _earlierDateTime_ be ! CreateTemporalDateTime(_earlierDate_.[[Year]], _earlierDate_.[[Month]], _earlierDate_.[[Day]], _earlierTime_.[[Hour]], _earlierTime_.[[Minute]], _earlierTime_.[[Second]], _earlierTime_.[[Millisecond]], _earlierTime_.[[Microsecond]], _earlierTime_.[[Nanosecond]], *"iso8601"*).
          1. Set _possibleInstants_ to ? GetPossibleInstantsFor(_timeZoneRec_, _earlierDateTime_).
          1. If _possibleInstants_ is empty, throw a *RangeError* exception.
          1. Return _possibleInstants_[0].
        1. Assert: _disambiguation_ is *"compatible"* or *"later"*.
        1. Let _norm_ be NormalizeTimeDuration(0, 0, 0, 0, 0, _nanoseconds_).
        1. Let _laterTime_ be AddTime(_dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _norm_).
        1. Let _laterDate_ be BalanceISODate(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]] + _laterTime_.[[Days]]).
        1. Let _laterDateTime_ be ! CreateTemporalDateTime(_laterDate_.[[Year]], _laterDate_.[[Month]], _laterDate_.[[Day]], _laterTime_.[[Hour]], _laterTime_.[[Minute]], _laterTime_.[[Second]], _laterTime_.[[Millisecond]], _laterTime_.[[Microsecond]], _laterTime_.[[Nanosecond]], *"iso8601"*).
        1. Set _possibleInstants_ to ? GetPossibleInstantsFor(_timeZoneRec_, _laterDateTime_).
        1. Set _n_ to _possibleInstants_'s length.
        1. If _n_ = 0, throw a *RangeError* exception.
        1. Return _possibleInstants_[_n_ - 1].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getpossibleinstantsfor" type="abstract operation">
      <h1>
        GetPossibleInstantsFor (
          _timeZoneRec_: a Time Zone Methods Record,
          _dateTime_: a Temporal.PlainDateTime,
        ): either a normal completion containing a List of Temporal.Instants or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines the possible Temporal.Instant exact times that may correspond to _dateTime_, by calling the `getPossibleInstantsFor` method of the given time zone.
        </dd>
      </dl>
      <emu-alg>
        1. Let _possibleInstants_ be ? TimeZoneMethodsRecordCall(_timeZoneRec_, ~get-possible-instants-for~, ¬´ _dateTime_ ¬ª).
        1. If TimeZoneMethodsRecordIsBuiltin(_timeZoneRec_), return ! CreateListFromArrayLike(_possibleInstants_, ¬´ Object ¬ª).
        1. Let _iteratorRecord_ be ? GetIterator(_possibleInstants_, ~sync~).
        1. Let _list_ be a new empty List.
        1. Repeat,
          1. Let _value_ be ? IteratorStepValue(_iteratorRecord_).
          1. If _value_ is ~done~, then
            1. Let _numResults_ be _list_'s length.
            1. If _numResults_ &gt; 1, then
              1. Let _epochNs_ be a new empty List.
              1. For each value _instant_ in _list_, do
                1. Append _instant_.[[EpochNanoseconds]] to the end of the List _epochNs_.
              1. Let _min_ be the least element of the List _epochNs_.
              1. Let _max_ be the greatest element of the List _epochNs_.
              1. If abs(‚Ñù(_max_ - _min_)) &gt; nsPerDay, throw a *RangeError* exception.
            1. Return _list_.
          1. If _value_ is not an Object or _value_ does not have an [[InitializedTemporalInstant]] internal slot, then
            1. Let _completion_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iteratorRecord_, _completion_).
          1. Append _value_ to the end of the List _list_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-timezoneequals" type="abstract operation">
      <h1>
        TimeZoneEquals (
          _one_: a String or Object,
          _two_: a String or Object,
        ): either a normal completion containing a Boolean or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns *true* if its arguments represent time zones using the same identifier.</dd>
      </dl>
      <emu-alg>
        1. If _one_ and _two_ are the same Object value, return *true*.
        1. Let _timeZoneOne_ be ? ToTemporalTimeZoneIdentifier(_one_).
        1. Let _timeZoneTwo_ be ? ToTemporalTimeZoneIdentifier(_two_).
        1. If _timeZoneOne_ is _timeZoneTwo_, return *true*.
        1. Let _offsetMinutesOne_ be ? ParseTimeZoneIdentifier(_timeZoneOne_).[[OffsetMinutes]].
        1. Let _offsetMinutesTwo_ be ? ParseTimeZoneIdentifier(_timeZoneTwo_).[[OffsetMinutes]].
        1. If _offsetMinutesOne_ is ~empty~ and _offsetMinutesTwo_ is ~empty~, then
          1. Let _recordOne_ be GetAvailableNamedTimeZoneIdentifier(_timeZoneOne_).
          1. Let _recordTwo_ be GetAvailableNamedTimeZoneIdentifier(_timeZoneTwo_).
          1. If _recordOne_ is not ~empty~ and _recordTwo_ is not ~empty~ and _recordOne_.[[PrimaryIdentifier]] is _recordTwo_.[[PrimaryIdentifier]], return *true*.
        1. Else,
          1. If _offsetMinutesOne_ is not ~empty~ and _offsetMinutesTwo_ is not ~empty~ and _offsetMinutesOne_ = _offsetMinutesTwo_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-parsetimezoneidentifier" type="abstract operation">
      <h1>
        ParseTimeZoneIdentifier (
          _identifier_: a String,
        ): either a normal completion containing a Record with fields [[Name]] (a String or ~empty~) and [[OffsetMinutes]] (an integer or ~empty~), or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          If _identifier_ is a named time zone identifier, [[Name]] will be _identifier_ and [[OffsetMinutes]] will be ~empty~.
          If _identifier_ is an offset time zone identifier, [[Name]] will be ~empty~ and [[OffsetMinutes]] will be a signed integer.
          Otherwise, a *RangeError* will be thrown.
        </dd>
      </dl>
      <emu-alg>
        1. Let _parseResult_ be ParseText(StringToCodePoints(_identifier_), |TimeZoneIdentifier|).
        1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
        1. If _parseResult_ contains a |TimeZoneIANAName| Parse Node, then
          1. Let _name_ be the source text matched by the |TimeZoneIANAName| Parse Node contained within _parseResult_.
          1. NOTE: _name_ is syntactically valid, but does not necessarily conform to <a href="https://data.iana.org/time-zones/theory.html#naming">IANA Time Zone Database naming guidelines</a> or correspond with an available named time zone identifier.
          1. Return the Record { [[Name]]: CodePointsToString(_name_), [[OffsetMinutes]]: ~empty~ }.
        1. Else,
          1. Assert: _parseResult_ contains a |TimeZoneUTCOffsetName| Parse Node.
          1. Let _offsetString_ be the source text matched by the |TimeZoneUTCOffsetName| Parse Node contained within _parseResult_.
          1. Let _offsetNanoseconds_ be ! ParseDateTimeUTCOffset(_offsetString_).
          1. Let _offsetMinutes_ be _offsetNanoseconds_ / (60 √ó 10<sup>9</sup>).
          1. Assert: _offsetMinutes_ is an integer.
          1. Return the Record { [[Name]]: ~empty~, [[OffsetMinutes]]: _offsetMinutes_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
