<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaindatetime-objects">
  <h1>Temporal.PlainDateTime Objects</h1>
  <p>A Temporal.PlainDateTime object is an Object that contains integers corresponding to a particular year, month, day, hour, minute, second, millisecond, microsecond, and nanosecond.</p>

  <emu-clause id="sec-temporal-plaindatetime-constructor">
    <h1>The Temporal.PlainDateTime Constructor</h1>
    <p>The Temporal.PlainDateTime constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.PlainDateTime object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.PlainDateTime behaviour must
        include a super call to the %Temporal.PlainDateTime% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.plaindatetime">
      <h1>Temporal.PlainDateTime ( _isoYear_, _isoMonth_, _isoDay_ [ , _hour_ [ , _minute_ [ , _second_ [ , _millisecond_ [ , _microsecond_ [ , _nanosecond_ [ , _calendarLike_ ] ] ] ] ] ] ] )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _isoYear_ to ? ToIntegerWithTruncation(_isoYear_).
        1. Set _isoMonth_ to ? ToIntegerWithTruncation(_isoMonth_).
        1. Set _isoDay_ to ? ToIntegerWithTruncation(_isoDay_).
        1. If _hour_ is *undefined*, set _hour_ to 0; else set _hour_ to ? ToIntegerWithTruncation(_hour_).
        1. If _minute_ is *undefined*, set _minute_ to 0; else set _minute_ to ? ToIntegerWithTruncation(_minute_).
        1. If _second_ is *undefined*, set _second_ to 0; else set _second_ to ? ToIntegerWithTruncation(_second_).
        1. If _millisecond_ is *undefined*, set _millisecond_ to 0; else set _millisecond_ to ? ToIntegerWithTruncation(_millisecond_).
        1. If _microsecond_ is *undefined*, set _microsecond_ to 0; else set _microsecond_ to ? ToIntegerWithTruncation(_microsecond_).
        1. If _nanosecond_ is *undefined*, set _nanosecond_ to 0; else set _nanosecond_ to ? ToIntegerWithTruncation(_nanosecond_).
        1. Let _calendar_ be ? ToTemporalCalendarSlotValue(_calendarLike_, *"iso8601"*).
        1. Return ? CreateTemporalDateTime(_isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindatetime-constructor">
    <h1>Properties of the Temporal.PlainDateTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.PlainDateTime constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.PlainDateTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal.plaindatetime.prototype">
      <h1>Temporal.PlainDateTime.prototype</h1>
      <p>The initial value of `Temporal.PlainDateTime.prototype` is %Temporal.PlainDateTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.from">
      <h1>Temporal.PlainDateTime.from ( _item_ [ , _options_ ] )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalDateTime]] internal slot, then
          1. Perform ? ToTemporalOverflow(_options_).
          1. Return ! CreateTemporalDateTime(_item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], _item_.[[ISOHour]], _item_.[[ISOMinute]], _item_.[[ISOSecond]], _item_.[[ISOMillisecond]], _item_.[[ISOMicrosecond]], _item_.[[ISONanosecond]], _item_.[[Calendar]]).
        1. Return ? ToTemporalDateTime(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.compare">
      <h1>Temporal.PlainDateTime.compare ( _one_, _two_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDateTime(_one_).
        1. Set _two_ to ? ToTemporalDateTime(_two_).
        1. Return ùîΩ(CompareISODateTime(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _one_.[[ISOHour]], _one_.[[ISOMinute]], _one_.[[ISOSecond]], _one_.[[ISOMillisecond]], _one_.[[ISOMicrosecond]], _one_.[[ISONanosecond]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _two_.[[ISOHour]], _two_.[[ISOMinute]], _two_.[[ISOSecond]], _two_.[[ISOMillisecond]], _two_.[[ISOMicrosecond]], _two_.[[ISONanosecond]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindatetime-prototype-object">
    <h1>Properties of the Temporal.PlainDateTime Prototype Object</h1>

    <p>The Temporal.PlainDateTime prototype object</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.PlainDateTime.prototype%</dfn>.</li>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.PlainDateTime instance and does not have a [[InitializedTemporalDateTime]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-note>
      An ECMAScript implementation that includes the ECMA-402 Internationalization API extends this prototype with additional properties in order to represent calendar data.
    </emu-note>

    <emu-clause id="sec-temporal.plaindatetime.prototype.constructor">
      <h1>Temporal.PlainDateTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainDateTime.prototype.constructor` is %Temporal.PlainDateTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype-@@tostringtag">
      <h1>Temporal.PlainDateTime.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the String value *"Temporal.PlainDateTime"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.calendarid">
      <h1>get Temporal.PlainDateTime.prototype.calendarId</h1>
      <p>
        `Temporal.PlainDateTime.prototype.calendarId` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? ToTemporalCalendarIdentifier(_dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.year">
      <h1>get Temporal.PlainDateTime.prototype.year</h1>
      <p>
        `Temporal.PlainDateTime.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarYear(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.month">
      <h1>get Temporal.PlainDateTime.prototype.month</h1>
      <p>
        `Temporal.PlainDateTime.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarMonth(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.monthcode">
      <h1>get Temporal.PlainDateTime.prototype.monthCode</h1>
      <p>
        `Temporal.PlainDateTime.prototype.monthCode` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ? CalendarMonthCode(_calendar_, _dateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.day">
      <h1>get Temporal.PlainDateTime.prototype.day</h1>
      <p>
        `Temporal.PlainDateTime.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_dateTime_.[[Calendar]], ¬´ ~day~ ¬ª).
        1. Return ùîΩ(? CalendarDay(_calendarRec_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.hour">
      <h1>get Temporal.PlainDateTime.prototype.hour</h1>
      <p>
        `Temporal.PlainDateTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISOHour]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.minute">
      <h1>get Temporal.PlainDateTime.prototype.minute</h1>
      <p>
        `Temporal.PlainDateTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISOMinute]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.second">
      <h1>get Temporal.PlainDateTime.prototype.second</h1>
      <p>
        `Temporal.PlainDateTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISOSecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.millisecond">
      <h1>get Temporal.PlainDateTime.prototype.millisecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISOMillisecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.microsecond">
      <h1>get Temporal.PlainDateTime.prototype.microsecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISOMicrosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.nanosecond">
      <h1>get Temporal.PlainDateTime.prototype.nanosecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.dayofweek">
      <h1>get Temporal.PlainDateTime.prototype.dayOfWeek</h1>
      <p>
        `Temporal.PlainDateTime.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarDayOfWeek(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.dayofyear">
      <h1>get Temporal.PlainDateTime.prototype.dayOfYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarDayOfYear(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.weekofyear">
      <h1>get Temporal.PlainDateTime.prototype.weekOfYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarWeekOfYear(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.yearofweek">
      <h1>get Temporal.PlainDateTime.prototype.yearOfWeek</h1>
      <p>
        `Temporal.PlainDateTime.prototype.yearOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarYearOfWeek(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.daysinweek">
      <h1>get Temporal.PlainDateTime.prototype.daysInWeek</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarDaysInWeek(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.daysinmonth">
      <h1>get Temporal.PlainDateTime.prototype.daysInMonth</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarDaysInMonth(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.daysinyear">
      <h1>get Temporal.PlainDateTime.prototype.daysInYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarDaysInYear(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.monthsinyear">
      <h1>get Temporal.PlainDateTime.prototype.monthsInYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ùîΩ(? CalendarMonthsInYear(_calendar_, _dateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.inleapyear">
      <h1>get Temporal.PlainDateTime.prototype.inLeapYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Return ? CalendarInLeapYear(_calendar_, _dateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.with">
      <h1>Temporal.PlainDateTime.prototype.with ( _temporalDateTimeLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If ? IsPartialTemporalObject(_temporalDateTimeLike_) is *false*, throw a *TypeError* exception.
        1. Let _resolvedOptions_ be ? SnapshotOwnProperties(? GetOptionsObject(_options_), *null*).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_dateTime_.[[Calendar]], ¬´ ~date-from-fields~, ~fields~, ~merge-fields~ ¬ª).
        1. Let _fieldNames_ be ? CalendarFields(_calendarRec_, ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_dateTime_, _fieldNames_, ¬´¬ª).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"hour"*, _dateTime_.[[ISOHour]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"minute"*, _dateTime_.[[ISOMinute]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"second"*, _dateTime_.[[ISOSecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"millisecond"*, _dateTime_.[[ISOMillisecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"microsecond"*, _dateTime_.[[ISOMicrosecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"nanosecond"*, _dateTime_.[[ISONanosecond]]).
        1. Append *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"nanosecond"*, and *"second"* to _fieldNames_.
        1. Let _partialDateTime_ be ? PrepareTemporalFields(_temporalDateTimeLike_, _fieldNames_, ~partial~).
        1. Set _fields_ to ? CalendarMergeFields(_calendarRec_, _fields_, _partialDateTime_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, ¬´¬ª).
        1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendarRec_, _fields_, _resolvedOptions_).
        1. Assert: IsValidISODate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Assert: IsValidTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ? CreateTemporalDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _calendarRec_.[[Receiver]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.withplaintime">
      <h1>Temporal.PlainDateTime.prototype.withPlainTime ( [ _plainTimeLike_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _plainTime_ be ? ToTemporalTimeOrMidnight(_plainTimeLike_).
        1. Return ? CreateTemporalDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _plainTime_.[[ISOHour]], _plainTime_.[[ISOMinute]], _plainTime_.[[ISOSecond]], _plainTime_.[[ISOMillisecond]], _plainTime_.[[ISOMicrosecond]], _plainTime_.[[ISONanosecond]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.withplaindate">
      <h1>Temporal.PlainDateTime.prototype.withPlainDate ( _plainDateLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _plainDate_ be ? ToTemporalDate(_plainDateLike_).
        1. Let _calendar_ be ? ConsolidateCalendars(_dateTime_.[[Calendar]], _plainDate_.[[Calendar]]).
        1. Return ? CreateTemporalDateTime(_plainDate_.[[ISOYear]], _plainDate_.[[ISOMonth]], _plainDate_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.withcalendar">
      <h1>Temporal.PlainDateTime.prototype.withCalendar ( _calendarLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be ? ToTemporalCalendarSlotValue(_calendarLike_).
        1. Return ? CreateTemporalDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.add">
      <h1>Temporal.PlainDateTime.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? AddDurationToOrSubtractDurationFromPlainDateTime(~add~, _dateTime_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.subtract">
      <h1>Temporal.PlainDateTime.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? AddDurationToOrSubtractDurationFromPlainDateTime(~subtract~, _dateTime_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.until">
      <h1>Temporal.PlainDateTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? DifferenceTemporalPlainDateTime(~until~, _dateTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.since">
      <h1>Temporal.PlainDateTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? DifferenceTemporalPlainDateTime(~since~, _dateTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.round">
      <h1>Temporal.PlainDateTime.prototype.round ( _roundTo_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If _roundTo_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If Type(_roundTo_) is String, then
          1. Let _paramString_ be _roundTo_.
          1. Set _roundTo_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_roundTo_, *"smallestUnit"*, _paramString_).
        1. Else,
          1. Set _roundTo_ to ? GetOptionsObject(_roundTo_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalRoundingIncrement reads *"roundingIncrement"* and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_roundTo_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_roundTo_, *"halfExpand"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_roundTo_, *"smallestUnit"*, ~time~, ~required~, ¬´ *"day"* ¬ª).
        1. If _smallestUnit_ is *"day"*, then
          1. Let _maximum_ be 1.
          1. Let _inclusive_ be *true*.
        1. Else,
          1. Let _maximum_ be MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
          1. Assert: _maximum_ is not *undefined*.
          1. Let _inclusive_ be *false*.
        1. Perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, _inclusive_).
        1. If _smallestUnit_ is *"nanosecond"* and _roundingIncrement_ is 1, then
          1. Return ! CreateTemporalDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _dateTime_.[[Calendar]]).
        1. Let _result_ be RoundISODateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Return ? CreateTemporalDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.equals">
      <h1>Temporal.PlainDateTime.prototype.equals ( _other_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Set _other_ to ? ToTemporalDateTime(_other_).
        1. Let _result_ be CompareISODateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _other_.[[ISOYear]], _other_.[[ISOMonth]], _other_.[[ISODay]], _other_.[[ISOHour]], _other_.[[ISOMinute]], _other_.[[ISOSecond]], _other_.[[ISOMillisecond]], _other_.[[ISOMicrosecond]], _other_.[[ISONanosecond]]).
        1. If _result_ is not 0, return *false*.
        1. Return ? CalendarEquals(_dateTime_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.tostring">
      <h1>Temporal.PlainDateTime.prototype.toString ( [ _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToCalendarNameOption reads *"calendarName"*, ToFractionalSecondDigits reads *"fractionalSecondDigits"*, and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _showCalendar_ be ? ToCalendarNameOption(_options_).
        1. Let _digits_ be ? ToFractionalSecondDigits(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_options_, *"smallestUnit"*, ~time~, *undefined*).
        1. If _smallestUnit_ is *"hour"*, throw a *RangeError* exception.
        1. Let _precision_ be ToSecondsStringPrecisionRecord(_smallestUnit_, _digits_).
        1. Let _result_ be RoundISODateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. Return ? TemporalDateTimeToString(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _dateTime_.[[Calendar]], _precision_.[[Precision]], _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.tolocalestring">
      <h1>Temporal.PlainDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>
        The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
      </p>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? TemporalDateTimeToString(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _dateTime_.[[Calendar]], *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.tojson">
      <h1>Temporal.PlainDateTime.prototype.toJSON ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? TemporalDateTimeToString(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _dateTime_.[[Calendar]], *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.valueof">
      <h1>Temporal.PlainDateTime.prototype.valueOf ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-note>
        <p>
          This method always throws, because in the absence of `valueOf()`, expressions with arithmetic operators such as `plainDateTime1 > plainDateTime2` would fall back to being equivalent to `plainDateTime1.toString() > plainDateTime2.toString()`.
          Lexicographical comparison of serialized strings might not seem obviously wrong, because the result would sometimes be correct.
          Implementations are encouraged to phrase the error message to point users to `Temporal.PlainDateTime.compare()`, `Temporal.PlainDateTime.prototype.equals()`, and/or `Temporal.PlainDateTime.prototype.toString()`.
        </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.tozoneddatetime">
      <h1>Temporal.PlainDateTime.prototype.toZonedDateTime ( _temporalTimeZoneLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _timeZone_ be ? ToTemporalTimeZoneSlotValue(_temporalTimeZoneLike_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_timeZone_, ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _instant_ be ? GetInstantFor(_timeZoneRec_, _dateTime_, _disambiguation_).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.toplaindate">
      <h1>Temporal.PlainDateTime.prototype.toPlainDate ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! CreateTemporalDate(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.toplainyearmonth">
      <h1>Temporal.PlainDateTime.prototype.toPlainYearMonth ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_dateTime_.[[Calendar]], ¬´ ~fields~, ~year-month-from-fields~ ¬ª).
        1. Let _fieldNames_ be ? CalendarFields(_calendarRec_, ¬´ *"monthCode"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_dateTime_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarYearMonthFromFields(_calendarRec_, _fields_).
        1. NOTE: The call to CalendarYearMonthFromFields is necessary in order to create a PlainYearMonth object with the [[ISOYear]], [[ISOMonth]], and [[ISODay]] internal slots set correctly.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.toplainmonthday">
      <h1>Temporal.PlainDateTime.prototype.toPlainMonthDay ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_dateTime_.[[Calendar]], ¬´ ~fields~, ~month-day-from-fields~ ¬ª).
        1. Let _fieldNames_ be ? CalendarFields(_calendarRec_, ¬´ *"day"*, *"monthCode"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_dateTime_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarMonthDayFromFields(_calendarRec_, _fields_).
        1. NOTE: The call to CalendarMonthDayFromFields is necessary in order to create a PlainMonthDay object with the [[ISOYear]], [[ISOMonth]], and [[ISODay]] internal slots set correctly.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.toplaintime">
      <h1>Temporal.PlainDateTime.prototype.toPlainTime ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! CreateTemporalTime(_dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.getisofields">
      <h1>Temporal.PlainDateTime.prototype.getISOFields ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _fields_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _dateTime_.[[Calendar]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, ùîΩ(_dateTime_.[[ISODay]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoHour"*, ùîΩ(_dateTime_.[[ISOHour]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMicrosecond"*, ùîΩ(_dateTime_.[[ISOMicrosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMillisecond"*, ùîΩ(_dateTime_.[[ISOMillisecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMinute"*, ùîΩ(_dateTime_.[[ISOMinute]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, ùîΩ(_dateTime_.[[ISOMonth]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoNanosecond"*, ùîΩ(_dateTime_.[[ISONanosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoSecond"*, ùîΩ(_dateTime_.[[ISOSecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, ùîΩ(_dateTime_.[[ISOYear]])).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.getcalendar">
      <h1>Temporal.PlainDateTime.prototype.getCalendar ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ToTemporalCalendarObject(_dateTime_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaindatetime-instances">
    <h1>Properties of Temporal.PlainDateTime Instances</h1>
    <p>
      Temporal.PlainDateTime instances are ordinary objects that inherit properties from the %Temporal.PlainDateTime.prototype% intrinsic object.
      Temporal.PlainDateTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaldatetime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaldatetime-instances" caption="Internal Slots of Temporal.PlainDateTime Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalDateTime]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.PlainDateTime instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOYear]]
            </td>
            <td>
              An integer representing the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMonth]]
            </td>
            <td>
              An integer between 1 and 12, inclusive, representing the month of the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISODay]]
            </td>
            <td>
              An integer between 1 and ISODaysInMonth([[ISOYear]], [[ISOMonth]]), inclusive, representing the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOHour]]
            </td>
            <td>
              An integer between 0 and 23, inclusive, representing the hour of the day.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMinute]]
            </td>
            <td>
              An integer between 0 and 59, inclusive, representing the minute of the hour.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOSecond]]
            </td>
            <td>
              An integer between 0 and 59, inclusive, representing the second within the minute.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMillisecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the millisecond within the second.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMicrosecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the microsecond within the millisecond.
            </td>
          </tr>
          <tr>
            <td>
              [[ISONanosecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the nanosecond within the microsecond.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              A String or Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaindatetime-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-temporal-iso-date-time-records">
      <h1>ISO Date-Time Records</h1>
      <p>
        An <dfn variants="ISO Date-Time Records">ISO Date-Time Record</dfn> is a Record value used to represent a valid calendar date in the ISO 8601 calendar together with a clock time.
        For any ISO Date-Time Record _r_, IsValidISODate(_r_.[[Year]], _r_.[[Month]], _r_.[[Day]]) must return *true*, and IsValidTime(_r_.[[Hour]], _r_.[[Minute]], _r_.[[Second]], _r_.[[Millisecond]], _r_.[[Microsecond]], _r_.[[Nanosecond]]) must return *true*.
        It is not necessary for ISODateTimeWithinLimits(_r_.[[Year]], _r_.[[Month]], _r_.[[Day]], _r_.[[Hour]], _r_.[[Minute]], _r_.[[Second]], _r_.[[Millisecond]], _r_.[[Microsecond]], _r_.[[Nanosecond]]) to return *true*.
      </p>
      <p>
        ISO Date-Time Records have the fields listed in <emu-xref href="#table-temporal-iso-date-time-record-fields"></emu-xref>.
      </p>
      <emu-table id="table-temporal-iso-date-time-record-fields" caption="ISO Date-Time Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer</td>
            <td>
              The year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>an integer between 1 and 12, inclusive</td>
            <td>
              The number of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>an integer between 1 and 31, inclusive</td>
            <td>
              The number of the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>[[Hour]]</td>
            <td>an integer in the inclusive range 0 to 23</td>
            <td>The number of the hour.</td>
          </tr>
          <tr>
            <td>[[Minute]]</td>
            <td>an integer in the inclusive range 0 to 59</td>
            <td>The number of the minute.</td>
          </tr>
          <tr>
            <td>[[Second]]</td>
            <td>an integer in the inclusive range 0 to 59</td>
            <td>The number of the second.</td>
          </tr>
          <tr>
            <td>[[Millisecond]]</td>
            <td>an integer in the inclusive range 0 to 999</td>
            <td>The number of the millisecond.</td>
          </tr>
          <tr>
            <td>[[Microsecond]]</td>
            <td>an integer in the inclusive range 0 to 999</td>
            <td>The number of the microsecond.</td>
          </tr>
          <tr>
            <td>[[Nanosecond]]</td>
            <td>an integer in the inclusive range 0 to 999</td>
            <td>The number of the nanosecond.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatetimewithinlimits" type="abstract operation">
      <h1>
        ISODateTimeWithinLimits (
          _year_: an integer,
          _month_: an integer between 1 and 12 inclusive,
          _day_: an integer between 1 and 31 inclusive,
          _hour_: an integer between 0 and 23 inclusive,
          _minute_: an integer between 0 and 59 inclusive,
          _second_: an integer between 0 and 59 inclusive,
          _millisecond_: an integer between 0 and 999 inclusive,
          _microsecond_: an integer between 0 and 999 inclusive,
          _nanosecond_: an integer between 0 and 999 inclusive,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The return value is *true* if the combination of a date in the ISO 8601 calendar with a wall-clock time, given by the arguments, is within the representable range of `Temporal.PlainDateTime`, and *false* otherwise.</dd>
      </dl>
      <emu-note>
        <p>
          Temporal.PlainDateTime objects can represent points in time within 24 hours (8.64 &times; 10<sup>13</sup> nanoseconds) of the Temporal.Instant boundaries.
          This ensures that a Temporal.Instant object can be converted into a Temporal.PlainDateTime object using any time zone.
        </p>
      </emu-note>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. If abs(ISODateToEpochDays(_year_, _month_ - 1, _day_)) > 10<sup>8</sup> + 1, return *false*.
        1. Let _ns_ be ‚Ñù(GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_)).
        1. If _ns_ &le; nsMinInstant - nsPerDay, then
          1. Return *false*.
        1. If _ns_ &ge; nsMaxInstant + nsPerDay, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-interprettemporaldatetimefields" type="abstract operation">
      <h1>
        InterpretTemporalDateTimeFields (
          _calendarRec_: a Calendar Methods Record,
          _fields_: an Object,
          _options_: an Object,
        ): either a normal completion containing an ISO Date-Time Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It interprets the date/time fields in the object _fields_ using the given calendar, and returns a Record with the fields according to the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. Assert: _options_ is an ordinary extensible Object that is not directly observable from ECMAScript code and for which the value of the [[Prototype]] internal slot is *null* and every property is a configurable data property.
        1. Assert: CalendarMethodsRecordHasLookedUp(_calendarRec_, ~date-from-fields~) is *true*.
        1. Let _timeResult_ be ? ToTemporalTimeRecord(_fields_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. NOTE: The following step is guaranteed to complete normally despite the *"overflow"* property existing, because of the assertion in the first step.
        1. Perform ! CreateDataPropertyOrThrow(_options_, *"overflow"*, _overflow_).
        1. Let _temporalDate_ be ? CalendarDateFromFields(_calendarRec_, _fields_, _options_).
        1. Set _timeResult_ to ? RegulateTime(_timeResult_.[[Hour]], _timeResult_.[[Minute]], _timeResult_.[[Second]], _timeResult_.[[Millisecond]], _timeResult_.[[Microsecond]], _timeResult_.[[Nanosecond]], _overflow_).
        1. Return ISO Date-Time Record {
          [[Year]]: _temporalDate_.[[ISOYear]],
          [[Month]]: _temporalDate_.[[ISOMonth]],
          [[Day]]: _temporalDate_.[[ISODay]],
          [[Hour]]: _timeResult_.[[Hour]],
          [[Minute]]: _timeResult_.[[Minute]],
          [[Second]]: _timeResult_.[[Second]],
          [[Millisecond]]: _timeResult_.[[Millisecond]],
          [[Microsecond]]: _timeResult_.[[Microsecond]],
          [[Nanosecond]]: _timeResult_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldatetime" type="abstract operation">
      <h1>
        ToTemporalDateTime (
          _item_: an ECMAScript language value,
          optional _options_: an Object or *undefined*,
        ): either a normal completion containing a Temporal.PlainDateTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns its argument _item_ if it is already a Temporal.PlainDateTime instance, converts _item_ to a new Temporal.PlainDateTime instance if possible, and throws otherwise.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _resolvedOptions_ be ? SnapshotOwnProperties(! GetOptionsObject(_options_), *null*).
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalDateTime]] internal slot, then
            1. Return _item_.
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Perform ? ToTemporalOverflow(_resolvedOptions_).
            1. Let _instant_ be ! CreateTemporalInstant(_item_.[[Nanoseconds]]).
            1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_item_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
            1. Return ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _item_.[[Calendar]]).
          1. If _item_ has an [[InitializedTemporalDate]] internal slot, then
            1. Perform ? ToTemporalOverflow(_resolvedOptions_).
            1. Return ? CreateTemporalDateTime(_item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], 0, 0, 0, 0, 0, 0, _item_.[[Calendar]]).
          1. Let _calendar_ be ? GetTemporalCalendarSlotValueWithISODefault(_item_).
          1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_calendar_, ¬´ ~date-from-fields~, ~fields~ ¬ª).
          1. Let _fieldNames_ be ? CalendarFields(_calendarRec_, ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª).
          1. Append *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"nanosecond"*, and *"second"* to _fieldNames_.
          1. Let _fields_ be ? PrepareTemporalFields(_item_, _fieldNames_, ¬´¬ª).
          1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendarRec_, _fields_, _resolvedOptions_).
        1. Else,
          1. If _item_ is not a String, throw a *TypeError* exception.
          1. Let _result_ be ? ParseTemporalDateTimeString(_item_).
          1. Assert: IsValidISODate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
          1. Assert: IsValidTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
          1. Let _calendar_ be _result_.[[Calendar]].
          1. If _calendar_ is *undefined*, set _calendar_ to *"iso8601"*.
          1. If IsBuiltinCalendar(_calendar_) is *false*, throw a *RangeError* exception.
          1. Set _calendar_ to the ASCII-lowercase of _calendar_.
          1. Perform ? ToTemporalOverflow(_resolvedOptions_).
        1. Return ? CreateTemporalDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balanceisodatetime" type="abstract operation">
      <h1>
        BalanceISODateTime (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
        ): an ISO Date-Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Let _balancedTime_ be BalanceTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Let _balancedDate_ be BalanceISODate(_year_, _month_, _day_ + _balancedTime_.[[Days]]).
        1. Return ISO Date-Time Record {
            [[Year]]: _balancedDate_.[[Year]],
            [[Month]]: _balancedDate_.[[Month]],
            [[Day]]: _balancedDate_.[[Day]],
            [[Hour]]: _balancedTime_.[[Hour]],
            [[Minute]]: _balancedTime_.[[Minute]],
            [[Second]]: _balancedTime_.[[Second]],
            [[Millisecond]]: _balancedTime_.[[Millisecond]],
            [[Microsecond]]: _balancedTime_.[[Microsecond]],
            [[Nanosecond]]: _balancedTime_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatetime" type="abstract operation">
      <h1>
        CreateTemporalDateTime (
          _isoYear_: an integer,
          _isoMonth_: an integer,
          _isoDay_: an integer,
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
          _calendar_: a String or Object,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.PlainDateTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.PlainDateTime instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. If IsValidISODate(_isoYear_, _isoMonth_, _isoDay_) is *false*, throw a *RangeError* exception.
        1. If IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, throw a *RangeError* exception.
        1. If ISODateTimeWithinLimits(_isoYear_, _isoMonth_, _isoDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
          1. Throw a *RangeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.PlainDateTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.PlainDateTime.prototype%"*, ¬´ [[InitializedTemporalDateTime]], [[ISOYear]], [[ISOMonth]], [[ISODay]], [[ISOHour]], [[ISOMinute]], [[ISOSecond]], [[ISOMillisecond]], [[ISOMicrosecond]], [[ISONanosecond]], [[Calendar]] ¬ª).
        1. Set _object_.[[ISOYear]] to _isoYear_.
        1. Set _object_.[[ISOMonth]] to _isoMonth_.
        1. Set _object_.[[ISODay]] to _isoDay_.
        1. Set _object_.[[ISOHour]] to _hour_.
        1. Set _object_.[[ISOMinute]] to _minute_.
        1. Set _object_.[[ISOSecond]] to _second_.
        1. Set _object_.[[ISOMillisecond]] to _millisecond_.
        1. Set _object_.[[ISOMicrosecond]] to _microsecond_.
        1. Set _object_.[[ISONanosecond]] to _nanosecond_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldatetimetostring" type="abstract operation">
      <h1>
        TemporalDateTimeToString (
          _isoYear_: an integer,
          _isoMonth_: an integer,
          _isoDay_: an integer,
          _hour_: an integer in the inclusive interval from 0 to 23,
          _minute_: an integer in the inclusive interval from 0 to 59,
          _second_: an integer in the inclusive interval from 0 to 59,
          _millisecond_: an integer in the inclusive interval from 0 to 999,
          _microsecond_: an integer in the inclusive interval from 0 to 999,
          _nanosecond_: an integer in the inclusive interval from 0 to 999,
          _calendar_: a String or Object,
          _precision_: an integer in the inclusive interval from 0 to 9, *"minute"*, or *"auto"*,
          _showCalendar_: *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It formats the internal slots of a Temporal.PlainDateTime into an ISO 8601 string, to the precision specified by _precision_.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_isoYear_, _isoMonth_, _isoDay_) is *true*.
        1. Let _yearString_ be PadISOYear(_isoYear_).
        1. Let _monthString_ be ToZeroPaddedDecimalString(_isoMonth_, 2).
        1. Let _dayString_ be ToZeroPaddedDecimalString(_isoDay_, 2).
        1. Let _subSecondNanoseconds_ be _millisecond_ &times; 10<sup>6</sup> + _microsecond_ &times; 10<sup>3</sup> + _nanosecond_.
        1. Let _timeString_ be FormatTimeString(_hour_, _minute_, _second_, _subSecondNanoseconds_, _precision_).
        1. Let _calendarString_ be ? MaybeFormatCalendarAnnotation(_calendar_, _showCalendar_).
        1. Return the string-concatenation of _yearString_, the code unit 0x002D (HYPHEN-MINUS), _monthString_, the code unit 0x002D (HYPHEN-MINUS), _dayString_, 0x0054 (LATIN CAPITAL LETTER T), _timeString_, and _calendarString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-compareisodatetime" type="abstract operation">
      <h1>
        CompareISODateTime (
          _y1_: an integer,
          _mon1_: an integer,
          _d1_: an integer,
          _h1_: an integer in the inclusive interval from 0 to 23,
          _min1_: an integer in the inclusive interval from 0 to 59,
          _s1_: an integer in the inclusive interval from 0 to 59,
          _ms1_: an integer in the inclusive interval from 0 to 999,
          _mus1_: an integer in the inclusive interval from 0 to 999,
          _ns1_: an integer in the inclusive interval from 0 to 999,
          _y2_: an integer,
          _mon2_: an integer,
          _d2_: an integer,
          _h2_: an integer in the inclusive interval from 0 to 23,
          _min2_: an integer in the inclusive interval from 0 to 59,
          _s2_: an integer in the inclusive interval from 0 to 59,
          _ms2_: an integer in the inclusive interval from 0 to 999,
          _mus2_: an integer in the inclusive interval from 0 to 999,
          _ns2_: an integer in the inclusive interval from 0 to 999,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs a comparison of two date-times according to ISO 8601 calendar arithmetic.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_y1_, _mon1_, _d1_) is *true*.
        1. Assert: IsValidISODate(_y2_, _mon2_, _d2_) is *true*.
        1. Let _dateResult_ be CompareISODate(_y1_, _mon1_, _d1_, _y2_, _mon2_, _d2_).
        1. If _dateResult_ is not 0, then
          1. Return _dateResult_.
        1. Return CompareTemporalTime(_h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddatetime" type="abstract operation">
      <h1>
        AddDateTime (
          _year_: an integer,
          _month_: an integer in the inclusive interval from 1 to 12,
          _day_: an integer in the inclusive interval from 1 to 31,
          _hour_: an integer in the inclusive interval from 0 to 23,
          _minute_: an integer in the inclusive interval from 0 to 59,
          _second_: an integer in the inclusive interval from 0 to 59,
          _millisecond_: an integer in the inclusive interval from 0 to 999,
          _microsecond_: an integer in the inclusive interval from 0 to 999,
          _nanosecond_: an integer in the inclusive interval from 0 to 999,
          _calendarRec_: a Calendar Methods Record,
          _years_: an integer,
          _months_: an integer,
          _weeks_: an integer,
          _days_: an integer,
          _norm_: a Normalized Time Duration Record,
          _options_: an Object or *undefined*,
        ): either a normal completion containing an ISO Date-Time Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds a duration to a combined date and time, according to the reckoning of the given _calendar_, and returns the result as a Record.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: ISODateTimeWithinLimits(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _timeResult_ be AddTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _norm_).
        1. Let _datePart_ be ! CreateTemporalDate(_year_, _month_, _day_, _calendarRec_.[[Receiver]]).
        1. Let _dateDuration_ be ? CreateTemporalDuration(_years_, _months_, _weeks_, _days_ + _timeResult_.[[Days]], 0, 0, 0, 0, 0, 0).
        1. Let _addedDate_ be ? AddDate(_calendarRec_, _datePart_, _dateDuration_, _options_).
        1. Return ISO Date-Time Record {
            [[Year]]: _addedDate_.[[ISOYear]],
            [[Month]]: _addedDate_.[[ISOMonth]],
            [[Day]]: _addedDate_.[[ISODay]],
            [[Hour]]: _timeResult_.[[Hour]],
            [[Minute]]: _timeResult_.[[Minute]],
            [[Second]]: _timeResult_.[[Second]],
            [[Millisecond]]: _timeResult_.[[Millisecond]],
            [[Microsecond]]: _timeResult_.[[Microsecond]],
            [[Nanosecond]]: _timeResult_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundisodatetime" type="abstract operation">
      <h1>
        RoundISODateTime (
          _year_: an integer,
          _month_: an integer in the inclusive interval from 1 to 12,
          _day_: an integer in the inclusive interval from 1 to 31,
          _hour_: an integer in the inclusive interval from 0 to 23,
          _minute_: an integer in the inclusive interval from 0 to 59,
          _second_: an integer in the inclusive interval from 0 to 59,
          _millisecond_: an integer in the inclusive interval from 0 to 999,
          _microsecond_: an integer in the inclusive interval from 0 to 999,
          _nanosecond_: an integer in the inclusive interval from 0 to 999,
          _increment_: an integer,
          _unit_: *"day"*, *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, or *"nanosecond"*,
          _roundingMode_: a String from the Identifier column of <emu-xref href="#table-temporal-rounding-modes"></emu-xref>,
        ): an ISO Date-Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It rounds the time part of a combined date and time, carrying over any excess into the date part.</dd>
      </dl>
      <emu-alg>
        1. Assert: ISODateTimeWithinLimits(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _roundedTime_ be RoundTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _increment_, _unit_, _roundingMode_).
        1. Let _balanceResult_ be BalanceISODate(_year_, _month_, _day_ + _roundedTime_.[[Days]]).
        1. Return ISO Date-Time Record {
            [[Year]]: _balanceResult_.[[Year]],
            [[Month]]: _balanceResult_.[[Month]],
            [[Day]]: _balanceResult_.[[Day]],
            [[Hour]]: _roundedTime_.[[Hour]],
            [[Minute]]: _roundedTime_.[[Minute]],
            [[Second]]: _roundedTime_.[[Second]],
            [[Millisecond]]: _roundedTime_.[[Millisecond]],
            [[Microsecond]]: _roundedTime_.[[Microsecond]],
            [[Nanosecond]]: _roundedTime_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differenceisodatetime" type="abstract operation">
      <h1>
        DifferenceISODateTime (
          _y1_: an integer,
          _mon1_: an integer between 1 and 12 inclusive,
          _d1_: an integer between 1 and 31 inclusive,
          _h1_: an integer between 0 and 23 inclusive,
          _min1_: an integer between 0 and 59 inclusive,
          _s1_: an integer between 0 and 59 inclusive,
          _ms1_: an integer between 0 and 999 inclusive,
          _mus1_: an integer between 0 and 999 inclusive,
          _ns1_: an integer between 0 and 999 inclusive,
          _y2_: an integer,
          _mon2_: an integer between 1 and 12 inclusive,
          _d2_: an integer between 1 and 31 inclusive,
          _h2_: an integer between 0 and 23 inclusive,
          _min2_: an integer between 0 and 59 inclusive,
          _s2_: an integer between 0 and 59 inclusive,
          _ms2_: an integer between 0 and 999 inclusive,
          _mus2_: an integer between 0 and 999 inclusive,
          _ns2_: an integer between 0 and 999 inclusive,
          _calendarRec_: a Calendar Methods Record,
          _largestUnit_: a String,
          _options_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
        ): either a normal completion containing a Normalized Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The returned Duration Record contains the elapsed duration from a first date and time, until a second date and time, according to the reckoning of the given calendar.
          The given date and time units are all in the ISO 8601 calendar.
          The _largestUnit_ and _options_ arguments are used in _calendar_'s `dateUntil` method.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: ISODateTimeWithinLimits(_y1_, _mon1_, _d1_, _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_) is *true*.
        1. Assert: ISODateTimeWithinLimits(_y2_, _mon2_, _d2_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_) is *true*.
        1. Assert: If _y1_ &ne; _y2_, and _mon1_ &ne; _mon2_, and _d1_ &ne; _d2_, and LargerOfTwoTemporalUnits(_largestUnit_, *"day"*) is not *"day"*, CalendarMethodsRecordHasLookedUp(_calendarRec_, ~date-until~) is *true*.
        1. Let _timeDuration_ be DifferenceTime(_h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_).
        1. Let _timeSign_ be NormalizedTimeDurationSign(_timeDuration_).
        1. Let _dateSign_ be CompareISODate(_y2_, _mon2_, _d2_, _y1_, _mon1_, _d1_).
        1. Let _adjustedDate_ be CreateISODateRecord(_y1_, _mon1_, _d1_).
        1. If _timeSign_ is -_dateSign_, then
          1. Set _adjustedDate_ to BalanceISODate(_adjustedDate_.[[Year]], _adjustedDate_.[[Month]], _adjustedDate_.[[Day]] - _timeSign_).
          1. Set _timeDuration_ to ? Add24HourDaysToNormalizedTimeDuration(_timeDuration_, -_timeSign_).
        1. Let _date1_ be ! CreateTemporalDate(_adjustedDate_.[[Year]], _adjustedDate_.[[Month]], _adjustedDate_.[[Day]], _calendarRec_.[[Receiver]]).
        1. Let _date2_ be ! CreateTemporalDate(_y2_, _mon2_, _d2_, _calendarRec_.[[Receiver]]).
        1. Let _dateLargestUnit_ be LargerOfTwoTemporalUnits(*"day"*, _largestUnit_).
        1. Let _untilOptions_ be ! SnapshotOwnProperties(_options_, *null*).
        1. Perform ! CreateDataPropertyOrThrow(_untilOptions_, *"largestUnit"*, _dateLargestUnit_).
        1. Let _dateDifference_ be ? DifferenceDate(_calendarRec_, _date1_, _date2_, _untilOptions_).
        1. Return ? CreateNormalizedDurationRecord(_dateDifference_.[[Years]], _dateDifference_.[[Months]], _dateDifference_.[[Weeks]], _dateDifference_.[[Days]], _timeDuration_).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-differencetemporalplaindatetime" type="abstract operation">
      <h1>
        DifferenceTemporalPlainDateTime (
          _operation_: ~since~ or ~until~,
          _dateTime_: a Temporal.PlainDateTime,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _dateTime_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~since~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Set _other_ to ? ToTemporalDateTime(_other_).
        1. If ? CalendarEquals(_dateTime_.[[Calendar]], _other_.[[Calendar]]) is *false*, throw a *RangeError* exception.
        1. Let _resolvedOptions_ be ? SnapshotOwnProperties(? GetOptionsObject(_options_), *null*).
        1. Let _settings_ be ? GetDifferenceSettings(_operation_, _resolvedOptions_, ~datetime~, &laquo; &raquo;, *"nanosecond"*, *"day"*).
        1. Let _datePartsIdentical_ be *false*.
        1. If _dateTime_.[[ISOYear]] = _other_.[[ISOYear]], and _dateTime_.[[ISOMonth]] = _other_.[[ISOMonth]], and _dateTime_.[[ISODay]] = _other_.[[ISODay]], then
          1. Set _datePartsIdentical_ to *true*.
        1. If _datePartsIdentical_ is *true*, and _dateTime_.[[ISOHour]] = _other_.[[ISOHour]], and _dateTime_.[[ISOMinute]] = _other_.[[ISOMinute]], and _dateTime_.[[ISOSecond]] = _other_.[[ISOSecond]], and _dateTime_.[[ISOMillisecond]] = _other_.[[ISOMillisecond]], and _dateTime_.[[ISOMicrosecond]] = _other_.[[ISOMicrosecond]], and _dateTime_.[[ISONanosecond]] = _other_.[[ISONanosecond]], then
          1. Return ! CreateTemporalDuration(0, 0, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_dateTime_.[[Calendar]], ¬´ ~date-add~, ~date-until~ ¬ª).
        1. Let _result_ be ? DifferenceISODateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _other_.[[ISOYear]], _other_.[[ISOMonth]], _other_.[[ISODay]], _other_.[[ISOHour]], _other_.[[ISOMinute]], _other_.[[ISOSecond]], _other_.[[ISOMillisecond]], _other_.[[ISOMicrosecond]], _other_.[[ISONanosecond]], _calendarRec_, _settings_.[[LargestUnit]], _resolvedOptions_).
        1. If _settings_.[[SmallestUnit]] is *"nanosecond"* and _settings_.[[RoundingIncrement]] = 1, let _roundingGranularityIsNoop_ be *true*; else let _roundingGranularityIsNoop_ be *false*.
        1. If _roundingGranularityIsNoop_ is *false*, then
          1. Let _relativeTo_ be ! CreateTemporalDate(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[Calendar]]).
          1. Let _roundRecord_ be ? RoundDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], _result_.[[NormalizedTime]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]], _relativeTo_, _calendarRec_).
          1. Let _roundResult_ be _roundRecord_.[[NormalizedDuration]].
          1. Let _normWithDays_ be ? Add24HourDaysToNormalizedTimeDuration(_roundResult_.[[NormalizedTime]], _roundResult_.[[Days]]).
          1. Let _timeResult_ be BalanceTimeDuration(_normWithDays_, _settings_.[[LargestUnit]]).
          1. Let _balanceResult_ be ? BalanceDateDurationRelative(_roundResult_.[[Years]], _roundResult_.[[Months]], _roundResult_.[[Weeks]], _timeResult_.[[Days]], _settings_.[[LargestUnit]], _settings_.[[SmallestUnit]], _relativeTo_, _calendarRec_).
        1. Else,
          1. Let _normWithDays_ be ? Add24HourDaysToNormalizedTimeDuration(_result_.[[NormalizedTime]], _result_.[[Days]]).
          1. Let _timeResult_ be BalanceTimeDuration(_normWithDays_, _settings_.[[LargestUnit]]).
          1. Let _balanceResult_ be ! CreateDateDurationRecord(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _timeResult_.[[Days]]).
        1. Return ? CreateTemporalDuration(_sign_ &times; _balanceResult_.[[Years]], _sign_ &times; _balanceResult_.[[Months]], _sign_ &times; _balanceResult_.[[Weeks]], _sign_ &times; _balanceResult_.[[Days]], _sign_ &times; _timeResult_.[[Hours]], _sign_ &times; _timeResult_.[[Minutes]], _sign_ &times; _timeResult_.[[Seconds]], _sign_ &times; _timeResult_.[[Milliseconds]], _sign_ &times; _timeResult_.[[Microseconds]], _sign_ &times; _timeResult_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-adddurationtoorsubtractdurationfromplaindatetime" type="abstract operation">
      <h1>
        AddDurationToOrSubtractDurationFromPlainDateTime (
          _operation_: ~add~ or ~subtract~,
          _dateTime_: a Temporal.PlainDateTime,
          _temporalDurationLike_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.PlainDateTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds/subtracts _temporalDurationLike_ to/from _dateTime_, returning a point in time that is in the future/past relative to _datetime_.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~subtract~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Let _duration_ be ? ToTemporalDurationRecord(_temporalDurationLike_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_dateTime_.[[Calendar]], ¬´ ~date-add~ ¬ª).
        1. Let _norm_ be NormalizeTimeDuration(_sign_ &times; _duration_.[[Hours]], _sign_ &times; _duration_.[[Minutes]], _sign_ &times; _duration_.[[Seconds]], _sign_ &times; _duration_.[[Milliseconds]], _sign_ &times; _duration_.[[Microseconds]], _sign_ &times; _duration_.[[Nanoseconds]]).
        1. Let _result_ be ? AddDateTime(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _calendarRec_, _sign_ &times; _duration_.[[Years]], _sign_ &times; _duration_.[[Months]], _sign_ &times; _duration_.[[Weeks]], _sign_ &times; _duration_.[[Days]], _norm_, _options_).
        1. Assert: IsValidISODate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Assert: IsValidTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ? CreateTemporalDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
