<!DOCTYPE html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaindatetime-objects">
  <h1>Temporal.PlainDateTime Objects</h1>
  <p>A Temporal.PlainDateTime object is an Object that contains integers corresponding to a particular year, month, day, hour, minute, second, millisecond, microsecond, and nanosecond.</p>

  <emu-clause id="sec-temporal-plaindatetime-constructor">
    <h1>The Temporal.PlainDateTime Constructor</h1>
    <p>The Temporal.PlainDateTime constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.PlainDateTime object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.PlainDateTime behaviour must
        include a super call to the %Temporal.PlainDateTime% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.plaindatetime">
      <h1>Temporal.PlainDateTime ( _isoYear_, _isoMonth_, _isoDay_ [ , _hour_ [ , _minute_ [ , _second_ [ , _millisecond_ [ , _microsecond_ [ , _nanosecond_ [ , _calendar_ ] ] ] ] ] ] ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _isoYear_ to ? ToIntegerWithTruncation(_isoYear_).
        1. Set _isoMonth_ to ? ToIntegerWithTruncation(_isoMonth_).
        1. Set _isoDay_ to ? ToIntegerWithTruncation(_isoDay_).
        1. If _hour_ is *undefined*, set _hour_ to 0; else set _hour_ to ? ToIntegerWithTruncation(_hour_).
        1. If _minute_ is *undefined*, set _minute_ to 0; else set _minute_ to ? ToIntegerWithTruncation(_minute_).
        1. If _second_ is *undefined*, set _second_ to 0; else set _second_ to ? ToIntegerWithTruncation(_second_).
        1. If _millisecond_ is *undefined*, set _millisecond_ to 0; else set _millisecond_ to ? ToIntegerWithTruncation(_millisecond_).
        1. If _microsecond_ is *undefined*, set _microsecond_ to 0; else set _microsecond_ to ? ToIntegerWithTruncation(_microsecond_).
        1. If _nanosecond_ is *undefined*, set _nanosecond_ to 0; else set _nanosecond_ to ? ToIntegerWithTruncation(_nanosecond_).
        1. If _calendar_ is *undefined*, set _calendar_ to *"iso8601"*.
        1. If _calendar_ is not a String, throw a *TypeError* exception.
        1. Set _calendar_ to ? CanonicalizeCalendar(_calendar_).
        1. If IsValidISODate(_isoYear_, _isoMonth_, _isoDay_) is *false*, throw a *RangeError* exception.
        1. Let _isoDate_ be CreateISODateRecord(_isoYear_, _isoMonth_, _isoDay_).
        1. If IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, throw a *RangeError* exception.
        1. Let _time_ be CreateTimeRecord(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_isoDate_, _time_).
        1. Return ? CreateTemporalDateTime(_isoDateTime_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindatetime-constructor">
    <h1>Properties of the Temporal.PlainDateTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.PlainDateTime constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.PlainDateTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal.plaindatetime.prototype">
      <h1>Temporal.PlainDateTime.prototype</h1>
      <p>The initial value of `Temporal.PlainDateTime.prototype` is %Temporal.PlainDateTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.from">
      <h1>Temporal.PlainDateTime.from ( _item_ [ , _options_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Return ? ToTemporalDateTime(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.compare">
      <h1>Temporal.PlainDateTime.compare ( _one_, _two_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDateTime(_one_).
        1. Set _two_ to ? ToTemporalDateTime(_two_).
        1. Return ùîΩ(CompareISODateTime(_one_.[[ISODateTime]], _two_.[[ISODateTime]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindatetime-prototype-object">
    <h1>Properties of the Temporal.PlainDateTime Prototype Object</h1>

    <p>The Temporal.PlainDateTime prototype object</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.PlainDateTime.prototype%</dfn>.</li>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.PlainDateTime instance and does not have a [[InitializedTemporalDateTime]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-note>
      An ECMAScript implementation that includes the ECMA-402 Internationalization API extends this prototype with additional properties in order to represent calendar data.
    </emu-note>

    <emu-clause id="sec-temporal.plaindatetime.prototype.constructor">
      <h1>Temporal.PlainDateTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainDateTime.prototype.constructor` is %Temporal.PlainDateTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype-%symbol.tostringtag%">
      <h1>Temporal.PlainDateTime.prototype[ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Temporal.PlainDateTime"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.calendarid">
      <h1>get Temporal.PlainDateTime.prototype.calendarId</h1>
      <p>
        `Temporal.PlainDateTime.prototype.calendarId` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.era">
      <h1>get Temporal.PlainDateTime.prototype.era</h1>
      <p>
        `Temporal.PlainDate.prototype.era` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _plainDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
        1. Return CalendarISOToDate(_plainDateTime_.[[Calendar]], _plainDateTime_.[[ISODateTime]].[[ISODate]]).[[Era]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.erayear">
      <h1>get Temporal.PlainDateTime.prototype.eraYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _plainDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
        1. Let _result_ be CalendarISOToDate(_plainDateTime_.[[Calendar]], _plainDateTime_.[[ISODateTime]].[[ISODate]]).[[EraYear]].
        1. If _result_ is *undefined*, return *undefined*.
        1. Return ùîΩ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.year">
      <h1>get Temporal.PlainDateTime.prototype.year</h1>
      <p>
        `Temporal.PlainDateTime.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[Year]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.month">
      <h1>get Temporal.PlainDateTime.prototype.month</h1>
      <p>
        `Temporal.PlainDateTime.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[Month]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.monthcode">
      <h1>get Temporal.PlainDateTime.prototype.monthCode</h1>
      <p>
        `Temporal.PlainDateTime.prototype.monthCode` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[MonthCode]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.day">
      <h1>get Temporal.PlainDateTime.prototype.day</h1>
      <p>
        `Temporal.PlainDateTime.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.hour">
      <h1>get Temporal.PlainDateTime.prototype.hour</h1>
      <p>
        `Temporal.PlainDateTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISODateTime]].[[Time]].[[Hour]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.minute">
      <h1>get Temporal.PlainDateTime.prototype.minute</h1>
      <p>
        `Temporal.PlainDateTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISODateTime]].[[Time]].[[Minute]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.second">
      <h1>get Temporal.PlainDateTime.prototype.second</h1>
      <p>
        `Temporal.PlainDateTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISODateTime]].[[Time]].[[Second]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.millisecond">
      <h1>get Temporal.PlainDateTime.prototype.millisecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISODateTime]].[[Time]].[[Millisecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.microsecond">
      <h1>get Temporal.PlainDateTime.prototype.microsecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISODateTime]].[[Time]].[[Microsecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.nanosecond">
      <h1>get Temporal.PlainDateTime.prototype.nanosecond</h1>
      <p>
        `Temporal.PlainDateTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(_dateTime_.[[ISODateTime]].[[Time]].[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.dayofweek">
      <h1>get Temporal.PlainDateTime.prototype.dayOfWeek</h1>
      <p>
        `Temporal.PlainDateTime.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[DayOfWeek]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.dayofyear">
      <h1>get Temporal.PlainDateTime.prototype.dayOfYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[DayOfYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.weekofyear">
      <h1>get Temporal.PlainDateTime.prototype.weekOfYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _result_ be CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[WeekOfYear]].[[Week]].
        1. If _result_ is *undefined*, return *undefined*.
        1. Return ùîΩ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.yearofweek">
      <h1>get Temporal.PlainDateTime.prototype.yearOfWeek</h1>
      <p>
        `Temporal.PlainDateTime.prototype.yearOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _result_ be CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[WeekOfYear]].[[Year]].
        1. If _result_ is *undefined*, return *undefined*.
        1. Return ùîΩ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.daysinweek">
      <h1>get Temporal.PlainDateTime.prototype.daysInWeek</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[DaysInWeek]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.daysinmonth">
      <h1>get Temporal.PlainDateTime.prototype.daysInMonth</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[DaysInMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.daysinyear">
      <h1>get Temporal.PlainDateTime.prototype.daysInYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[DaysInYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.monthsinyear">
      <h1>get Temporal.PlainDateTime.prototype.monthsInYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ùîΩ(CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[MonthsInYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindatetime.prototype.inleapyear">
      <h1>get Temporal.PlainDateTime.prototype.inLeapYear</h1>
      <p>
        `Temporal.PlainDateTime.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return CalendarISOToDate(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]]).[[InLeapYear]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.with">
      <h1>Temporal.PlainDateTime.prototype.with ( _temporalDateTimeLike_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If ? IsPartialTemporalObject(_temporalDateTimeLike_) is *false*, throw a *TypeError* exception.
        1. Let _calendar_ be _dateTime_.[[Calendar]].
        1. Let _fields_ be ISODateToFields(_calendar_, _dateTime_.[[ISODateTime]].[[ISODate]], ~date~).
        1. Set _fields_.[[Hour]] to _dateTime_.[[ISODateTime]].[[Time]].[[Hour]].
        1. Set _fields_.[[Minute]] to _dateTime_.[[ISODateTime]].[[Time]].[[Minute]].
        1. Set _fields_.[[Second]] to _dateTime_.[[ISODateTime]].[[Time]].[[Second]].
        1. Set _fields_.[[Millisecond]] to _dateTime_.[[ISODateTime]].[[Time]].[[Millisecond]].
        1. Set _fields_.[[Microsecond]] to _dateTime_.[[ISODateTime]].[[Time]].[[Microsecond]].
        1. Set _fields_.[[Nanosecond]] to _dateTime_.[[ISODateTime]].[[Time]].[[Nanosecond]].
        1. Let _partialDateTime_ be ? PrepareCalendarFields(_calendar_, _temporalDateTimeLike_, ¬´ ~year~, ~month~, ~month-code~, ~day~ ¬ª, ¬´ ~hour~, ~minute~, ~second~, ~millisecond~, ~microsecond~, ~nanosecond~ ¬ª, ~partial~).
        1. Set _fields_ to CalendarMergeFields(_calendar_, _fields_, _partialDateTime_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? GetTemporalOverflowOption(_resolvedOptions_).
        1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _overflow_).
        1. Return ? CreateTemporalDateTime(_result_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.withplaintime">
      <h1>Temporal.PlainDateTime.prototype.withPlainTime ( [ _plainTimeLike_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _time_ be ? ToTimeRecordOrMidnight(_plainTimeLike_).
        1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_dateTime_.[[ISODateTime]].[[ISODate]], _time_).
        1. Return ? CreateTemporalDateTime(_isoDateTime_, _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.withcalendar">
      <h1>Temporal.PlainDateTime.prototype.withCalendar ( _calendarLike_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _calendar_ be ? ToTemporalCalendarIdentifier(_calendarLike_).
        1. Return ! CreateTemporalDateTime(_dateTime_.[[ISODateTime]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.add">
      <h1>Temporal.PlainDateTime.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? AddDurationToDateTime(~add~, _dateTime_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.subtract">
      <h1>Temporal.PlainDateTime.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? AddDurationToDateTime(~subtract~, _dateTime_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.until">
      <h1>Temporal.PlainDateTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? DifferenceTemporalPlainDateTime(~until~, _dateTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.since">
      <h1>Temporal.PlainDateTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? DifferenceTemporalPlainDateTime(~since~, _dateTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.round">
      <h1>Temporal.PlainDateTime.prototype.round ( _roundTo_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If _roundTo_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If _roundTo_ is a String, then
          1. Let _paramString_ be _roundTo_.
          1. Set _roundTo_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_roundTo_, *"smallestUnit"*, _paramString_).
        1. Else,
          1. Set _roundTo_ to ? GetOptionsObject(_roundTo_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (GetRoundingIncrementOption reads *"roundingIncrement"* and GetRoundingModeOption reads *"roundingMode"*).
        1. Let _roundingIncrement_ be ? GetRoundingIncrementOption(_roundTo_).
        1. Let _roundingMode_ be ? GetRoundingModeOption(_roundTo_, ~half-expand~).
        1. Let _smallestUnit_ be ? GetTemporalUnitValuedOption(_roundTo_, *"smallestUnit"*, ~time~, ~required~, ¬´ ~day~ ¬ª).
        1. If _smallestUnit_ is ~day~, then
          1. Let _maximum_ be 1.
          1. Let _inclusive_ be *true*.
        1. Else,
          1. Let _maximum_ be MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
          1. Assert: _maximum_ is not ~unset~.
          1. Let _inclusive_ be *false*.
        1. Perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, _inclusive_).
        1. If _smallestUnit_ is ~nanosecond~ and _roundingIncrement_ = 1, then
          1. Return ! CreateTemporalDateTime(_dateTime_.[[ISODateTime]], _dateTime_.[[Calendar]]).
        1. Let _result_ be RoundISODateTime(_dateTime_.[[ISODateTime]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Return ? CreateTemporalDateTime(_result_, _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.equals">
      <h1>Temporal.PlainDateTime.prototype.equals ( _other_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Set _other_ to ? ToTemporalDateTime(_other_).
        1. If CompareISODateTime(_dateTime_.[[ISODateTime]], _other_.[[ISODateTime]]) ‚â† 0, return *false*.
        1. Return CalendarEquals(_dateTime_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.tostring">
      <h1>Temporal.PlainDateTime.prototype.toString ( [ _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (GetTemporalShowCalendarNameOption reads *"calendarName"*, GetTemporalFractionalSecondDigitsOption reads *"fractionalSecondDigits"*, and GetRoundingModeOption reads *"roundingMode"*).
        1. Let _showCalendar_ be ? GetTemporalShowCalendarNameOption(_resolvedOptions_).
        1. Let _digits_ be ? GetTemporalFractionalSecondDigitsOption(_resolvedOptions_).
        1. Let _roundingMode_ be ? GetRoundingModeOption(_resolvedOptions_, ~trunc~).
        1. Let _smallestUnit_ be ? GetTemporalUnitValuedOption(_resolvedOptions_, *"smallestUnit"*, ~time~, ~unset~).
        1. If _smallestUnit_ is ~hour~, throw a *RangeError* exception.
        1. Let _precision_ be ToSecondsStringPrecisionRecord(_smallestUnit_, _digits_).
        1. Let _result_ be RoundISODateTime(_dateTime_.[[ISODateTime]], _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. If ISODateTimeWithinLimits(_result_) is *false*, throw a *RangeError* exception.
        1. Return ISODateTimeToString(_result_, _dateTime_.[[Calendar]], _precision_.[[Precision]], _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.tolocalestring">
      <h1>Temporal.PlainDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ISODateTimeToString(_dateTime_.[[ISODateTime]], _dateTime_.[[Calendar]], ~auto~, ~auto~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.tojson">
      <h1>Temporal.PlainDateTime.prototype.toJSON ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ISODateTimeToString(_dateTime_.[[ISODateTime]], _dateTime_.[[Calendar]], ~auto~, ~auto~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.valueof">
      <h1>Temporal.PlainDateTime.prototype.valueOf ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-note>
        <p>
          This method always throws, because in the absence of `valueOf()`, expressions with arithmetic operators such as `plainDateTime1 > plainDateTime2` would fall back to being equivalent to `plainDateTime1.toString() > plainDateTime2.toString()`.
          Lexicographical comparison of serialized strings might not seem obviously wrong, because the result would sometimes be correct.
          Implementations are encouraged to phrase the error message to point users to `Temporal.PlainDateTime.compare()`, `Temporal.PlainDateTime.prototype.equals()`, and/or `Temporal.PlainDateTime.prototype.toString()`.
        </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.tozoneddatetime">
      <h1>Temporal.PlainDateTime.prototype.toZonedDateTime ( _temporalTimeZoneLike_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _timeZone_ be ? ToTemporalTimeZoneIdentifier(_temporalTimeZoneLike_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _disambiguation_ be ? GetTemporalDisambiguationOption(_resolvedOptions_).
        1. Let _epochNs_ be ? GetEpochNanosecondsFor(_timeZone_, _dateTime_.[[ISODateTime]], _disambiguation_).
        1. Return ! CreateTemporalZonedDateTime(_epochNs_, _timeZone_, _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.toplaindate">
      <h1>Temporal.PlainDateTime.prototype.toPlainDate ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! CreateTemporalDate(_dateTime_.[[ISODateTime]].[[ISODate]], _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindatetime.prototype.toplaintime">
      <h1>Temporal.PlainDateTime.prototype.toPlainTime ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! CreateTemporalTime(_dateTime_.[[ISODateTime]].[[Time]]).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaindatetime-instances">
    <h1>Properties of Temporal.PlainDateTime Instances</h1>
    <p>
      Temporal.PlainDateTime instances are ordinary objects that inherit properties from the %Temporal.PlainDateTime.prototype% intrinsic object.
      Temporal.PlainDateTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaldatetime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaldatetime-instances" caption="Internal Slots of Temporal.PlainDateTime Instances">
      <table>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[InitializedTemporalDateTime]]
          </td>
          <td>
            The only specified use of this slot is for distinguishing Temporal.PlainDateTime instances from other objects.
          </td>
        </tr>
        <tr>
          <td>
            [[ISODateTime]]
          </td>
          <td>
            An ISO Date-Time Record.
          </td>
        </tr>
        <tr>
          <td>
            [[Calendar]]
          </td>
          <td>
            A calendar type.
          </td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaindatetime-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-temporal-iso-date-time-records">
      <h1>ISO Date-Time Records</h1>
      <p>
        An <dfn variants="ISO Date-Time Records">ISO Date-Time Record</dfn> is a Record value used to represent a valid calendar date in the ISO 8601 calendar together with a clock time.
        For any ISO Date-Time Record _r_, IsValidISODate(_r_.[[ISODate]].[[Year]], _r_.[[ISODate]][[Month]], _r_.[[ISODate]].[[Day]]) must return *true*, and IsValidTime(_r_.[[Time]].[[Hour]], _r_.[[Time]].[[Minute]], _r_.[[Time]].[[Second]], _r_.[[Time]].[[Millisecond]], _r_.[[Time]].[[Microsecond]], _r_.[[Time]].[[Nanosecond]]) must return *true*.
        It is not necessary for ISODateTimeWithinLimits(_r_) to return *true*.
      </p>
      <p>ISO Date-Time Records have the fields listed in <emu-xref href="#table-temporal-iso-date-time-record-fields"></emu-xref>.</p>
      <emu-table id="table-temporal-iso-date-time-record-fields" caption="ISO Date-Time Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[ISODate]]</td>
            <td>an ISO Date Record</td>
            <td>
              The date in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>[[Time]]</td>
            <td>a Time Record</td>
            <td>The time. The [[Days]] field is ignored.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-timevaluetoisodatetimerecord" type="abstract operation">
      <h1>
        TimeValueToISODateTimeRecord (
          _t_: a finite time value,
        ): an ISO Date-Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It converts a time value into an ISO Date-Time Record.
        </dd>
      </dl>
      <emu-alg>
        1. Let _isoDate_ be CreateISODateRecord(‚Ñù(YearFromTime(_t_)), ‚Ñù(MonthFromTime(_t_)) + 1, ‚Ñù(DateFromTime(_t_))).
        1. Let _time_ be CreateTimeRecord(‚Ñù(HourFromTime(_t_)), ‚Ñù(MinFromTime(_t_)), ‚Ñù(SecFromTime(_t_)), ‚Ñù(msFromTime(_t_)), 0, 0).
        1. Return ISO Date-Time Record { [[ISODate]]: _isoDate_, [[Time]]: _time_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-combineisodateandtimerecord" type="abstract operation">
      <h1>
        CombineISODateAndTimeRecord (
          _isoDate_: an ISO Date Record,
          _time_: a Time Record,
        ): an ISO Date-Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It combines a date and a time into one ISO Date-Time Record.
        </dd>
      </dl>
      <emu-alg>
        1. NOTE: _time_.[[Days]] is ignored.
        1. Return ISO Date-Time Record { [[ISODate]]: _isoDate_, [[Time]]: _time_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatetimewithinlimits" type="abstract operation">
      <h1>
        ISODateTimeWithinLimits (
          _isoDateTime_: an ISO Date-Time Record,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The return value is *true* if the combination of a date in the ISO 8601 calendar with a wall-clock time, given by the arguments, is within the representable range of `Temporal.PlainDateTime`, and *false* otherwise.</dd>
      </dl>
      <emu-note>
        <p>
          Temporal.PlainDateTime objects can represent points in time within 24 hours (8.64 √ó 10<sup>13</sup> nanoseconds) of the Temporal.Instant boundaries.
          This ensures that a Temporal.Instant object can be converted into a Temporal.PlainDateTime object using any time zone.
        </p>
      </emu-note>
      <emu-alg>
        1. If abs(ISODateToEpochDays(_isoDateTime_.[[ISODate]].[[Year]], _isoDateTime_.[[ISODate]].[[Month]] - 1, _isoDateTime_.[[ISODate]].[[Day]])) > 10<sup>8</sup> + 1, return *false*.
        1. Let _ns_ be ‚Ñù(GetUTCEpochNanoseconds(_isoDateTime_)).
        1. If _ns_ ‚â§ nsMinInstant - nsPerDay, then
          1. Return *false*.
        1. If _ns_ ‚â• nsMaxInstant + nsPerDay, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-interprettemporaldatetimefields" type="abstract operation">
      <h1>
        InterpretTemporalDateTimeFields (
          _calendar_: a calendar type,
          _fields_: a Calendar Fields Record,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date-Time Record, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It interprets the date/time fields in the object _fields_ using the given calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _isoDate_ be ? CalendarDateFromFields(_calendar_, _fields_, _overflow_).
        1. Let _time_ be ? RegulateTime(_fields_.[[Hour]], _fields_.[[Minute]], _fields_.[[Second]], _fields_.[[Millisecond]], _fields_.[[Microsecond]], _fields_.[[Nanosecond]], _overflow_).
        1. Return CombineISODateAndTimeRecord(_isoDate_, _time_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldatetime" type="abstract operation">
      <h1>
        ToTemporalDateTime (
          _item_: an ECMAScript language value,
          optional _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.PlainDateTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Converts _item_ to a new Temporal.PlainDateTime instance if possible, and throws otherwise.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. If _item_ is an Object, then
          1. If _item_ has an [[InitializedTemporalDateTime]] internal slot, then
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Return ! CreateTemporalDateTime(_item_.[[ISODateTime]], _item_.[[Calendar]]).
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Let _isoDateTime_ be GetISODateTimeFor(_item_.[[TimeZone]], _item_.[[EpochNanoseconds]]).
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Return ! CreateTemporalDateTime(_isoDateTime_, _item_.[[Calendar]]).
          1. If _item_ has an [[InitializedTemporalDate]] internal slot, then
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_item_.[[ISODate]], MidnightTimeRecord()).
            1. Return ? CreateTemporalDateTime(_isoDateTime_, _item_.[[Calendar]]).
          1. Let _calendar_ be ? GetTemporalCalendarIdentifierWithISODefault(_item_).
          1. Let _fields_ be ? PrepareCalendarFields(_calendar_, _item_, ¬´ ~year~, ~month~, ~month-code~, ~day~ ¬ª, ¬´ ~hour~, ~minute~, ~second~, ~millisecond~, ~microsecond~, ~nanosecond~ ¬ª, ¬´¬ª).
          1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
          1. Let _overflow_ be ? GetTemporalOverflowOption(_resolvedOptions_).
          1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _overflow_).
          1. Return ? CreateTemporalDateTime(_result_, _calendar_).
        1. If _item_ is not a String, throw a *TypeError* exception.
        1. Let _result_ be ? ParseISODateTime(_item_, ¬´ |TemporalDateTimeString[~Zoned]| ¬ª).
        1. If _result_.[[Time]] is ~start-of-day~, let _time_ be MidnightTimeRecord(); else let _time_ be _result_.[[Time]].
        1. Let _calendar_ be _result_.[[Calendar]].
        1. If _calendar_ is ~empty~, set _calendar_ to *"iso8601"*.
        1. Set _calendar_ to ? CanonicalizeCalendar(_calendar_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
        1. Let _isoDate_ be CreateISODateRecord(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
        1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_isoDate_, _time_).
        1. Return ? CreateTemporalDateTime(_isoDateTime_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balanceisodatetime" type="abstract operation">
      <h1>
        BalanceISODateTime (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
        ): an ISO Date-Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Let _balancedTime_ be BalanceTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Let _balancedDate_ be BalanceISODate(_year_, _month_, _day_ + _balancedTime_.[[Days]]).
        1. Return CombineISODateAndTimeRecord(_balancedDate_, _balancedTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatetime" type="abstract operation">
      <h1>
        CreateTemporalDateTime (
          _isoDateTime_: an ISO Date-Time Record,
          _calendar_: a calendar type,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.PlainDateTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.PlainDateTime instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. If ISODateTimeWithinLimits(_isoDateTime_) is *false*, then
          1. Throw a *RangeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.PlainDateTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.PlainDateTime.prototype%"*, ¬´ [[InitializedTemporalDateTime]], [[ISODateTime]], [[Calendar]] ¬ª).
        1. Set _object_.[[ISODateTime]] to _isoDateTime_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatetimetostring" type="abstract operation">
      <h1>
        ISODateTimeToString (
          _isoDateTime_: an ISO Date-Time Record,
          _calendar_: a calendar type,
          _precision_: an integer in the inclusive interval from 0 to 9, ~minute~, or ~auto~,
          _showCalendar_: ~auto~, ~always~, ~never~, or ~critical~,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It formats an ISO Date-Time Record into an ISO 8601 string, to the precision specified by _precision_.</dd>
      </dl>
      <emu-alg>
        1. Let _yearString_ be PadISOYear(_isoDateTime_.[[ISODate]].[[Year]]).
        1. Let _monthString_ be ToZeroPaddedDecimalString(_isoDateTime_.[[ISODate]].[[Month]], 2).
        1. Let _dayString_ be ToZeroPaddedDecimalString(_isoDateTime_.[[ISODate]].[[Day]], 2).
        1. Let _subSecondNanoseconds_ be _isoDateTime_.[[Time]].[[Millisecond]] √ó 10<sup>6</sup> + _isoDateTime_.[[Time]].[[Microsecond]] √ó 10<sup>3</sup> + _isoDateTime_.[[Time]].[[Nanosecond]].
        1. Let _timeString_ be FormatTimeString(_isoDateTime_.[[Time]].[[Hour]], _isoDateTime_.[[Time]].[[Minute]], _isoDateTime_.[[Time]].[[Second]], _subSecondNanoseconds_, _precision_).
        1. Let _calendarString_ be FormatCalendarAnnotation(_calendar_, _showCalendar_).
        1. Return the string-concatenation of _yearString_, the code unit 0x002D (HYPHEN-MINUS), _monthString_, the code unit 0x002D (HYPHEN-MINUS), _dayString_, 0x0054 (LATIN CAPITAL LETTER T), _timeString_, and _calendarString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-compareisodatetime" type="abstract operation">
      <h1>
        CompareISODateTime (
          _isoDateTime1_: an ISO Date-Time Record,
          _isoDateTime2_: an ISO Date-Time Record,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs a comparison of two date-times according to ISO 8601 calendar arithmetic.</dd>
      </dl>
      <emu-alg>
        1. Let _dateResult_ be CompareISODate(_isoDateTime1_.[[ISODate]], _isoDateTime2_.[[ISODate]]).
        1. If _dateResult_ ‚â† 0, return _dateResult_.
        1. Return CompareTimeRecord(_isoDateTime1_.[[Time]], _isoDateTime2_.[[Time]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundisodatetime" type="abstract operation">
      <h1>
        RoundISODateTime (
          _isoDateTime_: an ISO Date-Time Record,
          _increment_: a positive integer,
          _unit_: a time unit or ~day~,
          _roundingMode_: a rounding mode,
        ): an ISO Date-Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It rounds the time part of a combined date and time, carrying over any excess into the date part.</dd>
      </dl>
      <emu-alg>
        1. Assert: ISODateTimeWithinLimits(_isoDateTime_) is *true*.
        1. Let _roundedTime_ be RoundTime(_isoDateTime_.[[Time]], _increment_, _unit_, _roundingMode_).
        1. Let _balanceResult_ be BalanceISODate(_isoDateTime_.[[ISODate]].[[Year]], _isoDateTime_.[[ISODate]].[[Month]], _isoDateTime_.[[ISODate]].[[Day]] + _roundedTime_.[[Days]]).
        1. Return CombineISODateAndTimeRecord(_balanceResult_, _roundedTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differenceisodatetime" type="abstract operation">
      <h1>
        DifferenceISODateTime (
          _isoDateTime1_: an ISO Date-Time Record,
          _isoDateTime2_: an ISO Date-Time Record,
          _calendar_: a calendar type,
          _largestUnit_: a Temporal unit,
        ): either a normal completion containing an Internal Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The returned Internal Duration Record contains the elapsed duration from a first date and time, until a second date and time, according to the reckoning of the given calendar.
          The given date and time units are all in the ISO 8601 calendar.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: ISODateTimeWithinLimits(_isoDateTime1_) is *true*.
        1. Assert: ISODateTimeWithinLimits(_isoDateTime2_) is *true*.
        1. Let _timeDuration_ be DifferenceTime(_isoDateTime1_.[[Time]], _isoDateTime2_.[[Time]]).
        1. Let _timeSign_ be TimeDurationSign(_timeDuration_).
        1. Let _dateSign_ be CompareISODate(_isoDateTime2_.[[ISODate]], _isoDateTime1_.[[ISODate]]).
        1. Let _adjustedDate_ be _isoDateTime2_.[[ISODate]].
        1. If _timeSign_ = -_dateSign_, then
          1. Set _adjustedDate_ to BalanceISODate(_adjustedDate_.[[Year]], _adjustedDate_.[[Month]], _adjustedDate_.[[Day]] + _timeSign_).
          1. Set _timeDuration_ to ? Add24HourDaysToTimeDuration(_timeDuration_, -_timeSign_).
        1. Let _dateLargestUnit_ be LargerOfTwoTemporalUnits(~day~, _largestUnit_).
        1. Let _dateDifference_ be CalendarDateUntil(_calendar_, _isoDateTime1_.[[ISODate]], _adjustedDate_, _dateLargestUnit_).
        1. If _largestUnit_ is not _dateLargestUnit_, then
          1. Set _timeDuration_ to ? Add24HourDaysToTimeDuration(_timeDuration_, _dateDifference_.[[Days]]).
          1. Set _dateDifference_.[[Days]] to 0.
        1. Return ? CombineDateAndTimeDuration(_dateDifference_, _timeDuration_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differenceplaindatetimewithrounding" type="abstract operation">
      <h1>
        DifferencePlainDateTimeWithRounding (
          _isoDateTime1_: an ISO Date-Time Record,
          _isoDateTime2_: an ISO Date-Time Record,
          _calendar_: a calendar type,
          _largestUnit_: a Temporal unit,
          _roundingIncrement_: a positive integer,
          _smallestUnit_: a Temporal unit,
          _roundingMode_: a rounding mode,
        ): either a normal completion containing an Internal Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If CompareISODateTime(_isoDateTime1_, _isoDateTime2_) = 0, then
          1. Return ! CombineDateAndTimeDuration(ZeroDateDuration(), 0).
        1. Let _diff_ be ? DifferenceISODateTime(_isoDateTime1_, _isoDateTime2_, _calendar_, _largestUnit_).
        1. If _smallestUnit_ is ~nanosecond~ and _roundingIncrement_ = 1, return _diff_.
        1. Let _destEpochNs_ be GetUTCEpochNanoseconds(_isoDateTime2_).
        1. Return ? RoundRelativeDuration(_diff_, _destEpochNs_, _isoDateTime1_, ~unset~, _calendar_, _largestUnit_, _roundingIncrement_, _smallestUnit_, _roundingMode_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differenceplaindatetimewithtotal" type="abstract operation">
      <h1>
        DifferencePlainDateTimeWithTotal (
          _isoDateTime1_: an ISO Date-Time Record,
          _isoDateTime2_: an ISO Date-Time Record,
          _calendar_: a calendar type,
          _unit_: a Temporal unit,
        ): either a normal completion containing a mathematical value or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If CompareISODateTime(_isoDateTime1_, _isoDateTime2_) = 0, then
          1. Return 0.
        1. Let _diff_ be ? DifferenceISODateTime(_isoDateTime1_, _isoDateTime2_, _calendar_, _unit_).
        1. If _unit_ is ~nanosecond~, return _diff_.[[Time]].
        1. Let _destEpochNs_ be GetUTCEpochNanoseconds(_isoDateTime2_).
        1. Return ? TotalRelativeDuration(_diff_, _destEpochNs_, _isoDateTime1_, ~unset~, _calendar_, _unit_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencetemporalplaindatetime" type="abstract operation">
      <h1>
        DifferenceTemporalPlainDateTime (
          _operation_: ~since~ or ~until~,
          _dateTime_: a Temporal.PlainDateTime,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _dateTime_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. Set _other_ to ? ToTemporalDateTime(_other_).
        1. If CalendarEquals(_dateTime_.[[Calendar]], _other_.[[Calendar]]) is *false*, throw a *RangeError* exception.
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _settings_ be ? GetDifferenceSettings(_operation_, _resolvedOptions_, ~datetime~, ¬´ ¬ª, ~nanosecond~, ~day~).
        1. If CompareISODateTime(_dateTime_.[[ISODateTime]], _other_.[[ISODateTime]]) = 0, then
          1. Return ! CreateTemporalDuration(0, 0, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _internalDuration_ be ? DifferencePlainDateTimeWithRounding(_dateTime_.[[ISODateTime]], _other_.[[ISODateTime]], _dateTime_.[[Calendar]], _settings_.[[LargestUnit]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]]).
        1. Let _result_ be ? TemporalDurationFromInternal(_internalDuration_, _settings_.[[LargestUnit]]).
        1. If _operation_ is ~since~, set _result_ to CreateNegatedTemporalDuration(_result_).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddurationtodatetime" type="abstract operation">
      <h1>
        AddDurationToDateTime (
          _operation_: ~add~ or ~subtract~,
          _dateTime_: a Temporal.PlainDateTime,
          _temporalDurationLike_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.PlainDateTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds/subtracts _temporalDurationLike_ to/from _dateTime_, returning a point in time that is in the future/past relative to _datetime_.</dd>
      </dl>
      <emu-alg>
        1. Let _duration_ be ? ToTemporalDuration(_temporalDurationLike_).
        1. If _operation_ is ~subtract~, set _duration_ to CreateNegatedTemporalDuration(_duration_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? GetTemporalOverflowOption(_resolvedOptions_).
        1. Let _internalDuration_ be ToInternalDurationRecordWith24HourDays(_duration_).
        1. Let _timeResult_ be AddTime(_dateTime_.[[ISODateTime]].[[Time]], _internalDuration_.[[Time]]).
        1. Let _dateDuration_ be ? AdjustDateDurationRecord(_internalDuration_.[[Date]], _timeResult_.[[Days]]).
        1. Let _addedDate_ be ? CalendarDateAdd(_dateTime_.[[Calendar]], _dateTime_.[[ISODateTime]].[[ISODate]], _dateDuration_, _overflow_).
        1. Let _result_ be CombineISODateAndTimeRecord(_addedDate_, _timeResult_).
        1. Return ? CreateTemporalDateTime(_result_, _dateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
