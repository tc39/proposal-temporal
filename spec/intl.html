<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-intl">
  <h1>Amendments to the ECMAScript® 2021 Internationalization API Specification</h1>

  <emu-note type="editor">
    <p>
      This section lists amendments which must be made to <a href="https://tc39.es/ecma402/">ECMA-402, the ECMAScript® 2021 Internationalization API Specification</a>.
      Text to be added is marked <ins>like this</ins>, and text to be deleted is marked <del>like this</del>.
    </p>
    <p>
      This text is based on top of the ECMA-402 spec text from commit <a href="https://github.com/tc39/ecma402/commit/b5edf2cdcca8d69590796cd41abf8399d249b8a1">b5edf2cdcca8d69590796cd41abf8399d249b8a1</a>.
    </p>
  </emu-note>

  <emu-clause id="sup-time-zone-names">
    <h1><a href="https://tc39.es/ecma402/#sec-time-zone-names">Time Zone Names</a></h1>

    <ins class="block">
      <p>
        <emu-xref href="#sec-time-zone-names"></emu-xref> defines a set of abstract operations concerning the names of supported time zones.
        This section introduces additional requirements on these operations for implementations.
      </p>
    </ins>

    <p>
      The ECMAScript 2021 Internationalization API Specification identifies time zones using the Zone and Link names of the IANA Time Zone Database. Their canonical form is the corresponding Zone name in the casing used in the IANA Time Zone Database.
    </p>

    <p>
      All registered Zone and Link names are allowed. Implementations must recognize all such names, and use best available current and historical information about their offsets from UTC and their daylight saving time rules in calculations. However, the set of combinations of time zone name and language tag for which localized time zone names are available is implementation dependent.
    </p>

    <emu-clause id="sup-isvalidtimezonename">
      <h1><a href="https://tc39.es/ecma402/#sec-isvalidtimezonename">IsValidTimeZoneName</a> ( _timeZone_ )</h1>

      <ins class="block">
        <p>This definition supersedes the definition provided in <emu-xref href="#sec-isvalidtimezonename"></emu-xref>.</p>
      </ins>
      <p>
        The IsValidTimeZoneName abstract operation verifies that the _timeZone_ argument (which must be a String value) represents a valid Zone or Link name of the IANA Time Zone Database.
      </p>
      <p>
        The abstract operation returns true if _timeZone_, converted to upper case as described in <emu-xref href="#sec-case-sensitivity-and-case-mapping"></emu-xref>, is equal to one of the Zone or Link names of the IANA Time Zone Database, converted to upper case as described in <emu-xref href="#sec-case-sensitivity-and-case-mapping"></emu-xref>. It returns false otherwise.
      </p>
    </emu-clause>

    <emu-clause id="sup-canonicalizetimezonename">
      <h1><a href="https://tc39.es/ecma402/#sec-canonicalizetimezonename">CanonicalizeTimeZoneName</a> <ins>( _timeZone_ )</ins></h1>

      <ins class="block">
        <p>This definition supersedes the definition provided in <emu-xref href="#sec-canonicalizetimezonename"></emu-xref>.</p>
      </ins>
      <p>
        The CanonicalizeTimeZoneName abstract operation returns the canonical and case-regularized form of the _timeZone_ argument (which must be a String value that is a valid time zone name as verified by the IsValidTimeZoneName abstract operation).
        The following steps are taken:
      </p>

      <emu-alg>
        1. <ins>Assert: Type(_timeZone_) is String.</ins>
        1. <ins>Assert: ! IsValidTimeZoneName(_timeZone_) is *true*.</ins>
        1. Let _ianaTimeZone_ be the Zone or Link name of the IANA Time Zone Database such that _timeZone_, converted to upper case as described in <emu-xref href="#sec-case-sensitivity-and-case-mapping"></emu-xref>, is equal to _ianaTimeZone_, converted to upper case as described in <emu-xref href="#sec-case-sensitivity-and-case-mapping"></emu-xref>.
        1. If _ianaTimeZone_ is a Link name, let _ianaTimeZone_ be the corresponding Zone name as specified in the *"backward"* file of the IANA Time Zone Database.
        1. If _ianaTimeZone_ is *"Etc/UTC"* or *"Etc/GMT"*, return *"UTC"*.
        1. Return _ianaTimeZone_.
      </emu-alg>

      <p>
        The Intl.DateTimeFormat constructor allows this time zone name; if the time zone is not specified, the host environment's current time zone is used. Implementations shall support UTC and the <del>host environment's current</del> time zone <ins>returned from DefaultTimeZone</ins> (if different from UTC) in formatting.
      </p>
    </emu-clause>

    <emu-clause id="sup-defaulttimezone">
      <h1><a href="https://tc39.es/ecma402/#sec-defaulttimezone">DefaultTimeZone</a> ( )</h1>

      <ins class="block">
        <p>This definition supersedes the definition provided in <emu-xref href="#sec-defaulttimezone"></emu-xref>.</p>
      </ins>
      <p>
        The DefaultTimeZone abstract operation returns a String value representing the valid (<emu-xref href="#sec-isvalidtimezonename"></emu-xref>) and canonicalized (<emu-xref href="#sec-canonicalizetimezonename"></emu-xref>) time zone name for the host environment's current time zone.
      </p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations">
    <h1><a href="https://tc39.es/ecma402/#sec-abstract-operations">Abstract Operations</a></h1>

    <emu-note type="editor">
      <p>In this section, some abstract operations that manipulate options objects are to be moved from ECMA-402 into ECMA-262.</p>
    </emu-note>

    <del class="block">
      <emu-clause id="sec-getoptionsobject-deleted">
        <h1><a href="https://tc39.es/ecma402/#sec-getoptionsobject">GetOptionsObject</a> ( _options_ )</h1>
        <p>
          The abstract operation GetOptionsObject returns an Object suitable for use with GetOption, either _options_ itself or a default empty Object.
          It throws a TypeError if _options_ is not undefined and not an Object.
        </p>
        <emu-alg>
          1. If _options_ is *undefined*, then
            1. Return ! OrdinaryObjectCreate(*null*).
          1. If Type(_options_) is Object, then
            1. Return _options_.
          1. Throw a *TypeError* exception.
        </emu-alg>
      </emu-clause>
    </del>
  </emu-clause>

  <emu-clause id="sec-datetimeformat-abstracts">
    <h1><a href="https://tc39.es/ecma402/#sec-datetimeformat-abstracts">Abstract Operations For DateTimeFormat Objects</a></h1>

    <emu-clause id="sec-temporal-initializedatetimeformat" aoid="InitializeDateTimeFormat">
      <h1>InitializeDateTimeFormat ( _dateTimeFormat_, _locales_, _options_ )</h1>

      <p>
        The abstract operation InitializeDateTimeFormat accepts the arguments _dateTimeFormat_ (which must be an object), _locales_, and _options_. It initializes _dateTimeFormat_ as a DateTimeFormat object. This abstract operation functions as follows:
      </p>

      <p>
        The following algorithm refers to the `type` nonterminal from <a href="https://www.unicode.org/reports/tr35/#Unicode_locale_identifier">UTS 35's Unicode Locale Identifier grammar</a>.
      </p>

      <emu-alg>
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. <del>Let _options_ be ? ToDateTimeOptions(_options_, *"any"*, *"date"*).</del>
        1. Let _opt_ be a new Record.
        1. Let _matcher_ be ? GetOption(_options_, *"localeMatcher"*, *"string"*, « *"lookup"*, *"best fit"* », *"best fit"*).
        1. Set _opt_.[[localeMatcher]] to _matcher_.
        1. Let _calendar_ be ? GetOption(_options_, *"calendar"*, *"string"*, *undefined*, *undefined*).
        1. If _calendar_ is not *undefined*, then
          1. If _calendar_ does not match the Unicode Locale Identifier `type` nonterminal, throw a *RangeError* exception.
        1. Set _opt_.[[ca]] to _calendar_.
        1. Let _numberingSystem_ be ? GetOption(_options_, *"numberingSystem"*, *"string"*, *undefined*, *undefined*).
        1. If _numberingSystem_ is not *undefined*, then
          1. If _numberingSystem_ does not match the Unicode Locale Identifier `type` nonterminal, throw a *RangeError* exception.
        1. Set _opt_.[[nu]] to _numberingSystem_.
        1. Let _hour12_ be ? GetOption(_options_, *"hour12"*, *"boolean"*, *undefined*, *undefined*).
        1. Let _hourCycle_ be ? GetOption(_options_, *"hourCycle"*, *"string"*, « *"h11"*, *"h12"*, *"h23"*, *"h24"* », *undefined*).
        1. If _hour12_ is not *undefined*, then
          1. Let _hourCycle_ be *null*.
        1. Set _opt_.[[hc]] to _hourCycle_.
        1. Let _localeData_ be %DateTimeFormat%.[[LocaleData]].
        1. Let _r_ be ResolveLocale(%DateTimeFormat%.[[AvailableLocales]], _requestedLocales_, _opt_, %DateTimeFormat%.[[RelevantExtensionKeys]], _localeData_).
        1. Set _dateTimeFormat_.[[Locale]] to _r_.[[locale]].
        1. Let _calendar_ be _r_.[[ca]].
        1. Set _dateTimeFormat_.[[Calendar]] to _calendar_.
        1. <del>Set _dateTimeFormat_.[[HourCycle]] to _r_.[[hc]].</del>
        1. <ins>Let _dataLocale_ be _r_.[[dataLocale]].</ins>
        1. <ins>Let _dataLocaleData_ be _localeData_.[[&lt;_dataLocale_&gt;]].</ins>
        1. <ins>Let _hcDefault_ be _dataLocaleData_.[[hourCycle]].</ins>
        1. <ins>Let _hc_ be _r_.[[hc]].</ins>
        1. <ins>If _hc_ is *null*, then</ins>
          1. <ins>Set _hc_ to _hcDefault_.</ins>
        1. <ins>If _hour12_ is not *undefined*, then</ins>
          1. <ins>If _hour12_ is *true*, then</ins>
            1. <ins>If _hcDefault_ is *"h11"* or *"h23"*, then</ins>
              1. <ins>Set _hc_ to *"h11"*.</ins>
            1. <ins>Else,</ins>
              1. <ins>Set _hc_ to *"h12"*.</ins>
          1. <ins>Else,</ins>
            1. <ins>Assert: _hour12_ is *false*.</ins>
            1. <ins>If _hcDefault_ is *"h11"* or *"h23"*, then</ins>
              1. <ins>Set _hc_ to *"h23"*.</ins>
            1. <ins>Else,</ins>
              1. <ins>Set _hc_ to *"h24"*.</ins>
        1. Set _dateTimeFormat_.[[NumberingSystem]] to _r_.[[nu]].
        1. <del>Let _dataLocale_ be _r_.[[dataLocale]].</del>
        1. Let _timeZone_ be ? Get(_options_, *"timeZone"*).
        1. If _timeZone_ is *undefined*, then
          1. Let _timeZone_ be DefaultTimeZone().
        1. Else,
          1. Let _timeZone_ be ? ToString(_timeZone_).
          1. If the result of IsValidTimeZoneName(_timeZone_) is *false*, then
            1. Throw a *RangeError* exception.
          1. Let _timeZone_ be CanonicalizeTimeZoneName(_timeZone_).
        1. Set _dateTimeFormat_.[[TimeZone]] to _timeZone_.
        1. Let _opt_ be a new Record.
        1. For each row of <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, in table order, do
          1. Let _prop_ be the name given in the Property column of the row.
          1. If _prop_ is *"fractionalSecondDigits"*, then
            1. Let _value_ be ? GetNumberOption(options, *"fractionalSecondDigits"*, 1, 3, *undefined*).
          1. Else,
            1. Let _value_ be ? GetOption(_options_, _prop_, *"string"*, « the strings given in the Values column of the row », *undefined*).
          1. Set _opt_.[[&lt;_prop_&gt;]] to _value_.
        1. <del>Let _dataLocaleData_ be _localeData_.[[&lt;_dataLocale_&gt;]].</del>
        1. Let _matcher_ be ? GetOption(_options_, *"formatMatcher"*, *"string"*, « *"basic"*, *"best fit"* », *"best fit"*).
        1. Let _dateStyle_ be ? GetOption(_options_, *"dateStyle"*, *"string"*, « *"full"*, *"long"*, *"medium"*, *"short"* », *undefined*).
        1. Set _dateTimeFormat_.[[DateStyle]] to _dateStyle_.
        1. Let _timeStyle_ be ? GetOption(_options_, *"timeStyle"*, *"string"*, « *"full"*, *"long"*, *"medium"*, *"short"* », *undefined*).
        1. Set _dateTimeFormat_.[[TimeStyle]] to _timeStyle_.
        1. <del>If _dateStyle_ is not *undefined* or _timeStyle_ is not *undefined*, then</del>
          1. <del>For each row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, do</del>
            1. <del>Let _prop_ be the name given in the Property column of the row.</del>
            1. <del>Let _p_ be _opt_.[[&lt;_prop_&gt;]].</del>
            1. <del>If _p_ is not *undefined*, then</del>
              1. <del>Throw a *TypeError* exception.</del>
          1. <del>Let _bestFormat_ be DateTimeStyleFormat(_dateStyle_, _timeStyle_, _dataLocaleData_).</del>
        1. <del>Else,</del>
          1. <del>Let _formats_ be _dataLocaleData_.[[formats]].[[&lt;_calendar_&gt;]].</del>
          1. <del>If _matcher_ is *"basic"*, then</del>
            1. <del>Let _bestFormat_ be BasicFormatMatcher(_opt_, _formats_).</del>
          1. <del>Else,</del>
            1. <del>Let _bestFormat_ be BestFitFormatMatcher(_opt_, _formats_).</del>
        1. <del>For each row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, in table order, do</del>
          1. <del>Let _prop_ be the name given in the Property column of the row.</del>
          1. <del>Let _p_ be _bestFormat_.[[&lt;_prop_&gt;]].</del>
          1. <del>If _p_ not *undefined*, then</del>
            1. <del>Set _dateTimeFormat_'s internal slot whose name is the Internal Slot column of the row to _p_.</del>
        1. <del>If _dateTimeFormat_.[[Hour]] is *undefined*, then</del>
          1. <del>Set _dateTimeFormat_.[[HourCycle]] to *undefined*.</del>
          1. <del>Let _pattern_ be _bestFormat_.[[pattern]].</del>
          1. <del>Let _rangePatterns_ be _bestFormat_.[[rangePatterns]].</del>
        1. <del>Else,</del>
          1. <del>Let _hcDefault_ be _dataLocaleData_.[[hourCycle]].</del>
          1. <del>Let _hc_ be _dateTimeFormat_.[[HourCycle]].</del>
          1. <del>If _hc_ is *null*, then</del>
            1. <del>Set _hc_ to _hcDefault_.</del>
          1. <del>If _hour12_ is not *undefined*, then</del>
            1. <del>If _hour12_ is *true*, then</del>
              1. <del>If _hcDefault_ is *"h11"* or *"h23"*, then</del>
                1. <del>Set _hc_ to *"h11"*.</del>
              1. <del>Else,</del>
                1. <del>Set _hc_ to *"h12"*.</del>
            1. <del>Else,</del>
              1. <del>Assert: _hour12_ is *false*.</del>
              1. <del>If _hcDefault_ is *"h11"* or *"h23"*, then</del>
                1. <del>Set _hc_ to *"h23"*.</del>
              1. <del>Else,</del>
                1. <del>Set _hc_ to *"h24"*.</del>
          1. <del>Set _dateTimeFormat_.[[HourCycle]] to _hc_.</del>
          1. <del>If _dateTimeformat_.[[HourCycle]] is *"h11"* or *"h12"*, then</del>
            1. <del>Let _pattern_ be _bestFormat_.[[pattern12]].</del>
            1. <del>Let _rangePatterns_ be _bestFormat_.[[rangePatterns12]].</del>
          1. <del>Else,</del>
            1. <del>Let _pattern_ be _bestFormat_.[[pattern]].</del>
            1. <del>Let _rangePatterns_ be _bestFormat_.[[rangePatterns]].</del>
        1. <ins>Let _expandedOptions_ be a copy of _opt_.</ins>
        1. <ins>Let _needDefaults_ be *true*.</ins>
        1. <ins>For each element _field_ of « *"weekday"*, *"year"*, *"month"*, *"day"*, *"hour"*, *"minute"*, *"second"* » in List order, do</ins>
          1. <ins>If _expandedOptions_.[[&lt;_field_&gt;]] is not *undefined*, then</ins>
            1. <ins>Set _needDefaults_ to *false*.</ins>
        1. <ins>If _needDefaults_ is *true*, then</ins>
          1. <ins>For each element _field_ of « *"year"*, *"month"*, *"day"*, *"hour"*, *"minute"*, *"second"* » in List order, do</ins>
            1. <ins>Set _expandedOptions_.[[&lt;_field_&gt;]] to *"numeric"*.</ins>
        1. <ins>Let _bestFormat_ be GetDateTimeFormatPattern(_dateStyle_, _timeStyle_, _matcher_, _expandedOptions_, _dataLocaleData_, _hc_).</ins>
        1. Set _dateTimeFormat_.[[Pattern]] to <del>_pattern_</del><ins>_bestFormat_.[[pattern]]</ins>.
        1. Set _dateTimeFormat_.[[RangePatterns]] to <del>_rangePatterns_</del><ins>_bestFormat_.[[rangePatterns]]</ins>.
        1. <ins>For each row in <emu-xref href="#table-temporal-patterns"></emu-xref>, except the header row, in table order, do</ins>
          1. <ins>Let _limitedOptions_ be a new Record.</ins>
          1. <ins>Let _needDefaults_ be *true*.</ins>
          1. <ins>Let _fields_ be the list of fields in the Supported fields column of the row.</ins>
          1. <ins>For each field _field_ of _opt_, do</ins>
            1. <ins>If _field_ is in _fields_, then</ins>
              1. <ins>Set _needDefaults_ to *false*.</ins>
              1. <ins>Set _limitedOptions_.[[&lt;_field_&gt;]] to _opt_.[[&lt;_field_&gt;]].</ins>
          1. <ins>If _needDefaults_ is *true*, then</ins>
            1. <ins>Let _defaultFields_ be the list of fields in the Default fields column of the row.</ins>
            1. <ins>For each _field_ of _defaultFields_, do</ins>
              1. <ins>If _field_ is *"timeZoneName"*, then</ins>
                1. <ins>Let _defaultValue_ be *"short"*.</ins>
              1. <ins>Else,</ins>
                1. <ins>Let _defaultValue_ be *"numeric"*.</ins>
              1. <ins>Set _limitedOptions_.[[&lt;_field_&gt;]] to _defaultValue_.</ins>
          1. <ins>Let _bestFormat_ be GetDateTimeFormatPattern(_matcher_, _limitedOptions_, _formats_, _hc_).</ins>
          1. <ins>If _bestFormat_ does not have any fields that are in _fields_, then</ins>
            1. <ins>Set _bestFormat_ to *null*.</ins>
          1. <ins>Set _dateTimeFormat_'s internal slot whose name is the Pattern column of the row to _bestFormat_.</ins>
        1. Return _dateTimeFormat_.
      </emu-alg>

      <ins class="block">
      <emu-table id="table-temporal-patterns">
        <emu-caption>Supported fields for Temporal patterns</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Supported fields</th>
              <th>Default fields</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>[[TemporalPlainDatePattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]]</td>
              <td>[[year]], [[month]], [[day]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainYearMonthPattern]]</th>
              <td>[[era]], [[year]], [[month]]</td>
              <td>[[year]], [[month]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainMonthDayPattern]]</th>
              <td>[[month]], [[day]]</td>
              <td>[[month]], [[day]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainTimePattern]]</th>
              <td>[[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]]</td>
              <td>[[hour]], [[minute]], [[second]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainDateTimePattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]]</td>
              <td>[[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]]</td>
            </tr>
            <tr>
              <th>[[TemporalInstantPattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]]</td>
              <td>[[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]]</td>
            </tr>
            <tr>
              <th>[[TemporalZonedDateTimePattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]], [[timeZoneName]]</td>
              <td>[[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[timeZoneName]]</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
      </ins>
    </emu-clause>

    <emu-clause id="sec-datetime-format-functions">
      <h1>DateTime Format Functions</h1>

      <p>A DateTime format function is an anonymous built-in function that has a [[DateTimeFormat]] internal slot.</p>
      <p>When a DateTime format function _F_ is called with optional argument _date_, the following steps are taken:</p>

      <emu-alg>
        1. Let _dtf_ be _F_.[[DateTimeFormat]].
        1. Assert: Type(_dtf_) is Object and _dtf_ has an [[InitializedDateTimeFormat]] internal slot.
        1. <del>If _date_ is not provided or is *undefined*, then</del>
          1. <del>Let _x_ be Call(%Date.now%, *undefined*).</del>
        1. <del>Else,</del>
          1. <del>Let _x_ be ? ToNumber(_date_).</del>
        1. Return ? FormatDateTime(_dtf_, <del>_x_</del><ins>_date_</ins>).
      </emu-alg>

      <p>
        The *"length"* property of a DateTime format function is 1.
      </p>
    </emu-clause>

    <emu-clause id="sec-formatdatetimepattern" aoid="FormatDateTimePattern">
      <h1>FormatDateTimePattern ( _dateTimeFormat_, <ins>_pattern_</ins>, _patternParts_, <del>_x_</del><ins>_epochNanoseconds_</ins>, _rangeFormatOptions_ )</h1>

      <p>
      The FormatDateTimePattern abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat), <ins>_pattern_ (which is a Record of the type contained by the %DateTimeFormat%.[[LocaleData]].[[<_locale_>]].[[formats]].[[<_calendar_>]] List as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>),</ins> _patternParts_ (which is a list of Records as returned by PartitionPattern), <del>_x_</del><ins>_epochNanoseconds_</ins> (which must be a <del>Number</del><ins>BigInt</ins> value), and _rangeFormatOptions_ (which is a range pattern Record as used in [[rangePattern]] or *undefined*), interprets _x_ as a time value as specified in ES2021, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>, and creates the corresponding parts according _pattern_ and to the effective locale and the formatting options of _dateTimeFormat_ and _rangeFormatOptions_. The following steps are taken:
      </p>

      <emu-alg>
        1. <del>Let _x_ be TimeClip(_x_).</del>
        1. <del>If _x_ is *NaN*, throw a *RangeError* exception.</del>
        1. Let _locale_ be _dateTimeFormat_.[[Locale]].
        1. Let _nfOptions_ be ObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_nfOptions_, *"useGrouping"*, *false*).
        1. Let _nf_ be ? Construct(%NumberFormat%, « _locale_, _nfOptions_ »).
        1. Let _nf2Options_ be ObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_nf2Options_, *"minimumIntegerDigits"*, 2).
        1. Perform ! CreateDataPropertyOrThrow(_nf2Options_, *"useGrouping"*, *false*).
        1. Let _nf2_ be ? Construct(%NumberFormat%, « _locale_, _nf2Options_ »).
        1. Let _fractionalSecondDigits_ be _dateTimeFormat_.[[FractionalSecondDigits]].
        1. If _fractionalSecondDigits_ is not *undefined*, then
          1. Let _nf3Options_ be ObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_nf3Options_, *"minimumIntegerDigits"*, _fractionalSecondDigits_).
          1. Perform ! CreateDataPropertyOrThrow(_nf3Options_, *"useGrouping"*, *false*).
          1. Let _nf3_ be ? Construct(%NumberFormat%, « _locale_, _nf3Options_ »).
        1. Let _tm_ be ToLocalTime(<del>_x_</del><ins>_epochNanoseconds_</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _result_ be a new empty List.
        1. Let _patternParts_ be PartitionPattern(<del>_dateTimeFormat_.[[Pattern]]</del><ins>_pattern_</ins>).
        1. For each element _patternPart_ of _patternParts_, in List order, do
          1. Let _p_ be _patternPart_.[[Type]].
          1. If _p_ is *"literal"*, then
            1. Append a new Record { [[Type]]: *"literal"*, [[Value]]: _patternPart_.[[Value]] } as the last element of the list _result_.
          1. Else if _p_ is equal to *"fractionalSecondDigits"*, then
            1. Let _v_ be _tm_.[[Millisecond]].
            1. Let _v_ be floor(_v_ × 10<sup>( _fractionalSecondDigits_ - 3 )</sup>).
            1. Let _fv_ be FormatNumeric(_nf3_, _v_).
            1. Append a new Record { [[Type]]: *"fractionalSecond"*, [[Value]]: _fv_ } as the last element of _result_.
          1. Else if _p_ matches a Property column of the row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, then
            1. If _rangeFormatOptions_ is not *undefined*, let _f_ be the value of _rangeFormatOptions_'s field whose name matches _p_.
            1. Else, let _f_ be <del>the value of _dateTimeFormat_'s internal slot whose name is the Internal Slot column of the matching row</del><ins>_pattern_.[[&lt;_p_&gt;]]</ins>.
            1. Let _v_ be the value of _tm_'s field whose name is the Internal Slot column of the matching row.
            1. If _p_ is *"year"* and _v_ ≤ 0, let _v_ be 1 - _v_.
            1. If _p_ is *"month"*, increase _v_ by 1.
            1. If _p_ is *"hour"* and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h11"* or *"h12"*, then
              1. Let _v_ be _v_ modulo 12.
              1. If _v_ is 0 and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h12"*, let _v_ be 12.
            1. If _p_ is *"hour"* and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h24"*, then
              1. If _v_ is 0, let _v_ be 24.
            1. <ins>If _p_ is *timeZoneName*, then</ins>
              1. <ins>If _tm_ has a [[timeZoneName]] field, then</ins>
                1. <ins>Set _v_ to _tm_.[[timeZoneName]].</ins>
              1. <ins>Else,</ins>
                1. <ins>Set _v_ to _dateTimeFormat_.[[TimeZone]].</ins>
            1. If _f_ is *"numeric"*, then
              1. Let _fv_ be FormatNumeric(_nf_, _v_).
            1. Else if _f_ is *"2-digit"*, then
              1. Let _fv_ be FormatNumeric(_nf2_, _v_).
              1. If the *"length"* property of _fv_ is greater than 2, let _fv_ be the substring of _fv_ containing the last two characters.
            1. Else if _f_ is *"narrow"*, *"short"*, or *"long"*, then let _fv_ be a String value representing _v_ in the form given by _f_; the String value depends upon the implementation and the effective locale and calendar of _dateTimeFormat_. If _p_ is *"month"* and _rangeFormatOptions_ is *undefined*, then the String value may also depend on whether <del>_dateTimeFormat_.[[Day]]</del><ins>_pattern_.[[day]]</ins> is *undefined*. If _p_ is *"month"* and _rangeFormatOptions_ is not *undefined*, then the String value may also depend on whether _rangeFormatOptions_.[[day]] is *undefined*. If _p_ is *"timeZoneName"*, then the String value may also depend on the value of the [[InDST]] field of _tm_. If _p_ is *"era"* and _rangeFormatOptions_ is *undefined*, then the String value may also depend on whether <del>_dateTimeFormat_.[[Era]]</del><ins>_pattern_.[[day]]</ins> is *undefined*. If _p_ is *"era"* and _rangeFormatOptions_ is not *undefined*, then the String value may also depend on whether _rangeFormatOptions_.[[era]] is *undefined*. If the implementation does not have a localized representation of _f_, then use _f_ itself.
            1. Append a new Record { [[Type]]: _p_, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"ampm"*, then
            1. Let _v_ be _tm_.[[Hour]].
            1. If _v_ is greater than 11, then
              1. Let _fv_ be an implementation and locale dependent String value representing *"post meridiem"*.
            1. Else,
              1. Let _fv_ be an implementation and locale dependent String value representing *"ante meridiem"*.
            1. Append a new Record { [[Type]]: *"dayPeriod"*, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"relatedYear"*, then
            1. Let _v_ be _tm_.[[RelatedYear]].
            1. Let _fv_ be FormatNumeric(_nf_, _v_).
            1. Append a new Record { [[Type]]: *"relatedYear"*, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"yearName"*, then
            1. Let _v_ be _tm_.[[YearName]].
            1. Append a new Record { [[Type]]: *"yearName"*, [[Value]]: _v_ } as the last element of the list _result_.
          1. Else,
            1. Let _unknown_ be an implementation-, locale-, and numbering system-dependent String based on <del>_x_</del><ins>_epochNanoseconds_</ins> and _p_.
            1. Append a new Record { [[Type]]: *"unknown"*, [[Value]]: _unknown_ } as the last element of _result_.
        1. Return _result_.
      </emu-alg>

      <emu-note>
        It is recommended that implementations use the locale and calendar dependent strings provided by the Common Locale Data Repository (available at <a href="http://cldr.unicode.org">http://cldr.unicode.org</a>), and use CLDR *"abbreviated"* strings for DateTimeFormat *"short"* strings, and CLDR *"wide"* strings for DateTimeFormat *"long"* strings.
      </emu-note>

      <emu-note>
        It is recommended that implementations use the time zone information of the IANA Time Zone Database.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-partitiondatetimepattern" aoid="PartitionDateTimePattern">
      <h1>PartitionDateTimePattern ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The PartitionDateTimePattern abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), <del>interprets _x_ as a time value as specified in ES2021, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>,</del> and creates the corresponding parts according to the effective locale and the formatting options of _dateTimeFormat_. The following steps are taken:
      </p>

      <emu-alg>
        1. <ins>Let _x_ be ? HandleDateTimeValue(_dateTimeFormat_, _x_).</ins>
        1. Let _patternParts_ be PartitionPattern(<del>_dateTimeFormat_.[[Pattern]]</del><ins>_x_.[[pattern]]</ins>).
        1. Let _result_ be ? FormatDateTimePattern(_dateTimeFormat_, <ins>_x_.[[pattern]]</ins>, _patternParts_, <del>_x_</del><ins>_x_.[[epochNanoseconds]]</ins>, *undefined*).
        1. Return _result_.
      </emu-alg>

      <emu-note>
        It is recommended that implementations use the locale and calendar dependent strings provided by the Common Locale Data Repository (available at <a href="http://cldr.unicode.org">http://cldr.unicode.org</a>), and use CLDR *"abbreviated"* strings for DateTimeFormat *"short"* strings, and CLDR *"wide"* strings for DateTimeFormat *"long"* strings.
      </emu-note>

      <emu-note>
        It is recommended that implementations use the time zone information of the IANA Time Zone Database.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-formatdatetime" aoid="FormatDateTime">
      <h1>FormatDateTime ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The FormatDateTime abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimePattern(_dateTimeFormat_, _x_).
        1. Let _result_ be the empty String.
        1. For each Record _part_ in _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatdatetimetoparts" aoid="FormatDateTimeToParts">
      <h1>FormatDateTimeToParts ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The FormatDateTimeToParts abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimePattern(_dateTimeFormat_, _x_).
        1. Let _result_ be ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record _part_ in _parts_, do
          1. Let _O_ be ObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataProperty(_result_, ! ToString(_n_), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-partitiondatetimerangepattern" aoid="PartitionDateTimeRangePattern">
      <h1>PartitionDateTimeRangePattern ( _dateTimeFormat_, _x_, _y_ )</h1>

      <p>
        The PartitionDateTimeRangePattern abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat), _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value) and _y_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), <del>interprets _x_ and _y_ as time values as specified in ES2021, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>,</del> and creates the corresponding parts according to the effective locale and the formatting options of _dateTimeFormat_. The following steps are taken:
      </p>
      <emu-alg>
        1. <del>Let _x_ be TimeClip(_x_).</del>
        1. <del>If _x_ is *NaN*, throw a *RangeError* exception.</del>
        1. <del>Let _y_ be TimeClip(_y_).</del>
        1. <del>If _y_ is *NaN*, throw a *RangeError* exception.</del>
        1. <ins>If either of ! IsTemporalObject(_x_) or ! IsTemporalObject(_y_) is *true*, then</ins>
          1. <ins>If ! SameTemporalType(_x_, _y_) is *false*, throw a *TypeError* exception.</ins>
        1. <ins>Let _x_ be ? HandleDateTimeValue(_dateTimeFormat_, _x_).</ins>
        1. <ins>Let _y_ be ? HandleDateTimeValue(_dateTimeFormat_, _y_).</ins>
        1. If _x_<ins>.[[epochNanoseconds]]</ins> is greater than _y_<ins>.[[epochNanoseconds]]</ins>, throw a *RangeError* exception.
        1. Let _tm1_ be ToLocalTime(_x_<ins>.[[epochNanoseconds]]</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _tm2_ be ToLocalTime(_y_<ins>.[[epochNanoseconds]]</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _rangePatterns_ be <del>_dateTimeFormat_.[[RangePatterns]]</del><ins>_x_.[[rangePatterns]]</ins>.
        1. <ins>Assert: _rangePatterns_ is equal to _y_.[[rangePatterns]].</ins>
        1. Let _rangePattern_ be *undefined*.
        1. Let _dateFieldsPracticallyEqual_ be *true*.
        1. Let _patternContainsLargerDateField_ be *false*.
        1. While _dateFieldsPracticallyEqual_ is *true* and _patternContainsLargerDateField_ is *false*, repeat for each row of <emu-xref href="#table-datetimeformat-rangepatternfields"></emu-xref> in order, except the header row:
          1. Let _fieldName_ be the name given in the Range Pattern Field column of the row.
          1. If _fieldName_ is equal to [[AmPm]], then
            1. Let _rp_ be _rangePatterns_.[[AmPm]].
            1. If _rangePattern_ is not *undefined* and _rp_ is *undefined*, then
              1. Set _patternContainsLargerDateField_ to *true*.
            1. Else,
              1. Let _v1_ be _tm1_.[[Hour]].
              1. Let _v2_ be _tm2_.[[Hour]].
              1. If _v1_ is greater than 11 and _v2_ less or equal than 11, or _v1_ is less or equal than 11 and _v2_ is greater than 11, then
                1. Set _dateFieldsPracticallyEqual_ to *false*.
              1. Let _rangePattern_ be _rp_.
          1. If _fieldName_ is equal to [[FractionalSecondDigits]], then
            1. Let _rp_ be _rangePatterns_.[[FractionalSecondDigits]].
            1. If _rangePattern_ is not *undefined* and _rp_ is *undefined*, then
              1. Set _patternContainsLargerDateField_ to *true*.
            1. Else,
              1. Let _fractionalSecondDigits_ be _dateTimeFormat_.[[FractionalSecondDigits]].
              1. If _fractionalSecondDigits_ is *undefined*, then
                1. Set _fractionalSecondDigits_ to 3.
              1. Let _v1_ be _tm1_.[[Millisecond]].
              1. Let _v2_ be _tm2_.[[Millisecond]].
              1. Let _v1_ be floor(_v1_ × 10<sup>( _fractionalSecondDigits_ - 3 )</sup>).
              1. Let _v2_ be floor(_v2_ × 10<sup>( _fractionalSecondDigits_ - 3 )</sup>).
              1. If _v1_ is not equal to _v2_, then
                1. Set _dateFieldsPracticallyEqual_ to *false*.
              1. Let _rangePattern_ be _rp_.
          1. Else,
            1. Let _rp_ be _rangePatterns_.[[&lt;_fieldName_&gt;>]].
            1. If _rangePattern_ is not *undefined* and _rp_ is *undefined*, then
              1. Set _patternContainsLargerDateField_ to *true*.
            1. Else,
              1. Let _v1_ be _tm1_.[[&lt;_fieldName_&gt;>]].
              1. Let _v2_ be _tm2_.[[&lt;_fieldName_&gt;]].
              1. If _v1_ is not equal to _v2_, then
                1. Set _dateFieldsPracticallyEqual_ to *false*.
              1. Let _rangePattern_ be _rp_.
        1. If _dateFieldsPracticallyEqual_ is *true*, then
          1. Let _pattern_ be <del>_dateTimeFormat_.[[Pattern]]</del><ins>_x_.[[pattern]]</ins>.
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. Let _result_ be ? FormatDateTimePattern(_dateTimeFormat_, <ins>_pattern_,</ins> _patternParts_, _x_<ins>.[[epochNanoseconds]]</ins>, *undefined*).
          1. For each element _r_ in _result_, do
            1. Set _r_.[[Source]] to *"shared"*.
          1. Return _result_.
        1. Let _result_ be a new empty List.
        1. If _rangePattern_ is *undefined*, then
          1. Let _rangePattern_ be _rangePatterns_.[[Default]].
        1. For each element _rangePatternPart_ in _rangePattern_.[[PatternParts]], do
          1. Let _pattern_ be _rangePatternPart_.[[Pattern]].
          1. Let _source_ be _rangePatternPart_.[[Source]].
          1. If _source_ is *"startRange"* or *"shared"*, then
            1. Let _z_ be _x_<ins>.[[epochNanoseconds]]</ins>.
          1. Else,
            1. Let _z_ be _y_<ins>.[[epochNanoseconds]]</ins>.
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. Let _partResult_ be ? FormatDateTimePattern(_dateTimeFormat_, <ins>_pattern_,</ins> _patternParts_, _z_, _rangePattern_).
          1. For each element _r_ in _partResult_, do
            1. Set _r_.[[Source]] to _source_.
          1. Add all elements in _partResult_ to _result_ in order.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimerange" aoid="FormatDateTimeRange">
      <h1>FormatDateTimeRange ( _dateTimeFormat_, _x_, _y_ )</h1>

      <p>
        The FormatDateTimeRange abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat), _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value) and _y_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimeRangePattern(_dateTimeFormat_, _x_, _y_).
        1. Let _result_ be the empty String.
        1. For each Record _part_ in _parts_, do
          1. Set _result_ to a String value produced by concatenating _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimerangetoparts" aoid="FormatDateTimeRangeToParts">
      <h1>FormatDateTimeRangeToParts ( _dateTimeFormat_, _x_, _y_ )</h1>

      <p>
        The FormatDateTimeRangeToParts abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat), _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value) and _y_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimeRangePattern(_dateTimeFormat_, _x_, _y_).
        1. Let _result_ be ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record _part_ in _parts_, do
          1. Let _O_ be ObjectCreate(%ObjectPrototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"source"*, _part_.[[Source]]).
          1. Perform ! CreateDataProperty(_result_, ! ToString(_n_), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-temporal-istemporalobject" aoid="IsTemporalObject">
      <h1>IsTemporalObject ( _value_ )</h1>

      <p>
        The IsTemporalObject abstract operation is called with argument _value_, and performs the following steps:
      </p>

      <emu-alg>
        1. If Type(_value_) is not Object, then
          1. Return *false*.
        1. If _value_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalTime]], [[InitializedTemporalDateTime]], [[InitializedTemporalZonedDateTime]], [[InitializedTemporalYearMonth]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalInstant]] internal slot, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-sametemporaltype" aoid="SameTemporalType">
      <h1>SameTemporalType ( _x_, _y_ )</h1>
      <p>
        The abstract operation SameTemporalType accepts two arguments (which may be any ECMAScript values), and determines whether they are both instances of the same Temporal type.
      </p>
      <emu-alg>
        1. If either of ! IsTemporalObject(_x_) or ! IsTemporalObject(_y_) is *false*, return *false*.
        1. If _x_ has an [[InitializedTemporalDate]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalDateTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalZonedDateTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalYearMonth]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalInstant]] internal slot and _y_ does not, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-getdatetimeformatpattern" aoid="GetDateTimeFormatPattern">
      <h1>GetDateTimeFormatPattern ( _dateStyle_, _timeStyle_, _matcher_, _opt_, _dataLocaleData_, _hc_ )</h1>

      <p>
         The abstract operation GetDateTimeFormatPattern accepts the arguments _dateStyle_ (one of *"full"*, *"long"*, *"medium"*, or *"short"*), _timeStyle_ (one of the values allowed for _dateStyle_), _matcher_ (which must be either *"basic"* or *"best fit"*), _opt_ (a Record with fields from the Property column of <emu-xref href="#table-datetimeformat-components"></emu-xref>), _dataLocaleData_ (a Record of the same type as [[LocaleData]] as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>), and _hc_ (one of *"h11"*, *"h12"*, *"h23"*, or *"h24"*).
         It returns a Record of the type contained by the List [[LocaleData]].[[&lt;_locale_&gt;]].[[formats]].[[&lt;_calendar_&gt;]] as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.
         This abstract operation functions as follows:
      </p>

      <emu-alg>
        1. If _dateStyle_ is not *undefined* or _timeStyle_ is not *undefined*, then
          1. For each row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, do
            1. Let _prop_ be the name given in the Property column of the row.
            1. Let _p_ be _opt_.[[&lt;_prop_&gt;]].
            1. If _p_ is not *undefined*, then
              1. Throw a *TypeError* exception.
          1. Let _bestFormat_ be DateTimeStyleFormat(_dateStyle_, _timeStyle_, _dataLocaleData_).
        1. Else,
          1. Let _formats_ be _dataLocaleData_.[[formats]].[[&lt;_calendar_&gt;]].
          1. If _matcher_ is *"basic"*, then
            1. Let _bestFormat_ be BasicFormatMatcher(_opt_, _formats_).
          1. Else,
            1. Let _bestFormat_ be BestFitFormatMatcher(_opt_, _formats_).
        1. If _bestFormat_.[[hour]] is not *undefined*, then
          1. If _hc_ is *"h11"* or *"h12"*, then
            1. Set _bestFormat_.[[pattern]] to _bestFormat_.[[pattern12]].
            1. Set _bestFormat_.[[rangePatterns]] to _bestFormat_.[[rangePatterns12]].
          1. Remove the [[pattern12]] field from _bestFormat_.
          1. Remove the [[rangePatterns12]] field from _bestFormat_.
          1. Set _bestFormat_.[[hourCycle]] to _hc_.
        1. Else,
          1. Set _bestFormat_.[[hourCycle]] to *undefined*.
        1. Return _bestFormat_.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevalue" aoid="HandleDateTimeValue">
      <h1>HandleDateTimeValue ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The abstract operation HandleDateTimeValue accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be an ECMAScript value). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. If ! IsTemporalObject(_x_) is *true*, then
        1. If _x_ has an [[InitializedTemporalDate]] internal slot, then
          1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainDatePattern]].
          1. Let _calendar_ be ? ToString(_x_.[[Calendar]]).
          1. If _calendar_ is _dateTimeFormat_.[[Calendar]], then
            1. Let _calendarOverride_ be _x_.[[Calendar]].
          1. Else if _calendar_ is *"iso8601"*, then
            1. Let _calendarOverride_ be ? GetBuiltinCalendar(_dateTimeFormat_.[[Calendar]]).
          1. Else,
            1. Throw a *RangeError* exception.
          1. Let _plainDateTime_ be ? CreateTemporalDateTime(_x_.[[ISOYear]], _x_.[[ISOMonth]], _x_.[[ISODay]], 12, 0, 0, 0, 0, 0, _calendarOverride_).
          1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _plainDateTime_, *"compatible"*).
        1. If _x_ has an [[InitializedTemporalYearMonth]] internal slot, then
          1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainYearMonthPattern]].
          1. Let _calendar_ be ? ToString(_x_.[[Calendar]]).
          1. If _calendar_ is not equal to _dateTimeFormat_.[[Calendar]], then
            1. Throw a *RangeError* exception.
          1. Let _plainDateTime_ be ? CreateTemporalDateTime(_x_.[[ISOYear]], _x_.[[ISOMonth]], _x_.[[ISODay]], 12, 0, 0, 0, 0, 0, _x_.[[Calendar]]).
          1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _plainDateTime_, *"compatible"*).
        1. If _x_ has an [[InitializedTemporalMonthDay]] internal slot, then
          1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainMonthDayPattern]].
          1. Let _calendar_ be ? ToString(_x_.[[Calendar]]).
          1. If _calendar_ is not equal to _dateTimeFormat_.[[Calendar]], then
            1. Throw a *RangeError* exception.
          1. Let _plainDateTime_ be ? CreateTemporalDateTime(_x_.[[ISOYear]], _x_.[[ISOMonth]], _x_.[[ISODay]], 12, 0, 0, 0, 0, 0, _x_.[[Calendar]]).
          1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _plainDateTime_, *"compatible"*).
        1. If _x_ has an [[InitializedTemporalTime]] internal slot, then
          1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainTimePattern]].
          1. Let _isoCalendar_ be ? GetISO8601Calendar().
          1. Let _plainDateTime_ be ? CreateTemporalDateTime(1970, 1, 1, _x_.[[ISOHour]], _x_.[[ISOMinute]], _x_.[[ISOSecond]], _x_.[[ISOMillisecond]], _x_.[[ISOMicrosecond]], _x_.[[ISONanosecond]], _isoCalendar_).
          1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _plainDateTime_, *"compatible"*).
        1. If _x_ has an [[InitializedTemporalDateTime]] internal slot, then
          1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainDateTimePattern]].
          1. Let _calendar_ be ? ToString(_x_.[[Calendar]]).
          1. If _calendar_ is not *"iso8601"* and not equal to _dateTimeFormat_.[[Calendar]], then
            1. Throw a *RangeError* exception.
          1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _x_, *"compatible"*).
        1. If _x_ has an [[InitializedTemporalInstant]] internal slot, then
          1. Let _pattern_ be _dateTimeFormat_.[[TemporalInstantPattern]].
          1. Let _instant_ be _x_.
        1. If _x_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Let _pattern_ be _dateTimeFormat_.[[TemporalZonedDateTimePattern]].
          1. Let _calendar_ be ? ToString(_x_.[[Calendar]]).
          1. If _calendar_ is not *"iso8601"* and not equal to _dateTimeFormat_.[[Calendar]], then
            1. Throw a *RangeError* exception.
          1. Let _timeZone_ be ? ToString(_x_.[[TimeZone]]).
          1. If _dateTimeFormat_.[[TimeZone]] is not equal to DefaultTimeZone(), and _timeZone_ is not equal to _dateTimeFormat_.[[TimeZone]], then
            1. Throw a *RangeError* exception.
          1. Let _instant_ be ! CreateTemporalInstant(_x_.[[Nanoseconds]]).
        1. If _pattern_ is *null*, throw a *TypeError* exception.
        1. Let _rangePatterns_ be _pattern_.[[rangePatterns]].
        1. Set _pattern_ to _pattern_.[[pattern]].
        1. Let _epochNanoseconds_ be _instant_.[[Nanoseconds]].
      1. Else,
        1. Let _pattern_ be _dateTimeFormat_.[[Pattern]].
        1. Let _rangePatterns_ be _dateTimeFormat_.[[RangePatterns]].
        1. If _x_ is *undefined*, then
          1. Set _x_ to ! Call(%Date.now%, *undefined*).
        1. Else,
          1. Set _x_ to ? ToNumber(_x_).
        1. Set _x_ to TimeClip(_x_).
        1. If _x_ is *NaN*, throw a *RangeError* exception.
        1. Let _epochNanoseconds_ be ℤ(_x_) × 10<sup>6</sup>.
      1. Return the new Record {
          [[pattern]]: _pattern_,
          [[rangePatterns]]: _rangePatterns_,
          [[epochNanoseconds]]: _epochNanoseconds_
        }.
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-temporal-tolocaltime" aoid="ToLocalTime">
      <h1>ToLocalTime ( _t_, _calendar_, _timeZone_ )</h1>

      <p>
        When the ToLocalTime abstract operation is called with arguments _t_ <ins>(in nanoseconds from the epoch)</ins>, _calendar_, and _timeZone_, the following steps are taken:
      </p>

      <emu-alg>
        1. Assert: Type(_t_) is <del>Number</del><ins>BigInt</ins>.
        1. If _calendar_ is *"gregory"*, then
          1. <del>Let _timeZoneOffset_ be the value calculated according to <emu-xref href="#sec-local-time-zone-adjustment">LocalTZA(_t_, *true*)</emu-xref> where the local time zone is replaced with timezone _timeZone_.</del>
          1. <ins>Let _timeZoneOffset_ be ! GetIANATimeZoneOffsetNanoseconds(_t_, _timeZone_).</ins>
          1. Let _tz_ be the time value _t_ + _timeZoneOffset_.
          1. Return a record with fields calculated from _tz_ according to <del><emu-xref href="#table-datetimeformat-tolocaltime-record"></emu-xref></del><ins><emu-xref href="#table-temporal-plaindatetimeformat-tolocaltime-record"></emu-xref></ins>.
        1. Else,
          1. Return a record with the fields of Column 1 of <del><emu-xref href="#table-datetimeformat-tolocaltime-record"></emu-xref></del><ins><emu-xref href="#table-temporal-plaindatetimeformat-tolocaltime-record"></emu-xref></ins> calculated from _t_ for the given _calendar_ and _timeZone_. The calculations should use best available information about the specified _calendar_ and _timeZone_, including current and historical information about time zone offsets from UTC and daylight saving time rules. <ins>Given the same values of _t_, _calendar_, and _timeZone_, the result must be the same for the lifetime of the surrounding agent</ins>.
      </emu-alg>

      <emu-table id="table-temporal-plaindatetimeformat-tolocaltime-record">
        <emu-caption>Record returned by ToLocalTime</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Field</th>
              <th>Value Calculation for Gregorian Calendar</th>
            </tr>
          </thead>
          <tr>
            <td>[[Weekday]]</td>
            <td>
              <del>`WeekDay(tz)` specified in ES2021's <emu-xref href="#sec-week-day">Week Day</emu-xref></del>
              <ins>! WeekDay(_tz_ / 10<sup>6</sup>)</ins>
            </td>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>
              <del>Let `year` be `YearFromTime(tz)` specified in ES2021's <emu-xref href="#sec-year-number">Year Number</emu-xref>. If `year` is less than 0, return 'BC', else, return 'AD'.</del>
              <ins>Let _year_ be ! YearFromTime(_tz_ / 10<sup>6</sup>). If _year_ is less than 0, return *"BC"*, else, return *"AD"*.</ins>
            </td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>
              <del>`YearFromTime(tz)` specified in ES2021's <emu-xref href="#sec-year-number">Year Number</emu-xref></del>
              <ins>! YearFromTime(_tz_ / 10<sup>6</sup>)</ins>
            </td>
          </tr>
          <tr>
            <td>[[RelatedYear]]</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>[[YearName]]</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>
              <del>`MonthFromTime(tz)` specified in ES2021's <emu-xref href="#sec-month-number">Month Number</emu-xref></del>
              <ins>! MonthFromTime(_tz_ / 10<sup>6</sup>)</ins>
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>
              <del>`DateFromTime(tz)` specified in ES2021's <emu-xref href="#sec-date-number">Date Number</emu-xref></del>
              <ins>! DateFromTime(_tz_ / 10<sup>6</sup>)</ins>
            </td>
          </tr>
          <tr>
            <td>[[Hour]]</td>
            <td>
              <del>`HourFromTime(tz)` specified in ES2021's <emu-xref href="#sec-hours-minutes-second-and-milliseconds">Hours, Minutes, Second, and Milliseconds</emu-xref></del>
              <ins>! HourFromTime(_tz_ / 10<sup>6</sup>)</ins>
            </td>
          </tr>
          <tr>
            <td>[[Minute]]</td>
            <td>
              <del>`MinFromTime(tz)` specified in ES2021's <emu-xref href="#sec-hours-minutes-second-and-milliseconds">Hours, Minutes, Second, and Milliseconds</emu-xref></del>
              <ins>! MinFromTime(_tz_ / 10<sup>6</sup>)</ins>
            </td>
          </tr>
          <tr>
            <td>[[Second]]</td>
            <td>
              <del>`SecFromTime(tz)` specified in ES2021's <emu-xref href="#sec-hours-minutes-second-and-milliseconds">Hours, Minutes, Second, and Milliseconds</emu-xref></del>
              <ins>! SecFromTime(_tz_ / 10<sup>6</sup>)</ins>
            </td>
          </tr>
          <tr>
            <td>[[Millisecond]]</td>
            <td>
              <del>`msFromTime(tz)` specified in ES2021's <emu-xref href="#sec-hours-minutes-second-and-milliseconds">Hours, Minutes, Second, and Milliseconds</emu-xref></del>
              <ins>! msFromTime(_tz_ / 10<sup>6</sup>)</ins>
            </td>
          </tr>
          <tr>
            <td><ins>[[Nanosecond]]</ins></td>
            <td><ins>_tz_ modulo 10<sup>9</sup></ins></td>
          </tr>
          <tr>
            <td>[[InDST]]</td>
            <td>Calculate *true* or *false* using the best available information about the specified _calendar_ and _timeZone_, including current and historical information about time zone offsets from UTC and daylight saving time rules.</td>
          </tr>
        </table>
      </emu-table>

      <emu-note>
        It is recommended that implementations use the time zone information of the IANA Time Zone Database.
      </emu-note>
      <emu-note>
        <ins>
          Time zone information is subject to change, and host environments may update their time zone database at any time.
          At a minimum, implementations must ensure that the time zone information for each particular value of _timeZone_ individually remains constant starting from the time it is first accessed, for the lifetime of the surrounding agent.
          Furthermore, it is recommended that the time zone information for all values of _timeZone_ as a whole (i.e. the time zone database) remains the same for the lifetime of the surrounding agent.
        </ins>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-prototype-object">
    <h1><a href="https://tc39.es/ecma402/#sec-properties-of-intl-datetimeformat-prototype-object">Properties of the Intl.DateTimeFormat Prototype Object</a></h1>

    <emu-clause id="sec-Intl.DateTimeFormat.prototype.formatToParts">
      <h1>Intl.DateTimeFormat.prototype.formatToParts ( _date_ )</h1>

      <p>
        When the `formatToParts` method is called with an argument _date_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. <del>If _date_ is *undefined*, then</del>
          1. <del>Let _x_ be Call(%Date.now%, *undefined*).</del>
        1. <del>Else,</del>
          1. <del>Let _x_ be ? ToNumber(_date_).</del>
        1. Return ? FormatDateTimeToParts(_dtf_, <del>_x_</del><ins>_date_</ins>).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.formatRange">
      <h1>Intl.DateTimeFormat.prototype.formatRange ( _startDate_, _endDate_ )</h1>

      <p>
        When the `formatRange` method is called with an arguments _startDate_ and _endDate_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _startDate_ is *undefined* or _endDate_ is *undefined*, throw a *TypeError* exception.
        1. <del>Let _x_ be ? ToNumber(_startDate_).</del>
        1. <del>Let _y_ be ? ToNumber(_endDate_).</del>
        1. Return ? FormatDateTimeRange(_dtf_, <del>_x_</del><ins>_startDate_</ins>, <del>_y_</del><ins>_endDate_</ins>).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.DateTimeFormat.prototype.formatRangeToParts">
      <h1>Intl.DateTimeFormat.prototype.formatRangeToParts ( _startDate_, _endDate_ )</h1>

      <p>
        When the `formatRangeToParts` method is called with an arguments _startDate_ and _endDate_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _startDate_ is *undefined* or _endDate_ is *undefined*, throw a *TypeError* exception.
        1. <del>Let _x_ be ? ToNumber(_startDate_).</del>
        1. <del>Let _y_ be ? ToNumber(_endDate_).</del>
        1. Return ? FormatDateTimeRangeToParts(_dtf_, <del>_x_</del><ins>_startDate_</ins>, <del>_y_</del><ins>_endDate_</ins>).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.resolvedoptions">
      <h1>Intl.DateTimeFormat.prototype.resolvedOptions ( )</h1>

      <p>
        This function provides access to the locale and formatting options computed during initialization of the object.
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. If Type(_dtf_) is not Object, throw a *TypeError* exception.
        1. Let _dtf_ be ? UnwrapDateTimeFormat(_dtf_).
        1. Let _options_ be ! ObjectCreate(%Object.prototype%).
        1. For each row of <emu-xref href="#table-datetimeformat-resolvedoptions-properties"></emu-xref>, except the header row, in table order, do
          1. Let _p_ be the Property value of the current row.
          1. If _p_ is *"hour12"*, then
            1. Let _hc_ be _dtf_.<del>[[HourCycle]]</del><ins>[[Pattern]].[[hourCycle]]</ins>.
            1. If _hc_ is *"h11"* or *"h12"*, let _v_ be *true*.
            1. Else if, _hc_ is *"h23"* or *"h24"*, let _v_ be *false*.
            1. Else, let _v_ be *undefined*.
          1. Else,
            1. <ins>If the Location value of the current row is ~object~, then</ins>
              1. Let _v_ be the value of _dtf_'s internal slot whose name is the Internal Slot value of the current row.
            1. <ins>Else,</ins>
              1. <ins>Assert: The Location value of the current row is ~pattern~.</ins>
              1. <ins>Let _v_ be the value of _dtf_.[[Pattern]]'s internal slot whose name is the Internal Slot value of the current row.</ins>
          1. If the Internal Slot value of the current row is an Internal Slot value in <emu-xref href="#table-datetimeformat-components"></emu-xref>, then
            1. If _dtf_.[[DateStyle]] is not *undefined* or _dtf_.[[TimeStyle]] is not *undefined*, then
              1. Let _v_ be *undefined*.
          1. If _v_ is not *undefined*, then
            1. Perform ! CreateDataPropertyOrThrow(_options_, _p_, _v_).
        1. Return _options_.
      </emu-alg>

      <emu-table id="table-datetimeformat-resolvedoptions-properties">
        <emu-caption>Resolved Options of DateTimeFormat Instances</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
              <th><ins>Location</ins></th>
            </tr>
          </thead>
          <tr>
            <td>[[Locale]]</td>
            <td>*"locale"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[Calendar]]</td>
            <td>*"calendar"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[NumberingSystem]]</td>
            <td>*"numberingSystem"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[TimeZone]]</td>
            <td>*"timeZone"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td><del>[[HourCycle]]</del><ins>[[hourCycle]]</ins></td>
            <td>*"hourCycle"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td></td>
            <td>*"hour12"*</td>
            <td></td>
          </tr>
          <tr>
            <td><del>[[Weekday]]</del><ins>[[weekday]]</ins></td>
            <td>*"weekday"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Era]]</del><ins>[[era]]</ins></td>
            <td>*"era"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Year]]</del><ins>[[year]]</ins></td>
            <td>*"year"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Month]]</del><ins>[[month]]</ins></td>
            <td>*"month"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Day]]</del><ins>[[day]]</ins></td>
            <td>*"day"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[DayPeriod]]</del><ins>[[dayPeriod]]</ins></td>
            <td>*"dayPeriod"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Hour]]</del><ins>[[hour]]</ins></td>
            <td>*"hour"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Minute]]</del><ins>[[minute]]</ins></td>
            <td>*"minute"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Second]]</del><ins>[[second]]</ins></td>
            <td>*"second"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[FractionalSecondDigits]]</del><ins>[[fractionalSecondDigits]]</ins></td>
            <td>*"fractionalSecondDigits"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[TimeZoneName]]</del><ins>[[timeZoneName]]</ins></td>
            <td>*"timeZoneName"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td>[[DateStyle]]</td>
            <td>*"dateStyle"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[TimeStyle]]</td>
            <td>*"timeStyle"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          </tr>
        </table>
      </emu-table>

      <p>
        For web compatibility reasons, if the property *"hourCycle"* is set, the *"hour12"* property should be set to *true* when *"hourCycle"* is *"h11"* or *"h12"*, or to *false* when *"hourCycle"* is *"h23"* or *"h24"*.
      </p>

      <emu-note>
        In this version of the ECMAScript 2021 Internationalization API, the *"timeZone"* property will be the name of the default time zone if no *"timeZone"* property was provided in the options object provided to the Intl.DateTimeFormat constructor. The first edition left the *"timeZone"* property *undefined* in this case.
      </emu-note>

      <emu-note>
        For compatibility with versions prior to the fifth edition, the *"hour12"* property is set in addition to the *"hourCycle"* property.
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-instances">
    <h1><a href="https://tc39.es/ecma402/#sec-properties-of-intl-datetimeformat-instances">Properties of Intl.DateTimeFormat Instances</a></h1>

    <p>
      Intl.DateTimeFormat instances are ordinary objects that inherit properties from %DateTimeFormat.prototype%.
    </p>

    <p>
      Intl.DateTimeFormat instances have an [[InitializedDateTimeFormat]] internal slot.
    </p>

    <p>
      Intl.DateTimeFormat instances also have several internal slots that are computed by the constructor:
    </p>

    <ul>
      <li>[[Locale]] is a String value with the language tag of the locale whose localization is used for formatting.</li>
      <li>[[Calendar]] is a String value with the *"type"* given in Unicode Technical Standard 35 for the calendar used for formatting.</li>
      <li>[[NumberingSystem]] is a String value with the *"type"* given in Unicode Technical Standard 35 for the numbering system used for formatting.</li>
      <li>[[TimeZone]] is a String value with the IANA time zone name of the time zone used for formatting.</li>
      <li><del>[[Weekday]], [[Era]], [[Year]], [[Month]], [[Day]], [[DayPeriod]], [[Hour]], [[Minute]], [[Second]], [[TimeZoneName]] are each either *undefined*, indicating that the component is not used for formatting, or one of the String values given in <emu-xref href="#table-datetimeformat-components"></emu-xref>, indicating how the component should be presented in the formatted output.</del></li>
      <li><del>[[FractionalSecondDigits]] is either *undefined* or a positive, non-negative integer Number value indicating the fraction digits to be used for fractional seconds. Numbers will be rounded or padded with trailing zeroes if necessary.</del></li>
      <li><del>[[HourCycle]] is a String value indicating whether the 12-hour format (*"h11"*, *"h12"*) or the 24-hour format (*"h23"*, *"h24"*) should be used. *"h11"* and *"h23"* start with hour 0 and go up to 11 and 23 respectively. *"h12"* and *"h24"* start with hour 1 and go up to 12 and 24. [[HourCycle]] is only used when [[Hour]] is not *undefined*.</del></li>
      <li>[[DateStyle]], [[TimeStyle]] are each either *undefined*, or a String value with values *"full"*, *"long"*, *"medium"*, or *"short"*.</li>
      <li>[[Pattern]]<ins>, [[TemporalPlainDatePattern]], [[TemporalPlainYearMonthPattern]], [[TemporalPlainMonthDayPattern]], [[TemporalPlainTimePattern]], [[TemporalPlainDateTimePattern]], [[TemporalInstantPattern]], and [[TemporalZonedDateTimePattern]] are</ins> <del>is a String value</del><ins>records containing at least a [[pattern]] field</ins> as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</li>
      <li>[[RangePatterns]] is a Record as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</li>
    </ul>

    <p>
      Finally, Intl.DateTimeFormat instances have a [[BoundFormat]] internal slot that caches the function returned by the format accessor (<emu-xref href="#sec-intl.datetimeformat.prototype.format"></emu-xref>).
    </p>
  </emu-clause>

  <emu-clause id="locale-sensitive-functions">
    <h1><a href="https://tc39.es/ecma402/#locale-sensitive-functions">Locale Sensitive Functions of the ECMAScript Language Specification</a></h1>

    <ins class="block">
      <emu-clause id="sup-temporal-calendar-abstract-ops">
        <h1>Abstract Operations for Temporal.Calendar Objects</h1>

        <emu-clause id="sup-temporal-isbuiltincalendar" aoid="IsBuiltinCalendar">
          <h1>IsBuiltinCalendar ( _id_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-isbuiltincalendar"></emu-xref>.</p>
          <emu-alg>
            1. Let _builtinCalendars_ be a List of Unicode BCP 47 calendar identifiers identifying the calendars for which the implementation provides the functionality of the constructed `Temporal.Calendar` objects. The list must include *"iso8601"*. The ordering is irrelevant.
            1. If _builtinCalendars_ contains _id_, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarera" aoid="CalendarEra">
          <h1>CalendarEra ( _calendar_, _dateLike_ )</h1>
          <p>
            The abstract operation CalendarEra calls the given _calendar_'s `era()` method and validates the result.
          </p>
          <emu-alg>
            1. Assert: Type(_calendar_) is Object.
            1. Let _result_ be ? Invoke(_calendar_, *"era"*, « _dateLike_ »).
            1. If _result_ is not *undefined*, set _result_ to ? ToString(_result_).
            1. Return _result_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarerayear" aoid="CalendarEraYear">
          <h1>CalendarEraYear ( _calendar_, _dateLike_ )</h1>
          <p>
            The abstract operation CalendarEraYear calls the given _calendar_'s `eraYear()` method and validates the result.
          </p>
          <emu-alg>
            1. Assert: Type(_calendar_) is Object.
            1. Let _result_ be ? Invoke(_calendar_, *"eraYear"*, « _dateLike_ »).
            1. If _result_ is not *undefined*, set _result_ to ? ToIntegerOrInfinity(_result_).
            1. Return _result_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-calendar-prototype-object">
        <h1>Properties of the Temporal.Calendar Prototype Object</h1>

        <emu-clause id="sup-temporal.calendar.prototype.datefromfields">
          <h1>Temporal.Calendar.prototype.dateFromFields ( _fields_, _options_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.datefromfields"></emu-xref>.</p>
          <p>
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? ISODateFromFields(_fields_, _options_).
            1. Else,
              1. Let _overflow_ be ? ToTemporalOverflow(_options_).
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"day"*, *"era"*, *"eraYear"*, *"month"*, *"monthCode"*, *"year"* », « *"day"* »).
              1. Let _result_ be a Record with [[Year]], [[Month]], and [[Day]] fields, that is the result of implementation-defined processing of _fields_, _overflow_, and the value of _calendar_.[[Identifier]].
            1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.yearmonthfromfields">
          <h1>Temporal.Calendar.prototype.yearMonthFromFields ( _fields_, _options_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.yearmonthfromfields"></emu-xref>.</p>
          <p>
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? ISOYearMonthFromFields(_fields_, _options_).
            1. Else,
              1. Let _overflow_ be ? ToTemporalOverflow(_options_).
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"era"*, *"eraYear"*, *"month"*, *"monthCode"*, *"year"* », « »).
              1. Let _result_ be a Record with [[Year]], [[Month]], and [[ReferenceISODay]] integer fields, that is the result of implementation-defined processing of _fields_, _overflow_, and the value of _calendar_.[[Identifier]].
            1. Return ? CreateTemporalYearMonth(_result_.[[Year]], _result_.[[Month]], _calendar_, _result_.[[ReferenceISODay]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthdayfromfields">
          <h1>Temporal.Calendar.prototype.monthDayFromFields ( _fields_, _options_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthdayfromfields"></emu-xref>.</p>
          <p>
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? ISOMonthDayFromFields(_fields_, _options_).
            1. Else,
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"day"*, *"era"*, *"eraYear"*, *"month"*, *"monthCode"*, *"year"* », « *"day"* »).
              1. Let _overflow_ be ? ToTemporalOverflow(_options_).
              1. Let _result_ be a Record with [[Month]], [[Day]], and [[ReferenceISOYear]] fields, that is the result of implementation-defined processing of _fields_, _overflow_, and the value of _calendar_.[[Identifier]].
            1. Return ? CreateTemporalMonthDay(_result_.[[Month]], _result_.[[Day]], _calendar_, _result_.[[ReferenceISOYear]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dateadd">
          <h1>Temporal.Calendar.prototype.dateAdd ( _date_, _duration_, _options_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dateadd"></emu-xref>.</p>
          <p>
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Set _date_ to ? ToTemporalDate(_date_).
            1. Set _duration_ to ? ToTemporalDuration(_duration_).
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? AddISODate(_date_.[[ISOYear]], _date_.[[ISOMonth]], _date_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _overflow_).
            1. Else,
              1. Let _result_ be a Record with [[Year]], [[Month]], and [[Day]] fields, that is the result of implementation-defined processing of _date_, _duration_, _overflow_, and the value of _calendar_.[[Identifier]].
            1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dateuntil">
          <h1>Temporal.Calendar.prototype.dateUntil ( _one_, _two_, _options_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dateuntil"></emu-xref>.</p>
          <p>
            The `dateUntil` method takes three arguments, _one_, _two_, and _options_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Set _one_ to ? ToTemporalDate(_one_).
            1. Set _two_ to ? ToTemporalDate(_two_).
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, « *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"* », *"auto"*, *"day"*).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ! DifferenceISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _largestUnit_).
            1. Else,
              1. Let _result_ be a Record with [[Years]], [[Months]], [[Weeks]], and [[Days]] fields, that is the result of implementation-defined processing of _one_, _two_, _largestUnit_, and the value of _calendar_.[[Identifier]].
            1. Return ? CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal.calendar.prototype.era">
          <h1>Temporal.Calendar.prototype.era ( _temporalDateLike_ )</h1>
          <p>
            The `era` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return *undefined*.
            1. Let _era_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return _era_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal.calendar.prototype.erayear">
          <h1>Temporal.Calendar.prototype.eraYear ( _temporalDateLike_ )</h1>
          <p>
            The `eraYear` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return *undefined*.
            1. Let _eraYear_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_eraYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.year">
          <h1>Temporal.Calendar.prototype.year ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.year"></emu-xref>.</p>
          <p>
            The `year` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _year_ be ! ISOYear(_temporalDateLike_).
            1. Else,
              1. Let _year_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_year_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.month">
          <h1>Temporal.Calendar.prototype.month ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.month"></emu-xref>.</p>
          <p>
            The `month` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is Object and _temporalDateLike_ has an [[InitializedTemporalMonthDay]] internal slot, then
              1. Throw a *TypeError* exception.
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _month_ be ! ISOMonth(_temporalDateLike_).
            1. Else,
              1. Let _month_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_month_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthcode">
          <h1>Temporal.Calendar.prototype.monthCode ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthcode"></emu-xref>.</p>
          <p>
            The `monthCode` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _monthCode_ be ! ISOMonthCode(_temporalDateLike_).
            1. Else,
              1. Let _monthCode_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return _monthCode_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.day">
          <h1>Temporal.Calendar.prototype.day ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.day"></emu-xref>.</p>
          <p>
            The `day` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalMonthDay]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _day_ be ! ISODay(_temporalDateLike_).
            1. Else,
              1. Let _day_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_day_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dayofweek">
          <h1>Temporal.Calendar.prototype.dayOfWeek ( _dateOrDateTime_ )</h1>
          <p>This definition supersedes the definition _temporalDateLike_ in <emu-xref href="#sec-temporal.calendar.prototype.dayofweek"></emu-xref>.</p>
          <p>
            The `dayOfWeek` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _dayOfWeek_ be ! ToISODayOfWeek(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
            1. Else,
              1. Let _dayOfWeek_ be the result of implementation-defined processing of _temporalDate_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_dayOfWeek_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dayofyear">
          <h1>Temporal.Calendar.prototype.dayOfYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dayofyear"></emu-xref>.</p>
          <p>
            The `dayOfYear` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _dayOfYear_ be ! ToISODayOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
            1. Else,
              1. Let _dayOfYear_ be the result of implementation-defined processing of _temporalDate_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_dayOfYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.weekofyear">
          <h1>Temporal.Calendar.prototype.weekOfYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.weekofyear"></emu-xref>.</p>
          <p>
            The `weekOfYear` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _weekOfYear_ be ! ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
            1. Else,
              1. Let _weekOfYear_ be the result of implementation-defined processing of _temporalDate_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_weekOfYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinweek">
          <h1>Temporal.Calendar.prototype.daysInWeek ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinweek"></emu-xref>.</p>
          <p>
            The `daysInWeek` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _daysInWeek_ be 7.
            1. Else,
              1. Let _daysInWeek_ be the result of implementation-defined processing of _temporalDate_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_daysInWeek_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinmonth">
          <h1>Temporal.Calendar.prototype.daysInMonth ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinmonth"></emu-xref>.</p>
          <p>
            The `daysInMonth` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalYearMonth]] internal slots, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _daysInMonth_ be ! ISODaysInMonth(_temporalDateLike_.[[ISOYear]], _temporalDateLike_.[[ISOMonth]]).
            1. Else,
              1. Let _daysInMonth_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_daysInMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinyear">
          <h1>Temporal.Calendar.prototype.daysInYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinyear"></emu-xref>.</p>
          <p>
            The `daysInYear` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _daysInYear_ be ! ISODaysInYear(_temporalDateLike_.[[ISOYear]]).
            1. Else,
              1. Let _daysInYear_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_daysInYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthsinyear">
          <h1>Temporal.Calendar.prototype.monthsInYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthsinyear"></emu-xref>.</p>
          <p>
            The `monthsInYear` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _monthsInYear_ be 12.
            1. Else,
              1. Let _monthsInYear_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return 𝔽(_monthsInYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.inleapyear">
          <h1>Temporal.Calendar.prototype.inLeapYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.inleapyear"></emu-xref>.</p>
          <p>
            The `inLeapYear` method takes one argument _temporalDateLike_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]] or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _inLeapYear_ be ! IsISOLeapYear(_temporalDateLike_.[[ISOYear]]).
            1. Else,
              1. Let _inLeapYear_ be the result of implementation-defined processing of _temporalDateLike_ and the value of _calendar_.[[Identifier]].
            1. Return _inLeapYear_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.fields">
          <h1>Temporal.Calendar.prototype.fields ( _fields_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.fields"></emu-xref>.</p>
          <p>
            The `fields` method takes one argument _fields_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _fieldNames_ be ? IterableToListOfType(_fields_, « String »).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be _fieldNames_.
            1. Else,
              1. Let _result_ be the result of implementation-defined processing of _fieldNames_ and the value of _calendar_.[[Identifier]].
            1. Return ! CreateArrayFromList(_result_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.mergefields">
          <h1>Temporal.Calendar.prototype.mergeFields ( _fields_, _additionalFields_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.mergefields"></emu-xref>.</p>
          <p>
            The `mergeFields` method takes two arguments, _fields_ and _additionalFields_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Set _fields_ to ? ToObject(_fields_).
            1. Set _additionalFields_ to ? ToObject(_additionalFields_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return ? DefaultMergeFields(_fields_, _additionalFields_).
            1. Let _fieldsKeys_ be ? EnumerableOwnPropertyNames(_fields_, ~key~).
            1. Let _fieldsCopied_ be ! OrdinaryObjectCreate(%Object.prototype%).
            1. For each element _key_ of _fieldsKeys_, do
              1. Let _propValue_ be ? Get(_fields_, _key_).
              1. If _propValue_ is not *undefined*, then
                1. Perform ! CreateDataPropertyOrThrow(_fieldsCopied_, _key_, _propValue_).
            1. Let _additionalFieldsKeys_ be ? EnumerableOwnPropertyNames(_additionalFields_, ~key~).
            1. Let _additionalFieldsCopied_ be ! OrdinaryObjectCreate(%Object.prototype%).
            1. For each element _key_ of _additionalFieldsKeys_, do
              1. Let _propValue_ be ? Get(_additionalFields_, _key_).
              1. If _propValue_ is not *undefined*, then
                1. Perform ! CreateDataPropertyOrThrow(_additionalFieldsCopied_, _key_, _propValue_).
            1. Return the result of implementation-defined processing of _fieldsCopied_, _additionalFieldsCopied_, and the value of _calendar_.[[Identifier]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-duration-prototype-object">
        <h1>Properties of the Temporal.Duration Prototype Object</h1>
        <emu-clause id="sup-temporal.duration.prototype.tolocalestring">
          <h1>Temporal.Duration.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <emu-note type="editor">
            <p>
              This function is currently not specified.
              See <a href="https://tc39.es/proposal-intl-duration-format/">the Intl.DurationFormat proposal</a>.
            </p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-instant-prototype-object">
        <h1>Properties of the Temporal.Instant Prototype Object</h1>
        <emu-clause id="sup-temporal.instant.prototype.tolocalestring">
          <h1>Temporal.Instant.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.instant.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            The `toLocaleString` method takes two arguments, _locales_ and _options_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _instant_ be the *this* value.
            1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _instant_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaindate-prototype-object">
        <h1>Properties of the Temporal.PlainDate Prototype Object</h1>
        <emu-clause id="sup-temporal.plaindate.prototype.tolocalestring">
          <h1>Temporal.PlainDate.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaindate.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            The `toLocaleString` method takes two arguments, _locales_ and _options_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _temporalDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _temporalDate_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindate.prototype.era">
          <h1>get Temporal.PlainDate.prototype.era</h1>
          <p>
            `Temporal.PlainDate.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
            1. Let _calendar_ be _plainDate_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainDate_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindate.prototype.erayear">
          <h1>get Temporal.PlainDate.prototype.eraYear</h1>
          <p>
            `Temporal.PlainDate.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
            1. Let _calendar_ be _plainDate_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainDate_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaindatetime-prototype-object">
        <h1>Properties of the Temporal.PlainDateTime Prototype Object</h1>
        <emu-clause id="sup-temporal.plaindatetime.prototype.tolocalestring">
          <h1>Temporal.PlainDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaindatetime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            The `toLocaleString` method takes two arguments, _locales_ and _options_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _dateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _dateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindatetime.prototype.era">
          <h1>get Temporal.PlainDateTime.prototype.era</h1>
          <p>
            `Temporal.PlainDate.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
            1. Let _calendar_ be _plainDateTime_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindatetime.prototype.erayear">
          <h1>get Temporal.PlainDateTime.prototype.eraYear</h1>
          <p>
            `Temporal.PlainDateTime.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
            1. Let _calendar_ be _plainDateTime_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plainmonthday-prototype-object">
        <h1>Properties of the Temporal.PlainMonthDay Prototype Object</h1>
          <emu-clause id="sup-temporal.plainmonthday.prototype.tolocalestring">
          <h1>Temporal.PlainMonthDay.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plainmonthday.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            The `toLocaleString` method takes two arguments, _locales_ and _options_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _monthDay_ be the *this* value.
            1. Perform ? RequireInternalSlot(_monthDay_, [[InitializedTemporalMonthDay]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _monthDay_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaintime-prototype-object">
        <h1>Properties of the Temporal.PlainTime Prototype Object</h1>
        <emu-clause id="sup-temporal.plaintime.prototype.tolocalestring">
          <h1>Temporal.PlainTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaintime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            The `toLocaleString` method takes two arguments, _locales_ and _options_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _temporalTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _temporalTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plainyearmonth-prototype-object">
        <h1>Properties of the Temporal.PlainYearMonth Prototype Object</h1>
        <emu-clause id="sup-temporal.plainyearmonth.prototype.tolocalestring">
          <h1>Temporal.PlainYearMonth.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plainyearmonth.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            The `toLocaleString` method takes two arguments, _locales_ and _options_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _yearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_yearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _yearMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plainyearmonth.prototype.era">
          <h1>get Temporal.PlainYearMonth.prototype.era</h1>
          <p>
            `Temporal.PlainYearMonth.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainYearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainYearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _calendar_ be _plainYearMonth_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainYearMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plainyearmonth.prototype.erayear">
          <h1>get Temporal.PlainYearMonth.prototype.eraYear</h1>
          <p>
            `Temporal.PlainYearMonth.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainYearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainYearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _calendar_ be _plainYearMonth_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainYearMonth_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-zoneddatetime-prototype-object">
        <h1>Properties of the Temporal.ZonedDateTime Prototype Object</h1>
        <emu-clause id="sup-temporal.zoneddatetime.prototype.tolocalestring">
          <h1>Temporal.ZonedDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.zoneddatetime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            The `toLocaleString` method takes two arguments, _locales_ and _options_.
            The following steps are taken:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _zonedDateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.zoneddatetime.prototype.era">
          <h1>get Temporal.ZonedDateTime.prototype.era</h1>
          <p>
            `Temporal.ZonedDateTime.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
            1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
            1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
            1. Let _plainDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
            1. Return ? CalendarEra(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.zoneddatetime.prototype.erayear">
          <h1>get Temporal.ZonedDateTime.prototype.eraYear</h1>
          <p>
            `Temporal.ZonedDateTime.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
            1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
            1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
            1. Let _plainDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
            1. Return ? CalendarEraYear(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-abstracts">
      <h1>Abstract Operations</h1>

      <emu-clause id="sup-temporal-preparetemporalfields">
        <h1>PrepareTemporalFields ( _fields_, _fieldNames_, _requiredFields_ )</h1>
        <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-preparetemporalfields"></emu-xref>.</p>
        <emu-alg>
          1. Assert: Type(_fields_) is Object.
          1. Let _result_ be ! OrdinaryObjectCreate(%Object.prototype%).
          1. For each value _property_ of _fieldNames_, do
            1. Let _value_ be ? Get(_fields_, _property_).
            1. If _value_ is *undefined*, then
              1. If _requiredFields_ contains _property_, then
                1. Throw a *TypeError* exception.
              1. Else,
                1. If _property_ is in the Property column of <emu-xref href="#table-temporal-field-requirements"></emu-xref>, then
                  1. Set _value_ to the corresponding Default value of the same row.
            1. Else,
              1. If _property_ is in the Property column of <emu-xref href="#table-temporal-field-requirements"></emu-xref>, then
                1. Let _Conversion_ represent the abstract operation named by the Conversion value of the same row.
                1. Set _value_ to ? _Conversion_(_value_).
            1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
          1. Let _era_ be ? Get(_result_, *"era"*).
          1. Let _eraYear_ be ? Get(_result_, *"eraYear"*).
          1. If _era_ is *undefined* and _eraYear_ is not *undefined*, or if _era_ is not *undefined* and _eraYear_ is *undefined*, then
            1. Throw a *RangeError* exception.
          1. Return _result_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>
