<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-intl">
  <h1>Amendments to the ECMAScript® 2023 Internationalization API Specification</h1>

  <emu-note type="editor">
    <p>
      This section lists amendments which must be made to <a href="https://tc39.es/ecma402/">ECMA-402, the ECMAScript® 2023 Internationalization API Specification</a>.
      Text to be added is marked <ins>like this</ins>, and text to be deleted is marked <del>like this</del>.
      Blocks of unmodified text between modified sections are marked by [...].
    </p>
    <p>
      This text is based on top of the ECMA-402 spec text from commit <a href="https://github.com/tc39/ecma402/commit/537afda7be28a443b79b3fd7e6c836a16ce4f75f">537afda7be28a443b79b3fd7e6c836a16ce4f75f</a>.
    </p>
  </emu-note>

  <emu-clause id="sup-case-sensitivity-and-case-mapping">
    <h1><a href="https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping">Case Sensitivity and Case Mapping</a></h1>

    <emu-note type="editor">
      <p>These definitions are moved into ECMA-262.</p>
    </emu-note>

    <p>
      The String values used to identify locales, currencies, scripts, and time zones are interpreted in an ASCII-case-insensitive manner, treating the code units 0x0041 through 0x005A (corresponding to Unicode characters LATIN CAPITAL LETTER A through LATIN CAPITAL LETTER Z) as equivalent to the corresponding code units 0x0061 through 0x007A (corresponding to Unicode characters LATIN SMALL LETTER A through LATIN SMALL LETTER Z), both inclusive. No other case folding equivalences are applied.
    </p>
    <emu-note>
      For example, *"ß"* (U+00DF) must not match or be mapped to *"SS"* (U+0053, U+0053). *"ı"* (U+0131) must not match or be mapped to *"I"* (U+0049).
    </emu-note>
    <del class="block">
      <p>
        The <em>ASCII-uppercase</em> of a String value _S_ is the String value derived from _S_ by replacing each occurrence of an ASCII lowercase letter code unit (0x0061 through 0x007A, inclusive) with the corresponding ASCII uppercase letter code unit (0x0041 through 0x005A, inclusive) while preserving all other code units.
      </p>
      <p>
        The <em>ASCII-lowercase</em> of a String value _S_ is the String value derived from _S_ by replacing each occurrence of an ASCII uppercase letter code unit (0x0041 through 0x005A, inclusive) with the corresponding ASCII lowercase letter code unit (0x0061 through 0x007A, inclusive) while preserving all other code units.
      </p>
      <p>
        A String value _A_ is an <em>ASCII-case-insensitive match</em> for String value _B_ if the ASCII-uppercase of _A_ is exactly the same sequence of code units as the ASCII-uppercase of _B_. A sequence of Unicode code points _A_ is an ASCII-case-insensitive match for _B_ if _B_ is an ASCII-case-insensitive match for ! CodePointsToString(_A_).
      </p>
    </del>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-use-of-iana-time-zone-database" oldids="sec-time-zone-names">
    <h1>Use of the IANA Time Zone Database</h1>

    <emu-note type="editor">This section replaces the <a href="https://tc39.es/ecma-402/#sec-time-zone-names">Time Zone Names</a> section in ECMA-402.</emu-note>
    <p>
      Implementations that adopt this specification are time zone aware: they use the IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a> to supply time zone identifiers and data used in ECMAScript calculations and formatting.
      This section defines how the IANA Time Zone Database should be used by time zone aware implementations.
    </p>
    <p>
      Except as overridden by AvailableNamedTimeZoneIdentifiers, each Zone in the IANA Time Zone Database must be a primary time zone identifier and each Link name in the IANA Time Zone Database must be a non-primary time zone identifier.
      No String may be an available named time zone identifier unless it is a Zone name or a Link name in the IANA Time Zone Database.
      Available named time zone identifiers returned by ECMAScript built-in objects must use the casing found in the IANA Time Zone Database.
    </p>
    <p>
      In the IANA Time Zone Database, the UTC time zone is represented by the Zone *"Etc/UTC"* which is distinct from the Zone *"Etc/GMT"*.
      For historical reasons, ECMAScript uses *"UTC"* as the primary identifier for the former Zone and does not recognize the latter Zone as distinct, instead requiring *"Etc/UTC"*, *"Etc/GMT"*, and *"GMT"* (if available) to be non-primary identifiers that resolve to *"UTC"*.
      This is the only deviation from the IANA Time Zone Database that is required of a time zone aware ECMAScript implementation.
    </p>
    <p>
      The IANA Time Zone Database is typically updated between five and ten times per year.
      These updates may add new Zone or Link names, may change Zones to Links, and may change the UTC offsets and transitions associated with any Zone.
      ECMAScript implementations are recommended to include updates to the IANA Time Zone Database as soon as possible.
      Such prompt action ensures that ECMAScript programs can accurately perform time-zone-sensitive calculations and can use newly-added available named time zone identifiers supplied by external input or the host environment.
    </p>

    <emu-note>
      <p>
        Although the IANA Time Zone Database maintainers strive for stability, in rare cases (averaging less than once per year) a Zone may be replaced by a new Zone.
        For example, in 2022 "*Europe/Kiev*" was deprecated to a Link resolving to a new "*Europe/Kyiv*" Zone.
      </p>
      <p>
        To reduce disruption from renaming changes, ECMAScript implementations are encouraged to initially add the new Zone as a non-primary time zone identifier that resolves to the current primary identifier.
        Then, after a waiting period, implementations are recommended to promote the new Zone to a primary time zone identifier while simultaneously demoting the deprecated name to non-primary.
        The recommended waiting period is two years after the IANA Time Zone Database release containing the changes.
        This delay allows other systems, that ECMAScript programs may interact with, to be updated to recognize the new Zone.
      </p>
      <p>
        A waiting period should only apply when a new Zone is added to replace an existing Zone.
        If an existing Zone and Link are swapped, then no waiting period is necessary.
      </p>
    </emu-note>

    <p>
      If implementations revise time zone information during the lifetime of an agent, then which identifiers are supported, the primary time zone identifier associated with any identifier, and the UTC offsets and transitions associated with any Zone, must be consistent with results previously observed by that agent.
      Due to the complexity of supporting this requirement, it is recommended that implementations maintain a fully consistent copy of the IANA Time Zone Database for the lifetime of each agent.
    </p>

    <p>This section complements but does not supersede <emu-xref href="#sec-time-zone-identifiers"></emu-xref>.</p>

    <emu-note>
      <p>
        The IANA Time Zone Database offers build options that affect which time zone identifiers are primary.
        The default build options merge different countries' time zones, for example *"Atlantic/Reykjavik"* being a Link to the Zone *"Africa/Abidjan"*.
        Geographically and politically distinct locations are likely to introduce divergent time zone rules in a future version of the IANA Time Zone Database.
        Therefore, it is recommended that ECMAScript implementations instead use build options such as <code>PACKRATDATA=backzone PACKRATLIST=zone.tab</code> or a similar alternative that ensures at least one primary identifier for each <a href="https://www.iso.org/glossary-for-iso-3166.html">ISO 3166-1 Alpha-2</a> country code.
      </p>
    </emu-note>

      <emu-clause id="sup-availablenamedtimezoneidentifiers" oldids="sec-availabletimezones" type="implementation-defined abstract operation">
        <h1>AvailableNamedTimeZoneIdentifiers ( ): a List of Time Zone Identifier Records</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            Its result describes all available named time zone identifiers in this implementation, as well as the primary time zone identifier corresponding to each available named time zone identifier.
            The List is ordered according to the [[Identifier]] field of each Time Zone Identifier Record.
          </dd>
          <dt>redefinition</dt>
          <dd>true</dd>
        </dl>
        <p>This definition supersedes the definition provided in <emu-xref href="#sec-availablenamedtimezoneidentifiers"></emu-xref>.</p>
        <emu-alg>
          1. Let _identifiers_ be a List containing the String value of each Zone or Link name in the IANA Time Zone Database.
          1. Assert: No element of _identifiers_ is an ASCII-case-insensitive match for any other element.
          1. Assert: Every element of _identifiers_ identifies a Zone or Link name in the IANA Time Zone Database.
          1. Set _identifiers_ to SortStringListByCodeUnit(_identifiers_).
          1. Let _result_ be a new empty List.
          1. For each element _identifier_ of _identifiers_, do
            1. Let _primary_ be _identifier_.
            1. If _identifier_ is a non-primary time zone identifier and _identifier_ is not *"UTC"*, then
              1. Set _primary_ to the name of the primary time zone identifier that _identifier_ resolves to, according to the rules for resolving Link names in the IANA Time Zone Database.
              1. NOTE: An implementation may need to resolve _identifier_ iteratively to obtain the primary time zone identifier.
            1. If _primary_ is one of *"Etc/UTC"*, *"Etc/GMT"*, or *"GMT"*, set _primary_ to *"UTC"*.
            1. Let _record_ be the Time Zone Identifier Record { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }.
            1. Append _record_ to _result_.
          1. Assert: _result_ contains a Time Zone Identifier Record _r_ such that _r_.[[Identifier]] is *"UTC"* and _r_.[[PrimaryIdentifier]] is *"UTC"*.
          1. Return _result_.
        </emu-alg>

        <emu-note>
          Time zone identifiers in the IANA Time Zone Database can change over time.
          At a minimum, implementations must limit changes to the result of AvailableNamedTimeZoneIdentifiers to the changes allowed by GetAvailableNamedTimeZoneIdentifier, for the lifetime of the surrounding agent.
          That is, implementations must not remove support for or change the primary vs. non-primary status of an identifier that was already reported as available, and they must not add support for an identifier that was already reported as not available.
          Due to the complexity of supporting these recommendations, it is recommended that the result of AvailableNamedTimeZoneIdentifiers remains the same for the lifetime of the surrounding agent.
        </emu-note>
      </emu-clause>
  </emu-clause>
  </ins>

  <del class="block">
  <emu-clause id="sec-time-zone-names-deleted">
    <h1>Time Zone Names</h1>

    <p>
      This specification identifies time zones using the Zone and Link names of the IANA Time Zone Database. Their canonical form is the corresponding Zone name in the casing used in the IANA Time Zone Database except as specifically overridden by CanonicalizeTimeZoneName.
    </p>

    <p>
      A conforming implementation must recognize *"UTC"* and all other Zone and Link names (and <strong>only</strong> such names), and use best available current and historical information about their offsets from UTC and their daylight saving time rules in calculations. However, the set of combinations of time zone name and language tag for which localized time zone names are available is implementation dependent.
    </p>

    <emu-clause id="sec-isvalidtimezonename" type="abstract operation">
      <h1>
        IsValidTimeZoneName (
          _timeZone_: a String,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It verifies that the _timeZone_ argument represents a valid Zone or Link name of the IANA Time Zone Database.</dd>
      </dl>
      <emu-alg>
        1. If one of the Zone or Link names of the IANA Time Zone Database is an ASCII-case-insensitive match for _timeZone_, return *true*.
        1. If _timeZone_ is an ASCII-case-insensitive match for *"UTC"*, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-note>
      Any value returned from SystemTimeZoneIdentifier that is not recognized as valid by IsTimeZoneOffsetString must be recognized as valid by IsValidTimeZoneName.
    </emu-note>

    <emu-clause id="sec-canonicalizetimezonename" type="abstract operation">
      <h1>
        CanonicalizeTimeZoneName (
          _timeZone_: a String value that is a valid time zone name as verified by IsValidTimeZoneName,
        )
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the canonical and case-regularized form of _timeZone_.</dd>
      </dl>
      <emu-alg>
        1. Let _ianaTimeZone_ be the String value of the Zone or Link name of the IANA Time Zone Database that is an ASCII-case-insensitive match of _timeZone_.
        1. If _ianaTimeZone_ is a Link name, set _ianaTimeZone_ to the String value of the corresponding Zone name as specified in the file <code>backward</code> of the IANA Time Zone Database.
        1. If _ianaTimeZone_ is *"Etc/UTC"* or *"Etc/GMT"*, or *"GMT"*, return *"UTC"*.
        1. Return _ianaTimeZone_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-availablecanonicaltimezones" type="implementation-defined abstract operation">
      <h1>
        AvailableCanonicalTimeZones (
        ): a List of Strings
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned List is a sorted List of supported Zone and Link names in the IANA Time Zone Database.</dd>
      </dl>
      <emu-alg>
        1. Let _names_ be a List of all Zone and Link names in the IANA Time Zone Database that are supported by the implementation.
        1. Let _result_ be a new empty List.
        1. For each element _name_ of _names_, do
          1. Assert: IsValidTimeZoneName( _name_ ) is *true*.
          1. Let _canonical_ be CanonicalizeTimeZoneName( _name_ ).
          1. If _result_ does not contain _canonical_, then
            1. Append _canonical_ to _result_.
        1. [declared="comparefn"] Sort _result_ in order as if an Array of the same values had been sorted using %Array.prototype.sort% using *undefined* as _comparefn_.
        1. Return _result_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
  </del>

  <emu-clause id="intl-object">
    <h1>The Intl Object</h1>
    <p>[...]</p>

    <emu-clause id="sec-function-properties-of-the-intl-object">
      <h1>Function Properties of the Intl Object</h1>
      <p>[...]</p>

      <emu-clause id="sec-intl.supportedvaluesof">
        <h1>Intl.supportedValuesOf ( _key_ )</h1>

        <p>
        When the `supportedValuesOf` method is called with argument _key_ , the following steps are taken:
        </p>

        <emu-alg>
          1. Let _key_ be ? ToString(_key_).
          1. If _key_ is *"calendar"*, then
            1. Let _list_ be AvailableCanonicalCalendars( ).
          1. Else if _key_ is *"collation"*, then
            1. Let _list_ be AvailableCanonicalCollations( ).
          1. Else if _key_ is *"currency"*, then
            1. Let _list_ be AvailableCanonicalCurrencies( ).
          1. Else if _key_ is *"numberingSystem"*, then
            1. Let _list_ be AvailableCanonicalNumberingSystems( ).
          1. Else if _key_ is *"timeZone"*, then
            1. <del>Let _list_ be AvailableCanonicalTimeZones( ).</del>
            1. <ins>Let _timeZones_ be AvailableNamedTimeZoneIdentifiers().</ins>
            1. [declared="record"] <ins>Let _list_ be a List consisting of every element _record_ of _timeZones_ for which _record_.[[Identifier]] = _record_.[[PrimaryIdentifier]].</ins>
          1. Else if _key_ is *"unit"*, then
            1. Let _list_ be AvailableCanonicalUnits( ).
          1. Else,
            1. Throw a *RangeError* exception.
          1. Return CreateArrayFromList( _list_ ).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations">
    <h1><a href="https://tc39.es/ecma402/#sec-abstract-operations">Abstract Operations</a></h1>

    <emu-note type="editor">
      <p>In this section, some abstract operations that manipulate options objects are to be moved from ECMA-402 into ECMA-262.</p>
    </emu-note>

    <del class="block">
      <emu-clause id="sec-getoptionsobject-deleted" type="abstract operation">
        <h1>
          GetOptionsObject (
            _options_: an ECMAScript language value,
          ): either a normal completion containing an Object or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            It returns an Object suitable for use with GetOption, either _options_ itself or a default empty Object.
            It throws a *TypeError* if _options_ is not *undefined* and not an Object.
          </dd>
          <dt>redefinition</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. If _options_ is *undefined*, then
            1. Return OrdinaryObjectCreate(*null*).
          1. If Type(_options_) is Object, then
            1. Return _options_.
          1. Throw a *TypeError* exception.
        </emu-alg>
      </emu-clause>
    </del>

    <p>[...]</p>

    <del class="block">
      <!-- https://tc39.es/ecma402/#sec-getoption -->
      <emu-clause id="sec-getoption-deleted" type="abstract operation">
        <h1>
          GetOption (
            _options_: an Object,
            _property_: a property key,
            _type_: ~boolean~ or ~string~,
            _values_: ~empty~ or a List of ECMAScript language values,
            _default_: ~required~ or an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It extracts the value of the specified property of _options_, converts it to the required _type_, checks whether it is allowed by _values_ if _values_ is not ~empty~, and substitutes _default_ if the value is *undefined*.</dd>
          <dt>redefinition</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Let _value_ be ? Get(_options_, _property_).
          1. If _value_ is *undefined*, then
            1. If _default_ is ~required~, throw a *RangeError* exception.
            1. Return _default_.
          1. If _type_ is ~boolean~, then
            1. Set _value_ to ToBoolean(_value_).
          1. Else,
            1. Assert: _type_ is ~string~.
            1. Set _value_ to ? ToString(_value_).
          1. If _values_ is not ~empty~ and _values_ does not contain _value_, throw a *RangeError* exception.
          1. Return _value_.
        </emu-alg>
      </emu-clause>
    </del>

    <p>[...]</p>

    <del class="block">
      <emu-table id="table-intl-rounding-modes">
        <emu-caption>Rounding modes in Intl.NumberFormat</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th rowspan="2">Identifier</th>
              <th rowspan="2">Description</th>
              <th colspan="5">Examples: Round to 0 fraction digits</th>
            </tr>
            <tr>
              <th>-1.5</th>
              <th>0.4</th>
              <th>0.5</th>
              <th>0.6</th>
              <th>1.5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>*"ceil"*</td>
              <td>Toward positive infinity</td>
              <td>⬆️ [-1]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [2]</td>
            </tr>
            <tr>
              <td>*"floor"*</td>
              <td>Toward negative infinity</td>
              <td>⬇️ [-2]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [1]</td>
            </tr>
            <tr>
              <td>*"expand"*</td>
              <td>Away from zero</td>
              <td>⬇️ [-2]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [2]</td>
            </tr>
            <tr>
              <td>*"trunc"*</td>
              <td>Toward zero</td>
              <td>⬆️ [-1]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [1]</td>
            </tr>
            <tr>
              <td>*"halfCeil"*</td>
              <td>Ties toward positive infinity</td>
              <td>⬆️ [-1]</td>
              <td>⬇️ [0]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [2]</td>
            </tr>
            <tr>
              <td>*"halfFloor"*</td>
              <td>Ties toward negative infinity</td>
              <td>⬇️ [-2]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [0]</td>
              <td>⬆️ [1]</td>
              <td>⬇️ [1]</td>
            </tr>
            <tr>
              <td>*"halfExpand"*</td>
              <td>Ties away from zero</td>
              <td>⬇️ [-2]</td>
              <td>⬇️ [0]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [2]</td>
            </tr>
            <tr>
              <td>*"halfTrunc"*</td>
              <td>Ties toward zero</td>
              <td>⬆️ [-1]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [0]</td>
              <td>⬆️ [1]</td>
              <td>⬇️ [1]</td>
            </tr>
            <tr>
              <td>*"halfEven"*</td>
              <td>Ties toward an even rounding increment multiple</td>
              <td>⬇️ [-2]</td>
              <td>⬇️ [0]</td>
              <td>⬇️ [0]</td>
              <td>⬆️ [1]</td>
              <td>⬆️ [2]</td>
            </tr>
          </tbody>
        </table>
        <emu-note>The examples are illustrative of the unique behaviour of each option. ⬆️ means "resolves toward positive infinity"; ⬇️ means "resolves toward negative infinity".</emu-note>
      </emu-table>
    </del>

    <del class="block">
      <emu-clause id="sec-getunsignedroundingmode-deleted" type="abstract operation">
        <h1>
          GetUnsignedRoundingMode (
            _roundingMode_: a String,
            _sign_: ~negative~ or ~positive~,
          ): a specification type from the Unsigned Rounding Mode column of <emu-xref href="#table-intl-unsigned-rounding-modes"></emu-xref>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the rounding mode that should be applied to the absolute value of a number to produce the same result as if _roundingMode_, one of the String values in the Identifier column of <emu-xref href="#table-intl-rounding-modes"></emu-xref>, were applied to the signed value of the number (negative if _sign_ is ~negative~, or positive otherwise).</dd>
          <dt>redefinition</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Return the specification type in the Unsigned Rounding Mode column of <emu-xref href="#table-intl-unsigned-rounding-modes"></emu-xref> for the row where the value in the Identifier column is _roundingMode_ and the value in the Sign column is _sign_.
        </emu-alg>
        <emu-table id="table-intl-unsigned-rounding-modes">
          <emu-caption>Conversion from rounding mode to unsigned rounding mode</emu-caption>
          <table class="real-table">
            <thead>
              <tr>
                <th>Identifier</th>
                <th>Sign</th>
                <th>Unsigned Rounding Mode</th>
              </tr>
            </thead>
            <tr>
              <td rowspan="2">*"ceil"*</td>
              <td>~positive~</td>
              <td>~infinity~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~zero~</td>
            </tr>
            <tr>
              <td rowspan="2">*"floor"*</td>
              <td>~positive~</td>
              <td>~zero~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~infinity~</td>
            </tr>
            <tr>
              <td rowspan="2">*"expand"*</td>
              <td>~positive~</td>
              <td>~infinity~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~infinity~</td>
            </tr>
            <tr>
              <td rowspan="2">*"trunc"*</td>
              <td>~positive~</td>
              <td>~zero~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~zero~</td>
            </tr>
            <tr>
              <td rowspan="2">*"halfCeil"*</td>
              <td>~positive~</td>
              <td>~half-infinity~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~half-zero~</td>
            </tr>
            <tr>
              <td rowspan="2">*"halfFloor"*</td>
              <td>~positive~</td>
              <td>~half-zero~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~half-infinity~</td>
            </tr>
            <tr>
              <td rowspan="2">*"halfExpand"*</td>
              <td>~positive~</td>
              <td>~half-infinity~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~half-infinity~</td>
            </tr>
            <tr>
              <td rowspan="2">*"halfTrunc"*</td>
              <td>~positive~</td>
              <td>~half-zero~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~half-zero~</td>
            </tr>
            <tr>
              <td rowspan="2">*"halfEven"*</td>
              <td>~positive~</td>
              <td>~half-even~</td>
            </tr>
            <tr>
              <td>~negative~</td>
              <td>~half-even~</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </del>

    <del class="block">
      <emu-clause id="sec-applyunsignedroundingmode-deleted" type="abstract operation">
        <h1>
          ApplyUnsignedRoundingMode (
            _x_: a mathematical value,
            _r1_: a mathematical value,
            _r2_: a mathematical value,
            _unsignedRoundingMode_: a specification type from the Unsigned Rounding Mode column of <emu-xref href="#table-intl-unsigned-rounding-modes"></emu-xref>, or *undefined*,
          ): a mathematical value
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It considers _x_, bracketed below by _r1_ and above by _r2_, and returns either _r1_ or _r2_ according to _unsignedRoundingMode_.</dd>
          <dt>redefinition</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. If _x_ is equal to _r1_, return _r1_.
          1. Assert: _r1_ &lt; _x_ &lt; _r2_.
          1. Assert: _unsignedRoundingMode_ is not *undefined*.
          1. If _unsignedRoundingMode_ is ~zero~, return _r1_.
          1. If _unsignedRoundingMode_ is ~infinity~, return _r2_.
          1. Let _d1_ be <emu-eqn>_x_ – _r1_</emu-eqn>.
          1. Let _d2_ be <emu-eqn>_r2_ – _x_</emu-eqn>.
          1. If _d1_ &lt; _d2_, return _r1_.
          1. If _d2_ &lt; _d1_, return _r2_.
          1. Assert: _d1_ is equal to _d2_.
          1. If _unsignedRoundingMode_ is ~half-zero~, return _r1_.
          1. If _unsignedRoundingMode_ is ~half-infinity~, return _r2_.
          1. Assert: _unsignedRoundingMode_ is ~half-even~.
          1. Let _cardinality_ be <emu-eqn>(_r1_ / (_r2_ – _r1_)) modulo 2</emu-eqn>.
          1. If _cardinality_ is 0, return _r1_.
          1. Return _r2_.
        </emu-alg>
      </emu-clause>
    </del>
  </emu-clause>

  <emu-clause id="sec-intl-datetimeformat-constructor">
    <h1><a href="https://tc39.es/ecma402/#sec-intl-datetimeformat-constructor">The Intl.DateTimeFormat Constructor</a></h1>

    <p>[...]</p>

    <emu-clause id="sec-createdatetimeformat" type="abstract operation" oldids="sec-initializedatetimeformat,sec-todatetimeoptions">
      <h1>
        CreateDateTimeFormat (
          _newTarget_: a constructor,
          _locales_: an ECMAScript language value,
          _options_: an ECMAScript language value,
          _required_: ~date~, ~time~, or ~any~,
          _defaults_: ~date~, ~time~, or ~all~,
          <ins>optional _toLocaleStringTimeZone_: a primary time zone identifier</ins>
        ): either a normal completion containing a DateTimeFormat object or a throw completion
      </h1>

      <dl class="header">
        <dt>description</dt>
        <dd><ins>If the additional _toLocaleStringTimeZone_ argument is provided, the time zone will be overridden and some adjustments will be made to the defaults in order to implement the behaviour of `Temporal.ZonedDateTime.prototype.toLocaleString`.</ins></dd>
      </dl>

      <emu-alg>
        1. Let _dateTimeFormat_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Intl.DateTimeFormat.prototype%"*, &laquo; [[InitializedDateTimeFormat]], [[Locale]], [[Calendar]], [[NumberingSystem]], [[TimeZone]], [[Weekday]], [[Era]], [[Year]], [[Month]], [[Day]], [[DayPeriod]], [[Hour]], [[Minute]], [[Second]], [[FractionalSecondDigits]], [[TimeZoneName]], [[HourCycle]], [[DateStyle]], [[TimeStyle]], [[Pattern]], [[RangePatterns]], [[BoundFormat]] &raquo;).
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. Set _options_ to ? CoerceOptionsToObject(_options_).
        1. Let _opt_ be a new Record.
        1. Let _matcher_ be ? GetOption(_options_, *"localeMatcher"*, ~string~, &laquo; *"lookup"*, *"best fit"* &raquo;, *"best fit"*).
        1. Set _opt_.[[localeMatcher]] to _matcher_.
        1. Let _calendar_ be ? GetOption(_options_, *"calendar"*, ~string~, ~empty~, *undefined*).
        1. If _calendar_ is not *undefined*, then
          1. If _calendar_ cannot be matched by the <code>type</code> Unicode locale nonterminal, throw a *RangeError* exception.
        1. Set _opt_.[[ca]] to _calendar_.
        1. Let _numberingSystem_ be ? GetOption(_options_, *"numberingSystem"*, ~string~, ~empty~, *undefined*).
        1. If _numberingSystem_ is not *undefined*, then
          1. If _numberingSystem_ cannot be matched by the <code>type</code> Unicode locale nonterminal, throw a *RangeError* exception.
        1. Set _opt_.[[nu]] to _numberingSystem_.
        1. Let _hour12_ be ? GetOption(_options_, *"hour12"*, ~boolean~, ~empty~, *undefined*).
        1. Let _hourCycle_ be ? GetOption(_options_, *"hourCycle"*, ~string~, &laquo; *"h11"*, *"h12"*, *"h23"*, *"h24"* &raquo;, *undefined*).
        1. If _hour12_ is not *undefined*, then
          1. Set _hourCycle_ to *null*.
        1. Set _opt_.[[hc]] to _hourCycle_.
        1. Let _localeData_ be %Intl.DateTimeFormat%.[[LocaleData]].
        1. Let _r_ be ResolveLocale(%Intl.DateTimeFormat%.[[AvailableLocales]], _requestedLocales_, _opt_, %Intl.DateTimeFormat%.[[RelevantExtensionKeys]], _localeData_).
        1. Set _dateTimeFormat_.[[Locale]] to _r_.[[locale]].
        1. Let _resolvedCalendar_ be _r_.[[ca]].
        1. Set _dateTimeFormat_.[[Calendar]] to _resolvedCalendar_.
        1. Set _dateTimeFormat_.[[NumberingSystem]] to _r_.[[nu]].
        1. Let _dataLocale_ be _r_.[[dataLocale]].
        1. Let _dataLocaleData_ be _localeData_.[[&lt;_dataLocale_&gt;]].
        1. If _hour12_ is *true*, then
          1. Let _hc_ be _dataLocaleData_.[[hourCycle12]].
        1. Else if _hour12_ is *false*, then
          1. Let _hc_ be _dataLocaleData_.[[hourCycle24]].
        1. Else,
          1. Assert: _hour12_ is *undefined*.
          1. Let _hc_ be _r_.[[hc]].
          1. If _hc_ is *null*, set _hc_ to _dataLocaleData_.[[hourCycle]].
        1. <del>Set _dateTimeFormat_.[[HourCycle]] to _hc_.</del>
        1. Let _timeZone_ be ? Get(_options_, *"timeZone"*).
        1. If _timeZone_ is *undefined*, then
          1. <ins>If _toLocaleStringTimeZone_ is present, then</ins>
            1. <ins>Set _timeZone_ to _toLocaleStringTimeZone_.</ins>
          1. <ins>Else,</ins>
            1. Set _timeZone_ to SystemTimeZoneIdentifier().
        1. Else,
          1. <ins>If _toLocaleStringTimeZone_ is present, throw a *TypeError* exception.</ins>
          1. Set _timeZone_ to ? ToString(_timeZone_).
        1. If IsTimeZoneOffsetString(_timeZone_) is *true*, then
          1. Let _parseResult_ be ParseText(StringToCodePoints(_timeZone_), <del>|UTCOffset|</del><ins>|UTCOffsetMinutePrecision|</ins>).
          1. Assert: _parseResult_ is a Parse Node.
          1. <del>If _parseResult_ contains more than one |MinuteSecond| Parse Node, throw a *RangeError* exception.</del>
          1. Let _offsetNanoseconds_ be <del>ParseTimeZoneOffsetString</del><ins>? ParseDateTimeUTCOffset</ins>(_timeZone_).
          1. Let _offsetMinutes_ be _offsetNanoseconds_ / (6 × 10<sup>10</sup>).
          1. Assert: _offsetMinutes_ is an integer.
          1. Set _timeZone_ to FormatOffsetTimeZoneIdentifier(_offsetMinutes_).
        1. <del>Else if IsValidTimeZoneName(_timeZone_) is *true*, then</del>
        1. <ins>Else,</ins>
          1. <ins>Let _timeZoneIdentifierRecord_ be GetAvailableNamedTimeZoneIdentifier(_timeZone_).</ins>
          1. <ins>If _timeZoneIdentifierRecord_ is ~empty~, then</ins>
            1. <ins>Throw a *RangeError* exception.</ins>
          1. Set _timeZone_ to <del>CanonicalizeTimeZoneName(_timeZone_)</del><ins>_timeZoneIdentifierRecord_.[[Identifier]]</ins>.
        1. <del>Else,</del>
          1. <del>Throw a *RangeError* exception.</del>
        1. Set _dateTimeFormat_.[[TimeZone]] to _timeZone_.
        1. Let _formatOptions_ be a new Record.
        1. Set _formatOptions_.[[hourCycle]] to _hc_.
        1. Let _hasExplicitFormatComponents_ be *false*.
        1. For each row of <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, in table order, do
          1. Let _prop_ be the name given in the Property column of the row.
          1. If _prop_ is *"fractionalSecondDigits"*, then
            1. Let _value_ be ? GetNumberOption(_options_, *"fractionalSecondDigits"*, 1, 3, *undefined*).
          1. Else,
            1. Let _values_ be a List whose elements are the strings given in the Values column of the row.
            1. Let _value_ be ? GetOption(_options_, _prop_, ~string~, _values_, *undefined*).
          1. Set _formatOptions_.[[&lt;_prop_&gt;]] to _value_.
          1. If _value_ is not *undefined*, then
            1. Set _hasExplicitFormatComponents_ to *true*.
        1. Let _formatMatcher_ be ? GetOption(_options_, *"formatMatcher"*, ~string~, &laquo; *"basic"*, *"best fit"* &raquo;, *"best fit"*).
        1. Let _dateStyle_ be ? GetOption(_options_, *"dateStyle"*, ~string~, &laquo; *"full"*, *"long"*, *"medium"*, *"short"* &raquo;, *undefined*).
        1. Set _dateTimeFormat_.[[DateStyle]] to _dateStyle_.
        1. Let _timeStyle_ be ? GetOption(_options_, *"timeStyle"*, ~string~, &laquo; *"full"*, *"long"*, *"medium"*, *"short"* &raquo;, *undefined*).
        1. Set _dateTimeFormat_.[[TimeStyle]] to _timeStyle_.
        1. <ins>Let _expandedOptions_ be a copy of _formatOptions_.</ins>
        1. <del>If _dateStyle_ is not *undefined* or _timeStyle_ is not *undefined*, then</del>
          1. <del>If _hasExplicitFormatComponents_ is *true*, then</del>
            1. <del>Throw a *TypeError* exception.</del>
          1. <del>If _required_ is ~date~ and _timeStyle_ is not *undefined*, then</del>
            1. <del>Throw a *TypeError* exception.</del>
          1. <del>If _required_ is ~time~ and _dateStyle_ is not *undefined*, then</del>
            1. <del>Throw a *TypeError* exception.</del>
          1. <del>Let _styles_ be _dataLocaleData_.[[styles]].[[&lt;_resolvedCalendar_&gt;]].</del>
          1. <del>Let _bestFormat_ be DateTimeStyleFormat(_dateStyle_, _timeStyle_, _styles_).</del>
        1. <del>Else,</del>
        1. <ins>If _dateStyle_ is *undefined* and _timeStyle_ is *undefined*, then</ins>
          1. Let _needDefaults_ be *true*.
          1. If _required_ is ~date~ or ~any~, then
            1. For each property name _prop_ of &laquo; *"weekday"*, *"year"*, *"month"*, *"day"* &raquo;, do
              1. Let _value_ be <del>_formatOptions_</del><ins>_expandedOptions_</ins>.[[&lt;_prop_&gt;]].
              1. If _value_ is not *undefined*, set _needDefaults_ to *false*.
          1. If _required_ is ~time~ or ~any~, then
            1. For each property name _prop_ of &laquo; *"dayPeriod"*, *"hour"*, *"minute"*, *"second"*, *"fractionalSecondDigits"* &raquo;, do
              1. Let _value_ be <del>_formatOptions_</del><ins>_expandedOptions_</ins>.[[&lt;_prop_&gt;]].
              1. If _value_ is not *undefined*, set _needDefaults_ to *false*.
          1. If _needDefaults_ is *true* and _defaults_ is either ~date~ or ~all~, then
            1. For each property name _prop_ of &laquo; *"year"*, *"month"*, *"day"* &raquo;, do
              1. Set <del>_formatOptions_</del><ins>_expandedOptions_</ins>.[[&lt;_prop_&gt;]] to *"numeric"*.
          1. If _needDefaults_ is *true* and _defaults_ is either ~time~ or ~all~, then
            1. For each property name _prop_ of &laquo; *"hour"*, *"minute"*, *"second"* &raquo;, do
              1. Set <del>_formatOptions_</del><ins>_expandedOptions_</ins>.[[&lt;_prop_&gt;]] to *"numeric"*.
          1. <del>Let _formats_ be _dataLocaleData_.[[formats]].[[&lt;_resolvedCalendar_&gt;]].</del>
          1. <del>If _formatMatcher_ is *"basic"*, then</del>
            1. <del>Let _bestFormat_ be BasicFormatMatcher(_formatOptions_, _formats_).</del>
          1. <del>Else,</del>
            1. <del>Let _bestFormat_ be BestFitFormatMatcher(_formatOptions_, _formats_).</del>
        1. <del>For each row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, in table order, do</del>
          1. <del>Let _prop_ be the name given in the Property column of the row.</del>
          1. <del>If _bestFormat_ has a field [[&lt;_prop_&gt;]], then</del>
            1. <del>Let _p_ be _bestFormat_.[[&lt;_prop_&gt;]].</del>
            1. <del>Set _dateTimeFormat_'s internal slot whose name is the Internal Slot column of the row to _p_.</del>
        1. <del>If _dateTimeFormat_.[[Hour]] is *undefined*, then</del>
          1. <del>Set _dateTimeFormat_.[[HourCycle]] to *undefined*.</del>
        1. <del>If _dateTimeFormat_.[[HourCycle]] is *"h11"* or *"h12"*, then</del>
          1. <del>Let _pattern_ be _bestFormat_.[[pattern12]].</del>
          1. <del>Let _rangePatterns_ be _bestFormat_.[[rangePatterns12]].</del>
        1. <del>Else,</del>
          1. <del>Let _pattern_ be _bestFormat_.[[pattern]].</del>
          1. <del>Let _rangePatterns_ be _bestFormat_.[[rangePatterns]].</del>
        1. <ins>Let _bestFormat_ be ? GetDateTimeFormatPattern(_required_, _dateStyle_, _timeStyle_, _formatMatcher_, _expandedOptions_, _dataLocaleData_, _resolvedCalendar_, _hasExplicitFormatComponents_).</ins>
        1. Set _dateTimeFormat_.[[Pattern]] to <del>_pattern_</del><ins>_bestFormat_.[[pattern]]</ins>.
        1. Set _dateTimeFormat_.[[RangePatterns]] to <del>_rangePatterns_</del><ins>_bestFormat_.[[rangePatterns]]</ins>.
        1. <ins>For each row in <emu-xref href="#table-temporal-patterns"></emu-xref>, except the header row, in table order, do</ins>
          1. <ins>Let _limitedOptions_ be a new Record.</ins>
          1. <ins>If _dateStyle_ is *undefined* and _timeStyle_ is *undefined*, then</ins>
            1. <ins>Set _needDefaults_ to *true*.</ins>
            1. <ins>Let _fields_ be the List of fields in the Supported fields column of the row.</ins>
            1. <ins>For each property name _prop_ of _formatOptions_, do</ins>
              1. <ins>If _prop_ is in _fields_, then</ins>
                1. <ins>Set _needDefaults_ to *false*.</ins>
                1. <ins>Set _limitedOptions_.[[&lt;_prop_&gt;]] to _formatOptions_.[[&lt;_prop_&gt;]].</ins>
            1. <ins>If _needDefaults_ is *true*, then</ins>
              1. <ins>Let _defaultFields_ be the List of fields in the Default fields column of the row.</ins>
              1. <ins>If the Pattern column of the row is [[TemporalInstantPattern]], and _toLocaleStringTimeZone_ is present, append [[timeZoneName]] to _defaultFields_.</ins>
              1. <ins>For each property name _prop_ of _defaultFields_, do</ins>
                1. <ins>If _prop_ is [[timeZoneName]], then</ins>
                  1. <ins>Let _defaultValue_ be *"short"*.</ins>
                1. <ins>Else,</ins>
                  1. <ins>Let _defaultValue_ be *"numeric"*.</ins>
                1. <ins>Set _limitedOptions_.[[&lt;_prop_&gt;]] to _defaultValue_.</ins>
          1. <ins>Set _bestFormat_ to ! GetDateTimeFormatPattern(~any~, _dateStyle_, _timeStyle_, _matcher_, _limitedOptions_, _dataLocaleData_, _resolvedCalendar_, _hasExplicitFormatComponents_).</ins>
          1. <ins>If _bestFormat_ does not have any fields that are in _fields_, then</ins>
            1. <ins>Set _bestFormat_ to *null*.</ins>
          1. <ins>Set _dateTimeFormat_'s internal slot whose name is the Pattern column of the row to _bestFormat_.</ins>
        1. Return _dateTimeFormat_.
      </emu-alg>

      <ins class="block">
      <emu-table id="table-temporal-patterns">
        <emu-caption>Supported fields for Temporal patterns</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Supported fields</th>
              <th>Default fields</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>[[TemporalPlainDatePattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]]</td>
              <td>[[year]], [[month]], [[day]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainYearMonthPattern]]</th>
              <td>[[era]], [[year]], [[month]]</td>
              <td>[[year]], [[month]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainMonthDayPattern]]</th>
              <td>[[month]], [[day]]</td>
              <td>[[month]], [[day]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainTimePattern]]</th>
              <td>[[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]]</td>
              <td>[[hour]], [[minute]], [[second]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainDateTimePattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]]</td>
              <td>[[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]]</td>
            </tr>
            <tr>
              <th>[[TemporalInstantPattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]], [[timeZoneName]]</td>
              <td>[[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]]</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
      </ins>
    </emu-clause>

    <emu-clause id="sec-datetime-format-functions">
      <h1>DateTime Format Functions</h1>

      <p>A DateTime format function is an anonymous built-in function that has a [[DateTimeFormat]] internal slot.</p>
      <p>When a DateTime format function _F_ is called with optional argument _date_, the following steps are taken:</p>

      <emu-alg>
        1. Let _dtf_ be _F_.[[DateTimeFormat]].
        1. Assert: Type(_dtf_) is Object and _dtf_ has an [[InitializedDateTimeFormat]] internal slot.
        1. If _date_ is not provided or is *undefined*, then
          1. Let _x_ be ! Call(%Date.now%, *undefined*).
        1. Else,
          1. Let _x_ be ? <del>ToNumber</del><ins>ToDateTimeFormattable</ins>(_date_).
        1. Return ? FormatDateTime(_dtf_, _x_).
      </emu-alg>

      <p>
        The *"length"* property of a DateTime format function is *1*<sub>𝔽</sub>.
      </p>
    </emu-clause>

    <emu-clause id="sec-formatdatetimepattern" type="abstract operation">
      <h1>
        FormatDateTimePattern (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          <ins>_pattern_: a Record of the type contained by the %Intl.DateTimeFormat%.[[LocaleData]].[[&lt;_locale_&gt;]].[[formats]].[[&lt;_calendar_&gt;]] List as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>,</ins>
          _patternParts_: a List of Records as returned by PartitionPattern,
          <del>_x_: a Number,</del>
          <ins>_epochNanoseconds_: a BigInt,</ins>
          _rangeFormatOptions_: a range pattern Record as used in [[rangePattern]], or *undefined*,
        ): either a normal completion containing a List of Records with fields [[Type]] (a String) and [[Value]] (a String), or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It <del>interprets _x_ as a time value as specified in es2024, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>, and</del> creates the corresponding parts <ins>for the epoch time _epochNanoseconds_</ins> according _pattern_ and to the effective locale and the formatting options of _dateTimeFormat_ and _rangeFormatOptions_.</dd>
      </dl>
      <emu-alg>
        1. <del>Let _x_ be TimeClip(_x_).</del>
        1. <del>If _x_ is *NaN*, throw a *RangeError* exception.</del>
        1. Let _locale_ be _dateTimeFormat_.[[Locale]].
        1. Let _nfOptions_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_nfOptions_, *"useGrouping"*, *false*).
        1. Let _nf_ be ! Construct(%Intl.NumberFormat%, &laquo; _locale_, _nfOptions_ &raquo;).
        1. Let _nf2Options_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_nf2Options_, *"minimumIntegerDigits"*, *2*<sub>𝔽</sub>).
        1. Perform ! CreateDataPropertyOrThrow(_nf2Options_, *"useGrouping"*, *false*).
        1. Let _nf2_ be ! Construct(%Intl.NumberFormat%, &laquo; _locale_, _nf2Options_ &raquo;).
        1. Let _fractionalSecondDigits_ be _dateTimeFormat_.[[FractionalSecondDigits]].
        1. If _fractionalSecondDigits_ is not *undefined*, then
          1. Let _nf3Options_ be OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_nf3Options_, *"minimumIntegerDigits"*, 𝔽(_fractionalSecondDigits_)).
          1. Perform ! CreateDataPropertyOrThrow(_nf3Options_, *"useGrouping"*, *false*).
          1. Let _nf3_ be ! Construct(%Intl.NumberFormat%, &laquo; _locale_, _nf3Options_ &raquo;).
        1. Let _tm_ be ToLocalTime(<del>ℤ(ℝ(_x_) &times; 10<sup>6</sup>)</del><ins>_epochNanoseconds_</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _result_ be a new empty List.
        1. For each Record { [[Type]], [[Value]] } _patternPart_ of _patternParts_, do
          1. Let _p_ be _patternPart_.[[Type]].
          1. If _p_ is *"literal"*, then
            1. Append the Record { [[Type]]: *"literal"*, [[Value]]: _patternPart_.[[Value]] } to _result_.
          1. Else if _p_ is equal to *"fractionalSecondDigits"*, then
            1. Assert: _fractionalSecondDigits_ is not *undefined*.
            1. Let _v_ be _tm_.[[Millisecond]].
            1. Set _v_ to floor(_v_ &times; 10<sup>( _fractionalSecondDigits_ - 3 )</sup>).
            1. Let _fv_ be FormatNumeric(_nf3_, _v_).
            1. Append the Record { [[Type]]: *"fractionalSecond"*, [[Value]]: _fv_ } to _result_.
          1. Else if _p_ is equal to *"dayPeriod"*, then
            1. Let _f_ be _dateTimeFormat_.[[DayPeriod]].
            1. Let _fv_ be a String value representing the day period of _tm_ in the form given by _f_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_.
            1. Append the Record { [[Type]]: _p_, [[Value]]: _fv_ } to _result_.
          1. Else if _p_ is equal to *"timeZoneName"*, then
            1. Let _f_ be _dateTimeFormat_.[[TimeZoneName]].
            1. Let _v_ be _dateTimeFormat_.[[TimeZone]].
            1. Let _fv_ be a String value representing _v_ in the form given by _f_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_. The String value may also depend on the value of the [[InDST]] field of _tm_ if _f_ is *"short"*, *"long"*, *"shortOffset"*, or *"longOffset"*. If the implementation does not have such a localized representation of _v_, then use the String value of _v_ itself.
            1. Append the Record { [[Type]]: _p_, [[Value]]: _fv_ } to _result_.
          1. Else if _p_ matches a Property column of the row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, then
            1. If _rangeFormatOptions_ is not *undefined*, let _f_ be the value of _rangeFormatOptions_'s field whose name matches _p_.
            1. Else, let _f_ be the value of <del>_dateTimeFormat_'s internal slot</del><ins>_pattern_'s field</ins> whose name is <del>the Internal Slot column of the matching row</del><ins>_p_</ins>.
            1. Let _v_ be the value of _tm_'s field whose name is the Internal Slot column of the matching row.
            1. If _p_ is *"year"* and _v_ &le; 0, set _v_ to 1 - _v_.
            1. If _p_ is *"month"*, set _v_ to _v_ + 1.
            1. If _p_ is *"hour"* and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h11"* or *"h12"*, then
              1. Set _v_ to _v_ modulo 12.
              1. If _v_ is 0 and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h12"*, set _v_ to 12.
            1. If _p_ is *"hour"* and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h24"*, then
              1. If _v_ is 0, set _v_ to 24.
            1. If _f_ is *"numeric"*, then
              1. Let _fv_ be FormatNumeric(_nf_, _v_).
            1. Else if _f_ is *"2-digit"*, then
              1. Let _fv_ be FormatNumeric(_nf2_, _v_).
              1. If the *"length"* property of _fv_ is greater than 2, set _fv_ to the substring of _fv_ containing the last two characters.
            1. Else if _f_ is *"narrow"*, *"short"*, or *"long"*, then
              1. Let _fv_ be a String value representing _v_ in the form given by _f_; the String value depends upon the implementation and the effective locale and calendar of _dateTimeFormat_. If _p_ is *"month"* and _rangeFormatOptions_ is *undefined*, then the String value may also depend on whether <del>_dateTimeFormat_.[[Day]]</del><ins>_pattern_.[[day]]</ins> is *undefined*. If _p_ is *"month"* and _rangeFormatOptions_ is not *undefined*, then the String value may also depend on whether _rangeFormatOptions_.[[day]] is *undefined*. If _p_ is *"era"* and _rangeFormatOptions_ is *undefined*, then the String value may also depend on whether <del>_dateTimeFormat_.[[Era]]</del><ins>_pattern_.[[era]]</ins> is *undefined*. If _p_ is *"era"* and _rangeFormatOptions_ is not *undefined*, then the String value may also depend on whether _rangeFormatOptions_.[[era]] is *undefined*. If the implementation does not have such a localized representation of _v_, then use ! ToString(_v_).
            1. Append the Record { [[Type]]: _p_, [[Value]]: _fv_ } to _result_.
          1. Else if _p_ is equal to *"ampm"*, then
            1. Let _v_ be _tm_.[[Hour]].
            1. If _v_ is greater than 11, then
              1. Let _fv_ be an implementation and locale dependent String value representing *"post meridiem"*.
            1. Else,
              1. Let _fv_ be an implementation and locale dependent String value representing *"ante meridiem"*.
            1. Append the Record { [[Type]]: *"dayPeriod"*, [[Value]]: _fv_ } to _result_.
          1. Else if _p_ is equal to *"relatedYear"*, then
            1. Let _v_ be _tm_.[[RelatedYear]].
            1. Let _fv_ be FormatNumeric(_nf_, _v_).
            1. Append the Record { [[Type]]: *"relatedYear"*, [[Value]]: _fv_ } to _result_.
          1. Else if _p_ is equal to *"yearName"*, then
            1. Let _v_ be _tm_.[[YearName]].
            1. Let _fv_ be an implementation and locale dependent String value representing _v_.
            1. Append the Record { [[Type]]: *"yearName"*, [[Value]]: _fv_ } to _result_.
          1. Else,
            1. Let _unknown_ be an implementation-, locale-, and numbering system-dependent String based on <del>_x_</del><ins>_epochNanoseconds_</ins> and _p_.
            1. Append the Record { [[Type]]: *"unknown"*, [[Value]]: _unknown_ } to _result_.
        1. Return _result_.
      </emu-alg>

      <emu-note>
        It is recommended that implementations use the locale and calendar dependent strings provided by the Common Locale Data Repository (available at <a href="https://cldr.unicode.org/">https://cldr.unicode.org/</a>), and use CLDR *"abbreviated"* strings for DateTimeFormat *"short"* strings, and CLDR *"wide"* strings for DateTimeFormat *"long"* strings.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-partitiondatetimepattern" type="abstract operation">
      <h1>
        PartitionDateTimePattern (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
        ): either a normal completion containing a List of Records with fields [[Type]] (a String) and [[Value]] (a String), or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It interprets _x_ as <del>a time value as specified in es2024, <emu-xref href="#sec-time-values-and-time-range"></emu-xref></del><ins>an epoch time</ins>, and creates the corresponding parts according to the <ins>type of _x_,</ins> effective locale<ins>,</ins> and the formatting options of _dateTimeFormat_.</dd>
      </dl>
      <emu-alg>
        1. <ins>Let _xFormatRecord_ be ? HandleDateTimeValue(_dateTimeFormat_, _x_).</ins>
        1. Let _patternParts_ be PartitionPattern(<del>_dateTimeFormat_.[[Pattern]]</del><ins>_xFormatRecord_.[[pattern]]</ins>).
        1. Let _result_ be ? FormatDateTimePattern(_dateTimeFormat_, <ins>_xFormatRecord_.[[pattern]],</ins> _patternParts_, <del>_x_</del><ins>_xFormatRecord_.[[EpochNanoseconds]]</ins>, *undefined*).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetime" type="abstract operation">
      <h1>
        FormatDateTime (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimePattern(_dateTimeFormat_, _x_).
        1. Let _result_ be the empty String.
        1. For each Record { [[Type]], [[Value]] } _part_ of _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimetoparts" type="abstract operation">
      <h1>
        FormatDateTimeToParts (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
        ): either a normal completion containing an Array or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimePattern(_dateTimeFormat_, _x_).
        1. Let _result_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record { [[Type]], [[Value]] } _part_ of _parts_, do
          1. Let _O_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataPropertyOrThrow(_result_, ! ToString(𝔽(_n_)), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-partitiondatetimerangepattern" type="abstract operation">
      <h1>
        PartitionDateTimeRangePattern (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
          _y_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
        ): either a normal completion containing a List of Records with fields [[Type]] (a String), [[Value]] (a String), and [[Source]] (a String), or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It interprets _x_ and _y_ <del>a time value as specified in es2024, <emu-xref href="#sec-time-values-and-time-range"></emu-xref></del><ins>epoch times</ins>, and creates the corresponding parts according to the <ins>types of _x_ and _y_,</ins> effective locale<ins>,</ins> and the formatting options of _dateTimeFormat_.</dd>
      </dl>
      <emu-alg>
        1. <del>Let _x_ be TimeClip(_x_).</del>
        1. <del>If _x_ is *NaN*, throw a *RangeError* exception.</del>
        1. <del>Let _y_ be TimeClip(_y_).</del>
        1. <del>If _y_ is *NaN*, throw a *RangeError* exception.</del>
        1. <ins>If IsTemporalObject(_x_) is *true* or IsTemporalObject(_y_) is *true*, then</ins>
          1. <ins>If SameTemporalType(_x_, _y_) is *false*, throw a *TypeError* exception.</ins>
        1. <ins>Let _xFormatRecord_ be ? HandleDateTimeValue(_dateTimeFormat_, _x_).</ins>
        1. <ins>Let _yFormatRecord_ be ? HandleDateTimeValue(_dateTimeFormat_, _y_).</ins>
        1. Let _tm1_ be ToLocalTime(<del>ℤ(ℝ(_x_) &times; 10<sup>6</sup>)</del><ins>_xFormatRecord_.[[epochNanoseconds]]</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _tm2_ be ToLocalTime(<del>ℤ(ℝ(_y_) &times; 10<sup>6</sup>)</del><ins>_yFormatRecord_.[[epochNanoseconds]]</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _rangePatterns_ be <del>_dateTimeFormat_.[[RangePatterns]]</del><ins>_xFormatRecord_.[[rangePatterns]]</ins>.
        1. <ins>Assert: _rangePatterns_ is equal to _yFormatRecord_.[[rangePatterns]].</ins>
        1. Let _selectedRangePattern_ be *undefined*.
        1. Let _relevantFieldsEqual_ be *true*.
        1. Let _checkMoreFields_ be *true*.
        1. For each row of <emu-xref href="#table-datetimeformat-rangepatternfields"></emu-xref>, except the header row, in table order, do
          1. Let _fieldName_ be the name given in the Range Pattern Field column of the row.
          1. If _rangePatterns_ has a field [[&lt;_fieldName_&gt;]], let _rangePattern_ be _rangePatterns_.[[&lt;_fieldName_&gt;]]; else let _rangePattern_ be *undefined*.
          1. If _selectedRangePattern_ is not *undefined* and _rangePattern_ is *undefined*, then
            1. NOTE: Because there is no range pattern for differences at or below this field, no further checks will be performed.
            1. Set _checkMoreFields_ to *false*.
          1. If _relevantFieldsEqual_ is *true* and _checkMoreFields_ is *true*, then
            1. Set _selectedRangePattern_ to _rangePattern_.
            1. If _fieldName_ is equal to [[AmPm]], then
              1. If _tm1_.[[Hour]] is less than 12, let _v1_ be *"am"*; else let _v1_ be *"pm"*.
              1. If _tm2_.[[Hour]] is less than 12, let _v2_ be *"am"*; else let _v2_ be *"pm"*.
            1. Else if _fieldName_ is equal to [[DayPeriod]], then
              1. Let _v1_ be a String value representing the day period of _tm1_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_.
              1. Let _v2_ be a String value representing the day period of _tm2_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_.
            1. Else if _fieldName_ is equal to [[FractionalSecondDigits]], then
              1. Let _fractionalSecondDigits_ be _dateTimeFormat_.[[FractionalSecondDigits]].
              1. If _fractionalSecondDigits_ is *undefined*, then
                1. Set _fractionalSecondDigits_ to 3.
              1. Let _exp_ be _fractionalSecondDigits_ - 3.
              1. Let _v1_ be floor(_tm1_.[[Millisecond]] &times; 10<sup>_exp_</sup>).
              1. Let _v2_ be floor(_tm2_.[[Millisecond]] &times; 10<sup>_exp_</sup>).
            1. Else,
              1. Let _v1_ be _tm1_.[[&lt;_fieldName_&gt;]].
              1. Let _v2_ be _tm2_.[[&lt;_fieldName_&gt;]].
            1. If _v1_ is not equal to _v2_, then
              1. Set _relevantFieldsEqual_ to *false*.
        1. If _relevantFieldsEqual_ is *true*, then
          1. Let _collapsedResult_ be a new empty List.
          1. Let _pattern_ be <del>_dateTimeFormat_.[[Pattern]]</del><ins>_xFormatRecord_.[[pattern]]</ins>.
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. Let _resultParts_ be ! FormatDateTimePattern(_dateTimeFormat_, <ins>_pattern_,</ins> _patternParts_, <del>_x_</del><ins>_xFormatRecord_.[[epochNanoseconds]]</ins>, *undefined*).
          1. For each Record { [[Type]], [[Value]] } _r_ of _resultParts_, do
            1. Append the Record { [[Type]]: _r_.[[Type]], [[Value]]: _r_.[[Value]], [[Source]]: *"shared"* } to _collapsedResult_.
          1. Return _collapsedResult_.
        1. Let _rangeResult_ be a new empty List.
        1. If _selectedRangePattern_ is *undefined*, then
          1. Set _selectedRangePattern_ to _rangePatterns_.[[Default]].
        1. For each Record { [[Pattern]], [[Source]] } _rangePatternPart_ of _selectedRangePattern_.[[PatternParts]], do
          1. Let _pattern_ be _rangePatternPart_.[[Pattern]].
          1. Let _source_ be _rangePatternPart_.[[Source]].
          1. If _source_ is *"startRange"* or *"shared"*, then
            1. Let _z_ be <del>_x_</del><ins>_xFormatRecord_.[[epochNanoseconds]]</ins>.
          1. Else,
            1. Let _z_ be <del>_y_</del><ins>_yFormatRecord_.[[epochNanoseconds]]</ins>.
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. Let _resultParts_ be ! FormatDateTimePattern(_dateTimeFormat_, <ins>_pattern_,</ins> _patternParts_, _z_, _selectedRangePattern_).
          1. For each Record { [[Type]], [[Value]] } _r_ of _resultParts_, do
            1. Append the Record { [[Type]]: _r_.[[Type]], [[Value]]: _r_.[[Value]], [[Source]]: _source_ } to _rangeResult_.
        1. Return _rangeResult_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimerange" type="abstract operation">
      <h1>
        FormatDateTimeRange (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
          _y_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimeRangePattern(_dateTimeFormat_, _x_, _y_).
        1. Let _result_ be the empty String.
        1. For each Record { [[Type]], [[Value]], [[Source]] } _part_ of _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimerangetoparts" type="abstract operation">
      <h1>
        FormatDateTimeRangeToParts (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
          _y_: a Number <ins>or an Object for which IsTemporalObject returns *true*</ins>,
        ): either a normal completion containing an Array or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimeRangePattern(_dateTimeFormat_, _x_, _y_).
        1. Let _result_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record { [[Type]], [[Value]], [[Source]] } _part_ of _parts_, do
          1. Let _O_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"source"*, _part_.[[Source]]).
          1. Perform ! CreateDataPropertyOrThrow(_result_, ! ToString(𝔽(_n_)), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-todatetimeformattable" type="abstract operation">
      <h1>
        ToDateTimeFormattable (
          _value_: an ECMAScript language value, but not *undefined*,
        ): either a normal completion containing either a Number or an Object for which IsTemporalObject returns *true*, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts _value_ to a value that can be formatted by an %Intl.DateTimeFormat% object.</dd>
      </dl>
      <emu-alg>
        1. If IsTemporalObject(_value_) is *true*, return _value_.
        1. Return ? ToNumber(_value_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-istemporalobject" type="abstract operation">
      <h1>
        IsTemporalObject (
          _value_: an ECMAScript language value,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If Type(_value_) is not Object, then
          1. Return *false*.
        1. If _value_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalTime]], [[InitializedTemporalDateTime]], [[InitializedTemporalZonedDateTime]], [[InitializedTemporalYearMonth]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalInstant]] internal slot, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-sametemporaltype" type="abstract operation">
      <h1>
        SameTemporalType (
          _x_: an ECMAScript language value,
          _y_: an ECMAScript language value,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines whether _x_ and _y_ are both instances of the same Temporal type.</dd>
      </dl>
      <emu-alg>
        1. If either of IsTemporalObject(_x_) or IsTemporalObject(_y_) is *false*, return *false*.
        1. If _x_ has an [[InitializedTemporalDate]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalDateTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalZonedDateTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalYearMonth]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalMonthDay]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalInstant]] internal slot and _y_ does not, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getdatetimeformatpattern" type="abstract operation">
      <h1>
        GetDateTimeFormatPattern (
          _required_: ~date~, ~time~, or ~any~,
          _dateStyle_: *"full"*, *"long"*, *"medium"*, *"short"*, or *undefined*,
          _timeStyle_: *"full"*, *"long"*, *"medium"*, *"short"*, or *undefined*,
          _formatMatcher_: *"basic"* or *"best fit"*,
          _formatOptions_: a Record,
          _dataLocaleData_: a Record of the same type as %Intl.DateTimeFormat%.[[LocaleData]] as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>,
          _resolvedCalendar_: a String,
          _hasExplicitFormatComponents_: a Boolean,
        ): either a normal completion containing a Record of the type contained by the List %Intl.DateTimeFormat%.[[LocaleData]].[[&lt;_locale_&gt;]].[[formats]].[[&lt;_calendar_&gt;]] as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>, or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _dateStyle_ is not *undefined* or _timeStyle_ is not *undefined*, then
          1. If _hasExplicitFormatComponents_ is *true*, then
            1. Throw a *TypeError* exception.
          1. If _required_ is ~date~ and _timeStyle_ is not *undefined*, then
            1. Throw a *TypeError* exception.
          1. If _required_ is ~time~ and _dateStyle_ is not *undefined*, then
            1. Throw a *TypeError* exception.
          1. Let _styles_ be _dataLocaleData_.[[styles]].[[&lt;_resolvedCalendar_&gt;]].
          1. Let _bestFormat_ be DateTimeStyleFormat(_dateStyle_, _timeStyle_, _styles_).
        1. Else,
          1. Let _formats_ be _dataLocaleData_.[[formats]].[[&lt;_resolvedCalendar_&gt;]].
          1. If _formatMatcher_ is *"basic"*, then
            1. Let _bestFormat_ be BasicFormatMatcher(_formatOptions_, _formats_).
          1. Else,
            1. Let _bestFormat_ be BestFitFormatMatcher(_formatOptions_, _formats_).
        1. If _bestFormat_.[[Hour]] is *undefined*, then
          1. Set _bestFormat_.[[HourCycle]] to *undefined*.
        1. If _bestFormat_.[[HourCycle]] is *"h11"* or *"h12"*, then
          1. Set _bestFormat_.[[pattern]] to _bestFormat_.[[pattern12]].
          1. Set _bestFormat_.[[rangePatterns]] to _bestFormat_.[[rangePatterns12]].
        1. Remove the [[pattern12]] field from _bestFormat_.
        1. Remove the [[rangePatterns12]] field from _bestFormat_.
        1. Return _bestFormat_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-datetimeformat-value-format-records">
      <h1>Value Format Records</h1>

      <p>
        Each <dfn id="datetimeformat-value-format-record">Value Format Record</dfn> has the fields
 defined in <emu-xref href="#table-datetimeformat-value-format-record"></emu-xref>.
      </p>

      <emu-table id="table-datetimeformat-value-format-record">
        <emu-caption>Record returned by HandleDateTimeValue</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value Type</th>
            </tr>
          </thead>
          <tr>
            <td>[[pattern]]</td>
            <td>a String value as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref></td>
          </tr>
          <tr>
            <td>[[rangePatterns]]</td>
            <td>a Record as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref></td>
          </tr>
          <tr>
            <td>[[epochNanoseconds]]</td>
            <td>a BigInt</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-handledatetimetemporaldate" type="abstract operation">
      <h1>
        HandleDateTimeTemporalDate (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _temporalDate_: a Temporal.PlainDate,
        ): either a normal completion containing a Value Format Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainDatePattern]].
      1. Let _calendar_ be ? ToTemporalCalendarIdentifier(_temporalDate_.[[Calendar]]).
      1. If _calendar_ is not _dateTimeFormat_.[[Calendar]] or *"iso8601"*, throw a *RangeError* exception.
      1. Let _plainDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 12, 0, 0, 0, 0, 0, _dateTimeFormat_.[[Calendar]]).
      1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_dateTimeFormat_.[[TimeZone]], « ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ »).
      1. Let _instant_ be ? GetInstantFor(_timeZoneRec_, _plainDateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-handledatetimetemporalyearmonth" type="abstract operation">
      <h1>
        HandleDateTimeTemporalYearMonth (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _temporalYearMonth_: a Temporal.PlainYearMonth,
        ): either a normal completion containing a Value Format Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainYearMonthPattern]].
      1. Let _calendar_ be ? ToTemporalCalendarIdentifier(_temporalYearMonth_.[[Calendar]]).
      1. If _calendar_ is not equal to _dateTimeFormat_.[[Calendar]], then
        1. Throw a *RangeError* exception.
      1. Let _plainDateTime_ be ? CreateTemporalDateTime(_temporalYearMonth_.[[ISOYear]], _temporalYearMonth_.[[ISOMonth]], _temporalYearMonth_.[[ISODay]], 12, 0, 0, 0, 0, 0, _dateTimeFormat_.[[Calendar]]).
      1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_dateTimeFormat_.[[TimeZone]], « ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ »).
      1. Let _instant_ be ? GetInstantFor(_timeZoneRec_, _plainDateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-handledatetimetemporalmonthday" type="abstract operation">
      <h1>
        HandleDateTimeTemporalMonthDay (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _temporalMonthDay_: a Temporal.PlainMonthDay,
        ): either a normal completion containing a Value Format Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainMonthDayPattern]].
      1. Let _calendar_ be ? ToTemporalCalendarIdentifier(_temporalMonthDay_.[[Calendar]]).
      1. If _calendar_ is not equal to _dateTimeFormat_.[[Calendar]], then
        1. Throw a *RangeError* exception.
      1. Let _plainDateTime_ be ? CreateTemporalDateTime(_temporalMonthDay_.[[ISOYear]], _temporalMonthDay_.[[ISOMonth]], _temporalMonthDay_.[[ISODay]], 12, 0, 0, 0, 0, 0, _dateTimeFormat_.[[Calendar]]).
      1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_dateTimeFormat_.[[TimeZone]], « ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ »).
      1. Let _instant_ be ? GetInstantFor(_timeZoneRec_, _plainDateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-handledatetimetemporaltime" type="abstract operation">
      <h1>
        HandleDateTimeTemporalTime (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _temporalTime_: a Temporal.PlainTime,
        ): either a normal completion containing a Value Format Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainTimePattern]].
      1. Let _plainDateTime_ be ? CreateTemporalDateTime(1970, 1, 1, _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], *"iso8601"*).
      1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_dateTimeFormat_.[[TimeZone]], « ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ »).
      1. Let _instant_ be ? GetInstantFor(_timeZoneRec_, _plainDateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-handledatetimetemporaldatetime" type="abstract operation">
      <h1>
        HandleDateTimeTemporalDateTime (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _dateTime_: a Temporal.PlainDateTime,
        ): either a normal completion containing a Value Format Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainDateTimePattern]].
      1. Let _calendar_ be ? ToTemporalCalendarIdentifier(_dateTime_.[[Calendar]]).
      1. If _calendar_ is not *"iso8601"* and not equal to _dateTimeFormat_.[[Calendar]], then
        1. Throw a *RangeError* exception.
      1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_dateTimeFormat_.[[TimeZone]], « ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ »).
      1. Let _instant_ be ? GetInstantFor(_timeZoneRec_, _dateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-handledatetimetemporalinstant" type="abstract operation">
      <h1>
        HandleDateTimeTemporalInstant (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _instant_: a Temporal.Instant,
        ): either a normal completion containing a Value Format Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalInstantPattern]].
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-handledatetimeothers" type="abstract operation">
      <h1>
        HandleDateTimeOthers (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number,
        ): either a normal completion containing a Value Format Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
      1. Let _pattern_ be _dateTimeFormat_.[[Pattern]].
      1. Let _rangePatterns_ be _dateTimeFormat_.[[RangePatterns]].
      1. Set _x_ to TimeClip(_x_).
      1. If _x_ is *NaN*, throw a *RangeError* exception.
      1. Let _epochNanoseconds_ be ℤ(_x_) &times; ℤ(10<sup>6</sup>).
      1. Return the Record {
          [[pattern]]: _pattern_,
          [[rangePatterns]]: _rangePatterns_,
          [[epochNanoseconds]]: _epochNanoseconds_
        }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-handledatetimevalue" type="abstract operation">
      <h1>
        HandleDateTimeValue (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number, or an Object for which IsTemporalObject returns *true*,
        ): either a normal completion containing a Value Format Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
      1. If _x_ is an Object, then
        1. If _x_ has an [[InitializedTemporalDate]] internal slot, then
          1. Return ? HandleDateTimeTemporalDate(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalYearMonth]] internal slot, then
          1. Return ? HandleDateTimeTemporalYearMonth(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalMonthDay]] internal slot, then
          1. Return ? HandleDateTimeTemporalMonthDay(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalTime]] internal slot, then
          1. Return ? HandleDateTimeTemporalTime(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalDateTime]] internal slot, then
          1. Return ? HandleDateTimeTemporalDateTime(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalInstant]] internal slot, then
          1. Return ? HandleDateTimeTemporalInstant(_dateTimeFormat_, _x_).
        1. Assert: _x_ has an [[InitializedTemporalZonedDateTime]] internal slot.
        1. Throw a *TypeError* exception.
      1. Return ? HandleDateTimeOthers(_dateTimeFormat_, _x_).
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-tolocaltime" type="implementation-defined abstract operation">
      <h1>
        ToLocalTime (
          _epochNs_: a BigInt,
          _calendar_: a String,
          _timeZoneIdentifier_: a String,
        ): a ToLocalTime Record
      </h1>

      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>

      <emu-alg>
        1. If IsTimeZoneOffsetString(_timeZoneIdentifier_) is *true*, then
          1. Let _offsetNs_ be ParseTimeZoneOffsetString(_timeZoneIdentifier_).
        1. Else,
          1. Assert: IsValidTimeZoneName(_timeZoneIdentifier_) is *true*.
          1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_timeZoneIdentifier_, _epochNs_).
        1. Let _tz_ be ℝ(_epochNs_) + _offsetNs_.
        1. If _calendar_ is *"gregory"*, then
          1. Return a ToLocalTime Record with fields calculated from _tz_ according to <emu-xref href="#table-datetimeformat-tolocaltime-record"></emu-xref>.
        1. Else,
          1. Return a ToLocalTime Record with the fields calculated from _tz_ for the given _calendar_. The calculations should use best available information about the specified _calendar_. <ins>Given the same values of _epochNs_, _calendar_, and _timeZoneIdentifier_, the result must be the same for the lifetime of the surrounding agent.</ins>
      </emu-alg>

      <emu-note>
        A conforming implementation must recognize *"UTC"* and all Zone and Link names from the IANA Time Zone Database (and <strong>only</strong> such names), and use best available current and historical information about their offsets from UTC and their daylight saving time rules in calculations.
      </emu-note>
      <emu-note>
        <ins>
          Time zone information is subject to change, and host environments may update their time zone database at any time.
          At a minimum, implementations must ensure that the time zone information for each particular value of _timeZone_ individually remains constant starting from the time it is first accessed, for the lifetime of the surrounding agent.
          Furthermore, it is recommended that the time zone information for all values of _timeZone_ as a whole (i.e. the time zone database) remains the same for the lifetime of the surrounding agent.
        </ins>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-prototype-object">
    <h1><a href="https://tc39.es/ecma402/#sec-properties-of-intl-datetimeformat-prototype-object">Properties of the Intl.DateTimeFormat Prototype Object</a></h1>

    <emu-clause id="sec-Intl.DateTimeFormat.prototype.formatToParts">
      <h1>Intl.DateTimeFormat.prototype.formatToParts ( _date_ )</h1>

      <p>
        When the `formatToParts` method is called with an argument _date_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _date_ is *undefined*, then
          1. Let _x_ be ! Call(%Date.now%, *undefined*).
        1. Else,
          1. Let _x_ be ? <del>ToNumber</del><ins>ToDateTimeFormattable</ins>(_date_).
        1. Return ? FormatDateTimeToParts(_dtf_, _x_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.formatRange">
      <h1>Intl.DateTimeFormat.prototype.formatRange ( _startDate_, _endDate_ )</h1>

      <p>
        When the `formatRange` method is called with an arguments _startDate_ and _endDate_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _startDate_ is *undefined* or _endDate_ is *undefined*, throw a *TypeError* exception.
        1. Let _x_ be ? <del>ToNumber</del><ins>ToDateTimeFormattable</ins>(_startDate_).
        1. Let _y_ be ? <del>ToNumber</del><ins>ToDateTimeFormattable</ins>(_endDate_).
        1. Return ? FormatDateTimeRange(_dtf_, _x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.DateTimeFormat.prototype.formatRangeToParts">
      <h1>Intl.DateTimeFormat.prototype.formatRangeToParts ( _startDate_, _endDate_ )</h1>

      <p>
        When the `formatRangeToParts` method is called with arguments _startDate_ and _endDate_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _startDate_ is *undefined* or _endDate_ is *undefined*, throw a *TypeError* exception.
        1. Let _x_ be ? <del>ToNumber</del><ins>ToDateTimeFormattable</ins>(_startDate_).
        1. Let _y_ be ? <del>ToNumber</del><ins>ToDateTimeFormattable</ins>(_endDate_).
        1. Return ? FormatDateTimeRangeToParts(_dtf_, _x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.resolvedoptions">
      <h1>Intl.DateTimeFormat.prototype.resolvedOptions ( )</h1>

      <p>
        This function provides access to the locale and formatting options computed during initialization of the object.
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. If the implementation supports the normative optional constructor mode of <emu-xref href="#legacy-constructor"></emu-xref>, then
          1. Set _dtf_ to ? UnwrapDateTimeFormat(_dtf_).
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. Let _options_ be OrdinaryObjectCreate(%Object.prototype%).
        1. For each row of <emu-xref href="#table-datetimeformat-resolvedoptions-properties"></emu-xref>, except the header row, in table order, do
          1. <ins>If the Location value of the current row is ~object~, then</ins>
            1. Let _v_ be the value of _dtf_'s internal slot whose name is the Internal Slot value of the current row.
          1. <ins>Else,</ins>
            1. <ins>Assert: The Location value of the current row is ~pattern~.</ins>
            1. <ins>Let _v_ be the value of _dtf_.[[Pattern]]'s internal slot whose name is the Internal Slot value of the current row.</ins>
          1. Let _p_ be the Property value of the current row.
          1. If the Internal Slot value of the current row is an Internal Slot value in <emu-xref href="#table-datetimeformat-components"></emu-xref>, then
            1. If _dtf_.[[DateStyle]] is not *undefined* or _dtf_.[[TimeStyle]] is not *undefined*, then
              1. Set _v_ to *undefined*.
          1. If _v_ is not *undefined*, then
            1. If there is a Conversion value in the current row, then
              1. Let _conversion_ be the Conversion value of the current row.
              1. If _conversion_ is ~hour12~, then
                1. If _v_ is *"h11"* or *"h12"*, set _v_ to *true*. Otherwise, set _v_ to *false*.
              1. Else,
                1. Assert: _conversion_ is ~number~.
                1. Set _v_ to 𝔽(_v_).
            1. Perform ! CreateDataPropertyOrThrow(_options_, _p_, _v_).
        1. Return _options_.
      </emu-alg>

      <emu-table id="table-datetimeformat-resolvedoptions-properties">
        <emu-caption>Resolved Options of DateTimeFormat Instances</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
              <th>Conversion</th>
              <th><ins>Location</ins></th>
            </tr>
          </thead>
          <tr>
            <td>[[Locale]]</td>
            <td>*"locale"*</td>
            <td></td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[Calendar]]</td>
            <td>*"calendar"*</td>
            <td></td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[NumberingSystem]]</td>
            <td>*"numberingSystem"*</td>
            <td></td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[TimeZone]]</td>
            <td>*"timeZone"*</td>
            <td></td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td><del>[[HourCycle]]</del><ins>[[hourCycle]]</ins></td>
            <td>*"hourCycle"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[HourCycle]]</del><ins>[[hourCycle]]</ins></td>
            <td>*"hour12"*</td>
            <td>~hour12~</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Weekday]]</del><ins>[[weekday]]</ins></td>
            <td>*"weekday"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Era]]</del><ins>[[era]]</ins></td>
            <td>*"era"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Year]]</del><ins>[[year]]</ins></td>
            <td>*"year"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Month]]</del><ins>[[month]]</ins></td>
            <td>*"month"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Day]]</del><ins>[[day]]</ins></td>
            <td>*"day"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[DayPeriod]]</del><ins>[[dayPeriod]]</ins></td>
            <td>*"dayPeriod"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Hour]]</del><ins>[[hour]]</ins></td>
            <td>*"hour"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Minute]]</del><ins>[[minute]]</ins></td>
            <td>*"minute"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Second]]</del><ins>[[second]]</ins></td>
            <td>*"second"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[FractionalSecondDigits]]</del><ins>[[fractionalSecondDigits]]</ins></td>
            <td>*"fractionalSecondDigits"*</td>
            <td>~number~</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[TimeZoneName]]</del><ins>[[timeZoneName]]</ins></td>
            <td>*"timeZoneName"*</td>
            <td></td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td>[[DateStyle]]</td>
            <td>*"dateStyle"*</td>
            <td></td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[TimeStyle]]</td>
            <td>*"timeStyle"*</td>
            <td></td>
            <td><ins>~object~</ins></td>
          </tr>
        </table>
      </emu-table>

      <p>
        For web compatibility reasons, if the property *"hourCycle"* is set, the *"hour12"* property should be set to *true* when *"hourCycle"* is *"h11"* or *"h12"*, or to *false* when *"hourCycle"* is *"h23"* or *"h24"*.
      </p>

      <emu-note>
        In this version of the API, the *"timeZone"* property will be the identifier of the host environment's time zone if no *"timeZone"* property was provided in the options object provided to the Intl.DateTimeFormat constructor. The first edition left the *"timeZone"* property *undefined* in this case.
      </emu-note>

      <emu-note>
        For compatibility with versions prior to the fifth edition, the *"hour12"* property is set in addition to the *"hourCycle"* property.
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-instances">
    <h1><a href="https://tc39.es/ecma402/#sec-properties-of-intl-datetimeformat-instances">Properties of Intl.DateTimeFormat Instances</a></h1>

    <p>
      Intl.DateTimeFormat instances are ordinary objects that inherit properties from %Intl.DateTimeFormat.prototype%.
    </p>

    <p>
      Intl.DateTimeFormat instances have an [[InitializedDateTimeFormat]] internal slot.
    </p>

    <p>
      Intl.DateTimeFormat instances also have several internal slots that are computed by the constructor:
    </p>

    <ul>
      <li>[[Locale]] is a String value with the language tag of the locale whose localization is used for formatting.</li>
      <li>[[Calendar]] is a String value representing the <a href="https://unicode.org/reports/tr35/#UnicodeCalendarIdentifier">Unicode Calendar Identifier</a> used for formatting.</li>
      <li>[[NumberingSystem]] is a String value representing the <a href="https://unicode.org/reports/tr35/#UnicodeNumberSystemIdentifier">Unicode Number System Identifier</a> used for formatting.</li>
      <li>[[TimeZone]] is a String value used for formatting that is either a time zone identifier from the IANA Time Zone Database or a UTC offset in ISO 8601 extended format.</li>
      <li><del>[[Weekday]], [[Era]], [[Year]], [[Month]], [[Day]], [[DayPeriod]], [[Hour]], [[Minute]], [[Second]], [[TimeZoneName]] are each either *undefined*, indicating that the component is not used for formatting, or one of the String values given in <emu-xref href="#table-datetimeformat-components"></emu-xref>, indicating how the component should be presented in the formatted output.</del></li>
      <li><del>[[FractionalSecondDigits]] is either *undefined* or a positive, non-zero integer indicating the fraction digits to be used for fractional seconds. Numbers will be rounded or padded with trailing zeroes if necessary.</del></li>
      <li><del>[[HourCycle]] is a String value indicating whether the 12-hour format (*"h11"*, *"h12"*) or the 24-hour format (*"h23"*, *"h24"*) should be used. *"h11"* and *"h23"* start with hour 0 and go up to 11 and 23 respectively. *"h12"* and *"h24"* start with hour 1 and go up to 12 and 24. [[HourCycle]] is only used when [[Hour]] is not *undefined*.</del></li>
      <li>[[DateStyle]], [[TimeStyle]] are each either *undefined*, or a String value with values *"full"*, *"long"*, *"medium"*, or *"short"*.</li>
      <li>[[Pattern]] is a String value as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</li>
      <li>[[RangePatterns]] is a Record as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</li>
      <li><ins>[[TemporalPlainDatePattern]], [[TemporalPlainYearMonthPattern]], [[TemporalPlainMonthDayPattern]], [[TemporalPlainTimePattern]], [[TemporalPlainDateTimePattern]], and [[TemporalInstantPattern]] are records containing at least a [[pattern]] field as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</ins></li>
    </ul>

    <p>
      Finally, Intl.DateTimeFormat instances have a [[BoundFormat]] internal slot that caches the function returned by the format accessor (<emu-xref href="#sec-intl.datetimeformat.prototype.format"></emu-xref>).
    </p>
  </emu-clause>

  <emu-clause id="locale-sensitive-functions">
    <h1><a href="https://tc39.es/ecma402/#locale-sensitive-functions">Locale Sensitive Functions of the ECMAScript Language Specification</a></h1>

    <ins class="block">
      <emu-clause id="sup-temporal-calendar-abstract-ops">
        <h1>Abstract Operations for Temporal.Calendar Objects</h1>

        <emu-clause id="sec-temporal-calendarera" type="abstract operation">
          <h1>
            CalendarEra (
              _calendar_: an Object,
              _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            ): either a normal completion containing either a String or *undefined*, or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It calls the given _calendar_'s `era()` method and validates the result.</dd>
          </dl>
          <emu-alg>
            1. Let _result_ be ? Invoke(_calendar_, *"era"*, « _dateLike_ »).
            1. If _result_ is *undefined*, return *undefined*.
            1. If Type(_result_) is not String, throw a *TypeError* exception.
            1. Return _result_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarerayear" type="abstract operation">
          <h1>
            CalendarEraYear (
              _calendar_: an Object,
              _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            ): either a normal completion containing either an integer or *undefined*, or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It calls the given _calendar_'s `eraYear()` method and validates the result.</dd>
          </dl>
          <emu-alg>
            1. Let _result_ be ? Invoke(_calendar_, *"eraYear"*, « _dateLike_ »).
            1. If _result_ is *undefined*, return *undefined*.
            1. If Type(_result_) is not Number, throw a *TypeError* exception.
            1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
            1. Return ℝ(_result_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatetoiso" type="implementation-defined abstract operation">
          <h1>
            CalendarDateToISO (
              _calendar_: a String,
              _fields_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
              _overflow_: *"constrain"* or *"reject"*,
            ): either a normal completion containing an ISO Date Record, or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It performs implementation-defined processing to convert _fields_, which represents a date or year and month or month and day in the built-in calendar identified by _calendar_, to a corresponding representative date in the ISO 8601 calendar, subject to processing specified by _overflow_.
              For *"reject"*, values that do not form a valid date cause an exception to be thrown, as described below.
              For *"constrain"*, values that do not form a valid date are clamped to the correct range.
              It then returns an ISO Date Record with the corresponding ISO 8601 date.
            </dd>
          </dl>
          <p>
            Clamping an invalid date to the correct range when _overflow_ is *"constrain"* is a behaviour specific to each built-in calendar, but all built-in calendars follow this guideline:
          </p>
          <ul>
            <li>Pick the closest day in the same month. If there are two equally-close dates in that month, pick the later one.</li>
            <li>If the month is a leap month that doesn't exist in the year, pick another date according to the cultural conventions of that calendar's users. Usually this will result in the same day in the month before or after where that month would normally fall in a leap year.</li>
            <li>Otherwise, pick the closest date that is still in the same year. If there are two equally-close dates in that year, pick the later one.</li>
            <li>If the entire year doesn't exist, pick the closest date in a different year. If there are two equally-close dates, pick the later one.</li>
          </ul>
          <p>
            Like RegulateISODate, the operation throws a *RangeError* exception if the date described by _fields_ is outside the range allowed by ISODateTimeWithinLimits, or if _overflow_ is *"reject"* and the date described by _fields_ does not exist.
          </p>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarmonthdaytoisoreferencedate" type="abstract operation">
          <h1>
            CalendarMonthDayToISOReferenceDate (
              _calendar_: a String,
              _fields_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
              _overflow_: *"constrain"* or *"reject"*,
            ): either a normal completion containing a Record with fields [[ISOMonth]], [[ISODay]], and [[ReferenceISOYear]], or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It performs implementation-defined processing to convert _fields_, which represents a calendar date without a year (i.e., month code and day pair, or equivalent) in the built-in calendar identified by _calendar_, to a corresponding reference date in the ISO 8601 calendar as described below, subject to processing specified by _overflow_.
              For *"reject"*, values that do not form a valid date cause an exception to be thrown.
              For *"constrain"*, values that do not form a valid date are clamped to the correct range as in CalendarDateToISO.
              It then returns a Record representing the reference ISO 8601 date.
            </dd>
          </dl>
          <p>
            The fields of the returned Record represent a reference date in the ISO 8601 calendar that, when converted to the built-in calendar identified by _calendar_, corresponds to the month code and day of _fields_ in an arbitrary but deterministically chosen reference year.
            The reference date is the latest ISO 8601 date corresponding to the calendar date, that is also earlier than or equal to the ISO 8601 date December 31, 1972.
            If that calendar date never occurs on or before the ISO 8601 date December 31, 1972, then the reference date is the earliest ISO 8601 date corresponding to that calendar date.
            The reference year is almost always 1972 (the first ISO 8601 leap year after the epoch), with exceptions for calendars where some dates (e.g. leap days or days in leap months) didn't occur during that ISO 8601 year. For example, Hebrew calendar leap month Adar I was a part of calendar years 5730 and 5733 (respectively overlapping ISO 8601 February/March 1970 and February/March 1973), but did not occur between them.
          </p>
          <p>
            Like RegulateISODate, the operation throws a *RangeError* exception if _overflow_ is *"reject"* and the month and day described by _fields_ does not exist.
            For example, when _calendar_ is *"gregory"* and _overflow_ is *"reject"*, _fields_ values of `{ monthCode: "M01", day: "32" }` and `{ "year": 2001, "month": 2, "day": 29 }` would both cause a *RangeError* to be thrown.
            In the latter case, even though February 29 is a date in leap years of the Gregorian calendar, 2001 was not a leap year and a month code cannot be determined from the nonexistent date 2001-02-29 with the specified month index.
          </p>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateaddition" type="implementation-defined abstract operation">
          <h1>
            CalendarDateAddition (
              _calendar_: a String,
              _date_: a Temporal.PlainDate,
              _duration_: a Date Duration Record,
              _overflow_: a String,
            ): either a normal completion containing an ISO Date Record, or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It performs implementation-defined processing to add _duration_ to _date_ in the context of the calendar represented by _calendar_ and returns the corresponding day, month and year of the result in the ISO 8601 calendar values as an ISO Date Record.
              It may throw a *RangeError* exception if _overflow_ is *"reject"* and the resulting month or day would need to be clamped in order to form a valid date in _calendar_, or if the date resulting from the addition is outside the range allowed by ISODateTimeWithinLimits.
            </dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedifference" type="abstract operation">
          <h1>
            CalendarDateDifference (
              _calendar_: a String,
              _one_: a Temporal.PlainDate,
              _two_: a Temporal.PlainDate,
              _largestUnit_: a String,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the difference between the two dates _one_ and _two_ in the context of the calendar represented by _calendar_ and returns the corresponding years, months, weeks and days as a Date Duration Record.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateera" type="abstract operation">
          <h1>
            CalendarDateEra (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns a lowercase String value representing that era, or *undefined* for calendars that do not have eras.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateerayear" type="abstract operation">
          <h1>
            CalendarDateEraYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the ordinal position of the year of _date_ in that era, or *undefined* for calendars that do not have eras.</dd>
          </dl>
          <emu-note>
            Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateyear" type="abstract operation">
          <h1>
            CalendarDateYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the year for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns it. The value should be a signed integer relative to the first day of a calendar-specific "epoch year".</dd>
          </dl>

          <emu-note>The year is relative to the first day of the calendar's epoch year, so if the epoch era starts in the middle of the year, the year will be the same value before and after the start date of the era.</emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatemonth" type="abstract operation">
          <h1>
            CalendarDateMonth (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the 1-based ordinal position of that month in the corresponding year of the calendar.</dd>
          </dl>
          <emu-note>
            When the number of months in a year of the identified calendar is variable, a different value can be returned for dates that are part of the same month in different years. For example, in the Hebrew calendar, 1 Nisan 5781 is associated with value 7 while 1 Nisan 5782 is associated with value 8 because 5782 is a leap year and Nisan follows the insertion of Adar I.
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatemonthcode" type="abstract operation">
          <h1>
            CalendarDateMonthCode (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns its month code. The month code for a month that is not a leap month and whose 1-based ordinal position in a common year of the calendar (i.e., a year that is not a leap year) is _n_ should be the string-concatenation of *"M"* and ToZeroPaddedDecimalString(_n_, 2), and the month code for a month that is a leap month inserted after a month whose 1-based ordinal position in a common year of the calendar is _p_ should be the string-concatenation of *"M"*, ToZeroPaddedDecimalString(_p_, 2), and *"L"*.</dd>
          </dl>
          <emu-note>
            For example, in the Hebrew calendar, the month code of Adar (and Adar II, in leap years) is *"M06"* and the month code of Adar I (the leap month inserted before Adar II) is *"M05L"*. In a calendar with a leap month at the start of some years, the month code of that month would be *"M00L"*.
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateday" type="abstract operation">
          <h1>
            CalendarDateDay (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainMonthDay,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the day of the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the 1-based ordinal position of that day in the corresponding month.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedayofweek" type="abstract operation">
          <h1>
            CalendarDateDayOfWeek (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the day of the week in the calendar represented by _calendar_. The return value should be 1-based, where 1 is the day corresponding to Monday in the given calendar.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedayofyear" type="abstract operation">
          <h1>
            CalendarDateDayOfYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the day of the year in the calendar represented by _calendar_. The return value should be 1-based.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateweekofyear" type="abstract operation">
          <h1>
            CalendarDateWeekOfYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
            ): a Year-Week Record
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and calculates the <em>calendar week of year</em>, and the corresponding <em>week calendar year</em>, in the calendar represented by _calendar_.</dd>
          </dl>
          <p>
            The value in the [[Week]] field should be 1-based.
          </p>
          <p>
            The value in the [[Year]] field is relative to the first day of a calendar-specific "epoch year", as in CalendarDateYear, not relative to an era as in CalendarDateEraYear.
          </p>
          <p>
            Usually the [[Year]] field will contain the same value given by CalendarDateYear, but may contain the previous or next year if the week number in the [[Week]] field overlaps two different years.
            See also ToISOWeekOfYear.
          </p>
          <p>
            It returns *undefined* in [[Week]] and [[Year]] field for calendars that do not have a well-defined week calendar system.
          </p>
          <emu-note type="editor">
            <p>
              More details about this function will be specified in
              <a href="https://tc39.es/proposal-intl-era-monthcode/">the Intl era and monthCode proposal</a>.
            </p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedaysinweek" type="abstract operation">
          <h1>
            CalendarDateDaysInWeek (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the number of days in the given week in the calendar represented by _calendar_.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedaysinmonth" type="abstract operation">
          <h1>
            CalendarDateDaysInMonth (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It identifies the month in the specified calendar that contains _date_ and returns the number of days in that month.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedaysinyear" type="abstract operation">
          <h1>
            CalendarDateDaysInYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the number of days in the given year in the calendar represented by _calendar_.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatemonthsinyear" type="abstract operation">
          <h1>
            CalendarDateMonthsInYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the number of months in the given year in the calendar represented by _calendar_.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateinleapyear" type="abstract operation">
          <h1>
            CalendarDateInLeapYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns *true* if it falls within a leap year for the calendar represented by _calendar_ and *false* otherwise.</dd>
          </dl>
          <emu-note>
            A "leap year" is a year that contains more days than other years (for solar or lunar calendars) or more months than other years (for lunisolar calendars like Hebrew or Chinese).
            Some calendars, especially lunisolar ones, have further variation in year length that is not represented in the output of this operation (e.g., the Hebrew calendar includes common years with 353, 354, or 355 days and leap years with 383, 384, or 385 days).
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarfielddescriptors" type="implementation-defined abstract operation">
          <h1>
            CalendarFieldDescriptors (
              _calendar_: a String,
              _type_: ~date~, ~year-month~, ~month-day~, or a List of Strings,
            ): a List of Calendar Field Descriptor Records
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It characterizes calendar-specific fields that are relevant for values of the provided _type_ in the built-in calendar identified by _calendar_ (inferring the type when _type_ is a List by interpreting its elements as field names). For example, *"era"* (with ToString conversion) and *"eraYear"* (with ToIntegerWithTruncation conversion) are returned when _calendar_ is *"gregory"* or *"japanese"* and _type_ is ~date~ or ~year-month~ or a List containing *"year"*.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarfieldkeystoignore" type="abstract operation">
          <h1>
            CalendarFieldKeysToIgnore (
              _calendar_: a String,
              _keys_: a List of property keys,
            ): a List of property keys
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the given _calendar_.
              A field always invalidates at least itself.
            </dd>
          </dl>
          <p>
            This operation is relevant for calendars which accept fields other than the standard set of ISO 8601 calendar fields, in order to implement the Temporal objects' `with()` methods, and `Temporal.Calendar.prototype.mergeFields()` in such a way that the result is free of ambiguity or conflicts.
          </p>
          <p>
            For example, given a _calendar_ that uses eras, such as *"gregory"*, a key in _keys_ being any one of *"year"*, *"era"*, or *"eraYear"* would exclude all three.
            Passing any one of the three to a `with()` method might conflict with either of the other two properties on the receiver object, so those properties of the receiver object should be ignored.
            Given this, in addition to the ISO 8601 mutual exclusion of *"month"* and *"monthCode"* as in ISOFieldKeysToIgnore, a possible implementation might produce the following results when _calendar_ is *"gregory"*:
          </p>
          <emu-table id="table-calendarfieldkeystoignore-example">
            <emu-caption>Example results of CalendarFieldKeysToIgnore</emu-caption>
            <table>
              <thead>
                <tr>
                  <th>_keys_</th>
                  <th>Returned List</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>« *"era"* »</td>
                  <td>« *"era"*, *"eraYear"*, *"year*" »</td>
                </tr>
                <tr>
                  <td>« *"eraYear"* »</td>
                  <td>« *"era"*, *"eraYear"*, *"year"* »</td>
                </tr>
                <tr>
                  <td>« *"year"* »</td>
                  <td>« *"era"*, *"eraYear"*, *"year"* »</td>
                </tr>
                <tr>
                  <td>« *"month"* »</td>
                  <td>« *"month"*, *"monthCode*" »</td>
                </tr>
                <tr>
                  <td>« *"monthCode"* »</td>
                  <td>« *"month"*, *"monthCode"* »</td>
                </tr>
                <tr>
                  <td>« *"day"* »</td>
                  <td>« *"day"* »</td>
                </tr>
                <tr>
                  <td>« *"year"*, *"month"*, *"day"* »</td>
                  <td>« *"era"*, *"eraYear"*, *"year"*, *"month"*, *"monthCode"*, *"day"* »</td>
                </tr>
              </tbody>
            </table>
          </emu-table>
          <emu-note>
            In a _calendar_ such as *"japanese"* where eras do not start and end at year and/or month boundaries, note that the returned List should contain *"era"* and *"eraYear"* if _keys_ contains *"day"*, *"month"*, or *"monthCode"* (not only if it contains *"era"*, *"eraYear"*, or *"year"*, as in the example above) because it's possible for changing the day or month to cause a conflict with the era.
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarresolvefields" type="abstract operation">
          <h1>
            CalendarResolveFields (
              _calendar_: a String,
              _fields_: an Object,
              _type_: ~date~, ~year-month~, or ~month-day~,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It performs implementation-defined processing to validate that _fields_ (which describes a date or partial date in the built-in calendar identified by _calendar_) is sufficiently complete to satisfy _type_ and not internally inconsistent, and mutates _fields_ into acceptable input for <emu-xref href="#sec-temporal-calendardatetoiso" title></emu-xref> or <emu-xref href="#sec-temporal-calendarmonthdaytoisoreferencedate" title></emu-xref> by merging data that can be represented in multiple forms into standard properties and removing redundant properties (for example, merging *"month"* and *"monthCode"* into *"month"* and merging *"era"* and *"eraYear"* into *"year"*).
            </dd>
          </dl>
          <p>
            The operation throws a *TypeError* exception if the properties of _fields_ are internally inconsistent within the calendar or insufficient to identify a unique instance of _type_ in the calendar. For example:
          </p>
          <ul>
            <li>If _type_ is ~date~ or ~month-day~ and *"day"* in the calendar has an interpretation analogous to ISO 8601 and its corresponding value is *undefined*.</li>
            <li>If *"month"* and *"monthCode"* in the calendar have interpretations analogous to ISO 8601 and either the corresponding values for both are *undefined* or neither value is *undefined* but they do not identify the same month.</li>
            <li>If _type_ is ~month-day~ and the value for *"monthCode"* is *undefined* and a year cannot be determined from _fields_.</li>
            <li>If _type_ is ~date~ or ~year-month~ and the calendar supports the usual partitioning of years into eras with their own year counting as represented by *"year"*, *"era"*, and *"eraYear"* (as in the Gregorian or traditional Japanese calendars) and any of the following cases apply:<ul>
              <li>The value for each of *"year"* and *"era"* and *"eraYear"* is *undefined*.</li>
              <li>The value for *"era"* is *undefined* but the value for *"eraYear"* is not.</li>
              <li>The value for *"eraYear"* is *undefined* but the value for *"era"* is not.</li>
              <li>None of the three values are *undefined* but the values for *"era"* and *"eraYear"* do not together identify the same year as the value for *"year"*.</li>
            </ul></li>
          </ul>
          <emu-note>
            When _type_ is ~month-day~ and *"month"* is provided without *"monthCode"*, it is recommended that all built-in calendars other than the ISO 8601 calendar require a disambiguating year (e.g., either *"year"* or *"era"* and *"eraYear"*), including those that always use exactly the same months as the ISO 8601 calendar (which receives special handling in this specification as a default calendar that is permanently stable for automated processing).
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-calendar-prototype-object">
        <h1>Properties of the Temporal.Calendar Prototype Object</h1>

        <emu-clause id="sup-temporal.calendar.prototype.datefromfields">
          <h1>Temporal.Calendar.prototype.dateFromFields ( _fields_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.datefromfields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _relevantFieldNames_ be « *"day"*, *"month"*, *"monthCode"*, *"year"* ».
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « *"year"*, *"day"* »).
            1. Else,
              1. Let _calendarRelevantFieldDescriptors_ be CalendarFieldDescriptors(_calendar_.[[Identifier]], ~date~).
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « », _calendarRelevantFieldDescriptors_).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Perform ? ISOResolveMonth(_fields_).
              1. Let _result_ be ? ISODateFromFields(_fields_, _overflow_).
            1. Else,
              1. Perform ? CalendarResolveFields(_calendar_.[[Identifier]], _fields_, ~date~).
              1. Let _result_ be ? CalendarDateToISO(_calendar_.[[Identifier]], _fields_, _overflow_).
            1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_.[[Identifier]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.yearmonthfromfields">
          <h1>Temporal.Calendar.prototype.yearMonthFromFields ( _fields_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.yearmonthfromfields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _relevantFieldNames_ be « *"month"*, *"monthCode"*, *"year"* ».
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « *"year"* »).
            1. Else,
              1. Let _calendarRelevantFieldDescriptors_ be CalendarFieldDescriptors(_calendar_.[[Identifier]], ~year-month~).
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « », _calendarRelevantFieldDescriptors_).
              1. Let _firstDayIndex_ be the 1-based index of the first day of the month described by _fields_ (i.e., 1 unless the month's first day is skipped by this calendar.)
              1. Perform ! CreateDataPropertyOrThrow(_fields_, *"day"*, 𝔽(_firstDayIndex_)).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Perform ? ISOResolveMonth(_fields_).
              1. Let _result_ be ? ISOYearMonthFromFields(_fields_, _overflow_).
            1. Else,
              1. Perform ? CalendarResolveFields(_calendar_.[[Identifier]], _fields_, ~year-month~).
              1. Let _result_ be ? CalendarDateToISO(_calendar_.[[Identifier]], _fields_, _overflow_).
              1. Set _result_.[[ReferenceISODay]] to _result_.[[Day]].
            1. Return ? CreateTemporalYearMonth(_result_.[[Year]], _result_.[[Month]], _calendar_.[[Identifier]], _result_.[[ReferenceISODay]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthdayfromfields">
          <h1>Temporal.Calendar.prototype.monthDayFromFields ( _fields_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthdayfromfields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _relevantFieldNames_ be « *"day"*, *"month"*, *"monthCode"*, *"year"* ».
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « *"day"* »).
            1. Else,
              1. Let _calendarRelevantFieldDescriptors_ be CalendarFieldDescriptors(_calendar_.[[Identifier]], ~month-day~).
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « », _calendarRelevantFieldDescriptors_).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Perform ? ISOResolveMonth(_fields_).
              1. Let _result_ be ? ISOMonthDayFromFields(_fields_, _overflow_).
            1. Else,
              1. Perform ? CalendarResolveFields(_calendar_.[[Identifier]], _fields_, ~month-day~).
              1. Let _result_ be ? CalendarMonthDayToISOReferenceDate(_calendar_.[[Identifier]], _fields_, _overflow_).
            1. Return ? CreateTemporalMonthDay(_result_.[[Month]], _result_.[[Day]], _calendar_.[[Identifier]], _result_.[[ReferenceISOYear]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dateadd">
          <h1>Temporal.Calendar.prototype.dateAdd ( _date_, _duration_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dateadd"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Set _date_ to ? ToTemporalDate(_date_).
            1. Set _duration_ to ? ToTemporalDuration(_duration_).
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. Let _norm_ be NormalizeTimeDuration(_duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
            1. Let _balanceResult_ be BalanceTimeDuration(_norm_, *"day"*).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? AddISODate(_date_.[[ISOYear]], _date_.[[ISOMonth]], _date_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]] + _balanceResult_.[[Days]], _overflow_).
            1. Else,
              1. Let _balancedDuration_ be ! CreateDateDurationRecord(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]] + _balanceResult_.[[Days]]).
              1. Let _result_ be ? CalendarDateAddition(_calendar_.[[Identifier]], _date_, _balancedDuration_, _overflow_).
            1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_.[[Identifier]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dateuntil">
          <h1>Temporal.Calendar.prototype.dateUntil ( _one_, _two_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dateuntil"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Set _one_ to ? ToTemporalDate(_one_).
            1. Set _two_ to ? ToTemporalDate(_two_).
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _largestUnit_ be ? GetTemporalUnit(_options_, *"largestUnit"*, ~date~, *"auto"*).
            1. If _largestUnit_ is *"auto"*, set _largestUnit_ to *"day"*.
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be DifferenceISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _largestUnit_).
            1. Else,
              1. Let _result_ be ! CalendarDateDifference(_calendar_.[[Identifier]], _one_, _two_, _largestUnit_).
              1. Assert: ! IsValidDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0) is *true*.
            1. Return ! CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal.calendar.prototype.era">
          <h1>Temporal.Calendar.prototype.era ( _temporalDateLike_ )</h1>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return *undefined*.
            1. Return ! CalendarDateEra(_calendar_.[[Identifier]], _temporalDateLike_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal.calendar.prototype.erayear">
          <h1>Temporal.Calendar.prototype.eraYear ( _temporalDateLike_ )</h1>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return *undefined*.
            1. Let _eraYear_ be ! CalendarDateEraYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. If _eraYear_ is *undefined*, then
              1. Return *undefined*.
            1. Return 𝔽(_eraYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.year">
          <h1>Temporal.Calendar.prototype.year ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.year"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Assert: _temporalDateLike_ has an [[ISOYear]] internal slot.
              1. Let _year_ be _temporalDateLike_.[[ISOYear]].
            1. Else,
              1. Let _year_ be ! CalendarDateYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_year_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.month">
          <h1>Temporal.Calendar.prototype.month ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.month"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is Object and _temporalDateLike_ has an [[InitializedTemporalMonthDay]] internal slot, then
              1. Throw a *TypeError* exception.
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Assert: _temporalDateLike_ has an [[ISOMonth]] internal slot.
              1. Let _month_ be _temporalDateLike_.[[ISOMonth]].
            1. Else,
              1. Let _month_ be ! CalendarDateMonth(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_month_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthcode">
          <h1>Temporal.Calendar.prototype.monthCode ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthcode"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Assert: _temporalDateLike_ has an [[ISOMonth]] internal slot.
              1. Let _monthCode_ be ISOMonthCode(_temporalDateLike_.[[ISOMonth]]).
            1. Else,
              1. Let _monthCode_ be ! CalendarDateMonthCode(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return _monthCode_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.day">
          <h1>Temporal.Calendar.prototype.day ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.day"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalMonthDay]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Assert: _temporalDateLike_ has an [[ISODay]] internal slot.
              1. Let _day_ be _temporalDateLike_.[[ISODay]].
            1. Else,
              1. Let _day_ be ! CalendarDateDay(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_day_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dayofweek">
          <h1>Temporal.Calendar.prototype.dayOfWeek ( _dateOrDateTime_ )</h1>
          <p>This definition supersedes the definition _temporalDateLike_ in <emu-xref href="#sec-temporal.calendar.prototype.dayofweek"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return 𝔽(ToISODayOfWeek(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
            1. Let _dayOfWeek_ be ! CalendarDateDayOfWeek(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_dayOfWeek_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dayofyear">
          <h1>Temporal.Calendar.prototype.dayOfYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dayofyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return 𝔽(ToISODayOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
            1. Let _dayOfYear_ be ! CalendarDateDayOfYear(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_dayOfYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.weekofyear">
          <h1>Temporal.Calendar.prototype.weekOfYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.weekofyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _yearWeek_ be ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
            1. Else,
              1. Let _yearWeek_ be CalendarDateWeekOfYear(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_yearWeek_.[[Week]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.yearofweek">
          <h1>Temporal.Calendar.prototype.yearOfWeek ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.yearofweek"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _yearWeek_ be ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
            1. Else,
              1. Let _yearWeek_ be CalendarDateWeekOfYear(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_yearWeek_.[[Year]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinweek">
          <h1>Temporal.Calendar.prototype.daysInWeek ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinweek"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _daysInWeek_ be 7.
            1. Else,
              1. Let _daysInWeek_ be ! CalendarDateDaysInWeek(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_daysInWeek_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinmonth">
          <h1>Temporal.Calendar.prototype.daysInMonth ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinmonth"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slots, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _daysInMonth_ be ISODaysInMonth(_temporalDateLike_.[[ISOYear]], _temporalDateLike_.[[ISOMonth]]).
            1. Else,
              1. Let _daysInMonth_ be ! CalendarDateDaysInMonth(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_daysInMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinyear">
          <h1>Temporal.Calendar.prototype.daysInYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return 𝔽(MathematicalDaysInYear(_temporalDateLike_.[[ISOYear]])).
            1. Let _daysInYear_ be ! CalendarDateDaysInYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_daysInYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthsinyear">
          <h1>Temporal.Calendar.prototype.monthsInYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthsinyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _monthsInYear_ be 12.
            1. Else,
              1. Let _monthsInYear_ be ! CalendarDateMonthsInYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_monthsInYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.inleapyear">
          <h1>Temporal.Calendar.prototype.inLeapYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.inleapyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. If MathematicalInLeapYear(EpochTimeForYear(_temporalDateLike_.[[ISOYear]])) is 1, then
                1. Let _inLeapYear_ be *true*.
              1. Else,
                1. Let _inLeapYear_ be *false*.
            1. Else,
              1. Let _inLeapYear_ be ! CalendarDateInLeapYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return _inLeapYear_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.fields">
          <h1>Temporal.Calendar.prototype.fields ( _fields_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.fields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _iteratorRecord_ be ? GetIterator(_fields_, ~sync~).
            1. Let _fieldNames_ be a new empty List.
            1. Let _next_ be *undefined*.
            1. Repeat, while _next_ is not ~done~,
              1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is not ~done~, then
                1. If _next_ is not a String, then
                  1. Let _completion_ be ThrowCompletion(a newly created *TypeError* object).
                  1. Return ? IteratorClose(_iteratorRecord_, _completion_).
                1. If _fieldNames_ contains _next_, then
                  1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
                  1. Return ? IteratorClose(_iteratorRecord_, _completion_).
                1. If _next_ is not one of *"year"*, *"month"*, *"monthCode"*, or *"day"*, then
                  1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
                  1. Return ? IteratorClose(_iteratorRecord_, _completion_).
                1. Append _next_ to the end of the List _fieldNames_.
            1. Let _result_ be _fieldNames_.
            1. If _calendar_.[[Identifier]] is not *"iso8601"*, then
              1. NOTE: Every built-in calendar preserves all input field names in output.
              1. Let _extraFieldDescriptors_ be CalendarFieldDescriptors(_calendar_.[[Identifier]], _fieldNames_).
              1. For each Calendar Field Descriptor Record _desc_ of _extraFieldDescriptors_, do
                1. Append _desc_.[[Property]] to _result_.
            1. Return CreateArrayFromList(_result_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.mergefields">
          <h1>Temporal.Calendar.prototype.mergeFields ( _fields_, _additionalFields_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.mergefields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _fieldsCopy_ be ? SnapshotOwnProperties(? ToObject(_fields_), *null*, « », « *undefined* »).
            1. Let _additionalFieldsCopy_ be ? SnapshotOwnProperties(? ToObject(_additionalFields_), *null*, « », « *undefined* »).
            1. NOTE: Every property of _fieldsCopy_ and _additionalFieldsCopy_ is an enumerable data property with non-*undefined* value, but some property keys may be Symbols.
            1. Let _additionalKeys_ be ! _additionalFieldsCopy_.[[OwnPropertyKeys]]().
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _overriddenKeys_ be ISOFieldKeysToIgnore(_additionalKeys_).
            1. Else,
              1. Let _overriddenKeys_ be CalendarFieldKeysToIgnore(_calendar_, _additionalKeys_).
            1. Let _merged_ be OrdinaryObjectCreate(*null*).
            1. NOTE: The following steps ensure that property iteration order of _merged_ matches that of _fields_ as modified by omitting overridden properties and appending non-overlapping properties from _additionalFields_ in iteration order.
            1. Let _fieldsKeys_ be ! _fieldsCopy_.[[OwnPropertyKeys]]().
            1. For each element _key_ of _fieldsKeys_, do
              1. Let _propValue_ be *undefined*.
              1. If _overriddenKeys_ contains _key_, then
                1. Set _propValue_ to ! Get(_additionalFieldsCopy_, _key_).
              1. Else,
                1. Set _propValue_ to ! Get(_fieldsCopy_, _key_).
              1. If _propValue_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_merged_, _key_, _propValue_).
            1. Perform ! CopyDataProperties(_merged_, _additionalFieldsCopy_, « »).
            1. Return _merged_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-duration-prototype-object">
        <h1>Properties of the Temporal.Duration Prototype Object</h1>
        <emu-clause id="sup-temporal.duration.prototype.tolocalestring">
          <h1>Temporal.Duration.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <emu-note type="editor">
            <p>
              This function is currently not specified.
              See <a href="https://tc39.es/proposal-intl-duration-format/">the Intl.DurationFormat proposal</a>.
            </p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-instant-prototype-object">
        <h1>Properties of the Temporal.Instant Prototype Object</h1>
        <emu-clause id="sup-temporal.instant.prototype.tolocalestring">
          <h1>Temporal.Instant.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.instant.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _instant_ be the *this* value.
            1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
            1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~any~, ~all~).
            1. Return ? FormatDateTime(_dateFormat_, _instant_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaindate-prototype-object">
        <h1>Properties of the Temporal.PlainDate Prototype Object</h1>
        <emu-clause id="sup-temporal.plaindate.prototype.tolocalestring">
          <h1>Temporal.PlainDate.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaindate.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _temporalDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
            1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~date~, ~date~).
            1. Return ? FormatDateTime(_dateFormat_, _temporalDate_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindate.prototype.era">
          <h1>get Temporal.PlainDate.prototype.era</h1>
          <p>
            `Temporal.PlainDate.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
            1. Let _calendar_ be _plainDate_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainDate_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindate.prototype.erayear">
          <h1>get Temporal.PlainDate.prototype.eraYear</h1>
          <p>
            `Temporal.PlainDate.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
            1. Let _calendar_ be _plainDate_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainDate_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaindatetime-prototype-object">
        <h1>Properties of the Temporal.PlainDateTime Prototype Object</h1>
        <emu-clause id="sup-temporal.plaindatetime.prototype.tolocalestring">
          <h1>Temporal.PlainDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaindatetime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _dateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
            1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~any~, ~all~).
            1. Return ? FormatDateTime(_dateFormat_, _dateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindatetime.prototype.era">
          <h1>get Temporal.PlainDateTime.prototype.era</h1>
          <p>
            `Temporal.PlainDate.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
            1. Let _calendar_ be _plainDateTime_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindatetime.prototype.erayear">
          <h1>get Temporal.PlainDateTime.prototype.eraYear</h1>
          <p>
            `Temporal.PlainDateTime.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
            1. Let _calendar_ be _plainDateTime_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plainmonthday-prototype-object">
        <h1>Properties of the Temporal.PlainMonthDay Prototype Object</h1>
          <emu-clause id="sup-temporal.plainmonthday.prototype.tolocalestring">
          <h1>Temporal.PlainMonthDay.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plainmonthday.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _monthDay_ be the *this* value.
            1. Perform ? RequireInternalSlot(_monthDay_, [[InitializedTemporalMonthDay]]).
            1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~date~, ~date~).
            1. Return ? FormatDateTime(_dateFormat_, _monthDay_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaintime-prototype-object">
        <h1>Properties of the Temporal.PlainTime Prototype Object</h1>
        <emu-clause id="sup-temporal.plaintime.prototype.tolocalestring">
          <h1>Temporal.PlainTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaintime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _temporalTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
            1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~time~, ~time~).
            1. Return ? FormatDateTime(_dateFormat_, _temporalTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plainyearmonth-prototype-object">
        <h1>Properties of the Temporal.PlainYearMonth Prototype Object</h1>
        <emu-clause id="sup-temporal.plainyearmonth.prototype.tolocalestring">
          <h1>Temporal.PlainYearMonth.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plainyearmonth.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _yearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_yearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~date~, ~date~).
            1. Return ? FormatDateTime(_dateFormat_, _yearMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plainyearmonth.prototype.era">
          <h1>get Temporal.PlainYearMonth.prototype.era</h1>
          <p>
            `Temporal.PlainYearMonth.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainYearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainYearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _calendar_ be _plainYearMonth_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainYearMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plainyearmonth.prototype.erayear">
          <h1>get Temporal.PlainYearMonth.prototype.eraYear</h1>
          <p>
            `Temporal.PlainYearMonth.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainYearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainYearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _calendar_ be _plainYearMonth_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainYearMonth_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-zoneddatetime-prototype-object">
        <h1>Properties of the Temporal.ZonedDateTime Prototype Object</h1>
        <emu-clause id="sup-temporal.zoneddatetime.prototype.tolocalestring">
          <h1>Temporal.ZonedDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.zoneddatetime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _timeZone_ be ? ToTemporalTimeZoneIdentifier(_zonedDateTime_.[[TimeZone]]).
            1. Let _timeZoneParseResult_ be ? ParseTimeZoneIdentifier(_timeZone_).
            1. If _timeZoneParseResult_.[[OffsetMinutes]] is not ~empty~, throw a *RangeError* exception.
            1. Let _timeZoneIdentifierRecord_ be GetAvailableNamedTimeZoneIdentifier(_timeZone_).
            1. If _timeZoneIdentifierRecord_ is ~empty~, throw a *RangeError* exception.
            1. Set _timeZone_ to _timeZoneIdentifierRecord_.[[Identifier]].
            1. Let _dateTimeFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~any~, ~all~, _timeZone_).
            1. Let _calendar_ be ? ToTemporalCalendarIdentifier(_zonedDateTime_.[[Calendar]]).
            1. If _calendar_ is not *"iso8601"* and not equal to _dateTimeFormat_.[[Calendar]], then
              1. Throw a *RangeError* exception.
            1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
            1. Return ? FormatDateTime(_dateTimeFormat_, _instant_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.zoneddatetime.prototype.era">
          <h1>get Temporal.ZonedDateTime.prototype.era</h1>
          <p>
            `Temporal.ZonedDateTime.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
            1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
            1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], « ~get-offset-nanoseconds-for~ »).
            1. Let _plainDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
            1. Return ? CalendarEra(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.zoneddatetime.prototype.erayear">
          <h1>get Temporal.ZonedDateTime.prototype.eraYear</h1>
          <p>
            `Temporal.ZonedDateTime.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
            1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
            1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], « ~get-offset-nanoseconds-for~ »).
            1. Let _plainDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
            1. Return ? CalendarEraYear(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>
