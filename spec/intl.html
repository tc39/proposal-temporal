<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-intl">
  <h1>Amendments to the ECMAScript® 2023 Internationalization API Specification</h1>

  <emu-note type="editor">
    <p>
      This section lists amendments which must be made to <a href="https://tc39.es/ecma402/">ECMA-402, the ECMAScript® 2023 Internationalization API Specification</a>.
      Text to be added is marked <ins>like this</ins>, and text to be deleted is marked <del>like this</del>.
    </p>
    <p>
      This text is based on top of the ECMA-402 spec text from commit <a href="https://github.com/tc39/ecma402/commit/eb81befe8b739f976a3d6e68ec567302c4e217f0">eb81befe8b739f976a3d6e68ec567302c4e217f0</a>.
    </p>
  </emu-note>

  <emu-clause id="sup-case-sensitivity-and-case-mapping">
    <h1><a href="https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping">Case Sensitivity and Case Mapping</a></h1>

    <emu-note type="editor">
      <p>These definitions are moved into ECMA-262.</p>
    </emu-note>

    <p>
      The String values used to identify locales, currencies, scripts, and time zones are interpreted in an ASCII-case-insensitive manner, treating the code units 0x0041 through 0x005A (corresponding to Unicode characters LATIN CAPITAL LETTER A through LATIN CAPITAL LETTER Z) as equivalent to the corresponding code units 0x0061 through 0x007A (corresponding to Unicode characters LATIN SMALL LETTER A through LATIN SMALL LETTER Z), both inclusive. No other case folding equivalences are applied.
    </p>
    <emu-note>
      For example, *"ß"* (U+00DF) must not match or be mapped to *"SS"* (U+0053, U+0053). *"ı"* (U+0131) must not match or be mapped to *"I"* (U+0049).
    </emu-note>
    <del class="block">
      <p>
        The <em>ASCII-uppercase</em> of a String value _S_ is the String value derived from _S_ by replacing each occurrence of an ASCII lowercase letter code unit (0x0061 through 0x007A, inclusive) with the corresponding ASCII uppercase letter code unit (0x0041 through 0x005A, inclusive) while preserving all other code units.
      </p>
      <p>
        The <em>ASCII-lowercase</em> of a String value _S_ is the String value derived from _S_ by replacing each occurrence of an ASCII uppercase letter code unit (0x0041 through 0x005A, inclusive) with the corresponding ASCII lowercase letter code unit (0x0061 through 0x007A, inclusive) while preserving all other code units.
      </p>
      <p>
        A String value _A_ is an <em>ASCII-case-insensitive match</em> for String value _B_ if the ASCII-uppercase of _A_ is exactly the same sequence of code units as the ASCII-uppercase of _B_. A sequence of Unicode code points _A_ is an ASCII-case-insensitive match for _B_ if _B_ is an ASCII-case-insensitive match for ! CodePointsToString(_A_).
      </p>
    </del>
  </emu-clause>

  <emu-clause id="sup-time-zone-names">
    <h1><a href="https://tc39.es/ecma402/#sec-time-zone-names">Time Zone Names</a></h1>

    <ins class="block">
      <p>
        <emu-xref href="#sec-time-zone-names"></emu-xref> defines a set of abstract operations concerning the names of supported time zones.
        This section introduces additional requirements on these operations for implementations.
      </p>
    </ins>

    <p>
      The ECMAScript 2023 Internationalization API Specification identifies time zones using the Zone and Link names of the IANA Time Zone Database. Their canonical form is the corresponding Zone name in the casing used in the IANA Time Zone Database except as specifically overridden by CanonicalizeTimeZoneName.
    </p>

    <p>
      A conforming implementation must recognize *"UTC"* and all other Zone and Link names (and <strong>only</strong> such names), and use best available current and historical information about their offsets from UTC and their daylight saving time rules in calculations. However, the set of combinations of time zone name and language tag for which localized time zone names are available is implementation dependent.
    </p>

    <del class="block">
      <emu-clause id="sup-isvalidtimezonename">
        <h1><a href="https://tc39.es/ecma402/#sec-isvalidtimezonename">IsValidTimeZoneName</a> ( _timeZone_ )</h1>

        <p>
          The abstract operation IsValidTimeZoneName takes argument _timeZone_, a String value, and verifies that it represents a valid Zone or Link name of the IANA Time Zone Database.
        </p>

        <emu-alg>
          1. If one of the Zone or Link names of the IANA Time Zone Database is an ASCII-case-insensitive match of _timeZone_, return *true*.
          1. If _timeZone_ is an ASCII-case-insensitive match of *"UTC"*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>
    </del>

    <emu-clause id="sup-canonicalizetimezonename" type="abstract operation">
      <h1>
        CanonicalizeTimeZoneName (
          _timeZone_: a String value that is <del>a valid</del><ins>an available</ins> time zone name as verified by <del>IsValidTimeZoneName</del><ins>IsAvailableTimeZoneName</ins>,
        )
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the canonical and case-regularized form of _timeZone_.</dd>
        <dt>redefinition</dt>
        <dd>true</dd>
      </dl>

      <emu-alg>
        1. Let _ianaTimeZone_ be the String value of the Zone or Link name of the IANA Time Zone Database that is an ASCII-case-insensitive match of _timeZone_.
        1. If _ianaTimeZone_ is a Link name, let _ianaTimeZone_ be the String value of the corresponding Zone name as specified in the file <code>backward</code> of the IANA Time Zone Database.
        1. If _ianaTimeZone_ is *"Etc/UTC"* or *"Etc/GMT"*, return *"UTC"*.
        1. Return _ianaTimeZone_.
      </emu-alg>

      <ins class="block">
        <p>This definition supersedes the definition provided in <emu-xref href="#sec-canonicalizetimezonename"></emu-xref>.</p>
      </ins>
    </emu-clause>

    <ins class="block">
      <emu-clause id="sup-availabletimezones" type="implementation-defined abstract operation">
        <h1>
          AvailableTimeZones (
          ): a List of Strings
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>The returned List is a sorted List of supported Zone and Link names in the IANA Time Zone Database.</dd>
          <dt>redefinition</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Let _timeZones_ be a List containing the String value of each Zone or Link name in the IANA Time Zone Database that is supported by the implementation.
          1. Assert: _timeZones_ contains *"UTC"*.
          1. Assert: _timeZones_ does not contain any element that does not identify a Zone or Link name in the IANA Time Zone Database.
          1. Return SortStringListByCodeUnit(_timeZones_).
        </emu-alg>

        <p>This definition supersedes the definition provided in <emu-xref href="#sec-availabletimezones"></emu-xref>.</p>
      </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-abstract-operations">
    <h1><a href="https://tc39.es/ecma402/#sec-abstract-operations">Abstract Operations</a></h1>

    <emu-note type="editor">
      <p>In this section, some abstract operations that manipulate options objects are to be moved from ECMA-402 into ECMA-262.</p>
    </emu-note>

    <del class="block">
      <emu-clause id="sec-getoptionsobject-deleted">
        <h1><a href="https://tc39.es/ecma402/#sec-getoptionsobject">GetOptionsObject</a> ( _options_ )</h1>
        <p>
          The abstract operation GetOptionsObject returns an Object suitable for use with GetOption, either _options_ itself or a default empty Object.
          It throws a TypeError if _options_ is not undefined and not an Object.
        </p>
        <emu-alg>
          1. If _options_ is *undefined*, then
            1. Return OrdinaryObjectCreate(*null*).
          1. If Type(_options_) is Object, then
            1. Return _options_.
          1. Throw a *TypeError* exception.
        </emu-alg>
      </emu-clause>
    </del>

    <del class="block">
      <!-- https://tc39.es/ecma402/#sec-getoption -->
      <emu-clause id="sec-getoption-deleted" type="abstract operation">
        <h1>
          GetOption (
            _options_: an Object,
            _property_: a property key,
            _type_: *"boolean"*, *"number"*, or *"string"*,
            _values_: *undefined* or a List of ECMAScript language values,
            _default_: ~required~ or an ECMAScript language value,
          )
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It extracts the value of the specified property of _options_, converts it to the required _type_, checks whether it is allowed by _values_ if _values_ is not *undefined*, and substitutes _default_ if the value is *undefined*.</dd>
          <dt>redefinition</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Let _value_ be ? Get(_options_, _property_).
          1. If _value_ is *undefined*, then
            1. If _default_ is ~required~, throw a *RangeError* exception.
            1. Return _default_.
          1. If _type_ is *"boolean"*, then
            1. Set _value_ to ToBoolean(_value_).
          1. Else if _type_ is *"number"*, then
            1. Set _value_ to ? ToNumber(_value_).
            1. If _value_ is *NaN*, throw a *RangeError* exception.
          1. Else,
            1. Assert: _type_ is *"string"*.
            1. Set _value_ to ? ToString(_value_).
          1. If _values_ is not *undefined* and _values_ does not contain an element equal to _value_, throw a *RangeError* exception.
          1. Return _value_.
        </emu-alg>
      </emu-clause>
    </del>
  </emu-clause>

  <emu-clause id="sec-datetimeformat-abstracts">
    <h1><a href="https://tc39.es/ecma402/#sec-datetimeformat-abstracts">Abstract Operations For DateTimeFormat Objects</a></h1>

    <emu-clause id="sec-temporal-initializedatetimeformat" aoid="InitializeDateTimeFormat">
      <h1>InitializeDateTimeFormat ( _dateTimeFormat_, _locales_, _options_ )</h1>

      <p>
        The abstract operation InitializeDateTimeFormat accepts the arguments _dateTimeFormat_ (which must be an object), _locales_, and _options_. It initializes _dateTimeFormat_ as a DateTimeFormat object. This abstract operation functions as follows:
      </p>

      <p>
        The following algorithm refers to the `type` nonterminal from <a href="https://www.unicode.org/reports/tr35/#Unicode_locale_identifier">UTS 35's Unicode Locale Identifier grammar</a>.
      </p>

      <emu-alg>
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. <del>Set _options_ to ? ToDateTimeOptions(_options_, *"any"*, *"date"*).</del>
        1. Let _opt_ be a new Record.
        1. Let _matcher_ be ? GetOption(_options_, *"localeMatcher"*, *"string"*, « *"lookup"*, *"best fit"* », *"best fit"*).
        1. Set _opt_.[[localeMatcher]] to _matcher_.
        1. Let _calendar_ be ? GetOption(_options_, *"calendar"*, *"string"*, *undefined*, *undefined*).
        1. If _calendar_ is not *undefined*, then
          1. If _calendar_ does not match the Unicode Locale Identifier `type` nonterminal, throw a *RangeError* exception.
        1. Set _opt_.[[ca]] to _calendar_.
        1. Let _numberingSystem_ be ? GetOption(_options_, *"numberingSystem"*, *"string"*, *undefined*, *undefined*).
        1. If _numberingSystem_ is not *undefined*, then
          1. If _numberingSystem_ does not match the Unicode Locale Identifier `type` nonterminal, throw a *RangeError* exception.
        1. Set _opt_.[[nu]] to _numberingSystem_.
        1. Let _hour12_ be ? GetOption(_options_, *"hour12"*, *"boolean"*, *undefined*, *undefined*).
        1. Let _hourCycle_ be ? GetOption(_options_, *"hourCycle"*, *"string"*, « *"h11"*, *"h12"*, *"h23"*, *"h24"* », *undefined*).
        1. If _hour12_ is not *undefined*, then
          1. Set _hourCycle_ to *null*.
        1. Set _opt_.[[hc]] to _hourCycle_.
        1. Let _localeData_ be %DateTimeFormat%.[[LocaleData]].
        1. Let _r_ be ResolveLocale(%DateTimeFormat%.[[AvailableLocales]], _requestedLocales_, _opt_, %DateTimeFormat%.[[RelevantExtensionKeys]], _localeData_).
        1. Set _dateTimeFormat_.[[Locale]] to _r_.[[locale]].
        1. Let _resolvedCalendar_ be _r_.[[ca]].
        1. Set _dateTimeFormat_.[[Calendar]] to _resolvedCalendar_.
        1. Set _dateTimeFormat_.[[NumberingSystem]] to _r_.[[nu]].
        1. Let _dataLocale_ be _r_.[[dataLocale]].
        1. Let _dataLocaleData_ be _localeData_.[[&lt;_dataLocale_&gt;]].
        1. Let _hcDefault_ be _dataLocaleData_.[[hourCycle]].
        1. If _hour12_ is *true*, then
          1. If _hcDefault_ is *"h11"* or *"h23"*, let _hc_ be *"h11"*. Otherwise, let _hc_ be *"h12"*.
        1. Else if _hour12_ is *false*, then
          1. If _hcDefault_ is *"h11"* or *"h23"*, let _hc_ be *"h23"*. Otherwise, let _hc_ be *"h24"*.
        1. Else,
          1. Assert: _hour12_ is *undefined*.
          1. Let _hc_ be _r_.[[hc]].
          1. If _hc_ is *null*, set _hc_ to _hcDefault_.
        1. <del>Set _dateTimeFormat_.[[HourCycle]] to _hc_.</del>
        1. Let _timeZone_ be ? Get(_options_, *"timeZone"*).
        1. If _timeZone_ is *undefined*, then
          1. Set _timeZone_ to DefaultTimeZone().
        1. Else,
          1. Set _timeZone_ to ? ToString(_timeZone_).
          1. If <del>the result of IsValidTimeZoneName(_timeZone_)</del><ins>IsAvailableTimeZoneName(_timeZone_)</ins> is *false*, then
            1. Throw a *RangeError* exception.
          1. Set _timeZone_ to CanonicalizeTimeZoneName(_timeZone_).
        1. Set _dateTimeFormat_.[[TimeZone]] to _timeZone_.
        1. Let _formatOptions_ be a new Record.
        1. Set _formatOptions_.[[hourCycle]] to _hc_.
        1. Let _hasExplicitFormatComponents_ be *false*.
        1. For each row of <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, in table order, do
          1. Let _prop_ be the name given in the Property column of the row.
          1. If _prop_ is *"fractionalSecondDigits"*, then
            1. Let _value_ be ? GetNumberOption(_options_, *"fractionalSecondDigits"*, 1, 3, *undefined*).
          1. Else,
            1. Let _values_ be a List whose elements are the strings given in the Values column of the row.
            1. Let _value_ be ? GetOption(_options_, _prop_, *"string"*, _values_, *undefined*).
          1. Set _formatOptions_.[[&lt;_prop_&gt;]] to _value_.
          1. If _value_ is not *undefined*, then
            1. Set _hasExplicitFormatComponents_ to *true*.
        1. Let _matcher_ be ? GetOption(_options_, *"formatMatcher"*, *"string"*, « *"basic"*, *"best fit"* », *"best fit"*).
        1. Let _dateStyle_ be ? GetOption(_options_, *"dateStyle"*, *"string"*, « *"full"*, *"long"*, *"medium"*, *"short"* », *undefined*).
        1. Set _dateTimeFormat_.[[DateStyle]] to _dateStyle_.
        1. Let _timeStyle_ be ? GetOption(_options_, *"timeStyle"*, *"string"*, « *"full"*, *"long"*, *"medium"*, *"short"* », *undefined*).
        1. Set _dateTimeFormat_.[[TimeStyle]] to _timeStyle_.
        1. <del>If _dateStyle_ is not *undefined* or _timeStyle_ is not *undefined*, then</del>
          1. <del>If _hasExplicitFormatComponents_ is *true*, then</del>
            1. <del>Throw a *TypeError* exception.</del>
          1. <del>Let _styles_ be _dataLocaleData_.[[styles]].[[&lt;_resolvedCalendar_&gt;]].</del>
          1. <del>Let _bestFormat_ be DateTimeStyleFormat(_dateStyle_, _timeStyle_, _styles_).</del>
        1. <del>Else,</del>
          1. <del>Let _formats_ be _dataLocaleData_.[[formats]].[[&lt;_resolvedCalendar_&gt;]].</del>
          1. <del>If _matcher_ is *"basic"*, then</del>
            1. <del>Let _bestFormat_ be BasicFormatMatcher(_formatOptions_, _formats_).</del>
          1. <del>Else,</del>
            1. <del>Let _bestFormat_ be BestFitFormatMatcher(_formatOptions_, _formats_).</del>
        1. <del>For each row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, in table order, do</del>
          1. <del>Let _prop_ be the name given in the Property column of the row.</del>
          1. <del>If _bestFormat_ has a field [[&lt;_prop_&gt;]], then</del>
            1. <del>Let _p_ be _bestFormat_.[[&lt;_prop_&gt;]].</del>
            1. <del>Set _dateTimeFormat_'s internal slot whose name is the Internal Slot column of the row to _p_.</del>
        1. <del>If _dateTimeFormat_.[[Hour]] is *undefined*, then</del>
          1. <del>Set _dateTimeFormat_.[[HourCycle]] to *undefined*.</del>
        1. <del>If _dateTimeFormat_.[[HourCycle]] is *"h11"* or *"h12"*, then</del>
          1. <del>Let _pattern_ be _bestFormat_.[[pattern12]].</del>
          1. <del>Let _rangePatterns_ be _bestFormat_.[[rangePatterns12]].</del>
        1. <del>Else,</del>
          1. <del>Let _pattern_ be _bestFormat_.[[pattern]].</del>
          1. <del>Let _rangePatterns_ be _bestFormat_.[[rangePatterns]].</del>
        1. <ins>Let _expandedOptions_ be a copy of _formatOptions_.</ins>
        1. <ins>Let _needDefaults_ be *true*.</ins>
        1. <ins>For each element _field_ of « *"weekday"*, *"year"*, *"month"*, *"day"*, *"hour"*, *"minute"*, *"second"* » in List order, do</ins>
          1. <ins>If _expandedOptions_.[[&lt;_field_&gt;]] is not *undefined*, then</ins>
            1. <ins>Set _needDefaults_ to *false*.</ins>
        1. <ins>If _needDefaults_ is *true*, then</ins>
          1. <ins>For each element _field_ of « *"year"*, *"month"*, *"day"*, *"hour"*, *"minute"*, *"second"* » in List order, do</ins>
            1. <ins>Set _expandedOptions_.[[&lt;_field_&gt;]] to *"numeric"*.</ins>
        1. <ins>Let _bestFormat_ be GetDateTimeFormatPattern(_dateStyle_, _timeStyle_, _matcher_, _expandedOptions_, _dataLocaleData_, _hc_, _resolvedCalendar_, _hasExplicitFormatComponents_).</ins>
        1. Set _dateTimeFormat_.[[Pattern]] to <del>_pattern_</del><ins>_bestFormat_.[[pattern]]</ins>.
        1. Set _dateTimeFormat_.[[RangePatterns]] to <del>_rangePatterns_</del><ins>_bestFormat_.[[rangePatterns]]</ins>.
        1. <ins>For each row in <emu-xref href="#table-temporal-patterns"></emu-xref>, except the header row, in table order, do</ins>
          1. <ins>Let _limitedOptions_ be a new Record.</ins>
          1. <ins>Let _needDefaults_ be *true*.</ins>
          1. <ins>Let _fields_ be the list of fields in the Supported fields column of the row.</ins>
          1. <ins>For each field _field_ of _formatOptions_, do</ins>
            1. <ins>If _field_ is in _fields_, then</ins>
              1. <ins>Set _needDefaults_ to *false*.</ins>
              1. <ins>Set _limitedOptions_.[[&lt;_field_&gt;]] to _formatOptions_.[[&lt;_field_&gt;]].</ins>
          1. <ins>If _needDefaults_ is *true*, then</ins>
            1. <ins>Let _defaultFields_ be the list of fields in the Default fields column of the row.</ins>
            1. <ins>For each element _field_ of _defaultFields_, do</ins>
              1. <ins>If _field_ is *"timeZoneName"*, then</ins>
                1. <ins>Let _defaultValue_ be *"short"*.</ins>
              1. <ins>Else,</ins>
                1. <ins>Let _defaultValue_ be *"numeric"*.</ins>
              1. <ins>Set _limitedOptions_.[[&lt;_field_&gt;]] to _defaultValue_.</ins>
          1. <ins>Let _bestFormat_ be GetDateTimeFormatPattern(_dateStyle_, _timeStyle_, _matcher_, _limitedOptions_, _dataLocaleData_, _hc_, _resolvedCalendar_, _hasExplicitFormatComponents_).</ins>
          1. <ins>If _bestFormat_ does not have any fields that are in _fields_, then</ins>
            1. <ins>Set _bestFormat_ to *null*.</ins>
          1. <ins>Set _dateTimeFormat_'s internal slot whose name is the Pattern column of the row to _bestFormat_.</ins>
        1. Return _dateTimeFormat_.
      </emu-alg>

      <ins class="block">
      <emu-table id="table-temporal-patterns">
        <emu-caption>Supported fields for Temporal patterns</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Pattern</th>
              <th>Supported fields</th>
              <th>Default fields</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>[[TemporalPlainDatePattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]]</td>
              <td>[[year]], [[month]], [[day]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainYearMonthPattern]]</th>
              <td>[[era]], [[year]], [[month]]</td>
              <td>[[year]], [[month]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainMonthDayPattern]]</th>
              <td>[[month]], [[day]]</td>
              <td>[[month]], [[day]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainTimePattern]]</th>
              <td>[[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]]</td>
              <td>[[hour]], [[minute]], [[second]]</td>
            </tr>
            <tr>
              <th>[[TemporalPlainDateTimePattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]]</td>
              <td>[[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]]</td>
            </tr>
            <tr>
              <th>[[TemporalInstantPattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]]</td>
              <td>[[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]]</td>
            </tr>
            <tr>
              <th>[[TemporalZonedDateTimePattern]]</th>
              <td>[[weekday]], [[era]], [[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[dayPeriod]], [[fractionalSecondDigits]], [[timeZoneName]]</td>
              <td>[[year]], [[month]], [[day]], [[hour]], [[minute]], [[second]], [[timeZoneName]]</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
      </ins>
    </emu-clause>

    <emu-clause id="sec-datetime-format-functions">
      <h1>DateTime Format Functions</h1>

      <p>A DateTime format function is an anonymous built-in function that has a [[DateTimeFormat]] internal slot.</p>
      <p>When a DateTime format function _F_ is called with optional argument _date_, the following steps are taken:</p>

      <emu-alg>
        1. Let _dtf_ be _F_.[[DateTimeFormat]].
        1. Assert: Type(_dtf_) is Object and _dtf_ has an [[InitializedDateTimeFormat]] internal slot.
        1. <del>If _date_ is not provided or is *undefined*, then</del>
          1. <del>Let _x_ be ! Call(%Date.now%, *undefined*).</del>
        1. <del>Else,</del>
          1. <del>Let _x_ be ? ToNumber(_date_).</del>
        1. Return ? FormatDateTime(_dtf_, <del>_x_</del><ins>_date_</ins>).
      </emu-alg>

      <p>
        The *"length"* property of a DateTime format function is 1.
      </p>
    </emu-clause>

    <emu-clause id="sec-formatdatetimepattern" aoid="FormatDateTimePattern">
      <h1>FormatDateTimePattern ( _dateTimeFormat_, <ins>_pattern_</ins>, _patternParts_, <del>_x_</del><ins>_epochNanoseconds_</ins>, _rangeFormatOptions_ )</h1>

      <p>
      The FormatDateTimePattern abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat), <ins>_pattern_ (which is a Record of the type contained by the %DateTimeFormat%.[[LocaleData]].[[<_locale_>]].[[formats]].[[<_calendar_>]] List as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>),</ins> _patternParts_ (which is a list of Records as returned by PartitionPattern), <del>_x_</del><ins>_epochNanoseconds_</ins> (which must be a <del>Number</del><ins>BigInt</ins> value), and _rangeFormatOptions_ (which is a range pattern Record as used in [[rangePattern]] or *undefined*), interprets _x_ as a time value as specified in ES2023, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>, and creates the corresponding parts according _pattern_ and to the effective locale and the formatting options of _dateTimeFormat_ and _rangeFormatOptions_. The following steps are taken:
      </p>

      <emu-alg>
        1. <del>Let _x_ be TimeClip(_x_).</del>
        1. <del>If _x_ is *NaN*, throw a *RangeError* exception.</del>
        1. Let _locale_ be _dateTimeFormat_.[[Locale]].
        1. Let _nfOptions_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_nfOptions_, *"useGrouping"*, *false*).
        1. Let _nf_ be ? Construct(%NumberFormat%, &laquo; _locale_, _nfOptions_ &raquo;).
        1. Let _nf2Options_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_nf2Options_, *"minimumIntegerDigits"*, 2).
        1. Perform ! CreateDataPropertyOrThrow(_nf2Options_, *"useGrouping"*, *false*).
        1. Let _nf2_ be ? Construct(%NumberFormat%, &laquo; _locale_, _nf2Options_ &raquo;).
        1. Let _fractionalSecondDigits_ be _dateTimeFormat_.[[FractionalSecondDigits]].
        1. If _fractionalSecondDigits_ is not *undefined*, then
          1. Let _nf3Options_ be OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_nf3Options_, *"minimumIntegerDigits"*, _fractionalSecondDigits_).
          1. Perform ! CreateDataPropertyOrThrow(_nf3Options_, *"useGrouping"*, *false*).
          1. Let _nf3_ be ? Construct(%NumberFormat%, &laquo; _locale_, _nf3Options_ &raquo;).
        1. Let _tm_ be ToLocalTime(<del>_x_</del><ins>_epochNanoseconds_</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _result_ be a new empty List.
        1. For each Record { [[Type]], [[Value]] } _patternPart_ in _patternParts_, do
          1. Let _p_ be _patternPart_.[[Type]].
          1. If _p_ is *"literal"*, then
            1. Append a new Record { [[Type]]: *"literal"*, [[Value]]: _patternPart_.[[Value]] } as the last element of the list _result_.
          1. Else if _p_ is equal to *"fractionalSecondDigits"*, then
            1. Let _v_ be _tm_.[[Millisecond]].
            1. Let _v_ be floor(_v_ &times; 10<sup>( _fractionalSecondDigits_ - 3 )</sup>).
            1. Let _fv_ be FormatNumeric(_nf3_, _v_).
            1. Append a new Record { [[Type]]: *"fractionalSecond"*, [[Value]]: _fv_ } as the last element of _result_.
          1. Else if _p_ is equal to *"dayPeriod"*, then
            1. Let _f_ be the value of _dateTimeFormat_'s internal slot whose name is the Internal Slot column of the matching row.
            1. Let _fv_ be a String value representing the day period of _tm_ in the form given by _f_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_.
            1. Append a new Record { [[Type]]: _p_, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"timeZoneName"*, then
            1. Let _f_ be _dateTimeFormat_.[[TimeZoneName]].
            1. Let _v_ be _dateTimeFormat_.[[TimeZone]].
            1. Let _fv_ be a String value representing _v_ in the form given by _f_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_. The String value may also depend on the value of the [[InDST]] field of _tm_ if _f_ is *"short"*, *"long"*, *"shortOffset"*, or *"longOffset"*. If the implementation does not have a localized representation of _f_, then use the String value of _v_ itself.
            1. Append a new Record { [[Type]]: _p_, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ matches a Property column of the row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, then
            1. If _rangeFormatOptions_ is not *undefined*, let _f_ be the value of _rangeFormatOptions_'s field whose name matches _p_.
            1. Else, let _f_ be <del>the value of _dateTimeFormat_'s internal slot whose name is the Internal Slot column of the matching row</del><ins>_pattern_.[[&lt;_p_&gt;]]</ins>.
            1. Let _v_ be the value of _tm_'s field whose name is the Internal Slot column of the matching row.
            1. If _p_ is *"year"* and _v_ &le; 0, let _v_ be 1 - _v_.
            1. If _p_ is *"month"*, increase _v_ by 1.
            1. If _p_ is *"hour"* and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h11"* or *"h12"*, then
              1. Let _v_ be _v_ modulo 12.
              1. If _v_ is 0 and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h12"*, let _v_ be 12.
            1. If _p_ is *"hour"* and <del>_dateTimeFormat_.[[HourCycle]]</del><ins>_pattern_.[[hourCycle]]</ins> is *"h24"*, then
              1. If _v_ is 0, let _v_ be 24.
            1. If _f_ is *"numeric"*, then
              1. Let _fv_ be FormatNumeric(_nf_, _v_).
            1. Else if _f_ is *"2-digit"*, then
              1. Let _fv_ be FormatNumeric(_nf2_, _v_).
              1. If the *"length"* property of _fv_ is greater than 2, let _fv_ be the substring of _fv_ containing the last two characters.
            1. Else if _f_ is *"narrow"*, *"short"*, or *"long"*, then let _fv_ be a String value representing _v_ in the form given by _f_; the String value depends upon the implementation and the effective locale and calendar of _dateTimeFormat_. If _p_ is *"month"* and _rangeFormatOptions_ is *undefined*, then the String value may also depend on whether <del>_dateTimeFormat_.[[Day]]</del><ins>_pattern_.[[day]]</ins> is *undefined*. If _p_ is *"month"* and _rangeFormatOptions_ is not *undefined*, then the String value may also depend on whether _rangeFormatOptions_.[[day]] is *undefined*. If _p_ is *"timeZoneName"*, then the String value may also depend on the value of the [[InDST]] field of _tm_. If _p_ is *"era"* and _rangeFormatOptions_ is *undefined*, then the String value may also depend on whether <del>_dateTimeFormat_.[[Era]]</del><ins>_pattern_.[[day]]</ins> is *undefined*. If _p_ is *"era"* and _rangeFormatOptions_ is not *undefined*, then the String value may also depend on whether _rangeFormatOptions_.[[era]] is *undefined*. If the implementation does not have a localized representation of _f_, then use _f_ itself.
            1. Append a new Record { [[Type]]: _p_, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"ampm"*, then
            1. Let _v_ be _tm_.[[Hour]].
            1. If _v_ is greater than 11, then
              1. Let _fv_ be an implementation and locale dependent String value representing *"post meridiem"*.
            1. Else,
              1. Let _fv_ be an implementation and locale dependent String value representing *"ante meridiem"*.
            1. Append a new Record { [[Type]]: *"dayPeriod"*, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"relatedYear"*, then
            1. Let _v_ be _tm_.[[RelatedYear]].
            1. Let _fv_ be FormatNumeric(_nf_, _v_).
            1. Append a new Record { [[Type]]: *"relatedYear"*, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"yearName"*, then
            1. Let _v_ be _tm_.[[YearName]].
            1. Let _fv_ be an implementation and locale dependent String value representing _v_.
            1. Append a new Record { [[Type]]: *"yearName"*, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else,
            1. Let _unknown_ be an implementation-, locale-, and numbering system-dependent String based on <del>_x_</del><ins>_epochNanoseconds_</ins> and _p_.
            1. Append a new Record { [[Type]]: *"unknown"*, [[Value]]: _unknown_ } as the last element of _result_.
        1. Return _result_.
      </emu-alg>

      <emu-note>
        It is recommended that implementations use the locale and calendar dependent strings provided by the Common Locale Data Repository (available at <a href="http://cldr.unicode.org">http://cldr.unicode.org</a>), and use CLDR *"abbreviated"* strings for DateTimeFormat *"short"* strings, and CLDR *"wide"* strings for DateTimeFormat *"long"* strings.
      </emu-note>

      <emu-note>
        It is recommended that implementations use the time zone information of the IANA Time Zone Database.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-partitiondatetimepattern" aoid="PartitionDateTimePattern">
      <h1>PartitionDateTimePattern ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The PartitionDateTimePattern abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), <del>interprets _x_ as a time value as specified in ES2023, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>,</del> and creates the corresponding parts according to the effective locale and the formatting options of _dateTimeFormat_. The following steps are taken:
      </p>

      <emu-alg>
        1. <ins>Let _x_ be ? HandleDateTimeValue(_dateTimeFormat_, _x_).</ins>
        1. Let _patternParts_ be PartitionPattern(<del>_dateTimeFormat_.[[Pattern]]</del><ins>_x_.[[pattern]]</ins>).
        1. Let _result_ be ? FormatDateTimePattern(_dateTimeFormat_, <ins>_x_.[[pattern]]</ins>, _patternParts_, <del>_x_</del><ins>_x_.[[epochNanoseconds]]</ins>, *undefined*).
        1. Return _result_.
      </emu-alg>

      <emu-note>
        It is recommended that implementations use the locale and calendar dependent strings provided by the Common Locale Data Repository (available at <a href="http://cldr.unicode.org">http://cldr.unicode.org</a>), and use CLDR *"abbreviated"* strings for DateTimeFormat *"short"* strings, and CLDR *"wide"* strings for DateTimeFormat *"long"* strings.
      </emu-note>

      <emu-note>
        It is recommended that implementations use the time zone information of the IANA Time Zone Database.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-formatdatetime" aoid="FormatDateTime">
      <h1>FormatDateTime ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The FormatDateTime abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimePattern(_dateTimeFormat_, _x_).
        1. Let _result_ be the empty String.
        1. For each Record _part_ in _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatdatetimetoparts" aoid="FormatDateTimeToParts">
      <h1>FormatDateTimeToParts ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The FormatDateTimeToParts abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimePattern(_dateTimeFormat_, _x_).
        1. Let _result_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record _part_ in _parts_, do
          1. Let _O_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataProperty(_result_, ! ToString(_n_), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-partitiondatetimerangepattern" aoid="PartitionDateTimeRangePattern">
      <h1>PartitionDateTimeRangePattern ( _dateTimeFormat_, _x_, _y_ )</h1>

      <p>
        The PartitionDateTimeRangePattern abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat), _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value) and _y_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), <del>interprets _x_ and _y_ as time values as specified in ES2023, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>,</del> and creates the corresponding parts according to the effective locale and the formatting options of _dateTimeFormat_. The following steps are taken:
      </p>
      <emu-alg>
        1. <del>Let _x_ be TimeClip(_x_).</del>
        1. <del>If _x_ is *NaN*, throw a *RangeError* exception.</del>
        1. <del>Let _y_ be TimeClip(_y_).</del>
        1. <del>If _y_ is *NaN*, throw a *RangeError* exception.</del>
        1. <ins>If either of ! IsTemporalObject(_x_) or ! IsTemporalObject(_y_) is *true*, then</ins>
          1. <ins>If ! SameTemporalType(_x_, _y_) is *false*, throw a *TypeError* exception.</ins>
        1. <ins>Let _x_ be ? HandleDateTimeValue(_dateTimeFormat_, _x_).</ins>
        1. <ins>Let _y_ be ? HandleDateTimeValue(_dateTimeFormat_, _y_).</ins>
        1. If _x_<ins>.[[epochNanoseconds]]</ins> is greater than _y_<ins>.[[epochNanoseconds]]</ins>, throw a *RangeError* exception.
        1. Let _tm1_ be ToLocalTime(_x_<ins>.[[epochNanoseconds]]</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _tm2_ be ToLocalTime(_y_<ins>.[[epochNanoseconds]]</ins>, _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _rangePatterns_ be <del>_dateTimeFormat_.[[RangePatterns]]</del><ins>_x_.[[rangePatterns]]</ins>.
        1. <ins>Assert: _rangePatterns_ is equal to _y_.[[rangePatterns]].</ins>
        1. Let _rangePattern_ be *undefined*.
        1. Let _dateFieldsPracticallyEqual_ be *true*.
        1. Let _patternContainsLargerDateField_ be *false*.
        1. While _dateFieldsPracticallyEqual_ is *true* and _patternContainsLargerDateField_ is *false*, repeat for each row of <emu-xref href="#table-datetimeformat-rangepatternfields"></emu-xref> in order, except the header row:
          1. Let _fieldName_ be the name given in the Range Pattern Field column of the row.
          1. If _fieldName_ is equal to [[AmPm]], then
            1. Let _rp_ be _rangePatterns_.[[AmPm]].
            1. If _rangePattern_ is not *undefined* and _rp_ is *undefined*, then
              1. Set _patternContainsLargerDateField_ to *true*.
            1. Else,
              1. Let _v1_ be _tm1_.[[Hour]].
              1. Let _v2_ be _tm2_.[[Hour]].
              1. If _v1_ is greater than 11 and _v2_ less or equal than 11, or _v1_ is less or equal than 11 and _v2_ is greater than 11, then
                1. Set _dateFieldsPracticallyEqual_ to *false*.
              1. Let _rangePattern_ be _rp_.
          1. If _fieldName_ is equal to [[FractionalSecondDigits]], then
            1. Let _rp_ be _rangePatterns_.[[FractionalSecondDigits]].
            1. If _rangePattern_ is not *undefined* and _rp_ is *undefined*, then
              1. Set _patternContainsLargerDateField_ to *true*.
            1. Else,
              1. Let _fractionalSecondDigits_ be _dateTimeFormat_.[[FractionalSecondDigits]].
              1. If _fractionalSecondDigits_ is *undefined*, then
                1. Set _fractionalSecondDigits_ to 3.
              1. Let _v1_ be _tm1_.[[Millisecond]].
              1. Let _v2_ be _tm2_.[[Millisecond]].
              1. Let _v1_ be floor(_v1_ &times; 10<sup>( _fractionalSecondDigits_ - 3 )</sup>).
              1. Let _v2_ be floor(_v2_ &times; 10<sup>( _fractionalSecondDigits_ - 3 )</sup>).
              1. If _v1_ is not equal to _v2_, then
                1. Set _dateFieldsPracticallyEqual_ to *false*.
              1. Let _rangePattern_ be _rp_.
          1. Else,
            1. Let _rp_ be _rangePatterns_.[[&lt;_fieldName_&gt;>]].
            1. If _rangePattern_ is not *undefined* and _rp_ is *undefined*, then
              1. Set _patternContainsLargerDateField_ to *true*.
            1. Else,
              1. Let _v1_ be _tm1_.[[&lt;_fieldName_&gt;>]].
              1. Let _v2_ be _tm2_.[[&lt;_fieldName_&gt;]].
              1. If _v1_ is not equal to _v2_, then
                1. Set _dateFieldsPracticallyEqual_ to *false*.
              1. Let _rangePattern_ be _rp_.
        1. If _dateFieldsPracticallyEqual_ is *true*, then
          1. Let _pattern_ be <del>_dateTimeFormat_.[[Pattern]]</del><ins>_x_.[[pattern]]</ins>.
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. Let _result_ be ? FormatDateTimePattern(_dateTimeFormat_, <ins>_pattern_,</ins> _patternParts_, _x_<ins>.[[epochNanoseconds]]</ins>, *undefined*).
          1. For each element _r_ in _result_, do
            1. Set _r_.[[Source]] to *"shared"*.
          1. Return _result_.
        1. Let _result_ be a new empty List.
        1. If _rangePattern_ is *undefined*, then
          1. Let _rangePattern_ be _rangePatterns_.[[Default]].
        1. For each element _rangePatternPart_ in _rangePattern_.[[PatternParts]], do
          1. Let _pattern_ be _rangePatternPart_.[[Pattern]].
          1. Let _source_ be _rangePatternPart_.[[Source]].
          1. If _source_ is *"startRange"* or *"shared"*, then
            1. Let _z_ be _x_<ins>.[[epochNanoseconds]]</ins>.
          1. Else,
            1. Let _z_ be _y_<ins>.[[epochNanoseconds]]</ins>.
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. Let _partResult_ be ? FormatDateTimePattern(_dateTimeFormat_, <ins>_pattern_,</ins> _patternParts_, _z_, _rangePattern_).
          1. For each element _r_ in _partResult_, do
            1. Set _r_.[[Source]] to _source_.
          1. Add all elements in _partResult_ to _result_ in order.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimerange" aoid="FormatDateTimeRange">
      <h1>FormatDateTimeRange ( _dateTimeFormat_, _x_, _y_ )</h1>

      <p>
        The FormatDateTimeRange abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat), _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value) and _y_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimeRangePattern(_dateTimeFormat_, _x_, _y_).
        1. Let _result_ be the empty String.
        1. For each Record { [[Type]], [[Value]], [[Source]] } _part_ in _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimerangetoparts" aoid="FormatDateTimeRangeToParts">
      <h1>FormatDateTimeRangeToParts ( _dateTimeFormat_, _x_, _y_ )</h1>

      <p>
        The FormatDateTimeRangeToParts abstract operation is called with arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat), _x_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value) and _y_ (which must be <del>a Number</del><ins>an ECMAScript</ins> value), and performs the following steps:
      </p>

      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimeRangePattern(_dateTimeFormat_, _x_, _y_).
        1. Let _result_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record { [[Type]], [[Value]], [[Source]] } _part_ in _parts_, do
          1. Let _O_ be OrdinaryObjectCreate(%ObjectPrototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"source"*, _part_.[[Source]]).
          1. Perform ! CreateDataProperty(_result_, ! ToString(_n_), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-temporal-istemporalobject" aoid="IsTemporalObject">
      <h1>IsTemporalObject ( _value_ )</h1>

      <p>
        The IsTemporalObject abstract operation is called with argument _value_, and performs the following steps:
      </p>

      <emu-alg>
        1. If Type(_value_) is not Object, then
          1. Return *false*.
        1. If _value_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalTime]], [[InitializedTemporalDateTime]], [[InitializedTemporalZonedDateTime]], [[InitializedTemporalYearMonth]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalInstant]] internal slot, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-sametemporaltype" aoid="SameTemporalType">
      <h1>SameTemporalType ( _x_, _y_ )</h1>
      <p>
        The abstract operation SameTemporalType accepts two arguments (which may be any ECMAScript values), and determines whether they are both instances of the same Temporal type.
      </p>
      <emu-alg>
        1. If either of ! IsTemporalObject(_x_) or ! IsTemporalObject(_y_) is *false*, return *false*.
        1. If _x_ has an [[InitializedTemporalDate]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalDateTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalZonedDateTime]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalYearMonth]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalMonthDay]] internal slot and _y_ does not, return *false*.
        1. If _x_ has an [[InitializedTemporalInstant]] internal slot and _y_ does not, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-getdatetimeformatpattern" aoid="GetDateTimeFormatPattern">
      <h1>GetDateTimeFormatPattern ( _dateStyle_, _timeStyle_, _matcher_, _formatOptions_, _dataLocaleData_, _hc_, _resolvedCalendar_, _hasExplicitFormatComponents_ )</h1>

      <p>
         The abstract operation GetDateTimeFormatPattern accepts the arguments _dateStyle_ (one of *"full"*, *"long"*, *"medium"*, or *"short"*), _timeStyle_ (one of the values allowed for _dateStyle_), _matcher_ (which must be either *"basic"* or *"best fit"*), _formatOptions_ (a Record with fields from the Property column of <emu-xref href="#table-datetimeformat-components"></emu-xref>), _dataLocaleData_ (a Record of the same type as [[LocaleData]] as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>), _hc_ (one of *"h11"*, *"h12"*, *"h23"*, or *"h24"*), _resolvedCalendar_ (a calendar value), and _hasExplicitFormatComponents_ (a Boolean).
         It returns a Record of the type contained by the List [[LocaleData]].[[&lt;_locale_&gt;]].[[formats]].[[&lt;_calendar_&gt;]] as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.
         This abstract operation functions as follows:
      </p>

      <emu-alg>
        1. If _dateStyle_ is not *undefined* or _timeStyle_ is not *undefined*, then
          1. If _hasExplicitFormatComponents_ is *true*, then
            1. Throw a *TypeError* exception.
          1. Let _styles_ be _dataLocaleData_.[[styles]].[[&lt;_resolvedCalendar_&gt;]].
          1. Let _bestFormat_ be DateTimeStyleFormat(_dateStyle_, _timeStyle_, _styles_).
        1. Else,
          1. Let _formats_ be _dataLocaleData_.[[formats]].[[&lt;_resolvedCalendar_&gt;]].
          1. If _matcher_ is *"basic"*, then
            1. Let _bestFormat_ be BasicFormatMatcher(_formatOptions_, _formats_).
          1. Else,
            1. Let _bestFormat_ be BestFitFormatMatcher(_formatOptions_, _formats_).
        1. If _bestFormat_.[[hour]] is not *undefined*, then
          1. If _hc_ is *"h11"* or *"h12"*, then
            1. Set _bestFormat_.[[pattern]] to _bestFormat_.[[pattern12]].
            1. Set _bestFormat_.[[rangePatterns]] to _bestFormat_.[[rangePatterns12]].
          1. Remove the [[pattern12]] field from _bestFormat_.
          1. Remove the [[rangePatterns12]] field from _bestFormat_.
          1. Set _bestFormat_.[[hourCycle]] to _hc_.
        1. Else,
          1. Set _bestFormat_.[[hourCycle]] to *undefined*.
        1. Return _bestFormat_.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevaluetemporaldate" aoid="HandleDateTimeTemporalDate">
      <h1>HandleDateTimeTemporalDate ( _dateTimeFormat_, _temporalDate_ )</h1>

      <p>
        The abstract operation HandleDateTimeTemporalDate accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _temporalDate_ (which must be an ECMAScript value has an [[InitializedTemporalDate]] internal slot). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. Assert: _temporalDate_ has an [[InitializedTemporalDate]] internal slot.
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainDatePattern]].
      1. Let _calendar_ be ? ToString(_temporalDate_.[[Calendar]]).
      1. If _calendar_ is _dateTimeFormat_.[[Calendar]], then
        1. Let _calendarOverride_ be _temporalDate_.[[Calendar]].
      1. Else if _calendar_ is *"iso8601"*, then
        1. Let _calendarOverride_ be _dateTimeFormat_.[[Calendar]].
      1. Else,
        1. Throw a *RangeError* exception.
      1. Let _plainDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 12, 0, 0, 0, 0, 0, _calendarOverride_).
      1. Let _timeZone_ be ! CreateTemporalTimeZone(_dateTimeFormat_.[[TimeZone]]).
      1. Let _instant_ be ? GetInstantFor(_timeZone_, _plainDateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>
    </ins>
    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevaluetemporalyearmonth" aoid="HandleDateTimeTemporalYearMonth">
      <h1>HandleDateTimeTemporalYearMonth ( _dateTimeFormat_, _temporalYearMonth_ )</h1>

      <p>
        The abstract operation HandleDateTimeTemporalYearMonth accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _temporalYearMonth_ (which must be an ECMAScript value has an [[InitializedTemporalYearMonth]] internal slot). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. Assert: _temporalYearMonth_ has an [[InitializedTemporalYearMonth]] internal slot.
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainYearMonthPattern]].
      1. Let _calendar_ be ? ToString(_temporalYearMonth_.[[Calendar]]).
      1. If _calendar_ is not equal to _dateTimeFormat_.[[Calendar]], then
        1. Throw a *RangeError* exception.
      1. Let _plainDateTime_ be ? CreateTemporalDateTime(_temporalYearMonth_.[[ISOYear]], _temporalYearMonth_.[[ISOMonth]], _temporalYearMonth_.[[ISODay]], 12, 0, 0, 0, 0, 0, _temporalYearMonth_.[[Calendar]]).
      1. Let _timeZone_ be ! CreateTemporalTimeZone(_dateTimeFormat_.[[TimeZone]]).
      1. Let _instant_ be ? GetInstantFor(_timeZone_, _plainDateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevaluetemporalmonthday" aoid="HandleDateTimeTemporalMonthDay">
      <h1>HandleDateTimeTemporalMonthDay ( _dateTimeFormat_, _temporalMonthDay_ )</h1>

      <p>
        The abstract operation HandleDateTimeTemporalMonthDay accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _temporalMonthDay_ (which must be an ECMAScript value has an [[InitializedTemporalMonthDay]] internal slot). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. Assert: _temporalMonthDay_ has an [[InitializedTemporalMonthDay]] internal slot.
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainMonthDayPattern]].
      1. Let _calendar_ be ? ToString(_temporalMonthDay_.[[Calendar]]).
      1. If _calendar_ is not equal to _dateTimeFormat_.[[Calendar]], then
        1. Throw a *RangeError* exception.
      1. Let _plainDateTime_ be ? CreateTemporalDateTime(_temporalMonthDay_.[[ISOYear]], _temporalMonthDay_.[[ISOMonth]], _temporalMonthDay_.[[ISODay]], 12, 0, 0, 0, 0, 0, _temporalMonthDay_.[[Calendar]]).
      1. Let _timeZone_ be ! CreateTemporalTimeZone(_dateTimeFormat_.[[TimeZone]]).
      1. Let _instant_ be ? GetInstantFor(_timeZone_, _plainDateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevaluetemporaltime" aoid="HandleDateTimeTemporalTime">
      <h1>HandleDateTimeTemporalTime ( _dateTimeFormat_, _temporalTime_ )</h1>

      <p>
        The abstract operation HandleDateTimeTemporalTime accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _temporalTime_ (which must be an ECMAScript value has an [[InitializedTemporalTime]] internal slot). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. Assert: _temporalTime_ has an [[InitializedTemporalTime]] internal slot.
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainTimePattern]].
      1. Let _plainDateTime_ be ? CreateTemporalDateTime(1970, 1, 1, _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], *"iso8601"*).
      1. Let _timeZone_ be ! CreateTemporalTimeZone(_dateTimeFormat_.[[TimeZone]]).
      1. Let _instant_ be ? GetInstantFor(_timeZone_, _plainDateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevaluetemporaldatetime" aoid="HandleDateTimeTemporalDateTime">
      <h1>HandleDateTimeTemporalDateTime ( _dateTimeFormat_, _dateTime_ )</h1>

      <p>
        The abstract operation HandleDateTimeTemporalDateTime accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _dateTime_ (which must be an ECMAScript value has an [[InitializedTemporalDateTime]] internal slot). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. Assert: _dateTime_ has an [[InitializedTemporalDateTime]] internal slot.
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalPlainDateTimePattern]].
      1. Let _calendar_ be ? ToString(_dateTime_.[[Calendar]]).
      1. If _calendar_ is not *"iso8601"* and not equal to _dateTimeFormat_.[[Calendar]], then
        1. Throw a *RangeError* exception.
      1. Let _timeZone_ be ! CreateTemporalTimeZone(_dateTimeFormat_.[[TimeZone]]).
      1. Let _instant_ be ? GetInstantFor(_timeZone_, _dateTime_, *"compatible"*).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevaluetemporalinstant" aoid="HandleDateTimeTemporalInstant">
      <h1>HandleDateTimeTemporalInstant ( _dateTimeFormat_, _instant_ )</h1>

      <p>
        The abstract operation HandleDateTimeTemporalInstant accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _instant_ (which must be an ECMAScript value has an [[InitializedTemporalDateTime]] internal slot). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. Assert: _instant_ has an [[InitializedTemporalInstant]] internal slot.
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalInstantPattern]].
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>
    </ins>
    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevaluetemporalzoneddatetime" aoid="HandleDateTimeTemporalZonedDateTime">
      <h1>HandleDateTimeTemporalZonedDateTime ( _dateTimeFormat_, _zonedDateTime_ )</h1>

      <p>
        The abstract operation HandleDateTimeTemporalZonedDateTime accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _zonedDateTime_ (which must be an ECMAScript value has an [[InitializedTemporalDateTime]] internal slot). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. Assert: _zonedDateTime_ has an [[InitializedTemporalZonedDateTime]] internal slot.
      1. Let _pattern_ be _dateTimeFormat_.[[TemporalZonedDateTimePattern]].
      1. Let _calendar_ be ? ToString(_zonedDateTime_.[[Calendar]]).
      1. If _calendar_ is not *"iso8601"* and not equal to _dateTimeFormat_.[[Calendar]], then
        1. Throw a *RangeError* exception.
      1. Let _timeZone_ be ? ToString(_zonedDateTime_.[[TimeZone]]).
      1. If _dateTimeFormat_.[[TimeZone]] is not equal to DefaultTimeZone(), and _timeZone_ is not equal to _dateTimeFormat_.[[TimeZone]], then
        1. Throw a *RangeError* exception.
      1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
      1. If _pattern_ is *null*, throw a *TypeError* exception.
      1. Return the Record {
          [[pattern]]: _pattern_.[[pattern]],
          [[rangePatterns]]: _pattern_.[[rangePatterns]],
          [[epochNanoseconds]]: _instant_.[[Nanoseconds]]
        }.
      </emu-alg>
    </emu-clause>
    </ins>

    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimeothers" aoid="HandleDateTimeOthers">
      <h1>HandleDateTimeOthers ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The abstract operation HandleDateTimeOthers accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be an ECMAScript value which IsTemporalObject(_x_) returns *false*). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. Assert: ! IsTemporalObject(_x_) is *false*.
      1. Let _pattern_ be _dateTimeFormat_.[[Pattern]].
      1. Let _rangePatterns_ be _dateTimeFormat_.[[RangePatterns]].
      1. If _x_ is *undefined*, then
        1. Set _x_ to ! Call(%Date.now%, *undefined*).
      1. Else,
        1. Set _x_ to ? ToNumber(_x_).
      1. Set _x_ to TimeClip(_x_).
      1. If _x_ is *NaN*, throw a *RangeError* exception.
      1. Let _epochNanoseconds_ be ℤ(_x_) &times; ℤ(10<sup>6</sup>).
      1. Return the Record {
          [[pattern]]: _pattern_,
          [[rangePatterns]]: _rangePatterns_,
          [[epochNanoseconds]]: _epochNanoseconds_
        }.
      </emu-alg>
    </emu-clause>
    </ins>
    <ins class="block">
    <emu-clause id="sec-temporal-handledatetimevalue" aoid="HandleDateTimeValue">
      <h1>HandleDateTimeValue ( _dateTimeFormat_, _x_ )</h1>

      <p>
        The abstract operation HandleDateTimeValue accepts the arguments _dateTimeFormat_ (which must be an object initialized as a DateTimeFormat) and _x_ (which must be an ECMAScript value). It returns a record which contains the appropriate pattern and epochNanoseconds values for the input. This abstract operation functions as follows:
      </p>

      <emu-alg>
      1. If ! IsTemporalObject(_x_) is *true*, then
        1. If _x_ has an [[InitializedTemporalDate]] internal slot, then
          1. Return ? HandleDateTimeTemporalDate(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalYearMonth]] internal slot, then
          1. Return ? HandleDateTimeTemporalYearMonth(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalMonthDay]] internal slot, then
          1. Return ? HandleDateTimeTemporalMonthDay(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalTime]] internal slot, then
          1. Return ? HandleDateTimeTemporalTime(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalDateTime]] internal slot, then
          1. Return ? HandleDateTimeTemporalDateTime(_dateTimeFormat_, _x_).
        1. If _x_ has an [[InitializedTemporalInstant]] internal slot, then
          1. Return ? HandleDateTimeTemporalInstant(_dateTimeFormat_, _x_).
        1. Assert: _x_ has an [[InitializedTemporalZonedDateTime]] internal slot.
        1. Return ? HandleDateTimeTemporalZonedDateTime(_dateTimeFormat_, _x_).
      1. Return ? HandleDateTimeOthers(_dateTimeFormat_, _x_).
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-temporal-tolocaltime" aoid="ToLocalTime">
      <h1>ToLocalTime ( _t_, _calendar_, _timeZone_ )</h1>

      <p>
        When the ToLocalTime abstract operation is called with arguments _t_ <ins>(in nanoseconds from the epoch)</ins>, _calendar_, and _timeZone_, the following steps are taken:
      </p>

      <emu-alg>
        1. Assert: Type(_t_) is <del>Number</del><ins>BigInt</ins>.
        1. If _calendar_ is *"gregory"*, then
          1. <del>Let _timeZoneOffset_ be the value calculated according to LocalTZA(_t_, *true*) where the local time zone is replaced with timezone _timeZone_.</del>
          1. <ins>Let _timeZoneOffset_ be GetNamedTimeZoneOffsetNanoseconds(_timeZone_, _t_).</ins>
          1. Let _tz_ be <del>_t_</del><ins>ℝ(_t_)</ins> + _timeZoneOffset_.
          1. Return a record with fields calculated from _tz_ according to <del><emu-xref href="#table-datetimeformat-tolocaltime-record"></emu-xref></del><ins><emu-xref href="#table-temporal-plaindatetimeformat-tolocaltime-record"></emu-xref></ins>.
        1. Else,
          1. Return a record with the fields of Column 1 of <del><emu-xref href="#table-datetimeformat-tolocaltime-record"></emu-xref></del><ins><emu-xref href="#table-temporal-plaindatetimeformat-tolocaltime-record"></emu-xref></ins> calculated from <del>_t_</del><ins>ℝ(_t_)</ins> for the given _calendar_ and _timeZone_. The calculations should use best available information about the specified _calendar_ and _timeZone_, including current and historical information about time zone offsets from UTC and daylight saving time rules. <ins>Given the same values of _t_, _calendar_, and _timeZone_, the result must be the same for the lifetime of the surrounding agent</ins>.
      </emu-alg>

      <emu-table id="table-temporal-plaindatetimeformat-tolocaltime-record">
        <emu-caption>Record returned by ToLocalTime</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Field</th>
              <th>Value Calculation for Gregorian Calendar</th>
            </tr>
          </thead>
          <tr>
            <td>[[Weekday]]</td>
            <td>
              <del>`WeekDay(tz)` specified in ES2023's <emu-xref href="#sec-week-day">Week Day</emu-xref></del>
              <ins>! WeekDay(𝔽(truncate(_tz_ / 10<sup>6</sup>)))</ins>
            </td>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>
              <del>Let `year` be `YearFromTime(tz)` specified in ES2023's <emu-xref href="#sec-year-number">Year Number</emu-xref>. If `year` is less than 0, return 'BC', else, return 'AD'.</del>
              <ins>Let _year_ be ! YearFromTime(𝔽(truncate(_tz_ / 10<sup>6</sup>))). If _year_ &lt; *-0*<sub>𝔽</sub>, return *"BC"*, else, return *"AD"*.</ins>
            </td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>
              <del>`YearFromTime(tz)` specified in ES2023's <emu-xref href="#sec-year-number">Year Number</emu-xref></del>
              <ins>! YearFromTime(𝔽(truncate(_tz_ / 10<sup>6</sup>)))</ins>
            </td>
          </tr>
          <tr>
            <td>[[RelatedYear]]</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>[[YearName]]</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>
              <del>`MonthFromTime(tz)` specified in ES2023's <emu-xref href="#sec-month-number">Month Number</emu-xref></del>
              <ins>! MonthFromTime(𝔽(truncate(_tz_ / 10<sup>6</sup>)))</ins>
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>
              <del>`DateFromTime(tz)` specified in ES2023's <emu-xref href="#sec-date-number">Date Number</emu-xref></del>
              <ins>! DateFromTime(𝔽(truncate(_tz_ / 10<sup>6</sup>)))</ins>
            </td>
          </tr>
          <tr>
            <td>[[Hour]]</td>
            <td>
              <del>`HourFromTime(tz)` specified in ES2023's <emu-xref href="#sec-hours-minutes-second-and-milliseconds">Hours, Minutes, Second, and Milliseconds</emu-xref></del>
              <ins>! HourFromTime(𝔽(truncate(_tz_ / 10<sup>6</sup>)))</ins>
            </td>
          </tr>
          <tr>
            <td>[[Minute]]</td>
            <td>
              <del>`MinFromTime(tz)` specified in ES2023's <emu-xref href="#sec-hours-minutes-second-and-milliseconds">Hours, Minutes, Second, and Milliseconds</emu-xref></del>
              <ins>! MinFromTime(𝔽(truncate(_tz_ / 10<sup>6</sup>)))</ins>
            </td>
          </tr>
          <tr>
            <td>[[Second]]</td>
            <td>
              <del>`SecFromTime(tz)` specified in ES2023's <emu-xref href="#sec-hours-minutes-second-and-milliseconds">Hours, Minutes, Second, and Milliseconds</emu-xref></del>
              <ins>! SecFromTime(𝔽(truncate(_tz_ / 10<sup>6</sup>)))</ins>
            </td>
          </tr>
          <tr>
            <td>[[Millisecond]]</td>
            <td>
              <del>`msFromTime(tz)` specified in ES2023's <emu-xref href="#sec-hours-minutes-second-and-milliseconds">Hours, Minutes, Second, and Milliseconds</emu-xref></del>
              <ins>! msFromTime(𝔽(truncate(_tz_ / 10<sup>6</sup>)))</ins>
            </td>
          </tr>
          <tr>
            <td><ins>[[Nanosecond]]</ins></td>
            <td><ins>_tz_ modulo 10<sup>9</sup></ins></td>
          </tr>
          <tr>
            <td>[[InDST]]</td>
            <td>Calculate *true* or *false* using the best available information about the specified _calendar_ and _timeZone_, including current and historical information about time zone offsets from UTC and daylight saving time rules.</td>
          </tr>
        </table>
      </emu-table>

      <emu-note>
        It is recommended that implementations use the time zone information of the IANA Time Zone Database.
      </emu-note>
      <emu-note>
        <ins>
          Time zone information is subject to change, and host environments may update their time zone database at any time.
          At a minimum, implementations must ensure that the time zone information for each particular value of _timeZone_ individually remains constant starting from the time it is first accessed, for the lifetime of the surrounding agent.
          Furthermore, it is recommended that the time zone information for all values of _timeZone_ as a whole (i.e. the time zone database) remains the same for the lifetime of the surrounding agent.
        </ins>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-prototype-object">
    <h1><a href="https://tc39.es/ecma402/#sec-properties-of-intl-datetimeformat-prototype-object">Properties of the Intl.DateTimeFormat Prototype Object</a></h1>

    <emu-clause id="sec-Intl.DateTimeFormat.prototype.formatToParts">
      <h1>Intl.DateTimeFormat.prototype.formatToParts ( _date_ )</h1>

      <p>
        When the `formatToParts` method is called with an argument _date_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. <del>If _date_ is *undefined*, then</del>
          1. <del>Let _x_ be ! Call(%Date.now%, *undefined*).</del>
        1. <del>Else,</del>
          1. <del>Let _x_ be ? ToNumber(_date_).</del>
        1. Return ? FormatDateTimeToParts(_dtf_, <del>_x_</del><ins>_date_</ins>).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.formatRange">
      <h1>Intl.DateTimeFormat.prototype.formatRange ( _startDate_, _endDate_ )</h1>

      <p>
        When the `formatRange` method is called with an arguments _startDate_ and _endDate_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _startDate_ is *undefined* or _endDate_ is *undefined*, throw a *TypeError* exception.
        1. <del>Let _x_ be ? ToNumber(_startDate_).</del>
        1. <del>Let _y_ be ? ToNumber(_endDate_).</del>
        1. Return ? FormatDateTimeRange(_dtf_, <del>_x_</del><ins>_startDate_</ins>, <del>_y_</del><ins>_endDate_</ins>).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.DateTimeFormat.prototype.formatRangeToParts">
      <h1>Intl.DateTimeFormat.prototype.formatRangeToParts ( _startDate_, _endDate_ )</h1>

      <p>
        When the `formatRangeToParts` method is called with an arguments _startDate_ and _endDate_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _startDate_ is *undefined* or _endDate_ is *undefined*, throw a *TypeError* exception.
        1. <del>Let _x_ be ? ToNumber(_startDate_).</del>
        1. <del>Let _y_ be ? ToNumber(_endDate_).</del>
        1. Return ? FormatDateTimeRangeToParts(_dtf_, <del>_x_</del><ins>_startDate_</ins>, <del>_y_</del><ins>_endDate_</ins>).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.resolvedoptions">
      <h1>Intl.DateTimeFormat.prototype.resolvedOptions ( )</h1>

      <p>
        This function provides access to the locale and formatting options computed during initialization of the object.
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. If the implementation supports the normative optional constructor mode of <emu-xref href="#legacy-constructor"></emu-xref>, then
          1. Set _dtf_ to ? UnwrapDateTimeFormat(_dtf_).
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. Let _options_ be OrdinaryObjectCreate(%Object.prototype%).
        1. For each row of <emu-xref href="#table-datetimeformat-resolvedoptions-properties"></emu-xref>, except the header row, in table order, do
          1. Let _p_ be the Property value of the current row.
          1. If _p_ is *"hour12"*, then
            1. Let _hc_ be _dtf_.<del>[[HourCycle]]</del><ins>[[Pattern]].[[hourCycle]]</ins>.
            1. If _hc_ is *"h11"* or *"h12"*, let _v_ be *true*.
            1. Else if, _hc_ is *"h23"* or *"h24"*, let _v_ be *false*.
            1. Else, let _v_ be *undefined*.
          1. Else,
            1. <ins>If the Location value of the current row is ~object~, then</ins>
              1. Let _v_ be the value of _dtf_'s internal slot whose name is the Internal Slot value of the current row.
            1. <ins>Else,</ins>
              1. <ins>Assert: The Location value of the current row is ~pattern~.</ins>
              1. <ins>Let _v_ be the value of _dtf_.[[Pattern]]'s internal slot whose name is the Internal Slot value of the current row.</ins>
          1. If the Internal Slot value of the current row is an Internal Slot value in <emu-xref href="#table-datetimeformat-components"></emu-xref>, then
            1. If _dtf_.[[DateStyle]] is not *undefined* or _dtf_.[[TimeStyle]] is not *undefined*, then
              1. Let _v_ be *undefined*.
          1. If _v_ is not *undefined*, then
            1. Perform ! CreateDataPropertyOrThrow(_options_, _p_, _v_).
        1. Return _options_.
      </emu-alg>

      <emu-table id="table-datetimeformat-resolvedoptions-properties">
        <emu-caption>Resolved Options of DateTimeFormat Instances</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
              <th><ins>Location</ins></th>
            </tr>
          </thead>
          <tr>
            <td>[[Locale]]</td>
            <td>*"locale"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[Calendar]]</td>
            <td>*"calendar"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[NumberingSystem]]</td>
            <td>*"numberingSystem"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[TimeZone]]</td>
            <td>*"timeZone"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td><del>[[HourCycle]]</del><ins>[[hourCycle]]</ins></td>
            <td>*"hourCycle"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td></td>
            <td>*"hour12"*</td>
            <td></td>
          </tr>
          <tr>
            <td><del>[[Weekday]]</del><ins>[[weekday]]</ins></td>
            <td>*"weekday"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Era]]</del><ins>[[era]]</ins></td>
            <td>*"era"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Year]]</del><ins>[[year]]</ins></td>
            <td>*"year"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Month]]</del><ins>[[month]]</ins></td>
            <td>*"month"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Day]]</del><ins>[[day]]</ins></td>
            <td>*"day"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[DayPeriod]]</del><ins>[[dayPeriod]]</ins></td>
            <td>*"dayPeriod"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Hour]]</del><ins>[[hour]]</ins></td>
            <td>*"hour"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Minute]]</del><ins>[[minute]]</ins></td>
            <td>*"minute"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[Second]]</del><ins>[[second]]</ins></td>
            <td>*"second"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[FractionalSecondDigits]]</del><ins>[[fractionalSecondDigits]]</ins></td>
            <td>*"fractionalSecondDigits"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td><del>[[TimeZoneName]]</del><ins>[[timeZoneName]]</ins></td>
            <td>*"timeZoneName"*</td>
            <td><ins>~pattern~</ins></td>
          </tr>
          <tr>
            <td>[[DateStyle]]</td>
            <td>*"dateStyle"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          <tr>
            <td>[[TimeStyle]]</td>
            <td>*"timeStyle"*</td>
            <td><ins>~object~</ins></td>
          </tr>
          </tr>
        </table>
      </emu-table>

      <p>
        For web compatibility reasons, if the property *"hourCycle"* is set, the *"hour12"* property should be set to *true* when *"hourCycle"* is *"h11"* or *"h12"*, or to *false* when *"hourCycle"* is *"h23"* or *"h24"*.
      </p>

      <emu-note>
        In this version of the ECMAScript 2023 Internationalization API, the *"timeZone"* property will be the name of the default time zone if no *"timeZone"* property was provided in the options object provided to the Intl.DateTimeFormat constructor. The first edition left the *"timeZone"* property *undefined* in this case.
      </emu-note>

      <emu-note>
        For compatibility with versions prior to the fifth edition, the *"hour12"* property is set in addition to the *"hourCycle"* property.
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-instances">
    <h1><a href="https://tc39.es/ecma402/#sec-properties-of-intl-datetimeformat-instances">Properties of Intl.DateTimeFormat Instances</a></h1>

    <p>
      Intl.DateTimeFormat instances are ordinary objects that inherit properties from %DateTimeFormat.prototype%.
    </p>

    <p>
      Intl.DateTimeFormat instances have an [[InitializedDateTimeFormat]] internal slot.
    </p>

    <p>
      Intl.DateTimeFormat instances also have several internal slots that are computed by the constructor:
    </p>

    <ul>
      <li>[[Locale]] is a String value with the language tag of the locale whose localization is used for formatting.</li>
      <li>[[Calendar]] is a String value with the *"type"* given in Unicode Technical Standard 35 for the calendar used for formatting.</li>
      <li>[[NumberingSystem]] is a String value with the *"type"* given in Unicode Technical Standard 35 for the numbering system used for formatting.</li>
      <li>[[TimeZone]] is a String value with the IANA time zone name of the time zone used for formatting.</li>
      <li><del>[[Weekday]], [[Era]], [[Year]], [[Month]], [[Day]], [[DayPeriod]], [[Hour]], [[Minute]], [[Second]], [[TimeZoneName]] are each either *undefined*, indicating that the component is not used for formatting, or one of the String values given in <emu-xref href="#table-datetimeformat-components"></emu-xref>, indicating how the component should be presented in the formatted output.</del></li>
      <li><del>[[FractionalSecondDigits]] is either *undefined* or a positive, non-negative integer Number value indicating the fraction digits to be used for fractional seconds. Numbers will be rounded or padded with trailing zeroes if necessary.</del></li>
      <li><del>[[HourCycle]] is a String value indicating whether the 12-hour format (*"h11"*, *"h12"*) or the 24-hour format (*"h23"*, *"h24"*) should be used. *"h11"* and *"h23"* start with hour 0 and go up to 11 and 23 respectively. *"h12"* and *"h24"* start with hour 1 and go up to 12 and 24. [[HourCycle]] is only used when [[Hour]] is not *undefined*.</del></li>
      <li>[[DateStyle]], [[TimeStyle]] are each either *undefined*, or a String value with values *"full"*, *"long"*, *"medium"*, or *"short"*.</li>
      <li>[[Pattern]] is a String value as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</li>
      <li>[[RangePatterns]] is a Record as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</li>
      <li><ins>[[TemporalPlainDatePattern]], [[TemporalPlainYearMonthPattern]], [[TemporalPlainMonthDayPattern]], [[TemporalPlainTimePattern]], [[TemporalPlainDateTimePattern]], [[TemporalInstantPattern]], and [[TemporalZonedDateTimePattern]] are records containing at least a [[pattern]] field as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</ins></li>
    </ul>

    <p>
      Finally, Intl.DateTimeFormat instances have a [[BoundFormat]] internal slot that caches the function returned by the format accessor (<emu-xref href="#sec-intl.datetimeformat.prototype.format"></emu-xref>).
    </p>
  </emu-clause>

  <emu-clause id="locale-sensitive-functions">
    <h1><a href="https://tc39.es/ecma402/#locale-sensitive-functions">Locale Sensitive Functions of the ECMAScript Language Specification</a></h1>

    <ins class="block">
      <emu-clause id="sup-temporal-calendar-abstract-ops">
        <h1>Abstract Operations for Temporal.Calendar Objects</h1>

        <emu-clause id="sec-temporal-calendarera" type="abstract operation">
          <h1>
            CalendarEra (
              _calendar_: an Object,
              _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            ): either a normal completion containing either a String or *undefined*, or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It calls the given _calendar_'s `era()` method and validates the result.</dd>
          </dl>
          <emu-alg>
            1. Assert: Type(_calendar_) is Object.
            1. Let _result_ be ? Invoke(_calendar_, *"era"*, « _dateLike_ »).
            1. If _result_ is *undefined*, return _result_.
            1. If Type(_result_) is not String, throw a *TypeError* exception.
            1. Return _result_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarerayear" type="abstract operation">
          <h1>
            CalendarEraYear (
              _calendar_: an Object,
              _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            ): either a normal completion containing either an integer or *undefined*, or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It calls the given _calendar_'s `eraYear()` method and validates the result.</dd>
          </dl>
          <emu-alg>
            1. Assert: Type(_calendar_) is Object.
            1. Let _result_ be ? Invoke(_calendar_, *"eraYear"*, « _dateLike_ »).
            1. If _result_ is *undefined*, return _result_.
            1. If Type(_result_) is not Number, throw a *TypeError* exception.
            1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
            1. Return ℝ(_result_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatetoiso" type="implementation-defined abstract operation">
          <h1>
            CalendarDateToISO (
              _calendar_: a String,
              _fields_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
              _overflow_: *"constrain"* or *"reject"*,
            ): either a normal completion containing an ISO Date Record, or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It performs implementation-defined processing to convert _fields_, which represents a date or year and month or month and day in the built-in calendar identified by _calendar_, to a corresponding representative date in the ISO 8601 calendar, subject to processing specified by _overflow_.
              For *"reject"*, values that do not form a valid date cause an exception to be thrown, as described below.
              For *"constrain"*, values that do not form a valid date are clamped to the correct range.
              It then returns an ISO Date Record with the corresponding ISO 8601 date.
            </dd>
          </dl>
          <p>
            Like RegulateISODate, the operation throws a *RangeError* exception if the date described by _fields_ is outside the range allowed by ISODateTimeWithinLimits, or if _overflow_ is *"reject"* and the date described by _fields_ does not exist.
          </p>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarmonthdaytoisoreferencedate" type="abstract operation">
          <h1>
            CalendarMonthDayToISOReferenceDate (
              _calendar_: a String,
              _fields_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
              _overflow_: *"constrain"* or *"reject"*,
            ): either a normal completion containing a Record with fields [[ISOMonth]], [[ISODay]], and [[ReferenceISOYear]], or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It performs implementation-defined processing to convert _fields_, which represents a calendar date without a year (i.e., month code and day pair, or equivalent) in the built-in calendar identified by _calendar_, to a corresponding reference date in the ISO 8601 calendar as described below, subject to processing specified by _overflow_.
              For *"reject"*, values that do not form a valid date cause an exception to be thrown.
              For *"constrain"*, values that do not form a valid date are clamped to the correct range.
              It then returns a Record representing the reference ISO 8601 date.
            </dd>
          </dl>
          <p>
            The fields of the returned Record represent a reference date in the ISO 8601 calendar that, when converted to the built-in calendar identified by _calendar_, corresponds to the month code and day of _fields_ in an arbitrary but deterministically chosen reference year.
            The reference date is the latest ISO 8601 date corresponding to the calendar date, that is also earlier than or equal to the ISO 8601 date December 31, 1972.
            If that calendar date never occurs on or before the ISO 8601 date December 31, 1972, then the reference date is the earliest ISO 8601 date corresponding to that calendar date.
            The reference year is almost always 1972 (the first ISO 8601 leap year after the epoch), with exceptions for calendars where some dates (e.g. leap days or days in leap months) didn't occur during that ISO 8601 year. For example, Hebrew calendar leap month Adar I was a part of calendar years 5730 and 5733 (respectively overlapping ISO 8601 February/March 1970 and February/March 1973), but did not occur between them.
          </p>
          <p>
            Like RegulateISODate, the operation throws a *RangeError* exception if _overflow_ is *"reject"* and the month and day described by _fields_ does not exist.
            For example, when _calendar_ is *"gregory"* and _overflow_ is *"reject"*, _fields_ values of `{ monthCode: "M01", day: "32" }` and `{ "year": 2001, "month": 2, "day": 29 }` would both cause a *RangeError* to be thrown.
            In the latter case, even though February 29 is a date in leap years of the Gregorian calendar, 2001 was not a leap year and a month code cannot be determined from the nonexistent date 2001-02-29 with the specified month index.
          </p>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateaddition" type="implementation-defined abstract operation">
          <h1>
            CalendarDateAddition (
              _calendar_: a String,
              _date_: a Temporal.PlainDate,
              _duration_: a Date Duration Record,
              _overflow_: a String,
            ): either a normal completion containing an ISO Date Record, or an abrupt completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It performs implementation-defined processing to add _duration_ to _date_ in the context of the calendar represented by _calendar_ and returns the corresponding day, month and year of the result in the ISO 8601 calendar values as an ISO Date Record.
              It may throw a *RangeError* exception if _overflow_ is *"reject"* and the resulting month or day would need to be clamped in order to form a valid date in _calendar_, or if the date resulting from the addition is outside the range allowed by ISODateTimeWithinLimits.
            </dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedifference" type="abstract operation">
          <h1>
            CalendarDateDifference (
              _calendar_: a String,
              _one_: a Temporal.PlainDate,
              _two_: a Temporal.PlainDate,
              _largestUnit_: a String,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the difference between the two dates _one_ and _two_ in the context of the calendar represented by _calendar_ and returns the corresponding years, months, weeks and days as a Date Duration Record.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateera" type="abstract operation">
          <h1>
            CalendarDateEra (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns a lowercase String value representing that era, or *undefined* for calendars that do not have eras.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateerayear" type="abstract operation">
          <h1>
            CalendarDateEraYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the ordinal position of the year of _date_ in that era, or *undefined* for calendars that do not have eras.</dd>
          </dl>
          <emu-note>
            Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateyear" type="abstract operation">
          <h1>
            CalendarDateYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the year for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns it. The value should be a signed integer relative to the first day of a calendar-specific "epoch year".</dd>
          </dl>

          <emu-note>The year is relative to the first day of the calendar's epoch year, so if the epoch era starts in the middle of the year, the year will be the same value before and after the start date of the era.</emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatemonth" type="abstract operation">
          <h1>
            CalendarDateMonth (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the 1-based ordinal position of that month in the corresponding year of the calendar.</dd>
          </dl>
          <emu-note>
            When the number of months in a year of the identified calendar is variable, a different value can be returned for dates that are part of the same month in different years. For example, in the Hebrew calendar, 1 Nisan 5781 is associated with value 7 while 1 Nisan 5782 is associated with value 8 because 5782 is a leap year and Nisan follows the insertion of Adar I.
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatemonthcode" type="abstract operation">
          <h1>
            CalendarDateMonthCode (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns its month code. The month code for a month that is not a leap month and whose 1-based ordinal position in a common year of the calendar (i.e., a year that is not a leap year) is _n_ should be the string-concatenation of *"M"* and ToZeroPaddedDecimalString(_n_, 2), and the month code for a month that is a leap month inserted after a month whose 1-based ordinal position in a common year of the calendar is _p_ should be the string-concatenation of *"M"*, ToZeroPaddedDecimalString(_p_, 2), and *"L"*.</dd>
          </dl>
          <emu-note>
            For example, in the Hebrew calendar, the month code of Adar (and Adar II, in leap years) is *"M06"* and the month code of Adar I (the leap month inserted before Adar II) is *"M05L"*. In a calendar with a leap month at the start of some years, the month code of that month would be *"M00L"*.
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateday" type="abstract operation">
          <h1>
            CalendarDateDay (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainMonthDay,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs implementation-defined processing to find the day of the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the 1-based ordinal position of that day in the corresponding month.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedayofweek" type="abstract operation">
          <h1>
            CalendarDateDayOfWeek (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the day of the week in the calendar represented by _calendar_. The return value should be 1-based, where 1 is the day corresponding to Monday in the given calendar.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedayofyear" type="abstract operation">
          <h1>
            CalendarDateDayOfYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the day of the year in the calendar represented by _calendar_. The return value should be 1-based.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateweekofyear" type="abstract operation">
          <h1>
            CalendarDateWeekOfYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
            ): a Year-Week Record
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and calculates the <em>calendar week of year</em>, and the corresponding <em>week calendar year</em>, in the calendar represented by _calendar_.</dd>
          </dl>
          <p>
            The value in the [[Week]] field should be 1-based.
          </p>
          <p>
            The value in the [[Year]] field is relative to the first day of a calendar-specific "epoch year", as in CalendarDateYear, not relative to an era as in CalendarDateEraYear.
          </p>
          <p>
            Usually the [[Year]] field will contain the same value given by CalendarDateYear, but may contain the previous or next year if the week number in the [[Week]] field overlaps two different years.
            See also ToISOWeekOfYear.
          </p>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedaysinweek" type="abstract operation">
          <h1>
            CalendarDateDaysInWeek (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the number of days in the given week in the calendar represented by _calendar_.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedaysinmonth" type="abstract operation">
          <h1>
            CalendarDateDaysInMonth (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It identifies the month in the specified calendar that contains _date_ and returns the number of days in that month.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatedaysinyear" type="abstract operation">
          <h1>
            CalendarDateDaysInYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the number of days in the given year in the calendar represented by _calendar_.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatemonthsinyear" type="abstract operation">
          <h1>
            CalendarDateMonthsInYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns the number of months in the given year in the calendar represented by _calendar_.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardateinleapyear" type="abstract operation">
          <h1>
            CalendarDateInLeapYear (
              _calendar_: a String,
              _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
            )
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It takes a date-like object _date_ and returns *true* if it falls within a leap year for the calendar represented by _calendar_ and *false* otherwise.</dd>
          </dl>
          <emu-note>
            A "leap year" is a year that contains more days than other years (for solar or lunar calendars) or more months than other years (for lunisolar calendars like Hebrew or Chinese).
            Some calendars, especially lunisolar ones, have further variation in year length that is not represented in the output of this operation (e.g., the Hebrew calendar includes common years with 353, 354, or 355 days and leap years with 383, 384, or 385 days).
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendardatefields" type="abstract operation">
          <h1>
            CalendarDateFields (
              _calendar_: a String,
              _fields_: a List of Strings,
            ): a List of Strings
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It interprets _fields_ as the names of fields (<emu-xref href="#table-temporal-field-requirements"></emu-xref>) necessary for a given operation and returns a new List by appending the names of additional relevant fields specific to the built-in calendar identified by _calendar_. For example, when _calendar_ is *"gregory"* or *"japanese"*, *"era"* and *"eraYear"* are appended if and only if _fields_ contains *"year"*.</dd>
          </dl>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarfieldkeystoignore" type="abstract operation">
          <h1>
            CalendarFieldKeysToIgnore (
              _calendar_: a String,
              _keys_: a List of property keys,
            ): a List of property keys
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the given _calendar_.
              A field always invalidates at least itself.
            </dd>
          </dl>
          <p>
            This operation is relevant for calendars which accept fields other than the standard set of ISO 8601 calendar fields, in order to implement the Temporal objects' `with()` methods, and `Temporal.Calendar.prototype.mergeFields()` in such a way that the result is free of ambiguity or conflicts.
          </p>
          <p>
            For example, given a _calendar_ that uses eras, such as *"gregory"*, a key in _keys_ being any one of *"year"*, *"era"*, or *"eraYear"* would exclude all three.
            Passing any one of the three to a `with()` method might conflict with either of the other two properties on the receiver object, so those properties of the receiver object should be ignored.
            Given this, in addition to the ISO 8601 mutual exclusion of *"month"* and *"monthCode"* as in ISOFieldKeysToIgnore, a possible implementation might produce the following results when _calendar_ is *"gregory"*:
          </p>
          <emu-table id="table-calendarfieldkeystoignore-example">
            <emu-caption>Example results of CalendarFieldKeysToIgnore</emu-caption>
            <table>
              <thead>
                <tr>
                  <th>_keys_</th>
                  <th>Returned List</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>« *"era"* »</td>
                  <td>« *"era"*, *"eraYear"*, *"year*" »</td>
                </tr>
                <tr>
                  <td>« *"eraYear"* »</td>
                  <td>« *"era"*, *"eraYear"*, *"year"* »</td>
                </tr>
                <tr>
                  <td>« *"year"* »</td>
                  <td>« *"era"*, *"eraYear"*, *"year"* »</td>
                </tr>
                <tr>
                  <td>« *"month"* »</td>
                  <td>« *"month"*, *"monthCode*" »</td>
                </tr>
                <tr>
                  <td>« *"monthCode"* »</td>
                  <td>« *"month"*, *"monthCode"* »</td>
                </tr>
                <tr>
                  <td>« *"day"* »</td>
                  <td>« *"day"* »</td>
                </tr>
                <tr>
                  <td>« *"year"*, *"month"*, *"day"* »</td>
                  <td>« *"era"*, *"eraYear"*, *"year"*, *"month"*, *"monthCode"*, *"day"* »</td>
                </tr>
              </tbody>
            </table>
          </emu-table>
          <emu-note>
            In a _calendar_ such as *"japanese"* where eras do not start and end at year and/or month boundaries, note that the returned List should contain *"era"* and *"eraYear"* if _keys_ contains *"day"*, *"month"*, or *"monthCode"* (not only if it contains *"era"*, *"eraYear"*, or *"year"*, as in the example above) because it's possible for changing the day or month to cause a conflict with the era.
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-temporal-calendarresolvefields" type="abstract operation">
          <h1>
            CalendarResolveFields (
              _calendar_: a String,
              _fields_: an Object,
              _type_: ~date~, ~year-month~, or ~month-day~,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              It performs implementation-defined processing to validate that _fields_ (which describes a date or partial date in the built-in calendar identified by _calendar_) is sufficiently complete to satisfy _type_ and not internally inconsistent, and mutates _fields_ into acceptable input for <emu-xref href="#sec-temporal-calendardatetoiso" title></emu-xref> or <emu-xref href="#sec-temporal-calendarmonthdaytoisoreferencedate" title></emu-xref> by merging data that can be represented in multiple forms into standard properties and removing redundant properties (for example, merging *"month"* and *"monthCode"* into *"month"* and merging *"era"* and *"eraYear"* into *"year"*).
            </dd>
          </dl>
          <p>
            The operation throws a *TypeError* exception if the properties of _fields_ are internally inconsistent within the calendar or insufficient to identify a unique instance of _type_ in the calendar. For example:
          </p>
          <ul>
            <li>If _type_ is ~date~ or ~month-day~ and *"day"* in the calendar has an interpretation analogous to ISO 8601 and its corresponding value is *undefined*.</li>
            <li>If *"month"* and *"monthCode"* in the calendar have interpretations analogous to ISO 8601 and either the corresponding values for both are *undefined* or neither value is *undefined* but they do not identify the same month.</li>
            <li>If _type_ is ~date~ or ~year-month~ and the calendar supports the usual partitioning of years into eras with their own year counting as represented by *"year"*, *"era"*, and *"eraYear"* (as in the Gregorian or traditional Japanese calendars) and any of the following cases apply:<ul>
              <li>The value for each of *"year"* and *"era"* and *"eraYear"* is *undefined*.</li>
              <li>The value for *"era"* is *undefined* but the value for *"eraYear"* is not.</li>
              <li>The value for *"eraYear"* is *undefined* but the value for *"era"* is not.</li>
              <li>None of the three values are *undefined* but the values for *"era"* and *"eraYear"* do not together identify the same year as the value for *"year"*.</li>
            </ul></li>
          </ul>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-calendar-prototype-object">
        <h1>Properties of the Temporal.Calendar Prototype Object</h1>

        <emu-clause id="sup-temporal.calendar.prototype.datefromfields">
          <h1>Temporal.Calendar.prototype.dateFromFields ( _fields_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.datefromfields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _relevantFieldNames_ be « *"day"*, *"month"*, *"monthCode"*, *"year"* ».
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « *"year"*, *"day"* »).
            1. Else,
              1. Let _fieldNames_ be CalendarDateFields(_calendar_.[[Identifier]], _relevantFieldNames_).
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, « »).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? ISODateFromFields(_fields_, _overflow_).
            1. Else,
              1. Perform ? CalendarResolveFields(_calendar_.[[Identifier]], _fields_, ~date~).
              1. Let _result_ be ? CalendarDateToISO(_calendar_.[[Identifier]], _fields_, _overflow_).
            1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_.[[Identifier]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.yearmonthfromfields">
          <h1>Temporal.Calendar.prototype.yearMonthFromFields ( _fields_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.yearmonthfromfields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _relevantFieldNames_ be « *"month"*, *"monthCode"*, *"year"* ».
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « *"year"* »).
            1. Else,
              1. Let _fieldNames_ be CalendarDateFields(_calendar_.[[Identifier]], _relevantFieldNames_).
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, « »).
              1. Let _firstDayIndex_ be the 1-based index of the first day of the month described by _fields_ (i.e., 1 unless the month's first day is skipped by this calendar.)
              1. Perform ! CreateDataPropertyOrThrow(_fields_, *"day"*, 𝔽(_firstDayIndex_)).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? ISOYearMonthFromFields(_fields_, _overflow_).
            1. Else,
              1. Perform ? CalendarResolveFields(_calendar_.[[Identifier]], _fields_, ~year-month~).
              1. Let _result_ be ? CalendarDateToISO(_calendar_.[[Identifier]], _fields_, _overflow_).
              1. Set _result_.[[ReferenceISODay]] to _result_.[[Day]].
            1. Return ? CreateTemporalYearMonth(_result_.[[Year]], _result_.[[Month]], _calendar_.[[Identifier]], _result_.[[ReferenceISODay]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthdayfromfields">
          <h1>Temporal.Calendar.prototype.monthDayFromFields ( _fields_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthdayfromfields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_fields_) is not Object, throw a *TypeError* exception.
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _relevantFieldNames_ be « *"day"*, *"month"*, *"monthCode"*, *"year"* ».
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, « *"day"* »).
            1. Else,
              1. Let _fieldNames_ be CalendarDateFields(_calendar_.[[Identifier]], _relevantFieldNames_).
              1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, « »).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? ISOMonthDayFromFields(_fields_, _overflow_).
            1. Else,
              1. Perform ? CalendarResolveFields(_calendar_.[[Identifier]], _fields_, ~month-day~).
              1. Let _result_ be ? CalendarMonthDayToISOReferenceDate(_calendar_.[[Identifier]], _fields_, _overflow_).
            1. Return ? CreateTemporalMonthDay(_result_.[[Month]], _result_.[[Day]], _calendar_.[[Identifier]], _result_.[[ReferenceISOYear]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dateadd">
          <h1>Temporal.Calendar.prototype.dateAdd ( _date_, _duration_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dateadd"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Set _date_ to ? ToTemporalDate(_date_).
            1. Set _duration_ to ? ToTemporalDuration(_duration_).
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _overflow_ be ? ToTemporalOverflow(_options_).
            1. Let _balanceResult_ be ? <emu-meta suppress-effects="user-code">BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"day"*)</emu-meta>.
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be ? AddISODate(_date_.[[ISOYear]], _date_.[[ISOMonth]], _date_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]], _overflow_).
            1. Else,
              1. Let _balancedDuration_ be ! CreateDateDurationRecord(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]]).
              1. Let _result_ be ? CalendarDateAddition(_calendar_.[[Identifier]], _date_, _balancedDuration_, _overflow_).
            1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_.[[Identifier]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dateuntil">
          <h1>Temporal.Calendar.prototype.dateUntil ( _one_, _two_ [ , _options_ ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dateuntil"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Set _one_ to ? ToTemporalDate(_one_).
            1. Set _two_ to ? ToTemporalDate(_two_).
            1. Set _options_ to ? GetOptionsObject(_options_).
            1. Let _largestUnit_ be ? GetTemporalUnit(_options_, *"largestUnit"*, ~date~, *"auto"*).
            1. If _largestUnit_ is *"auto"*, set _largestUnit_ to *"day"*.
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be DifferenceISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _largestUnit_).
            1. Else,
              1. Let _result_ be ! CalendarDateDifference(_calendar_.[[Identifier]], _one_, _two_, _largestUnit_).
              1. Assert: ! IsValidDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0) is *true*.
            1. Return ! CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal.calendar.prototype.era">
          <h1>Temporal.Calendar.prototype.era ( _temporalDateLike_ )</h1>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return *undefined*.
            1. Return ! CalendarDateEra(_calendar_.[[Identifier]], _temporalDateLike_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-temporal.calendar.prototype.erayear">
          <h1>Temporal.Calendar.prototype.eraYear ( _temporalDateLike_ )</h1>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return *undefined*.
            1. Let _eraYear_ be ! CalendarDateEraYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. If _eraYear_ is *undefined*, then
              1. Return *undefined*.
            1. Return 𝔽(_eraYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.year">
          <h1>Temporal.Calendar.prototype.year ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.year"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Assert: _temporalDateLike_ has an [[ISOYear]] internal slot.
              1. Let _year_ be _temporalDateLike_.[[ISOYear]].
            1. Else,
              1. Let _year_ be ! CalendarDateYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_year_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.month">
          <h1>Temporal.Calendar.prototype.month ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.month"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is Object and _temporalDateLike_ has an [[InitializedTemporalMonthDay]] internal slot, then
              1. Throw a *TypeError* exception.
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Assert: _temporalDateLike_ has an [[ISOMonth]] internal slot.
              1. Let _month_ be _temporalDateLike_.[[ISOMonth]].
            1. Else,
              1. Let _month_ be ! CalendarDateMonth(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_month_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthcode">
          <h1>Temporal.Calendar.prototype.monthCode ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthcode"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Assert: _temporalDateLike_ has an [[ISOMonth]] internal slot.
              1. Let _monthCode_ be ISOMonthCode(_temporalDateLike_.[[ISOMonth]]).
            1. Else,
              1. Let _monthCode_ be ! CalendarDateMonthCode(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return _monthCode_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.day">
          <h1>Temporal.Calendar.prototype.day ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.day"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalMonthDay]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Assert: _temporalDateLike_ has an [[ISODay]] internal slot.
              1. Let _day_ be _temporalDateLike_.[[ISODay]].
            1. Else,
              1. Let _day_ be ! CalendarDateDay(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_day_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dayofweek">
          <h1>Temporal.Calendar.prototype.dayOfWeek ( _dateOrDateTime_ )</h1>
          <p>This definition supersedes the definition _temporalDateLike_ in <emu-xref href="#sec-temporal.calendar.prototype.dayofweek"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return 𝔽(ToISODayOfWeek(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
            1. Let _dayOfWeek_ be ! CalendarDateDayOfWeek(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_dayOfWeek_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.dayofyear">
          <h1>Temporal.Calendar.prototype.dayOfYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.dayofyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return 𝔽(ToISODayOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
            1. Let _dayOfYear_ be ! CalendarDateDayOfYear(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_dayOfYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.weekofyear">
          <h1>Temporal.Calendar.prototype.weekOfYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.weekofyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _yearWeek_ be ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
            1. Else,
              1. Let _yearWeek_ be CalendarDateWeekOfYear(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_yearWeek_.[[Week]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.yearofweek">
          <h1>Temporal.Calendar.prototype.yearOfWeek ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.yearofweek"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _yearWeek_ be ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
            1. Else,
              1. Let _yearWeek_ be CalendarDateWeekOfYear(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_yearWeek_.[[Year]]).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinweek">
          <h1>Temporal.Calendar.prototype.daysInWeek ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinweek"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _daysInWeek_ be 7.
            1. Else,
              1. Let _daysInWeek_ be ! CalendarDateDaysInWeek(_calendar_.[[Identifier]], _temporalDate_).
            1. Return 𝔽(_daysInWeek_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinmonth">
          <h1>Temporal.Calendar.prototype.daysInMonth ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinmonth"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slots, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _daysInMonth_ be ISODaysInMonth(_temporalDateLike_.[[ISOYear]], _temporalDateLike_.[[ISOMonth]]).
            1. Else,
              1. Let _daysInMonth_ be ! CalendarDateDaysInMonth(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_daysInMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.daysinyear">
          <h1>Temporal.Calendar.prototype.daysInYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.daysinyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Return DaysInYear(𝔽(_temporalDateLike_.[[ISOYear]])).
            1. Let _daysInYear_ be ! CalendarDateDaysInYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_daysInYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.monthsinyear">
          <h1>Temporal.Calendar.prototype.monthsInYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.monthsinyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _monthsInYear_ be 12.
            1. Else,
              1. Let _monthsInYear_ be ! CalendarDateMonthsInYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return 𝔽(_monthsInYear_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.inleapyear">
          <h1>Temporal.Calendar.prototype.inLeapYear ( _temporalDateLike_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.inleapyear"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
              1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. If InLeapYear(TimeFromYear(𝔽(_temporalDateLike_.[[ISOYear]]))) is *1*<sub>𝔽</sub>, then
                1. Let _inLeapYear_ be *true*.
              1. Else,
                1. Let _inLeapYear_ be *false*.
            1. Else,
              1. Let _inLeapYear_ be ! CalendarDateInLeapYear(_calendar_.[[Identifier]], _temporalDateLike_).
            1. Return _inLeapYear_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.fields">
          <h1>Temporal.Calendar.prototype.fields ( _fields_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.fields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Let _iteratorRecord_ be ? GetIterator(_fields_, ~sync~).
            1. Let _fieldNames_ be a new empty List.
            1. Let _next_ be *true*.
            1. Repeat, while _next_ is not *false*,
              1. Set _next_ to ? IteratorStep(_iteratorRecord_).
              1. If _next_ is not *false*, then
                1. Let _nextValue_ be ? IteratorValue(_next_).
                1. If Type(_nextValue_) is not String, then
                  1. Let _completion_ be ThrowCompletion(a newly created *TypeError* object).
                  1. Return ? IteratorClose(_iteratorRecord_, _completion_).
                1. If _fieldNames_ contains _nextValue_, then
                  1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
                  1. Return ? IteratorClose(_iteratorRecord_, _completion_).
                1. If _nextValue_ is not one of *"year"*, *"month"*, *"monthCode"*, *"day"*, *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"*, then
                    1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
                    1. Return ? IteratorClose(_iteratorRecord_, _completion_).
                1. Append _nextValue_ to the end of the List _fieldNames_.
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _result_ be _fieldNames_.
            1. Else,
              1. Let _result_ be CalendarDateFields(_calendar_.[[Identifier]], _fieldNames_).
            1. Return CreateArrayFromList(_result_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sup-temporal.calendar.prototype.mergefields">
          <h1>Temporal.Calendar.prototype.mergeFields ( _fields_, _additionalFields_ )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.calendar.prototype.mergefields"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _calendar_ be the *this* value.
            1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
            1. Set _fields_ to ? ToObject(_fields_).
            1. Let _fieldsCopy_ be OrdinaryObjectCreate(*null*).
            1. Perform ? CopyDataProperties(_fieldsCopy_, _fields_, « », « *undefined* »).
            1. Set _additionalFields_ to ? ToObject(_additionalFields_).
            1. Let _additionalFieldsCopy_ be OrdinaryObjectCreate(*null*).
            1. Perform ? CopyDataProperties(_additionalFieldsCopy_, _additionalFields_, « », « *undefined* »).
            1. NOTE: Every property of _fieldsCopy_ and _additionalFieldsCopy_ is an enumerable data property with non-*undefined* value, but some property keys may be Symbols.
            1. Let _additionalKeys_ be ! _additionalFieldsCopy_.[[OwnPropertyKeys]]().
            1. If _calendar_.[[Identifier]] is *"iso8601"*, then
              1. Let _overriddenKeys_ be ISOFieldKeysToIgnore(_additionalKeys_).
            1. Else,
              1. Let _overriddenKeys_ be CalendarFieldKeysToIgnore(_calendar_, _additionalKeys_).
            1. Let _merged_ be OrdinaryObjectCreate(*null*).
            1. NOTE: The following steps ensure that property iteration order of _merged_ matches that of _fields_ as modified by omitting overridden properties and appending non-overlapping properties from _additionalFields_ in iteration order.
            1. Let _fieldsKeys_ be ! _fieldsCopy_.[[OwnPropertyKeys]]().
            1. For each element _key_ of _fieldsKeys_, do
              1. Let _propValue_ be *undefined*.
              1. If _overriddenKeys_ contains _key_, then
                1. Set _propValue_ to ! Get(_additionalFieldsCopy_, _key_).
              1. Else,
                1. Set _propValue_ to ! Get(_fieldsCopy_, _key_).
              1. If _propValue_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_merged_, _key_, _propValue_).
            1. Perform ! CopyDataProperties(_merged_, _additionalFieldsCopy_, « »).
            1. Return _merged_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-duration-prototype-object">
        <h1>Properties of the Temporal.Duration Prototype Object</h1>
        <emu-clause id="sup-temporal.duration.prototype.tolocalestring">
          <h1>Temporal.Duration.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <emu-note type="editor">
            <p>
              This function is currently not specified.
              See <a href="https://tc39.es/proposal-intl-duration-format/">the Intl.DurationFormat proposal</a>.
            </p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-instant-prototype-object">
        <h1>Properties of the Temporal.Instant Prototype Object</h1>
        <emu-clause id="sup-temporal.instant.prototype.tolocalestring">
          <h1>Temporal.Instant.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.instant.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _instant_ be the *this* value.
            1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _instant_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaindate-prototype-object">
        <h1>Properties of the Temporal.PlainDate Prototype Object</h1>
        <emu-clause id="sup-temporal.plaindate.prototype.tolocalestring">
          <h1>Temporal.PlainDate.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaindate.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _temporalDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _temporalDate_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindate.prototype.era">
          <h1>get Temporal.PlainDate.prototype.era</h1>
          <p>
            `Temporal.PlainDate.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
            1. Let _calendar_ be _plainDate_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainDate_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindate.prototype.erayear">
          <h1>get Temporal.PlainDate.prototype.eraYear</h1>
          <p>
            `Temporal.PlainDate.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDate_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
            1. Let _calendar_ be _plainDate_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainDate_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaindatetime-prototype-object">
        <h1>Properties of the Temporal.PlainDateTime Prototype Object</h1>
        <emu-clause id="sup-temporal.plaindatetime.prototype.tolocalestring">
          <h1>Temporal.PlainDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaindatetime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _dateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _dateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindatetime.prototype.era">
          <h1>get Temporal.PlainDateTime.prototype.era</h1>
          <p>
            `Temporal.PlainDate.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
            1. Let _calendar_ be _plainDateTime_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plaindatetime.prototype.erayear">
          <h1>get Temporal.PlainDateTime.prototype.eraYear</h1>
          <p>
            `Temporal.PlainDateTime.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
            1. Let _calendar_ be _plainDateTime_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plainmonthday-prototype-object">
        <h1>Properties of the Temporal.PlainMonthDay Prototype Object</h1>
          <emu-clause id="sup-temporal.plainmonthday.prototype.tolocalestring">
          <h1>Temporal.PlainMonthDay.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plainmonthday.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _monthDay_ be the *this* value.
            1. Perform ? RequireInternalSlot(_monthDay_, [[InitializedTemporalMonthDay]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _monthDay_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plaintime-prototype-object">
        <h1>Properties of the Temporal.PlainTime Prototype Object</h1>
        <emu-clause id="sup-temporal.plaintime.prototype.tolocalestring">
          <h1>Temporal.PlainTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaintime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _temporalTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _temporalTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-plainyearmonth-prototype-object">
        <h1>Properties of the Temporal.PlainYearMonth Prototype Object</h1>
        <emu-clause id="sup-temporal.plainyearmonth.prototype.tolocalestring">
          <h1>Temporal.PlainYearMonth.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plainyearmonth.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _yearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_yearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _yearMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plainyearmonth.prototype.era">
          <h1>get Temporal.PlainYearMonth.prototype.era</h1>
          <p>
            `Temporal.PlainYearMonth.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainYearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainYearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _calendar_ be _plainYearMonth_.[[Calendar]].
            1. Return ? CalendarEra(_calendar_, _plainYearMonth_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.plainyearmonth.prototype.erayear">
          <h1>get Temporal.PlainYearMonth.prototype.eraYear</h1>
          <p>
            `Temporal.PlainYearMonth.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _plainYearMonth_ be the *this* value.
            1. Perform ? RequireInternalSlot(_plainYearMonth_, [[InitializedTemporalYearMonth]]).
            1. Let _calendar_ be _plainYearMonth_.[[Calendar]].
            1. Return ? CalendarEraYear(_calendar_, _plainYearMonth_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sup-properties-of-the-temporal-zoneddatetime-prototype-object">
        <h1>Properties of the Temporal.ZonedDateTime Prototype Object</h1>
        <emu-clause id="sup-temporal.zoneddatetime.prototype.tolocalestring">
          <h1>Temporal.ZonedDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
          <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.zoneddatetime.prototype.tolocalestring"></emu-xref>.</p>
          <p>
            This method performs the following steps when called:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
            1. Return ? FormatDateTime(_dateFormat_, _zonedDateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.zoneddatetime.prototype.era">
          <h1>get Temporal.ZonedDateTime.prototype.era</h1>
          <p>
            `Temporal.ZonedDateTime.prototype.era` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
            1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
            1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
            1. Let _plainDateTime_ be ? GetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
            1. Return ? CalendarEra(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-get-temporal.zoneddatetime.prototype.erayear">
          <h1>get Temporal.ZonedDateTime.prototype.eraYear</h1>
          <p>
            `Temporal.ZonedDateTime.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
            Its get accessor function performs the following steps:
          </p>
          <emu-alg>
            1. Let _zonedDateTime_ be the *this* value.
            1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
            1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
            1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
            1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
            1. Let _plainDateTime_ be ? GetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
            1. Return ? CalendarEraYear(_calendar_, _plainDateTime_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>
