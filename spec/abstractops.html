<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-abstract-ops">
  <h1>Abstract operations</h1>

  <!-- Based on ECMA-262 IterableToList -->
  <emu-clause id="sec-iterabletolistoftype" aoid="IterableToListOfType">
    <h1>IterableToListOfType ( _items_, _elementTypes_ )</h1>
    <p>
      The abstract operation IterableToListOfType takes arguments _items_ and _elementTypes_ (a List of names of ECMAScript Language Types).
      It is used to create a List value whose elements are provided by the values of the iterable _items_.
      _elementTypes_ contains the names of ECMAScript Language Types that are allowed for element values of the List that is created.
      It performs the following steps when called:
    </p>
    <emu-alg>
      1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~).
      1. Let _values_ be a new empty List.
      1. Let _next_ be *true*.
      1. Repeat, while _next_ is not *false*,
        1. Set _next_ to ? IteratorStep(_iteratorRecord_).
        1. If _next_ is not *false*, then
          1. Let _nextValue_ be ? IteratorValue(_next_).
          1. If Type(_nextValue_) is not an element of _elementTypes_, then
            1. Let _completion_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iteratorRecord_, _completion_).
          1. Append _nextValue_ to the end of the List _values_.
      1. Return _values_.
    </emu-alg>
  </emu-clause>

  <!-- Copied from ECMA-402 GetOptionsObject -->
  <emu-clause id="sec-getoptionsobject" aoid="GetOptionsObject">
    <h1>GetOptionsObject ( _options_ )</h1>
    <p>
      The abstract operation GetOptionsObject returns an Object suitable for use with GetOption, either _options_ itself or a default empty Object.
      It throws a TypeError if _options_ is not undefined and not an Object.
    </p>
    <emu-alg>
      1. If _options_ is *undefined*, then
        1. Return OrdinaryObjectCreate(*null*).
      1. If Type(_options_) is Object, then
        1. Return _options_.
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>

  <!-- Copied from ECMA-402 GetOption -->
  <emu-clause id="sec-getoption" type="abstract operation">
    <h1>
      GetOption (
        _options_: an Object,
        _property_: a property key,
        _type_: *"boolean"*, *"number"*, or *"string"*,
        _values_: *undefined* or a List of ECMAScript language values,
        _default_: ~required~ or an ECMAScript language value,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It extracts the value of the specified property of _options_, converts it to the required _type_, checks whether it is allowed by _values_ if _values_ is not *undefined*, and substitutes _default_ if the value is *undefined*.</dd>
    </dl>
    <emu-alg>
      1. Let _value_ be ? Get(_options_, _property_).
      1. If _value_ is *undefined*, then
        1. If _default_ is ~required~, throw a *RangeError* exception.
        1. Return _default_.
      1. If _type_ is *"boolean"*, then
        1. Set _value_ to ToBoolean(_value_).
      1. Else if _type_ is *"number"*, then
        1. Set _value_ to ? ToNumber(_value_).
        1. If _value_ is *NaN*, throw a *RangeError* exception.
      1. Else,
        1. Assert: _type_ is *"string"*.
        1. Set _value_ to ? ToString(_value_).
      1. If _values_ is not *undefined* and _values_ does not contain an element equal to _value_, throw a *RangeError* exception.
      1. Return _value_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporaloverflow" aoid="ToTemporalOverflow">
    <h1>ToTemporalOverflow ( _options_ )</h1>
    <emu-alg>
      1. If _options_ is *undefined*, return *"constrain"*.
      1. Return ? GetOption(_options_, *"overflow"*, *"string"*, ¬´ *"constrain"*, *"reject"* ¬ª, *"constrain"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporaldisambiguation" aoid="ToTemporalDisambiguation">
    <h1>ToTemporalDisambiguation ( _options_ )</h1>
    <emu-alg>
      1. If _options_ is *undefined*, return *"compatible"*.
      1. Return ? GetOption(_options_, *"disambiguation"*, *"string"*, ¬´ *"compatible"*, *"earlier"*, *"later"*, *"reject"* ¬ª, *"compatible"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporalroundingmode" aoid="ToTemporalRoundingMode">
    <h1>ToTemporalRoundingMode ( _normalizedOptions_, _fallback_ )</h1>
    <p>
      The abstract operation ToTemporalRoundingMode extracts the value of the property named *"roundingMode"* from _normalizedOptions_ and makes sure it is a valid value for the option.
      The value _fallback_ is returned if the property is not present.
    </p>
    <emu-note type="editor">
      <p>
        The rounding modes accepted by this abstract operation (and therefore in the Temporal API) are intended to be the same as whatever is eventually standardized in the <a href="https://github.com/tc39/proposal-intl-numberformat-v3">Intl.NumberFormat V3</a> proposal.
      </p>
    </emu-note>
    <emu-alg>
      1. Return ? GetOption(_normalizedOptions_, *"roundingMode"*, *"string"*, ¬´ *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, *"halfEven"* ¬ª, _fallback_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-negatetemporalroundingmode" aoid="NegateTemporalRoundingMode">
    <h1>NegateTemporalRoundingMode ( _roundingMode_ )</h1>
    <p>
      The abstract operation NegateTemporalRoundingMode returns the correct rounding mode to use when rounding the negative of a value that was originally given with _roundingMode_.
    </p>
    <emu-note type="editor">
      <p>
        The rounding modes accepted by this abstract operation (and therefore in the Temporal API) are intended to be the same as whatever is eventually standardized in the <a href="https://github.com/tc39/proposal-intl-numberformat-v3">Intl.NumberFormat V3</a> proposal.
      </p>
    </emu-note>
    <emu-alg>
      1. If _roundingMode_ is *"ceil"*, return *"floor"*.
      1. If _roundingMode_ is *"floor"*, return *"ceil"*.
      1. If _roundingMode_ is *"halfCeil"*, return *"halfFloor"*.
      1. If _roundingMode_ is *"halfFloor"*, return *"halfCeil"*.
      1. Return _roundingMode_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporaloffset" aoid="ToTemporalOffset">
    <h1>ToTemporalOffset ( _options_, _fallback_ )</h1>
    <p>
      The abstract operation ToTemporalOffset extracts the value of the property named *"offset"* from _options_ and makes sure it is a valid value for the option.
      The value _fallback_ is returned if the property is not present.
    </p>
    <emu-alg>
      1. If _options_ is *undefined*, return _fallback_.
      1. Return ? GetOption(_options_, *"offset"*, *"string"*, ¬´ *"prefer"*, *"use"*, *"ignore"*, *"reject"* ¬ª, _fallback_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-tocalendarnameoption" type="abstract operation">
    <h1>
      ToCalendarNameOption (
        _normalizedOptions_: an Object,
      ): either a normal completion containing a String, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It extracts the value of the property named *"calendarName"* from _normalizedOptions_ and makes sure it is a valid value for the option.</dd>
    </dl>
    <emu-note>
      This property is used in `toString` methods in Temporal to control whether a calendar annotation should be output.
    </emu-note>
    <emu-alg>
      1. Return ? GetOption(_normalizedOptions_, *"calendarName"*, *"string"*, ¬´ *"auto"*, *"always"*, *"never"*, *"critical"* ¬ª, *"auto"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totimezonenameoption" type="abstract operation">
    <h1>
      ToTimeZoneNameOption (
        _normalizedOptions_: an Object,
      ): either a normal completion containing a String, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It extracts the value of the property named *"timeZoneName"* from _normalizedOptions_ and makes sure it is a valid value for the option.</dd>
    </dl>
    <emu-note>
      This property is used in `Temporal.ZonedDateTime.prototype.toString()`.
      It is different from the `timeZone` property passed to `Temporal.ZonedDateTime.from()` and from the `timeZone` property in the options passed to `Temporal.Instant.prototype.toString()`.
    </emu-note>
    <emu-alg>
      1. Return ? GetOption(_normalizedOptions_, *"timeZoneName"*, *"string"*, ¬´ *"auto"*, *"never"*, *"critical"* ¬ª, *"auto"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-toshowoffsetoption" aoid="ToShowOffsetOption">
    <h1>ToShowOffsetOption ( _normalizedOptions_ )</h1>
    <p>
      The abstract operation ToShowOffsetOption extracts the value of the property named *"offset"* from _normalizedOptions_ and makes sure it is a valid value for the option.
    </p>
    <emu-note>
      This property is used in `Temporal.ZonedDateTime.prototype.toString()`.
      It is different from the `offset` property passed to `Temporal.ZonedDateTime.from()`.
    </emu-note>
    <emu-alg>
      1. Return ? GetOption(_normalizedOptions_, *"offset"*, *"string"*, ¬´ *"auto"*, *"never"* ¬ª, *"auto"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporalroundingincrement" type="abstract operation">
    <h1>
      ToTemporalRoundingIncrement (
        _normalizedOptions_: an Object,
      ): either a normal completion containing a Number, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It extracts the value of the property named *"roundingIncrement"* from _normalizedOptions_, makes sure it is a finite Number greater than or equal to 1, and returns that value.
        It performs no further validation.
      </dd>
    </dl>
    <emu-alg>
      1. Let _increment_ be ? GetOption(_normalizedOptions_, *"roundingIncrement"*, *"number"*, *undefined*, *1*<sub>ùîΩ</sub>).
      1. If _increment_ is not finite, throw a *RangeError* exception.
      1. If _increment_ &lt; *1*<sub>ùîΩ</sub>, throw a *RangeError* exception.
      1. Return _increment_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-validatetemporalroundingincrement" type="abstract operation">
    <h1>
      ValidateTemporalRoundingIncrement (
        _increment_: a Number,
        _dividend_: a positive integer,
        _inclusive_: a Boolean,
      ): either a normal completion containing an integer, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It truncates an _increment_ from ToTemporalRoundingIncrement to an integer and returns the result if it evenly divides _dividend_, otherwise throwing a *RangeError*.
        _dividend_ must be divided into more than one part unless _inclusive_ is *true*.
      </dd>
    </dl>
    <emu-alg>
      1. If _inclusive_ is *true*, then
        1. Let _maximum_ be ùîΩ(_dividend_).
      1. Else if _dividend_ is more than 1, then
        1. Let _maximum_ be ùîΩ(_dividend_ - 1).
      1. Else,
        1. Let _maximum_ be *1*<sub>ùîΩ</sub>.
      1. If _increment_ &gt; _maximum_, throw a *RangeError* exception.
      1. Set _increment_ to floor(‚Ñù(_increment_)).
      1. If _dividend_ modulo _increment_ &ne; 0, then
        1. Throw a *RangeError* exception.
      1. Return _increment_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-tosecondsstringprecision" aoid="ToSecondsStringPrecision">
    <h1>ToSecondsStringPrecision ( _normalizedOptions_ )</h1>
    <p>
      The abstract operation ToSecondsStringPrecision combines the values of the options `smallestUnit` and `fractionalSecondDigits` to yield a precision for printing minutes and seconds to a string, and a rounding unit and increment.
      The precision may be an integer 0 through 9 signifying a number of digits after the decimal point in the seconds, the string *"minute"* signifying not to print seconds at all, or the string *"auto"* signifying to drop trailing zeroes after the decimal point.
    </p>
    <emu-alg>
      1. Let _smallestUnit_ be ? GetTemporalUnit(_normalizedOptions_, *"smallestUnit"*, ~time~, *undefined*).
      1. If _smallestUnit_ is *"hour"*, throw a *RangeError* exception.
      1. If _smallestUnit_ is *"minute"*, then
        1. Return the Record {
            [[Precision]]: *"minute"*,
            [[Unit]]: *"minute"*,
            [[Increment]]: 1
          }.
      1. If _smallestUnit_ is *"second"*, then
        1. Return the Record {
            [[Precision]]: 0,
            [[Unit]]: *"second"*,
            [[Increment]]: 1
          }.
      1. If _smallestUnit_ is *"millisecond"*, then
        1. Return the Record {
            [[Precision]]: 3,
            [[Unit]]: *"millisecond"*,
            [[Increment]]: 1
          }.
      1. If _smallestUnit_ is *"microsecond"*, then
        1. Return the Record {
            [[Precision]]: 6,
            [[Unit]]: *"microsecond"*,
            [[Increment]]: 1
          }.
      1. If _smallestUnit_ is *"nanosecond"*, then
        1. Return the Record {
            [[Precision]]: 9,
            [[Unit]]: *"nanosecond"*,
            [[Increment]]: 1
          }.
      1. Assert: _smallestUnit_ is *undefined*.
      1. Let _fractionalDigitsVal_ be ? Get(_normalizedOptions_, *"fractionalSecondDigits"*).
      1. If Type(_fractionalDigitsVal_) is not Number, then
        1. If _fractionalDigitsVal_ is not *undefined*, then
          1. If ? ToString(_fractionalDigitsVal_) is not *"auto"*, throw a *RangeError* exception.
        1. Return the Record {
            [[Precision]]: *"auto"*,
            [[Unit]]: *"nanosecond"*,
            [[Increment]]: 1
          }.
      1. If _fractionalDigitsVal_ is *NaN*, *+&infin;*<sub>ùîΩ</sub>, or *-&infin;*<sub>ùîΩ</sub>, throw a *RangeError* exception.
      1. Let _fractionalDigitCount_ be truncate(‚Ñù(_fractionalDigitsVal_)).
      1. If _fractionalDigitCount_ &lt; 0 or _fractionalDigitCount_ &gt; 9, throw a *RangeError* exception.
      1. If _fractionalDigitCount_ is 0, then
        1. Return the Record {
            [[Precision]]: 0,
            [[Unit]]: *"second"*,
            [[Increment]]: 1
          }.
      1. If _fractionalDigitCount_ is 1, 2, or 3, then
        1. Return the Record {
            [[Precision]]: _fractionalDigitCount_,
            [[Unit]]: *"millisecond"*,
            [[Increment]]: 10<sup>3 - _fractionalDigitCount_</sup>
          }.
      1. If _fractionalDigitCount_ is 4, 5, or 6, then
        1. Return the Record {
            [[Precision]]: _fractionalDigitCount_,
            [[Unit]]: *"microsecond"*,
            [[Increment]]: 10<sup>6 - _fractionalDigitCount_</sup>
          }.
      1. Assert: _fractionalDigitCount_ is 7, 8, or 9.
      1. Return the Record {
          [[Precision]]: _fractionalDigitCount_,
          [[Unit]]: *"nanosecond"*,
          [[Increment]]: 10<sup>9 - _fractionalDigitCount_</sup>
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-gettemporalunit" type="abstract operation">
    <h1>
      GetTemporalUnit (
        _normalizedOptions_: an Object,
        _key_: a property key,
        _unitGroup_: ~date~, ~time~, or ~datetime~,
        _default_: ~required~ or an ECMAScript language value,
        optional _extraValues_: a List of ECMAScript language values,
      ): either a normal completion containing an ECMAScript language value, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It attempts to read from the specified property of _normalizedOptions_ a Temporal unit that is <emu-not-ref>covered</emu-not-ref> by the union of _unitGroup_ and _extraValues_, substituting _default_ if the property value is *undefined*.</dd>
    </dl>
    <p>
      Both singular and plural unit names are accepted, but only the singular form is used internally.
    </p>
    <emu-alg>
      1. Let _singularNames_ be a new empty List.
      1. For each row of <emu-xref href="#table-temporal-units"></emu-xref>, except the header row, in table order, do
        1. Let _unit_ be the value in the Singular column of the row.
        1. If the Category column of the row is ~date~ and _unitGroup_ is ~date~ or ~datetime~, append _unit_ to _singularNames_.
        1. Else if the Category column of the row is ~time~ and _unitGroup_ is ~time~ or ~datetime~, append _unit_ to _singularNames_.
      1. If _extraValues_ is present, then
        1. Set _singularNames_ to the list-concatenation of _singularNames_ and _extraValues_.
      1. If _default_ is ~required~, then
        1. Let _defaultValue_ be *undefined*.
      1. Else,
        1. Let _defaultValue_ be _default_.
        1. If _defaultValue_ is not *undefined* and _singularNames_ does not contain _defaultValue_, then
          1. Append _defaultValue_ to _singularNames_.
      1. Let _allowedValues_ be a copy of _singularNames_.
      1. For each element _singularName_ of _singularNames_, do
        1. If _singularName_ is listed in the Singular column of <emu-xref href="#table-temporal-units"></emu-xref>, then
          1. Let _pluralName_ be the value in the Plural column of the corresponding row.
          1. Append _pluralName_ to _allowedValues_.
      1. NOTE: For each singular Temporal unit name that is contained within _allowedValues_, the corresponding plural name is also contained within it.
      1. Let _value_ be ? GetOption(_normalizedOptions_, _key_, *"string"*, _allowedValues_, _defaultValue_).
      1. If _value_ is *undefined* and _default_ is ~required~, throw a *RangeError* exception.
      1. If _value_ is listed in the Plural column of <emu-xref href="#table-temporal-units"></emu-xref>, then
        1. Set _value_ to the value in the Singular column of the corresponding row.
      1. Return _value_.
    </emu-alg>
    <emu-table id="table-temporal-units">
      <emu-caption>Temporal units by descending magnitude</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Singular</th>
            <th>Plural</th>
            <th>Category</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>*"year"*</td>
            <td>*"years"*</td>
            <td>~date~</td>
          </tr>

          <tr>
            <td>*"month"*</td>
            <td>*"months"*</td>
            <td>~date~</td>
          </tr>

          <tr>
            <td>*"week"*</td>
            <td>*"weeks"*</td>
            <td>~date~</td>
          </tr>

          <tr>
            <td>*"day"*</td>
            <td>*"days"*</td>
            <td>~date~</td>
          </tr>

          <tr>
            <td>*"hour"*</td>
            <td>*"hours"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"minute"*</td>
            <td>*"minutes"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"second"*</td>
            <td>*"seconds"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"millisecond"*</td>
            <td>*"milliseconds"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"microsecond"*</td>
            <td>*"microseconds"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"nanosecond"*</td>
            <td>*"nanoseconds"*</td>
            <td>~time~</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-torelativetemporalobject" aoid="ToRelativeTemporalObject">
    <h1>ToRelativeTemporalObject ( _options_ )</h1>
    <p>
      The abstract operation ToRelativeTemporalObject examines the value of the `relativeTo` property of its _options_ argument.
      If this is not present, it returns *undefined*.
      Otherwise, it attempts to return a Temporal.ZonedDateTime instance or Temporal.PlainDate instance, in order of preference, by converting the value.
      If neither of those are possible, the operation throws a *RangeError*.
    </p>
    <emu-alg>
      1. Assert: Type(_options_) is Object.
      1. Let _value_ be ? Get(_options_, *"relativeTo"*).
      1. If _value_ is *undefined*, then
        1. Return _value_.
      1. Let _offsetBehaviour_ be ~option~.
      1. Let _matchBehaviour_ be ~match exactly~.
      1. If Type(_value_) is Object, then
        1. If _value_ has either an [[InitializedTemporalDate]] or [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return _value_.
        1. If _value_ has an [[InitializedTemporalDateTime]] internal slot, then
          1. Return ! CreateTemporalDate(_value_.[[ISOYear]], _value_.[[ISOMonth]], _value_.[[ISODay]], _value_.[[Calendar]]).
        1. Let _calendar_ be ? GetTemporalCalendarWithISODefault(_value_).
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"monthCode"*, *"nanosecond"*, *"second"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_value_, _fieldNames_, ¬´¬ª).
        1. Let _dateOptions_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_dateOptions_, *"overflow"*, *"constrain"*).
        1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _dateOptions_).
        1. Let _offsetString_ be ? Get(_value_, *"offset"*).
        1. Let _timeZone_ be ? Get(_value_, *"timeZone"*).
        1. If _timeZone_ is not *undefined*, then
          1. Set _timeZone_ to ? ToTemporalTimeZone(_timeZone_).
        1. If _offsetString_ is *undefined*, then
          1. Set _offsetBehaviour_ to ~wall~.
      1. Else,
        1. Let _string_ be ? ToString(_value_).
        1. Let _result_ be ? ParseTemporalRelativeToString(_string_).
        1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_result_.[[Calendar]]).
        1. Let _offsetString_ be _result_.[[TimeZone]].[[OffsetString]].
        1. Let _timeZoneName_ be _result_.[[TimeZone]].[[Name]].
        1. If _timeZoneName_ is *undefined*, then
          1. Let _timeZone_ be *undefined*.
        1. Else,
          1. If IsTimeZoneOffsetString(_timeZoneName_) is *false*, then
            1. If IsAvailableTimeZoneName(_timeZoneName_) is *false*, throw a *RangeError* exception.
            1. Set _timeZoneName_ to ! CanonicalizeTimeZoneName(_timeZoneName_).
          1. Let _timeZone_ be ! CreateTemporalTimeZone(_timeZoneName_).
          1. If _result_.[[TimeZone]].[[Z]] is *true*, then
            1. Set _offsetBehaviour_ to ~exact~.
          1. Else if _offsetString_ is *undefined*, then
            1. Set _offsetBehaviour_ to ~wall~.
          1. Set _matchBehaviour_ to ~match minutes~.
      1. If _timeZone_ is *undefined*, then
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      1. If _offsetBehaviour_ is ~option~, then
        1. Set _offsetString_ to ? ToString(_offsetString_).
        1. If IsTimeZoneOffsetString(_offsetString_) is *false*, throw a *RangeError* exception.
        1. Let _offsetNs_ be ParseTimeZoneOffsetString(_offsetString_).
      1. Else,
        1. Let _offsetNs_ be 0.
      1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _offsetBehaviour_, _offsetNs_, _timeZone_, *"compatible"*, *"reject"*, _matchBehaviour_).
      1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-largeroftwotemporalunits" aoid="LargerOfTwoTemporalUnits">
    <h1>LargerOfTwoTemporalUnits ( _u1_, _u2_ )</h1>
    <p>
      The abstract operation LargerOfTwoTemporalUnits, given two strings representing Temporal units, returns the string representing the larger of the two units.
    </p>
    <emu-alg>
      1. Assert: Both _u1_ and _u2_ are listed in the Singular column of <emu-xref href="#table-temporal-units"></emu-xref>.
      1. For each row of <emu-xref href="#table-temporal-units"></emu-xref>, except the header row, in table order, do
        1. Let _unit_ be the value in the Singular column of the row.
        1. If SameValue(_u1_, _unit_) is *true*, return _unit_.
        1. If SameValue(_u2_, _unit_) is *true*, return _unit_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-maximumtemporaldurationroundingincrement" aoid="MaximumTemporalDurationRoundingIncrement">
    <h1>MaximumTemporalDurationRoundingIncrement ( _unit_ )</h1>
    <emu-alg>
      1. If _unit_ is *"year"*, *"month"*, *"week"*, or *"day"*, then
        1. Return *undefined*.
      1. If _unit_ is *"hour"*, then
        1. Return 24.
      1. If _unit_ is *"minute"* or *"second"*, then
        1. Return 60.
      1. Assert: _unit_ is one of *"millisecond"*, *"microsecond"*, or *"nanosecond"*.
      1. Return 1000.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-rejectobjectwithcalendarortimezone" aoid="RejectObjectWithCalendarOrTimeZone">
    <h1>RejectObjectWithCalendarOrTimeZone ( _object_ )</h1>
    <p>
      The abstract operation RejectObjectWithCalendarOrTimeZone throws an exception if its argument _object_ is an instance of one of the Temporal types that carries a calendar or time zone, or is an object that has a `calendar` or `timeZone` property.
    </p>
    <emu-alg>
      1. Assert: Type(_object_) is Object.
      1. If _object_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalTime]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
        1. Throw a *TypeError* exception.
      1. Let _calendarProperty_ be ? Get(_object_, *"calendar"*).
      1. If _calendarProperty_ is not *undefined*, then
        1. Throw a *TypeError* exception.
      1. Let _timeZoneProperty_ be ? Get(_object_, *"timeZone"*).
      1. If _timeZoneProperty_ is not *undefined*, then
        1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-formatsecondsstringpart" aoid="FormatSecondsStringPart">
    <h1>FormatSecondsStringPart ( _second_, _millisecond_, _microsecond_, _nanosecond_, _precision_ )</h1>
    <emu-alg>
      1. Assert: _second_, _millisecond_, _microsecond_, and _nanosecond_ are integers.
      1. If _precision_ is *"minute"*, return *""*.
      1. Let _secondsString_ be the string-concatenation of the code unit 0x003A (COLON) and ToZeroPaddedDecimalString(_second_, 2).
      1. Let _fraction_ be _millisecond_ &times; 10<sup>6</sup> + _microsecond_ &times; 10<sup>3</sup> + _nanosecond_.
      1. If _precision_ is *"auto"*, then
        1. If _fraction_ is 0, return _secondsString_.
        1. Set _fraction_ to ToZeroPaddedDecimalString(_fraction_, 9).
        1. Set _fraction_ to the longest possible substring of _fraction_ starting at position 0 and not ending with the code unit 0x0030 (DIGIT ZERO).
      1. Else,
        1. If _precision_ is 0, return _secondsString_.
        1. Set _fraction_ to ToZeroPaddedDecimalString(_fraction_, 9).
        1. Set _fraction_ to the substring of _fraction_ from 0 to _precision_.
      1. Return the string-concatenation of _secondsString_, the code unit 0x002E (FULL STOP), and _fraction_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-getunsignedroundingmode" type="abstract operation">
    <h1>
      GetUnsignedRoundingMode (
        _roundingMode_: *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, or *"halfEven"*,
        _isNegative_: *true* or *false*,
      ): ~zero~, ~infinity~, ~half-zero~, ~half-infinity~, or ~half-even~
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        The return value is the rounding mode that should be applied to the absolute value of a number to produce the same result as if _roundingMode_ were applied to the signed value of the number (negative if _isNegative_ is *true*, or positive otherwise).
      </dd>
    </dl>
    <emu-alg>
      1. If _isNegative_ is *true*, return the specification type in the third column of <emu-xref href="#table-temporal-unsigned-rounding-modes"></emu-xref> where the first column is _roundingMode_ and the second column is "negative".
      1. Else, return the specification type in the third column of <emu-xref href="#table-temporal-unsigned-rounding-modes"></emu-xref> where the first column is _roundingMode_ and the second column is "positive".
    </emu-alg>
    <emu-note type="editor">
      <p>This operation is intended to be the same one as in the <a href="https://tc39.es/proposal-intl-numberformat-v3/out/numberformat/diff.html#sec-getunsignedroundingmode">Intl.NumberFormat v3</a> proposal.</p>
    </emu-note>
    <emu-table id="table-temporal-unsigned-rounding-modes">
      <emu-caption>Conversion from rounding mode to unsigned rounding mode</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Identifier</th>
            <th>Sign</th>
            <th>Unsigned Rounding Mode</th>
          </tr>
        </thead>
        <tr>
          <td rowspan="2">*"ceil"*</td>
          <td>positive</td>
          <td>~infinity~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~zero~</td>
        </tr>
        <tr>
          <td rowspan="2">*"floor"*</td>
          <td>positive</td>
          <td>~zero~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~infinity~</td>
        </tr>
        <tr>
          <td rowspan="2">*"expand"*</td>
          <td>positive</td>
          <td>~infinity~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~infinity~</td>
        </tr>
        <tr>
          <td rowspan="2">*"trunc"*</td>
          <td>positive</td>
          <td>~zero~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~zero~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfCeil"*</td>
          <td>positive</td>
          <td>~half-infinity~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-zero~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfFloor"*</td>
          <td>positive</td>
          <td>~half-zero~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-infinity~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfExpand"*</td>
          <td>positive</td>
          <td>~half-infinity~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-infinity~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfTrunc"*</td>
          <td>positive</td>
          <td>~half-zero~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-zero~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfEven"*</td>
          <td>positive</td>
          <td>~half-even~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-even~</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-applyunsignedroundingmode" type="abstract operation">
    <h1>
      ApplyUnsignedRoundingMode (
        _x_: a mathematical value,
        _r1_: a mathematical value,
        _r2_: a mathematical value,
        _unsignedRoundingMode_: ~zero~, ~infinity~, ~half-zero~, ~half-infinity~, ~half-even~, or *undefined*,
      ): a mathematical value
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It considers _x_, bracketed below by _r1_ and above by _r2_, and returns either _r1_ or _r2_ according to _unsignedRoundingMode_.
      </dd>
    </dl>
    <emu-alg>
      1. If _x_ is equal to _r1_, return _r1_.
      1. Assert: _r1_ &lt; _x_ &lt; _r2_.
      1. Assert: _unsignedRoundingMode_ is not *undefined*.
      1. If _unsignedRoundingMode_ is ~zero~, return _r1_.
      1. If _unsignedRoundingMode_ is ~infinity~, return _r2_.
      1. Let _d1_ be <emu-eqn>_x_ ‚Äì _r1_</emu-eqn>.
      1. Let _d2_ be <emu-eqn>_r2_ ‚Äì _x_</emu-eqn>.
      1. If _d1_ &lt; _d2_, return _r1_.
      1. If _d2_ &lt; _d1_, return _r2_.
      1. Assert: _d1_ is equal to _d2_.
      1. If _unsignedRoundingMode_ is ~half-zero~, return _r1_.
      1. If _unsignedRoundingMode_ is ~half-infinity~, return _r2_.
      1. Assert: _unsignedRoundingMode_ is ~half-even~.
      1. Let _cardinality_ be <emu-eqn>(_r1_ / (_r2_ ‚Äì _r1_)) modulo 2</emu-eqn>.
      1. If _cardinality_ is 0, return _r1_.
      1. Return _r2_.
    </emu-alg>
    <emu-note type="editor">
      <p>This operation is intended to be the same one as in the <a href="https://tc39.es/proposal-intl-numberformat-v3/out/numberformat/diff.html#sec-applyunsignedroundingmode">Intl.NumberFormat v3</a> proposal.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-roundnumbertoincrement" type="abstract operation">
    <h1>
      RoundNumberToIncrement (
        _x_: a mathematical value,
        _increment_: an integer,
        _roundingMode_: *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, or *"halfEven"*,
      ): an integer
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It rounds _x_ to the nearest multiple of _increment_, up or down according to _roundingMode_.</dd>
    </dl>
    <emu-alg>
      1. Let _quotient_ be _x_ / _increment_.
      1. If _quotient_ &lt; 0, then
        1. Let _isNegative_ be *true*.
        1. Set _quotient_ to -_quotient_.
      1. Else,
        1. Let _isNegative_ be *false*.
      1. Let _unsignedRoundingMode_ be GetUnsignedRoundingMode(_roundingMode_, _isNegative_).
      1. Let _r1_ be the largest integer such that _r1_ ‚â§ _quotient_.
      1. Let _r2_ be the smallest integer such that _r2_ &gt; _quotient_.
      1. Let _rounded_ be ApplyUnsignedRoundingMode(_quotient_, _r1_, _r2_, _unsignedRoundingMode_).
      1. If _isNegative_ is *true*, set _rounded_ to -_rounded_.
      1. Return _rounded_ &times; _increment_.
    </emu-alg>
    <emu-note type="editor">
      <p>
        The rounding modes accepted by this abstract operation are intended to be the same as whatever is eventually standardized in the <a href="https://github.com/tc39/proposal-intl-numberformat-v3">Intl.NumberFormat V3</a> proposal.
      </p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-roundnumbertoincrementasifpositive" type="abstract operation">
    <h1>
      RoundNumberToIncrementAsIfPositive (
        _x_: a mathematical value,
        _increment_: an integer,
        _roundingMode_: *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, or *"halfEven"*,
      ): an integer
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It rounds _x_ to the nearest multiple of _increment_, up or down according to _roundingMode_, but always as if _x_ were positive.
        For example, *"floor"* and *"trunc"* behave identically.
        This is used when rounding exact times, where "rounding down" conceptually always means towards the beginning of time, even if the time is expressed as a negative amount of time relative to an epoch.
      </dd>
    </dl>
    <emu-alg>
      1. Let _quotient_ be _x_ / _increment_.
      1. Let _unsignedRoundingMode_ be GetUnsignedRoundingMode(_roundingMode_, *false*).
      1. Let _r1_ be the largest integer such that _r1_ &leq; _quotient_.
      1. Let _r2_ be the smallest integer such that _r2_ &gt; _quotient_.
      1. Let _rounded_ be ApplyUnsignedRoundingMode(_quotient_, _r1_, _r2_, _unsignedRoundingMode_).
      1. Return _rounded_ &times; _increment_.
    </emu-alg>
    <emu-note type="editor">
      <p>
        The rounding modes accepted by this abstract operation are intended to be the same as whatever is eventually standardized in the <a href="https://github.com/tc39/proposal-intl-numberformat-v3">Intl.NumberFormat V3</a> proposal.
      </p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-iso8601grammar">
    <h1>ISO 8601 grammar</h1>
    <p>
      Several operations in this section are intended to parse ISO 8601 strings representing a date, a time, a duration, or a combined date and time.
      For the purposes of these operations, a valid ISO 8601 string is defined as a string that can be generated by one of the goal elements of the following grammar.
    </p>
    <p>
      This grammar is adapted from the ABNF grammar of ISO 8601 that is given in appendix A of <a href="https://tools.ietf.org/html/rfc3339#appendix-A">RFC 3339</a>, augmented with the grammar of annotations in section 3.1 of <a href="https://datatracker.ietf.org/doc/html/draft-ietf-sedate-datetime-extended#section-3.1">Date and Time on the Internet: Timestamps with additional information</a>
    </p>
    <p>
      The grammar deviates from the standard given in ISO 8601 in the following ways:
    </p>
    <ul>
      <li>Only the calendar date format is supported, not the weekdate or ordinal date format.</li>
      <li>Two-digit years are disallowed.</li>
      <li><a href="https://tc39.es/ecma262/#sec-expanded-years">Expanded Years</a> of 6 digits are allowed.</li>
      <li>Fractional parts may have 1 through 9 decimal places.</li>
      <li>In time representations, only seconds are allowed to have a fractional part.</li>
      <li>In duration representations, only hours, minutes, and seconds are allowed to have a fractional part.</li>
      <li>Any number of conforming <a href="https://datatracker.ietf.org/doc/html/draft-ietf-sedate-datetime-extended#section-3.1">suffixes in square brackets</a> are allowed.</li>
      <li>
        Time zone and <a href="https://tools.ietf.org/html/bcp47#section-2.1">BCP 47 calendar</a> suffixes are the only recognized ones.
        Others are ignored, unless they are marked with a *!*, in which case they are rejected.
      </li>
      <li>A space may be used to separate the date and time in a combined date / time representation, but not in a duration.</li>
      <li>Alphabetic designators may be in lower or upper case.</li>
      <li>Period or comma may be used as the decimal separator.</li>
      <li>A time zone offset of *"-00:00"* is allowed, and means the same thing as *"+00:00"*.</li>
      <li>
        In a combined representation, combinations of date, time, and time zone offset with Basic (no `-` or `:` separators) and Extended (with `-` or `:` separators) formatting are allowed.
        (The date, time, and time zone offset must each be fully in Basic format or Extended format.)
      </li>
      <li>
        When parsing a date representation for a Temporal.PlainMonthDay, the year may be omitted.
        The year may optionally be replaced by *"--"* as in RFC 3339.
      </li>
      <li>When parsing a date representation without a day for a Temporal.PlainYearMonth, the expression is allowed to be in Basic format.</li>
      <li>A duration specifier of *"W"* (weeks) can be combined with any of the other specifiers.</li>
      <li>Anything else described by the standard as requiring mutual agreement between communicating parties, is disallowed.</li>
    </ul>

    <emu-grammar type="definition">
      Alpha : one of
          `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M`
          `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`
          `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m`
          `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`

      LowercaseAlpha : one of
          `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m`
          `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`

      ASCIISign : one of
          `+` `-`

      Sign :
          ASCIISign
          U+2212

      UnpaddedHour :
          DecimalDigit
          `1` DecimalDigit
          `20`
          `21`
          `22`
          `23`

      Hour :
          `0` DecimalDigit
          `1` DecimalDigit
          `20`
          `21`
          `22`
          `23`

      MinuteSecond :
          `0` DecimalDigit
          `1` DecimalDigit
          `2` DecimalDigit
          `3` DecimalDigit
          `4` DecimalDigit
          `5` DecimalDigit

      DecimalSeparator : one of
          `.` `,`

      DaysDesignator : one of
          `D` `d`

      HoursDesignator : one of
          `H` `h`

      MinutesDesignator : one of
          `M` `m`

      MonthsDesignator : one of
          `M` `m`

      DurationDesignator : one of
          `P` `p`

      SecondsDesignator : one of
          `S` `s`

      DateTimeSeparator :
          &lt;SP&gt;
          `T`
          `t`

      TimeDesignator : one of
          `T` `t`

      WeeksDesignator : one of
          `W` `w`

      YearsDesignator : one of
          `Y` `y`

      UTCDesignator : one of
          `Z` `z`

      AnnotationCriticalFlag :
          `!`

      DateFourDigitYear :
          DecimalDigit DecimalDigit DecimalDigit DecimalDigit

      DateExtendedYear :
          Sign DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

      DateYear :
          DateFourDigitYear
          DateExtendedYear

      DateMonth :
          `0` NonZeroDigit
          `10`
          `11`
          `12`

      DateMonthWithThirtyOneDays : one of
          `01` `03` `05` `07` `08` `10` `12`

      DateDay :
          `0` NonZeroDigit
          `1` DecimalDigit
          `2` DecimalDigit
          `30`
          `31`

      DateSpecYearMonth :
          DateYear `-`? DateMonth

      TwoDashes :
          `--`

      DateSpecMonthDay :
          TwoDashes? DateMonth `-`? DateDay

      ValidMonthDay :
          DateMonth `-`? `0` NonZeroDigit
          DateMonth `-`? `1` DecimalDigit
          DateMonth `-`? `2` DecimalDigit
          DateMonth `-`? `30` but not one of `0230` or `02-30`
          DateMonthWithThirtyOneDays `-`? `31`

      Date :
          DateYear `-` DateMonth `-` DateDay
          DateYear DateMonth DateDay

      TimeHour :
          Hour

      TimeMinute :
          MinuteSecond

      TimeSecond :
          MinuteSecond
          `60`

      FractionalPart :
          DecimalDigit DecimalDigit? DecimalDigit? DecimalDigit? DecimalDigit? DecimalDigit? DecimalDigit? DecimalDigit? DecimalDigit?

      Fraction :
          DecimalSeparator FractionalPart

      TimeFraction :
          Fraction

      TimeZoneUTCOffset :
          UTCOffset
          UTCDesignator

      TimeZoneUTCOffsetName :
          Sign Hour
          Sign Hour `:` MinuteSecond
          Sign Hour MinuteSecond
          Sign Hour `:` MinuteSecond `:` MinuteSecond Fraction?
          Sign Hour MinuteSecond MinuteSecond Fraction?

      TZLeadingChar :
          Alpha
          `.`
          `_`

      TZChar[Legacy] :
          Alpha
          `.`
          `-`
          `_`
          [+Legacy] `+`
          [+Legacy] DecimalDigit

      TimeZoneIANANameComponent[Legacy] :
          > Readability note: This production matches 1 to 14 characters.
          TZLeadingChar but not `.`
          TZLeadingChar TZChar[?Legacy] but not `..`
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]

      TimeZoneIANANameTail[Legacy] :
          TimeZoneIANANameComponent[?Legacy]
          TimeZoneIANANameComponent[?Legacy] `/` TimeZoneIANANameTail[?Legacy]

      TimeZoneIANALegacyName :
          TimeZoneIANANameTail[+Legacy] [&gt; but only if `etc/gmt` |ASCIISign| |UnpaddedHour| matches the ASCII-lowercase of the sequence of code points matched by (|TimeZoneIANANameTail|)]
          TimeZoneIANANameTail[+Legacy] [&gt; but only if the sequence of code points matched by |TimeZoneIANANameTail| is an ASCII-case-insensitive match for an element of ¬´ *"Etc/GMT0"*, *"GMT0"*, *"GMT-0"*, *"GMT+0"*, *"EST5EDT"*, *"CST6CDT"*, *"MST7MDT"*, *"PST8PDT"* ¬ª]

      TimeZoneIANAName :
          TimeZoneIANANameTail[~Legacy]
          TimeZoneIANALegacyName

      TimeZoneIdentifier :
          TimeZoneIANAName
          TimeZoneUTCOffsetName

      TimeZoneAnnotation :
          `[` AnnotationCriticalFlag? TimeZoneIdentifier `]`

      AKeyLeadingChar :
          LowercaseAlpha
          `_`

      AKeyChar :
          AKeyLeadingChar
          DecimalDigit
          `-`

      AValChar :
          Alpha
          DecimalDigit

      AnnotationKeyTail :
          AKeyChar AnnotationKeyTail?

      AnnotationKey :
          AKeyLeadingChar AnnotationKeyTail?

      AnnotationValueComponent :
          AValChar AnnotationValueComponent?

      AnnotationValueTail :
          AnnotationValueComponent
          AnnotationValueComponent `-` AnnotationValueTail

      AnnotationValue :
          AnnotationValueTail

      Annotation :
          `[` AnnotationCriticalFlag? AnnotationKey `=` AnnotationValue `]`

      Annotations :
          Annotation Annotations?

      TimeSpec :
          TimeHour
          TimeHour `:` TimeMinute
          TimeHour TimeMinute
          TimeHour `:` TimeMinute `:` TimeSecond TimeFraction?
          TimeHour TimeMinute TimeSecond TimeFraction?

      TimeSpecWithOptionalOffsetNotAmbiguous :
          TimeSpec TimeZoneUTCOffset? but not one of ValidMonthDay or DateSpecYearMonth

      DateTime :
          Date
          Date DateTimeSeparator TimeSpec TimeZoneUTCOffset?

      AnnotatedTime :
          TimeDesignator TimeSpec TimeZoneUTCOffset? TimeZoneAnnotation? Annotations?
          TimeSpecWithOptionalOffsetNotAmbiguous TimeZoneAnnotation? Annotations?

      AnnotatedDateTime:
          DateTime TimeZoneAnnotation? Annotations?

      AnnotatedDateTimeTimeRequired :
          Date DateTimeSeparator TimeSpec TimeZoneUTCOffset? TimeZoneAnnotation? Annotations?

      AnnotatedYearMonth:
          DateSpecYearMonth TimeZoneAnnotation? Annotations?

      AnnotatedMonthDay:
          DateSpecMonthDay TimeZoneAnnotation? Annotations?

      DurationWholeSeconds :
          DecimalDigits[~Sep]

      DurationSecondsFraction :
          TimeFraction

      DurationSecondsPart :
          DurationWholeSeconds DurationSecondsFraction? SecondsDesignator

      DurationWholeMinutes :
          DecimalDigits[~Sep]

      DurationMinutesFraction :
          TimeFraction

      DurationMinutesPart :
          DurationWholeMinutes DurationMinutesFraction? MinutesDesignator DurationSecondsPart?

      DurationWholeHours :
          DecimalDigits[~Sep]

      DurationHoursFraction :
          TimeFraction

      DurationHoursPart :
          DurationWholeHours DurationHoursFraction? HoursDesignator DurationMinutesPart
          DurationWholeHours DurationHoursFraction? HoursDesignator DurationSecondsPart?

      DurationTime :
          TimeDesignator DurationHoursPart
          TimeDesignator DurationMinutesPart
          TimeDesignator DurationSecondsPart

      DurationDays :
          DecimalDigits[~Sep]

      DurationDaysPart :
          DurationDays DaysDesignator

      DurationWeeks :
          DecimalDigits[~Sep]

      DurationWeeksPart :
          DurationWeeks WeeksDesignator DurationDaysPart?

      DurationMonths :
          DecimalDigits[~Sep]

      DurationMonthsPart :
          DurationMonths MonthsDesignator DurationWeeksPart
          DurationMonths MonthsDesignator DurationDaysPart?

      DurationYears :
          DecimalDigits[~Sep]

      DurationYearsPart :
          DurationYears YearsDesignator DurationMonthsPart
          DurationYears YearsDesignator DurationWeeksPart
          DurationYears YearsDesignator DurationDaysPart?

      DurationDate :
          DurationYearsPart DurationTime?
          DurationMonthsPart DurationTime?
          DurationWeeksPart DurationTime?
          DurationDaysPart DurationTime?

      Duration :
          Sign? DurationDesignator DurationDate
          Sign? DurationDesignator DurationTime

      TemporalInstantString :
          Date DateTimeSeparator TimeSpec TimeZoneUTCOffset TimeZoneAnnotation? Annotations?

      TemporalDateTimeString :
          AnnotatedDateTime

      TemporalDurationString :
          Duration

      TemporalMonthDayString :
          AnnotatedMonthDay
          AnnotatedDateTime

      TemporalTimeString :
          AnnotatedTime
          AnnotatedDateTimeTimeRequired

      TemporalYearMonthString :
          AnnotatedYearMonth
          AnnotatedDateTime

      TemporalZonedDateTimeString :
          DateTime TimeZoneAnnotation Annotations?
    </emu-grammar>

    <emu-clause id="sec-temporal-iso8601grammar-early-errors">
      <h1>Early errors</h1>
      <emu-grammar>
        DateExtendedYear :
          Sign DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if |DateExtendedYear| is *"-000000"* or *"‚àí000000"* (U+2212 MINUS SIGN followed by `000000`).
        </li>
      </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-parseisodatetime" type="abstract operation">
    <h1>
      ParseISODateTime (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component as a distinct field.</dd>
    </dl>
    <emu-note>The value of ! ToIntegerOrInfinity(*undefined*) is 0.</emu-note>
    <emu-alg>
      1. Let _parseResult_ be ~empty~.
      1. For each nonterminal _goal_ of &laquo; |TemporalDateTimeString|, |TemporalInstantString|, |TemporalTimeString|, |TemporalZonedDateTimeString| &raquo;, do
        1. If _parseResult_ is not a Parse Node, set _parseResult_ to ParseText(StringToCodePoints(_isoString_), _goal_).
      1. For each nonterminal _goal_ of &laquo; |TemporalMonthDayString|, |TemporalYearMonthString| &raquo;, do
        1. If _parseResult_ is not a Parse Node, then
          1. Set _parseResult_ to ParseText(StringToCodePoints(_isoString_), _goal_).
          1. If _parseResult_ is a Parse Node, then
            1. For each |Annotation| Parse Node _annotation_ contained within _parseResult_, do
              1. Let _key_ be the source text matched by the |AnnotationKey| Parse Node contained within _annotation_.
              1. Let _value_ be the source text matched by the |AnnotationValue| Parse Node contained within _annotation_.
              1. If CodePointsToString(_key_) is *"u-ca"* and the ASCII-lowercase of CodePointsToString(_value_) is not *"iso8601"*, throw a *RangeError* exception.
      1. If _parseResult_ is not a Parse Node, throw a *RangeError* exception.
      1. Let each of _year_, _month_, _day_, _hour_, _minute_, _second_, and _fSeconds_ be the source text matched by the respective |DateYear|, |DateMonth|, |DateDay|, |TimeHour|, |TimeMinute|, |TimeSecond|, and |TimeFraction| Parse Node contained within _parseResult_, or an empty sequence of code points if not present.
      1. If the first code point of _year_ is U+2212 (MINUS SIGN), replace the first code point with U+002D (HYPHEN-MINUS).
      1. Let _yearMV_ be ! ToIntegerOrInfinity(CodePointsToString(_year_)).
      1. If _month_ is empty, then
        1. Let _monthMV_ be 1.
      1. Else,
        1. Let _monthMV_ be ! ToIntegerOrInfinity(CodePointsToString(_month_)).
      1. If _day_ is empty, then
        1. Let _dayMV_ be 1.
      1. Else,
        1. Let _dayMV_ be ! ToIntegerOrInfinity(CodePointsToString(_day_)).
      1. Let _hourMV_ be ! ToIntegerOrInfinity(CodePointsToString(_hour_)).
      1. Let _minuteMV_ be ! ToIntegerOrInfinity(CodePointsToString(_minute_)).
      1. Let _secondMV_ be ! ToIntegerOrInfinity(CodePointsToString(_second_)).
      1. If _secondMV_ is 60, then
        1. Set _secondMV_ to 59.
      1. If _fSeconds_ is not empty, then
        1. Let _fSecondsDigits_ be the substring of CodePointsToString(_fSeconds_) from 1.
        1. Let _fSecondsDigitsExtended_ be the string-concatenation of _fSecondsDigits_ and *"000000000"*.
        1. Let _millisecond_ be the substring of _fSecondsDigitsExtended_ from 0 to 3.
        1. Let _microsecond_ be the substring of _fSecondsDigitsExtended_ from 3 to 6.
        1. Let _nanosecond_ be the substring of _fSecondsDigitsExtended_ from 6 to 9.
        1. Let _millisecondMV_ be ! ToIntegerOrInfinity(_millisecond_).
        1. Let _microsecondMV_ be ! ToIntegerOrInfinity(_microsecond_).
        1. Let _nanosecondMV_ be ! ToIntegerOrInfinity(_nanosecond_).
      1. Else,
        1. Let _millisecondMV_ be 0.
        1. Let _microsecondMV_ be 0.
        1. Let _nanosecondMV_ be 0.
      1. If IsValidISODate(_yearMV_, _monthMV_, _dayMV_) is *false*, throw a *RangeError* exception.
      1. If IsValidTime(_hourMV_, _minuteMV_, _secondMV_, _millisecondMV_, _microsecondMV_, _nanosecondMV_) is *false*, throw a *RangeError* exception.
      1. Let _timeZoneResult_ be the Record { [[Z]]: *false*, [[OffsetString]]: *undefined*, [[Name]]: *undefined* }.
      1. If _parseResult_ contains a |TimeZoneIdentifier| Parse Node, then
        1. Let _name_ be the source text matched by the |TimeZoneIdentifier| Parse Node contained within _parseResult_.
        1. Set _timeZoneResult_.[[Name]] to CodePointsToString(_name_).
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, then
        1. Set _timeZoneResult_.[[Z]] to *true*.
      1. Else,
        1. If _parseResult_ contains a |UTCOffset| Parse Node, then
          1. Let _offset_ be the source text matched by the |UTCOffset| Parse Node contained within _parseResult_.
          1. Set _timeZoneResult_.[[OffsetString]] to CodePointsToString(_offset_).
      1. Let _calendar_ be *undefined*.
      1. For each |Annotation| Parse Node _annotation_ contained within _parseResult_, do
        1. Let _key_ be the source text matched by the |AnnotationKey| Parse Node contained within _annotation_.
        1. If CodePointsToString(_key_) is *"u-ca"*, then
          1. If _calendar_ is *undefined*, then
            1. Let _value_ be the source text matched by the |AnnotationValue| Parse Node contained within _annotation_.
            1. Let _calendar_ be CodePointsToString(_value_).
        1. Else,
          1. If _annotation_ contains an |AnnotationCriticalFlag| Parse Node, throw a *RangeError* exception.
      1. Return the Record {
          [[Year]]: _yearMV_,
          [[Month]]: _monthMV_,
          [[Day]]: _dayMV_,
          [[Hour]]: _hourMV_,
          [[Minute]]: _minuteMV_,
          [[Second]]: _secondMV_,
          [[Millisecond]]: _millisecondMV_,
          [[Microsecond]]: _microsecondMV_,
          [[Nanosecond]]: _nanosecondMV_,
          [[TimeZone]]: _timeZoneResult_,
          [[Calendar]]: _calendar_
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalinstantstring" type="abstract operation">
    <h1>
      ParseTemporalInstantString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.Instant instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. If ParseText(StringToCodePoints(_isoString_), |TemporalInstantString|) is a List of errors, throw a *RangeError* exception.
      1. Let _result_ be ? ParseISODateTime(_isoString_).
      1. Let _offsetString_ be _result_.[[TimeZone]].[[OffsetString]].
      1. If _result_.[[TimeZone]].[[Z]] is *true*, then
        1. Set _offsetString_ to *"+00:00"*.
      1. Assert: _offsetString_ is not *undefined*.
      1. Return the Record {
        [[Year]]: _result_.[[Year]],
        [[Month]]: _result_.[[Month]],
        [[Day]]: _result_.[[Day]],
        [[Hour]]: _result_.[[Hour]],
        [[Minute]]: _result_.[[Minute]],
        [[Second]]: _result_.[[Second]],
        [[Millisecond]]: _result_.[[Millisecond]],
        [[Microsecond]]: _result_.[[Microsecond]],
        [[Nanosecond]]: _result_.[[Nanosecond]],
        [[TimeZoneOffsetString]]: _offsetString_
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalzoneddatetimestring" type="abstract operation">
    <h1>
      ParseTemporalZonedDateTimeString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.ZonedDateTime instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. If ParseText(StringToCodePoints(_isoString_), |TemporalZonedDateTimeString|) is a List of errors, throw a *RangeError* exception.
      1. Return ? ParseISODateTime(_isoString_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalcalendarstring" type="abstract operation">
    <h1>
      ParseTemporalCalendarString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns the calendar identifier, or *undefined* if there is none.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be Completion(ParseISODateTime(_isoString_)).
      1. If _parseResult_ is a normal completion, then
        1. Let _calendar_ be _parseResult_.[[Value]].[[Calendar]].
        1. If _calendar_ is *undefined*, return *"iso8601"*.
        1. Else, return _calendar_.
      1. Else,
        1. Set _parseResult_ to ParseText(StringToCodePoints(_isoString_), |AnnotationValue|).
        1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
        1. Else, return _isoString_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaldatestring" type="abstract operation">
    <h1>
      ParseTemporalDateString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as a full or partial ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.PlainDate instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. Let _parts_ be ? ParseTemporalDateTimeString(_isoString_).
      1. Return the Record {
        [[Year]]: _parts_.[[Year]],
        [[Month]]: _parts_.[[Month]],
        [[Day]]: _parts_.[[Day]],
        [[Calendar]]: _parts_.[[Calendar]]
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaldatetimestring" type="abstract operation">
    <h1>
      ParseTemporalDateTimeString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.PlainDateTime instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalDateTimeString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, throw a *RangeError* exception.
      1. Return ? ParseISODateTime(_isoString_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaldurationstring" type="abstract operation">
    <h1>
      ParseTemporalDurationString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 duration string and returns a Duration Record.</dd>
    </dl>
    <emu-note>The value of ToIntegerWithTruncation(*""*) is 0.</emu-note>
    <emu-note>Use of mathematical values rather than approximations is important to avoid off-by-one errors with input like "PT46H66M71.50040904S".</emu-note>
    <emu-alg>
      1. Let _duration_ be ParseText(StringToCodePoints(_isoString_), |TemporalDurationString|).
      1. If _duration_ is a List of errors, throw a *RangeError* exception.
      1. Let each of _sign_, _years_, _months_, _weeks_, _days_, _hours_, _fHours_, _minutes_, _fMinutes_, _seconds_, and _fSeconds_ be the source text matched by the respective |Sign|, |DurationYears|, |DurationMonths|, |DurationWeeks|, |DurationDays|, |DurationWholeHours|, |DurationHoursFraction|, |DurationWholeMinutes|, |DurationMinutesFraction|, |DurationWholeSeconds|, and |DurationSecondsFraction| Parse Node contained within _duration_, or an empty sequence of code points if not present.
      1. Let _yearsMV_ be ? ToIntegerWithTruncation(CodePointsToString(_years_)).
      1. Let _monthsMV_ be ? ToIntegerWithTruncation(CodePointsToString(_months_)).
      1. Let _weeksMV_ be ? ToIntegerWithTruncation(CodePointsToString(_weeks_)).
      1. Let _daysMV_ be ? ToIntegerWithTruncation(CodePointsToString(_days_)).
      1. Let _hoursMV_ be ? ToIntegerWithTruncation(CodePointsToString(_hours_)).
      1. If _fHours_ is not empty, then
        1. If any of _minutes_, _fMinutes_, _seconds_, _fSeconds_ is not empty, throw a *RangeError* exception.
        1. Let _fHoursDigits_ be the substring of CodePointsToString(_fHours_) from 1.
        1. Let _fHoursScale_ be the length of _fHoursDigits_.
        1. Let _minutesMV_ be ? ToIntegerWithTruncation(_fHoursDigits_) / 10<sup>_fHoursScale_</sup> &times; 60.
      1. Else,
        1. Let _minutesMV_ be ? ToIntegerWithTruncation(CodePointsToString(_minutes_)).
      1. If _fMinutes_ is not empty, then
        1. If any of _seconds_, _fSeconds_ is not empty, throw a *RangeError* exception.
        1. Let _fMinutesDigits_ be the substring of CodePointsToString(_fMinutes_) from 1.
        1. Let _fMinutesScale_ be the length of _fMinutesDigits_.
        1. Let _secondsMV_ be ? ToIntegerWithTruncation(_fMinutesDigits_) / 10<sup>_fMinutesScale_</sup> &times; 60.
      1. Else if _seconds_ is not empty, then
        1. Let _secondsMV_ be ? ToIntegerWithTruncation(CodePointsToString(_seconds_)).
      1. Else,
        1. Let _secondsMV_ be remainder(_minutesMV_, 1) &times; 60.
      1. If _fSeconds_ is not empty, then
        1. Let _fSecondsDigits_ be the substring of CodePointsToString(_fSeconds_) from 1.
        1. Let _fSecondsScale_ be the length of _fSecondsDigits_.
        1. Let _millisecondsMV_ be ? ToIntegerWithTruncation(_fSecondsDigits_) / 10<sup>_fSecondsScale_</sup> &times; 1000.
      1. Else,
        1. Let _millisecondsMV_ be remainder(_secondsMV_, 1) &times; 1000.
      1. Let _microsecondsMV_ be remainder(_millisecondsMV_, 1) &times; 1000.
      1. Let _nanosecondsMV_ be remainder(_microsecondsMV_, 1) &times; 1000.
      1. If _sign_ contains the code point U+002D (HYPHEN-MINUS) or U+2212 (MINUS SIGN), then
        1. Let _factor_ be -1.
      1. Else,
        1. Let _factor_ be 1.
      1. Return ! CreateDurationRecord(_yearsMV_ &times; _factor_, _monthsMV_ &times; _factor_, _weeksMV_ &times; _factor_, _daysMV_ &times; _factor_, _hoursMV_ &times; _factor_, floor(_minutesMV_) &times; _factor_, floor(_secondsMV_) &times; _factor_, floor(_millisecondsMV_) &times; _factor_, floor(_microsecondsMV_) &times; _factor_, floor(_nanosecondsMV_) &times; _factor_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalmonthdaystring" type="abstract operation">
    <h1>
      ParseTemporalMonthDayString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.PlainMonthDay instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalMonthDayString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, throw a *RangeError* exception.
      1. Let _result_ be ? ParseISODateTime(_isoString_).
      1. Let _year_ be _result_.[[Year]].
      1. If _parseResult_ does not contain a |DateYear| Parse Node, then
        1. Set _year_ to *undefined*.
      1. Return the Record {
        [[Year]]: _year_,
        [[Month]]: _result_.[[Month]],
        [[Day]]: _result_.[[Day]],
        [[Calendar]]: _result_.[[Calendar]]
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalrelativetostring" type="abstract operation">
    <h1>
      ParseTemporalRelativeToString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns the information needed to construct either a Temporal.ZonedDateTime or a Temporal.PlainDate instance, e.g. as the value of a `relativeTo` option.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalDateTimeString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| ParseNode but no |TimeZoneAnnotation| Parse Node, throw a *RangeError* exception.
      1. Return ? ParseISODateTime(_isoString_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaltimestring" type="abstract operation">
    <h1>
      ParseTemporalTimeString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 time of day and returns the information needed to construct a Temporal.PlainTime instance.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalTimeString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, throw a *RangeError* exception.
      1. Let _result_ be ? ParseISODateTime(_isoString_).
      1. Return the Record {
        [[Hour]]: _result_.[[Hour]],
        [[Minute]]: _result_.[[Minute]],
        [[Second]]: _result_.[[Second]],
        [[Millisecond]]: _result_.[[Millisecond]],
        [[Microsecond]]: _result_.[[Microsecond]],
        [[Nanosecond]]: _result_.[[Nanosecond]],
        [[Calendar]]: _result_.[[Calendar]]
        }.
    </emu-alg>
    <emu-note>
      <p>A successful parse using |TemporalTimeString| guarantees absence of ambiguity with respect to any ISO 8601 date-only, year-month, or month-day representation.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaltimezonestring" type="abstract operation">
    <h1>
      ParseTemporalTimeZoneString (
        _timeZoneString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as either a time zone identifier or an ISO 8601 string and returns a Record representing information about the time zone.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_timeZoneString_), |TimeZoneIdentifier|).
      1. If _parseResult_ is a Parse Node, then
        1. Return the Record { [[Z]]: *false*, [[OffsetString]]: *undefined*, [[Name]]: _timeZoneString_ }.
      1. Let _result_ be ? ParseISODateTime(_timeZoneString_).
      1. Let _timeZoneResult_ be _result_.[[TimeZone]].
      1. If _timeZoneResult_.[[Z]] is *false*, _timeZoneResult_.[[OffsetString]] is *undefined*, and _timeZoneResult_.[[Name]] is *undefined*, throw a *RangeError* exception.
      1. Return _timeZoneResult_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalyearmonthstring" type="abstract operation">
    <h1>
      ParseTemporalYearMonthString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as a full or partial ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.PlainYearMonth instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalYearMonthString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, throw a *RangeError* exception.
      1. Let _result_ be ? ParseISODateTime(_isoString_).
      1. Return the Record {
        [[Year]]: _result_.[[Year]],
        [[Month]]: _result_.[[Month]],
        [[Day]]: _result_.[[Day]],
        [[Calendar]]: _result_.[[Calendar]]
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-topositiveintegerwithtruncation" type="abstract operation">
    <h1>
      ToPositiveIntegerWithTruncation (
        _argument_: an ECMAScript language value,
      ): either a normal completion containing a positive integer, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It converts _argument_ to an integer representing its Number value with fractional part truncated (replacing *NaN* with 0), or throws a *RangeError* when that Number value is not finite or not positive.</dd>
    </dl>
    <emu-alg>
      1. Let _integer_ be ? ToIntegerWithTruncation(_argument_).
      1. If _integer_ &le; 0, throw a *RangeError* exception.
      1. Return _integer_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-tointegerwithtruncation" type="abstract operation">
    <h1>
      ToIntegerWithTruncation (
        _argument_: an ECMAScript language value,
      ): either a normal completion containing an integer, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It converts _argument_ to an integer representing its Number value with fractional part truncated (replacing *NaN* with 0), or throws a *RangeError* when that Number value is not finite.</dd>
    </dl>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If _number_ is *NaN*, return 0.
      1. If _number_ is *+&infin;*<sub>ùîΩ</sub> or *-&infin;*<sub>ùîΩ</sub>, throw a *RangeError* exception.
      1. Return truncate(‚Ñù(number)).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-tointegerifintegral" type="abstract operation">
    <h1>
      ToIntegerIfIntegral (
        _argument_: an ECMAScript language value,
      ): either a normal completion containing an integer, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It converts _argument_ to an integer representing its Number value (replacing *NaN* with 0), or throws a *RangeError* when that Number value is not a finite integral Number.</dd>
    </dl>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If _number_ is *NaN*, *+0*<sub>ùîΩ</sub>, or *-0*<sub>ùîΩ</sub>, return 0.
      1. If IsIntegralNumber(_number_) is *false*, throw a *RangeError* exception.
      1. Return ‚Ñù(_number_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-preparetemporalfields" type="abstract operation">
    <h1>
      PrepareTemporalFields (
        _fields_: an Object,
        _fieldNames_: a List of property names,
        _requiredFields_: ~partial~ or a List of property names,
      ): either a normal completion containing an Object, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        The returned Object has a null prototype, and an own data property for each element of _fieldNames_ that corresponds with a non-*undefined* property of the same name on _fields_ used as the input for relevant conversion.
        When _requiredFields_ is ~partial~, this operation throws if none of the properties are present with a non-*undefined* value.
        When _requiredFields_ is a List, this operation throws if any of the properties named by it are absent or undefined, and otherwise substitutes a relevant default for any absent or undefined non-required property (ensuring that the returned object has a property for each element of _fieldNames_).
      </dd>
    </dl>
    <emu-alg>
      1. Let _result_ be OrdinaryObjectCreate(*null*).
      1. Let _any_ be *false*.
      1. For each property name _property_ of _fieldNames_, do
        1. Let _value_ be ? Get(_fields_, _property_).
        1. If _value_ is not *undefined*, then
          1. Set _any_ to *true*.
          1. If _property_ is in the Property column of <emu-xref href="#table-temporal-field-requirements"></emu-xref> and there is a Conversion value in the same row, then
            1. Let _Conversion_ be the Conversion value of the same row.
            1. If _Conversion_ is ~ToIntegerWithTruncation~, then
              1. Set _value_ to ? ToIntegerWithTruncation(_value_).
              1. Set _value_ to ùîΩ(_value_).
            1. Else if _Conversion_ is ~ToPositiveIntegerWithTruncation~, then
              1. Set _value_ to ? ToPositiveIntegerWithTruncation(_value_).
              1. Set _value_ to ùîΩ(_value_).
            1. Else,
              1. Assert: _Conversion_ is ~ToString~.
              1. Set _value_ to ? ToString(_value_).
          1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
        1. Else if _requiredFields_ is a List, then
          1. If _requiredFields_ contains _property_, then
            1. Throw a *TypeError* exception.
          1. If _property_ is in the Property column of <emu-xref href="#table-temporal-field-requirements"></emu-xref>, then
            1. Set _value_ to the corresponding Default value of the same row.
          1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
      1. If _requiredFields_ is ~partial~ and _any_ is *false*, then
        1. Throw a *TypeError* exception.
      1. Return _result_.
    </emu-alg>
    <emu-note>
      The value of ! ToIntegerWithTruncation(*undefined*) is 0.
      ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.
    </emu-note>
    <emu-table id="table-temporal-field-requirements">
      <emu-caption>Temporal field requirements</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Property</th>
            <th>Conversion</th>
            <th>Default</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>*"year"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"month"*</td>
            <td>~ToPositiveIntegerWithTruncation~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"monthCode"*</td>
            <td>~ToString~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"day"*</td>
            <td>~ToPositiveIntegerWithTruncation~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"hour"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"minute"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"second"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"millisecond"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"microsecond"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"nanosecond"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"offset"*</td>
            <td>~ToString~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"era"*</td>
            <td>~ToString~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"eraYear"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"timeZone"*</td>
            <td></td>
            <td>*undefined*</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-getdifferencesettings" type="abstract operation">
    <h1>
      GetDifferenceSettings (
        _operation_: ~since~ or ~until~,
        _options_: an ECMAScript language value,
        _unitGroup_: ~date~, ~time~, or ~datetime~,
        _disallowedUnits_: a List of Strings,
        _fallbackSmallestUnit_: a String,
        _smallestLargestDefaultUnit_: a String,
      ): either a normal completion containing a Record or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It reads unit and rounding options needed by difference operations.</dd>
    </dl>
    <emu-alg>
      1. Set _options_ to ? GetOptionsObject(_options_).
      1. Let _smallestUnit_ be ? GetTemporalUnit(_options_, *"smallestUnit"*, _unitGroup_, _fallbackSmallestUnit_).
      1. If _disallowedUnits_ contains _smallestUnit_, throw a *RangeError* exception.
      1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalUnits(_smallestLargestDefaultUnit_, _smallestUnit_).
      1. Let _largestUnit_ be ? GetTemporalUnit(_options_, *"largestUnit"*, _unitGroup_, *"auto"*).
      1. If _disallowedUnits_ contains _largestUnit_, throw a *RangeError* exception.
      1. If _largestUnit_ is *"auto"*, set _largestUnit_ to _defaultLargestUnit_.
      1. If LargerOfTwoTemporalUnits(_largestUnit_, _smallestUnit_) is not _largestUnit_, throw a *RangeError* exception.
      1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
      1. If _operation_ is ~since~, then
        1. Set _roundingMode_ to ! NegateTemporalRoundingMode(_roundingMode_).
      1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
      1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_).
      1. If _maximum_ is *undefined*, then
        1. Set _roundingIncrement_ to floor(‚Ñù(_roundingIncrement_)).
      1. Else,
        1. Set _roundingIncrement_ to ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, *false*).
      1. Return the Record {
            [[SmallestUnit]]: _smallestUnit_,
            [[LargestUnit]]: _largestUnit_,
            [[RoundingMode]]: _roundingMode_,
            [[RoundingIncrement]]: _roundingIncrement_,
            [[Options]]: _options_
            }.
    </emu-alg>
  </emu-clause>
</emu-clause>
