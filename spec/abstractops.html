<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-abstract-ops">
  <h1>Abstract operations</h1>

  <!-- Based on ECMA-262 IterableToList -->
  <emu-clause id="sec-iterabletolistoftype" aoid="IterableToListOfType">
    <h1>IterableToListOfType ( _items_, _elementTypes_ )</h1>
    <p>
      The abstract operation IterableToListOfType takes arguments _items_ and _elementTypes_ (a List of names of ECMAScript Language Types).
      It is used to create a List value whose elements are provided by the values of the iterable _items_.
      _elementTypes_ contains the names of ECMAScript Language Types that are allowed for element values of the List that is created.
      It performs the following steps when called:
    </p>
    <emu-alg>
      1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~).
      1. Let _values_ be a new empty List.
      1. Let _next_ be *true*.
      1. Repeat, while _next_ is not *false*,
        1. Set _next_ to ? IteratorStep(_iteratorRecord_).
        1. If _next_ is not *false*, then
          1. Let _nextValue_ be ? IteratorValue(_next_).
          1. If Type(_nextValue_) is not an element of _elementTypes_, then
            1. Let _completion_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iteratorRecord_, _completion_).
          1. Append _nextValue_ to the end of the List _values_.
      1. Return _values_.
    </emu-alg>
  </emu-clause>

  <!-- Copied from ECMA-402 GetOptionsObject -->
  <emu-clause id="sec-getoptionsobject" aoid="GetOptionsObject">
    <h1>GetOptionsObject ( _options_ )</h1>
    <p>
      The abstract operation GetOptionsObject returns an Object suitable for use with GetOption, either _options_ itself or a default empty Object.
      It throws a TypeError if _options_ is not undefined and not an Object.
    </p>
    <emu-alg>
      1. If _options_ is *undefined*, then
        1. Return OrdinaryObjectCreate(*null*).
      1. If Type(_options_) is Object, then
        1. Return _options_.
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>

  <!-- Copied from ECMA-402 GetOption -->
  <emu-clause id="sec-getoption" type="abstract operation">
    <h1>
      GetOption (
        _options_: an Object,
        _property_: a property key,
        _type_: *"boolean"*, *"number"*, or *"string"*,
        _values_: *undefined* or a List of ECMAScript language values,
        _default_: ~required~ or an ECMAScript language value,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It extracts the value of the specified property of _options_, converts it to the required _type_, checks whether it is allowed by _values_ if _values_ is not *undefined*, and substitutes _default_ if the value is *undefined*.</dd>
    </dl>
    <emu-alg>
      1. Let _value_ be ? Get(_options_, _property_).
      1. If _value_ is *undefined*, then
        1. If _default_ is ~required~, throw a *RangeError* exception.
        1. Return _default_.
      1. If _type_ is *"boolean"*, then
        1. Set _value_ to ToBoolean(_value_).
      1. Else if _type_ is *"number"*, then
        1. Set _value_ to ? ToNumber(_value_).
        1. If _value_ is *NaN*, throw a *RangeError* exception.
      1. Else,
        1. Assert: _type_ is *"string"*.
        1. Set _value_ to ? ToString(_value_).
      1. If _values_ is not *undefined* and _values_ does not contain an element equal to _value_, throw a *RangeError* exception.
      1. Return _value_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporaloverflow" aoid="ToTemporalOverflow">
    <h1>ToTemporalOverflow ( _options_ )</h1>
    <emu-alg>
      1. If _options_ is *undefined*, return *"constrain"*.
      1. Return ? GetOption(_options_, *"overflow"*, *"string"*, « *"constrain"*, *"reject"* », *"constrain"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporaldisambiguation" aoid="ToTemporalDisambiguation">
    <h1>ToTemporalDisambiguation ( _options_ )</h1>
    <emu-alg>
      1. If _options_ is *undefined*, return *"compatible"*.
      1. Return ? GetOption(_options_, *"disambiguation"*, *"string"*, « *"compatible"*, *"earlier"*, *"later"*, *"reject"* », *"compatible"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporalroundingmode" aoid="ToTemporalRoundingMode">
    <h1>ToTemporalRoundingMode ( _normalizedOptions_, _fallback_ )</h1>
    <p>
      The abstract operation ToTemporalRoundingMode extracts the value of the property named *"roundingMode"* from _normalizedOptions_ and makes sure it is a valid value for the option.
      The value _fallback_ is returned if the property is not present.
    </p>
    <emu-note type="editor">
      <p>
        The rounding modes accepted by this abstract operation (and therefore in the Temporal API) are intended to be the same as whatever is eventually standardized in the <a href="https://github.com/tc39/proposal-intl-numberformat-v3">Intl.NumberFormat V3</a> proposal.
      </p>
    </emu-note>
    <emu-alg>
      1. Return ? GetOption(_normalizedOptions_, *"roundingMode"*, *"string"*, « *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, *"halfEven"* », _fallback_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-negatetemporalroundingmode" aoid="NegateTemporalRoundingMode">
    <h1>NegateTemporalRoundingMode ( _roundingMode_ )</h1>
    <p>
      The abstract operation NegateTemporalRoundingMode returns the correct rounding mode to use when rounding the negative of a value that was originally given with _roundingMode_.
    </p>
    <emu-note type="editor">
      <p>
        The rounding modes accepted by this abstract operation (and therefore in the Temporal API) are intended to be the same as whatever is eventually standardized in the <a href="https://github.com/tc39/proposal-intl-numberformat-v3">Intl.NumberFormat V3</a> proposal.
      </p>
    </emu-note>
    <emu-alg>
      1. If _roundingMode_ is *"ceil"*, return *"floor"*.
      1. If _roundingMode_ is *"floor"*, return *"ceil"*.
      1. If _roundingMode_ is *"halfCeil"*, return *"halfFloor"*.
      1. If _roundingMode_ is *"halfFloor"*, return *"halfCeil"*.
      1. Return _roundingMode_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporaloffset" aoid="ToTemporalOffset">
    <h1>ToTemporalOffset ( _options_, _fallback_ )</h1>
    <p>
      The abstract operation ToTemporalOffset extracts the value of the property named *"offset"* from _options_ and makes sure it is a valid value for the option.
      The value _fallback_ is returned if the property is not present.
    </p>
    <emu-alg>
      1. If _options_ is *undefined*, return _fallback_.
      1. Return ? GetOption(_options_, *"offset"*, *"string"*, « *"prefer"*, *"use"*, *"ignore"*, *"reject"* », _fallback_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-tocalendarnameoption" type="abstract operation">
    <h1>
      ToCalendarNameOption (
        _normalizedOptions_: an Object,
      ): either a normal completion containing a String, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It extracts the value of the property named *"calendarName"* from _normalizedOptions_ and makes sure it is a valid value for the option.</dd>
    </dl>
    <emu-note>
      This property is used in `toString` methods in Temporal to control whether a calendar annotation should be output.
    </emu-note>
    <emu-alg>
      1. Return ? GetOption(_normalizedOptions_, *"calendarName"*, *"string"*, « *"auto"*, *"always"*, *"never"*, *"critical"* », *"auto"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totimezonenameoption" type="abstract operation">
    <h1>
      ToTimeZoneNameOption (
        _normalizedOptions_: an Object,
      ): either a normal completion containing a String, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It extracts the value of the property named *"timeZoneName"* from _normalizedOptions_ and makes sure it is a valid value for the option.</dd>
    </dl>
    <emu-note>
      This property is used in `Temporal.ZonedDateTime.prototype.toString()`.
      It is different from the `timeZone` property passed to `Temporal.ZonedDateTime.from()` and from the `timeZone` property in the options passed to `Temporal.Instant.prototype.toString()`.
    </emu-note>
    <emu-alg>
      1. Return ? GetOption(_normalizedOptions_, *"timeZoneName"*, *"string"*, « *"auto"*, *"never"*, *"critical"* », *"auto"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-toshowoffsetoption" aoid="ToShowOffsetOption">
    <h1>ToShowOffsetOption ( _normalizedOptions_ )</h1>
    <p>
      The abstract operation ToShowOffsetOption extracts the value of the property named *"offset"* from _normalizedOptions_ and makes sure it is a valid value for the option.
    </p>
    <emu-note>
      This property is used in `Temporal.ZonedDateTime.prototype.toString()`.
      It is different from the `offset` property passed to `Temporal.ZonedDateTime.from()`.
    </emu-note>
    <emu-alg>
      1. Return ? GetOption(_normalizedOptions_, *"offset"*, *"string"*, « *"auto"*, *"never"* », *"auto"*).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-totemporalroundingincrement" type="abstract operation">
    <h1>
      ToTemporalRoundingIncrement (
        _normalizedOptions_: an Object,
      ): either a normal completion containing a positive integer, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It extracts the value of the property named *"roundingIncrement"* from _normalizedOptions_, makes sure it represents a number in the inclusive interval from 1 to 10<sup>9</sup>, and returns that value truncated to an integer.
      </dd>
    </dl>
    <emu-alg>
      1. Let _increment_ be ? GetOption(_normalizedOptions_, *"roundingIncrement"*, *"number"*, *undefined*, *1*<sub>𝔽</sub>).
      1. If _increment_ is not finite, throw a *RangeError* exception.
      1. Let _integerIncrement_ be truncate(ℝ(_increment_)).
      1. If _integerIncrement_ &lt; 1 or _integerIncrement_ &gt; 10<sup>9</sup>, throw a *RangeError* exception.
      1. Return _integerIncrement_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-validatetemporalroundingincrement" type="abstract operation">
    <h1>
      ValidateTemporalRoundingIncrement (
        _increment_: a positive integer,
        _dividend_: a positive integer,
        _inclusive_: a Boolean,
      ): either a normal completion containing ~unused~, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It verifies that _increment_ evenly divides _dividend_, otherwise throwing a *RangeError*.
        _dividend_ must be divided into more than one part unless _inclusive_ is *true*.
      </dd>
    </dl>
    <emu-alg>
      1. If _inclusive_ is *true*, then
        1. Let _maximum_ be _dividend_.
      1. Else,
        1. Assert: _dividend_ &gt; 1.
        1. Let _maximum_ be _dividend_ - 1.
      1. If _increment_ &gt; _maximum_, throw a *RangeError* exception.
      1. If _dividend_ modulo _increment_ &ne; 0, then
        1. Throw a *RangeError* exception.
      1. Return ~unused~.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-tofractionalseconddigits" type="abstract operation">
    <h1>
      ToFractionalSecondDigits (
        _normalizedOptions_: an Object,
      ): either a normal completion containing either an integer or *"auto"*, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It extracts the value of the property named *"fractionalSecondDigits"* from _normalizedOptions_ and makes sure it is a valid value for the option.</dd>
    </dl>
    <emu-alg>
      1. Let _digitsValue_ be ? Get(_normalizedOptions_, *"fractionalSecondDigits"*).
      1. If _digitsValue_ is *undefined*, return *"auto"*.
      1. If _digitsValue_ is not a Number, then
        1. If ? ToString(_digitsValue_) is not *"auto"*, throw a *RangeError* exception.
        1. Return *"auto"*.
      1. If _digitsValue_ is *NaN*, *+&infin;*<sub>𝔽</sub>, or *-&infin;*<sub>𝔽</sub>, throw a *RangeError* exception.
      1. Let _digitCount_ be floor(ℝ(_digitsValue_)).
      1. If _digitCount_ &lt; 0 or _digitCount_ &gt; 9, throw a *RangeError* exception.
      1. Return _digitCount_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-tosecondsstringprecisionrecord" type="abstract operation">
    <h1>
      ToSecondsStringPrecisionRecord (
        _smallestUnit_: one of *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"*, or *undefined*,
        _fractionalDigitCount_: either *"auto"* or an integer in the inclusive range 0 to 9,
      ): a Record with fields [[Precision]] (one of *"minute"*, *"auto"*, or an integer in the inclusive range 0 to 9), [[Unit]] (one of *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, or *"nanosecond"*), and [[Increment]] (one of 1, 10, or 100)
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        The returned Record represents details for serializing minutes and seconds to a string subject to the specified _smallestUnit_ or (when _smallestUnit_ is *undefined*) _fractionalDigitCount_ digits after the decimal point in the seconds.
        Its [[Precision]] field is either that count of digits, the string *"auto"* signifying that there should be no insignificant trailing zeroes, or the string *"minute"* signifying that seconds should not be included at all.
        Its [[Unit]] field is the most precise unit that can contribute to the string, and its [[Increment]] field indicates the rounding increment that should be applied to that unit.
      </dd>
    </dl>
    <emu-alg>
      1. If _smallestUnit_ is *"minute"*, then
        1. Return the Record {
            [[Precision]]: *"minute"*,
            [[Unit]]: *"minute"*,
            [[Increment]]: 1
          }.
      1. If _smallestUnit_ is *"second"*, then
        1. Return the Record {
            [[Precision]]: 0,
            [[Unit]]: *"second"*,
            [[Increment]]: 1
          }.
      1. If _smallestUnit_ is *"millisecond"*, then
        1. Return the Record {
            [[Precision]]: 3,
            [[Unit]]: *"millisecond"*,
            [[Increment]]: 1
          }.
      1. If _smallestUnit_ is *"microsecond"*, then
        1. Return the Record {
            [[Precision]]: 6,
            [[Unit]]: *"microsecond"*,
            [[Increment]]: 1
          }.
      1. If _smallestUnit_ is *"nanosecond"*, then
        1. Return the Record {
            [[Precision]]: 9,
            [[Unit]]: *"nanosecond"*,
            [[Increment]]: 1
          }.
      1. Assert: _smallestUnit_ is *undefined*.
      1. If _fractionalDigitCount_ is *"auto"*, then
        1. Return the Record {
            [[Precision]]: *"auto"*,
            [[Unit]]: *"nanosecond"*,
            [[Increment]]: 1
          }.
      1. If _fractionalDigitCount_ is 0, then
        1. Return the Record {
            [[Precision]]: 0,
            [[Unit]]: *"second"*,
            [[Increment]]: 1
          }.
      1. If _fractionalDigitCount_ is 1, 2, or 3, then
        1. Return the Record {
            [[Precision]]: _fractionalDigitCount_,
            [[Unit]]: *"millisecond"*,
            [[Increment]]: 10<sup>3 - _fractionalDigitCount_</sup>
          }.
      1. If _fractionalDigitCount_ is 4, 5, or 6, then
        1. Return the Record {
            [[Precision]]: _fractionalDigitCount_,
            [[Unit]]: *"microsecond"*,
            [[Increment]]: 10<sup>6 - _fractionalDigitCount_</sup>
          }.
      1. Assert: _fractionalDigitCount_ is 7, 8, or 9.
      1. Return the Record {
          [[Precision]]: _fractionalDigitCount_,
          [[Unit]]: *"nanosecond"*,
          [[Increment]]: 10<sup>9 - _fractionalDigitCount_</sup>
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-gettemporalunit" type="abstract operation">
    <h1>
      GetTemporalUnit (
        _normalizedOptions_: an Object,
        _key_: a property key,
        _unitGroup_: ~date~, ~time~, or ~datetime~,
        _default_: ~required~ or an ECMAScript language value,
        optional _extraValues_: a List of ECMAScript language values,
      ): either a normal completion containing an ECMAScript language value, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It attempts to read from the specified property of _normalizedOptions_ a Temporal unit that is <emu-not-ref>covered</emu-not-ref> by the union of _unitGroup_ and _extraValues_, substituting _default_ if the property value is *undefined*.</dd>
    </dl>
    <p>
      Both singular and plural unit names are accepted, but only the singular form is used internally.
    </p>
    <emu-alg>
      1. Let _singularNames_ be a new empty List.
      1. For each row of <emu-xref href="#table-temporal-units"></emu-xref>, except the header row, in table order, do
        1. Let _unit_ be the value in the Singular column of the row.
        1. If the Category column of the row is ~date~ and _unitGroup_ is ~date~ or ~datetime~, append _unit_ to _singularNames_.
        1. Else if the Category column of the row is ~time~ and _unitGroup_ is ~time~ or ~datetime~, append _unit_ to _singularNames_.
      1. If _extraValues_ is present, then
        1. Set _singularNames_ to the list-concatenation of _singularNames_ and _extraValues_.
      1. If _default_ is ~required~, then
        1. Let _defaultValue_ be *undefined*.
      1. Else,
        1. Let _defaultValue_ be _default_.
        1. If _defaultValue_ is not *undefined* and _singularNames_ does not contain _defaultValue_, then
          1. Append _defaultValue_ to _singularNames_.
      1. Let _allowedValues_ be a copy of _singularNames_.
      1. For each element _singularName_ of _singularNames_, do
        1. If _singularName_ is listed in the Singular column of <emu-xref href="#table-temporal-units"></emu-xref>, then
          1. Let _pluralName_ be the value in the Plural column of the corresponding row.
          1. Append _pluralName_ to _allowedValues_.
      1. NOTE: For each singular Temporal unit name that is contained within _allowedValues_, the corresponding plural name is also contained within it.
      1. Let _value_ be ? GetOption(_normalizedOptions_, _key_, *"string"*, _allowedValues_, _defaultValue_).
      1. If _value_ is *undefined* and _default_ is ~required~, throw a *RangeError* exception.
      1. If _value_ is listed in the Plural column of <emu-xref href="#table-temporal-units"></emu-xref>, then
        1. Set _value_ to the value in the Singular column of the corresponding row.
      1. Return _value_.
    </emu-alg>
    <emu-table id="table-temporal-units">
      <emu-caption>Temporal units by descending magnitude</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Singular</th>
            <th>Plural</th>
            <th>Category</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>*"year"*</td>
            <td>*"years"*</td>
            <td>~date~</td>
          </tr>

          <tr>
            <td>*"month"*</td>
            <td>*"months"*</td>
            <td>~date~</td>
          </tr>

          <tr>
            <td>*"week"*</td>
            <td>*"weeks"*</td>
            <td>~date~</td>
          </tr>

          <tr>
            <td>*"day"*</td>
            <td>*"days"*</td>
            <td>~date~</td>
          </tr>

          <tr>
            <td>*"hour"*</td>
            <td>*"hours"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"minute"*</td>
            <td>*"minutes"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"second"*</td>
            <td>*"seconds"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"millisecond"*</td>
            <td>*"milliseconds"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"microsecond"*</td>
            <td>*"microseconds"*</td>
            <td>~time~</td>
          </tr>

          <tr>
            <td>*"nanosecond"*</td>
            <td>*"nanoseconds"*</td>
            <td>~time~</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-torelativetemporalobject" aoid="ToRelativeTemporalObject">
    <h1>ToRelativeTemporalObject ( _options_ )</h1>
    <p>
      The abstract operation ToRelativeTemporalObject examines the value of the `relativeTo` property of its _options_ argument.
      If this is not present, it returns *undefined*.
      Otherwise, it attempts to return a Temporal.ZonedDateTime instance or Temporal.PlainDate instance, in order of preference, by converting the value.
      If neither of those are possible, the operation throws a *RangeError*.
    </p>
    <emu-alg>
      1. Assert: Type(_options_) is Object.
      1. Let _value_ be ? Get(_options_, *"relativeTo"*).
      1. If _value_ is *undefined*, then
        1. Return _value_.
      1. Let _offsetBehaviour_ be ~option~.
      1. Let _matchBehaviour_ be ~match exactly~.
      1. If Type(_value_) is Object, then
        1. If _value_ has either an [[InitializedTemporalDate]] or [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return _value_.
        1. If _value_ has an [[InitializedTemporalDateTime]] internal slot, then
          1. Return ! CreateTemporalDate(_value_.[[ISOYear]], _value_.[[ISOMonth]], _value_.[[ISODay]], _value_.[[Calendar]]).
        1. Let _calendar_ be ? GetTemporalCalendarSlotValueWithISODefault(_value_).
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, « *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"monthCode"*, *"nanosecond"*, *"second"*, *"year"* »).
        1. Append *"timeZone"* to _fieldNames_.
        1. Append *"offset"* to _fieldNames_.
        1. Let _fields_ be ? PrepareTemporalFields(_value_, _fieldNames_, «»).
        1. Let _dateOptions_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_dateOptions_, *"overflow"*, *"constrain"*).
        1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _dateOptions_).
        1. Let _offsetString_ be ! Get(_fields_, *"offset"*).
        1. Let _timeZone_ be ! Get(_fields_, *"timeZone"*).
        1. If _timeZone_ is not *undefined*, then
          1. Set _timeZone_ to ? ToTemporalTimeZone(_timeZone_).
        1. If _offsetString_ is *undefined*, then
          1. Set _offsetBehaviour_ to ~wall~.
      1. Else,
        1. Let _string_ be ? ToString(_value_).
        1. Let _result_ be ? ParseTemporalRelativeToString(_string_).
        1. Let _calendar_ be _result_.[[Calendar]].
        1. If _calendar_ is *undefined*, set _calendar_ to *"iso8601"*.
        1. Let _offsetString_ be _result_.[[TimeZone]].[[OffsetString]].
        1. Let _timeZoneName_ be _result_.[[TimeZone]].[[Name]].
        1. If _timeZoneName_ is *undefined*, then
          1. Let _timeZone_ be *undefined*.
        1. Else,
          1. If IsTimeZoneOffsetString(_timeZoneName_) is *false*, then
            1. If IsAvailableTimeZoneName(_timeZoneName_) is *false*, throw a *RangeError* exception.
            1. Set _timeZoneName_ to ! CanonicalizeTimeZoneName(_timeZoneName_).
          1. Let _timeZone_ be ! CreateTemporalTimeZone(_timeZoneName_).
          1. If _result_.[[TimeZone]].[[Z]] is *true*, then
            1. Set _offsetBehaviour_ to ~exact~.
          1. Else if _offsetString_ is *undefined*, then
            1. Set _offsetBehaviour_ to ~wall~.
          1. Set _matchBehaviour_ to ~match minutes~.
      1. If _timeZone_ is *undefined*, then
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      1. If _offsetBehaviour_ is ~option~, then
        1. If IsTimeZoneOffsetString(_offsetString_) is *false*, throw a *RangeError* exception.
        1. Let _offsetNs_ be ParseTimeZoneOffsetString(_offsetString_).
      1. Else,
        1. Let _offsetNs_ be 0.
      1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _offsetBehaviour_, _offsetNs_, _timeZone_, *"compatible"*, *"reject"*, _matchBehaviour_).
      1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-largeroftwotemporalunits" aoid="LargerOfTwoTemporalUnits">
    <h1>LargerOfTwoTemporalUnits ( _u1_, _u2_ )</h1>
    <p>
      The abstract operation LargerOfTwoTemporalUnits, given two strings representing Temporal units, returns the string representing the larger of the two units.
    </p>
    <emu-alg>
      1. Assert: Both _u1_ and _u2_ are listed in the Singular column of <emu-xref href="#table-temporal-units"></emu-xref>.
      1. For each row of <emu-xref href="#table-temporal-units"></emu-xref>, except the header row, in table order, do
        1. Let _unit_ be the value in the Singular column of the row.
        1. If SameValue(_u1_, _unit_) is *true*, return _unit_.
        1. If SameValue(_u2_, _unit_) is *true*, return _unit_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-maximumtemporaldurationroundingincrement" aoid="MaximumTemporalDurationRoundingIncrement">
    <h1>MaximumTemporalDurationRoundingIncrement ( _unit_ )</h1>
    <emu-alg>
      1. If _unit_ is *"year"*, *"month"*, *"week"*, or *"day"*, then
        1. Return *undefined*.
      1. If _unit_ is *"hour"*, then
        1. Return 24.
      1. If _unit_ is *"minute"* or *"second"*, then
        1. Return 60.
      1. Assert: _unit_ is one of *"millisecond"*, *"microsecond"*, or *"nanosecond"*.
      1. Return 1000.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-rejecttemporalobject" type="abstract operation">
    <h1>
      RejectTemporalObject (
        _object_: an Object,
      ): either a normal completion containing ~unused~, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It throws an exception if its argument _object_ is an instance of one of the time-related or date-related Temporal types, or is an object that has a `calendar` or `timeZone` property.</dd>
    </dl>
    <emu-alg>
      1. If _object_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalTime]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
        1. Throw a *TypeError* exception.
      1. Let _calendarProperty_ be ? Get(_object_, *"calendar"*).
      1. If _calendarProperty_ is not *undefined*, then
        1. Throw a *TypeError* exception.
      1. Let _timeZoneProperty_ be ? Get(_object_, *"timeZone"*).
      1. If _timeZoneProperty_ is not *undefined*, then
        1. Throw a *TypeError* exception.
      1. Return ~unused~.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-formatsecondsstringpart" aoid="FormatSecondsStringPart">
    <h1>FormatSecondsStringPart ( _second_, _millisecond_, _microsecond_, _nanosecond_, _precision_ )</h1>
    <emu-alg>
      1. Assert: _second_, _millisecond_, _microsecond_, and _nanosecond_ are integers.
      1. If _precision_ is *"minute"*, return *""*.
      1. Let _secondsString_ be the string-concatenation of the code unit 0x003A (COLON) and ToZeroPaddedDecimalString(_second_, 2).
      1. Let _fraction_ be _millisecond_ &times; 10<sup>6</sup> + _microsecond_ &times; 10<sup>3</sup> + _nanosecond_.
      1. If _precision_ is *"auto"*, then
        1. If _fraction_ is 0, return _secondsString_.
        1. Set _fraction_ to ToZeroPaddedDecimalString(_fraction_, 9).
        1. Set _fraction_ to the longest possible substring of _fraction_ starting at position 0 and not ending with the code unit 0x0030 (DIGIT ZERO).
      1. Else,
        1. If _precision_ is 0, return _secondsString_.
        1. Set _fraction_ to ToZeroPaddedDecimalString(_fraction_, 9).
        1. Set _fraction_ to the substring of _fraction_ from 0 to _precision_.
      1. Return the string-concatenation of _secondsString_, the code unit 0x002E (FULL STOP), and _fraction_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-getunsignedroundingmode" type="abstract operation">
    <h1>
      GetUnsignedRoundingMode (
        _roundingMode_: *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, or *"halfEven"*,
        _isNegative_: *true* or *false*,
      ): ~zero~, ~infinity~, ~half-zero~, ~half-infinity~, or ~half-even~
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        The return value is the rounding mode that should be applied to the absolute value of a number to produce the same result as if _roundingMode_ were applied to the signed value of the number (negative if _isNegative_ is *true*, or positive otherwise).
      </dd>
    </dl>
    <emu-alg>
      1. If _isNegative_ is *true*, return the specification type in the third column of <emu-xref href="#table-temporal-unsigned-rounding-modes"></emu-xref> where the first column is _roundingMode_ and the second column is "negative".
      1. Else, return the specification type in the third column of <emu-xref href="#table-temporal-unsigned-rounding-modes"></emu-xref> where the first column is _roundingMode_ and the second column is "positive".
    </emu-alg>
    <emu-note type="editor">
      <p>This operation is intended to be the same one as in the <a href="https://tc39.es/proposal-intl-numberformat-v3/out/numberformat/diff.html#sec-getunsignedroundingmode">Intl.NumberFormat v3</a> proposal.</p>
    </emu-note>
    <emu-table id="table-temporal-unsigned-rounding-modes">
      <emu-caption>Conversion from rounding mode to unsigned rounding mode</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Identifier</th>
            <th>Sign</th>
            <th>Unsigned Rounding Mode</th>
          </tr>
        </thead>
        <tr>
          <td rowspan="2">*"ceil"*</td>
          <td>positive</td>
          <td>~infinity~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~zero~</td>
        </tr>
        <tr>
          <td rowspan="2">*"floor"*</td>
          <td>positive</td>
          <td>~zero~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~infinity~</td>
        </tr>
        <tr>
          <td rowspan="2">*"expand"*</td>
          <td>positive</td>
          <td>~infinity~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~infinity~</td>
        </tr>
        <tr>
          <td rowspan="2">*"trunc"*</td>
          <td>positive</td>
          <td>~zero~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~zero~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfCeil"*</td>
          <td>positive</td>
          <td>~half-infinity~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-zero~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfFloor"*</td>
          <td>positive</td>
          <td>~half-zero~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-infinity~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfExpand"*</td>
          <td>positive</td>
          <td>~half-infinity~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-infinity~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfTrunc"*</td>
          <td>positive</td>
          <td>~half-zero~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-zero~</td>
        </tr>
        <tr>
          <td rowspan="2">*"halfEven"*</td>
          <td>positive</td>
          <td>~half-even~</td>
        </tr>
        <tr>
          <td>negative</td>
          <td>~half-even~</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-applyunsignedroundingmode" type="abstract operation">
    <h1>
      ApplyUnsignedRoundingMode (
        _x_: a mathematical value,
        _r1_: a mathematical value,
        _r2_: a mathematical value,
        _unsignedRoundingMode_: ~zero~, ~infinity~, ~half-zero~, ~half-infinity~, ~half-even~, or *undefined*,
      ): a mathematical value
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It considers _x_, bracketed below by _r1_ and above by _r2_, and returns either _r1_ or _r2_ according to _unsignedRoundingMode_.
      </dd>
    </dl>
    <emu-alg>
      1. If _x_ is equal to _r1_, return _r1_.
      1. Assert: _r1_ &lt; _x_ &lt; _r2_.
      1. Assert: _unsignedRoundingMode_ is not *undefined*.
      1. If _unsignedRoundingMode_ is ~zero~, return _r1_.
      1. If _unsignedRoundingMode_ is ~infinity~, return _r2_.
      1. Let _d1_ be <emu-eqn>_x_ – _r1_</emu-eqn>.
      1. Let _d2_ be <emu-eqn>_r2_ – _x_</emu-eqn>.
      1. If _d1_ &lt; _d2_, return _r1_.
      1. If _d2_ &lt; _d1_, return _r2_.
      1. Assert: _d1_ is equal to _d2_.
      1. If _unsignedRoundingMode_ is ~half-zero~, return _r1_.
      1. If _unsignedRoundingMode_ is ~half-infinity~, return _r2_.
      1. Assert: _unsignedRoundingMode_ is ~half-even~.
      1. Let _cardinality_ be <emu-eqn>(_r1_ / (_r2_ – _r1_)) modulo 2</emu-eqn>.
      1. If _cardinality_ is 0, return _r1_.
      1. Return _r2_.
    </emu-alg>
    <emu-note type="editor">
      <p>This operation is intended to be the same one as in the <a href="https://tc39.es/proposal-intl-numberformat-v3/out/numberformat/diff.html#sec-applyunsignedroundingmode">Intl.NumberFormat v3</a> proposal.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-roundnumbertoincrement" type="abstract operation">
    <h1>
      RoundNumberToIncrement (
        _x_: a mathematical value,
        _increment_: an integer,
        _roundingMode_: *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, or *"halfEven"*,
      ): an integer
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It rounds _x_ to the nearest multiple of _increment_, up or down according to _roundingMode_.</dd>
    </dl>
    <emu-alg>
      1. Let _quotient_ be _x_ / _increment_.
      1. If _quotient_ &lt; 0, then
        1. Let _isNegative_ be *true*.
        1. Set _quotient_ to -_quotient_.
      1. Else,
        1. Let _isNegative_ be *false*.
      1. Let _unsignedRoundingMode_ be GetUnsignedRoundingMode(_roundingMode_, _isNegative_).
      1. Let _r1_ be the largest integer such that _r1_ ≤ _quotient_.
      1. Let _r2_ be the smallest integer such that _r2_ &gt; _quotient_.
      1. Let _rounded_ be ApplyUnsignedRoundingMode(_quotient_, _r1_, _r2_, _unsignedRoundingMode_).
      1. If _isNegative_ is *true*, set _rounded_ to -_rounded_.
      1. Return _rounded_ &times; _increment_.
    </emu-alg>
    <emu-note type="editor">
      <p>
        The rounding modes accepted by this abstract operation are intended to be the same as whatever is eventually standardized in the <a href="https://github.com/tc39/proposal-intl-numberformat-v3">Intl.NumberFormat V3</a> proposal.
      </p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-roundnumbertoincrementasifpositive" type="abstract operation">
    <h1>
      RoundNumberToIncrementAsIfPositive (
        _x_: a mathematical value,
        _increment_: an integer,
        _roundingMode_: *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, or *"halfEven"*,
      ): an integer
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It rounds _x_ to the nearest multiple of _increment_, up or down according to _roundingMode_, but always as if _x_ were positive.
        For example, *"floor"* and *"trunc"* behave identically.
        This is used when rounding exact times, where "rounding down" conceptually always means towards the beginning of time, even if the time is expressed as a negative amount of time relative to an epoch.
      </dd>
    </dl>
    <emu-alg>
      1. Let _quotient_ be _x_ / _increment_.
      1. Let _unsignedRoundingMode_ be GetUnsignedRoundingMode(_roundingMode_, *false*).
      1. Let _r1_ be the largest integer such that _r1_ &leq; _quotient_.
      1. Let _r2_ be the smallest integer such that _r2_ &gt; _quotient_.
      1. Let _rounded_ be ApplyUnsignedRoundingMode(_quotient_, _r1_, _r2_, _unsignedRoundingMode_).
      1. Return _rounded_ &times; _increment_.
    </emu-alg>
    <emu-note type="editor">
      <p>
        The rounding modes accepted by this abstract operation are intended to be the same as whatever is eventually standardized in the <a href="https://github.com/tc39/proposal-intl-numberformat-v3">Intl.NumberFormat V3</a> proposal.
      </p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-iso8601grammar">
    <h1>ISO 8601 grammar</h1>
    <p>
      Several operations in this section are intended to parse ISO 8601 strings representing a date, a time, a duration, or a combined date and time.
      For the purposes of these operations, a valid ISO 8601 string is defined as a string that can be generated by one of the goal elements of the following grammar.
    </p>
    <p>
      This grammar is adapted from the ABNF grammar of ISO 8601 that is given in appendix A of <a href="https://tools.ietf.org/html/rfc3339#appendix-A">RFC 3339</a>, augmented with the grammar of annotations in section 3.1 of <a href="https://datatracker.ietf.org/doc/html/draft-ietf-sedate-datetime-extended#section-3.1">Date and Time on the Internet: Timestamps with additional information</a>
    </p>
    <p>
      The grammar deviates from the standard given in ISO 8601 in the following ways:
    </p>
    <ul>
      <li>Only the calendar date format is supported, not the weekdate or ordinal date format.</li>
      <li>Two-digit years are disallowed.</li>
      <li><a href="https://tc39.es/ecma262/#sec-expanded-years">Expanded Years</a> of 6 digits are allowed.</li>
      <li>Fractional parts may have 1 through 9 decimal places.</li>
      <li>In time representations, only seconds are allowed to have a fractional part.</li>
      <li>In duration representations, only hours, minutes, and seconds are allowed to have a fractional part.</li>
      <li>Any number of conforming <a href="https://datatracker.ietf.org/doc/html/draft-ietf-sedate-datetime-extended#section-3.1">suffixes in square brackets</a> are allowed.</li>
      <li>
        Time zone and <a href="https://tools.ietf.org/html/bcp47#section-2.1">BCP 47 calendar</a> suffixes are the only recognized ones.
        Others are ignored, unless they are marked with a *!*, in which case they are rejected.
      </li>
      <li>A space may be used to separate the date and time in a combined date / time representation, but not in a duration.</li>
      <li>Alphabetic designators may be in lower or upper case.</li>
      <li>Period or comma may be used as the decimal separator.</li>
      <li>A time zone offset of *"-00:00"* is allowed, and means the same thing as *"+00:00"*.</li>
      <li>
        In a combined representation, combinations of date, time, and time zone offset with Basic (no `-` or `:` separators) and Extended (with `-` or `:` separators) formatting are allowed.
        (The date, time, and time zone offset must each be fully in Basic format or Extended format.)
      </li>
      <li>
        When parsing a date representation for a Temporal.PlainMonthDay, the year may be omitted.
        The year may optionally be replaced by *"--"* as in RFC 3339.
      </li>
      <li>When parsing a date representation without a day for a Temporal.PlainYearMonth, the expression is allowed to be in Basic format.</li>
      <li>A duration specifier of *"W"* (weeks) can be combined with any of the other specifiers.</li>
      <li>Anything else described by the standard as requiring mutual agreement between communicating parties, is disallowed.</li>
    </ul>

    <emu-grammar type="definition">
      Alpha : one of
          `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M`
          `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`
          `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m`
          `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`

      LowercaseAlpha : one of
          `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m`
          `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`

      ASCIISign : one of
          `+` `-`

      Sign :
          ASCIISign
          U+2212

      UnpaddedHour :
          DecimalDigit
          `1` DecimalDigit
          `20`
          `21`
          `22`
          `23`

      Hour :
          `0` DecimalDigit
          `1` DecimalDigit
          `20`
          `21`
          `22`
          `23`

      MinuteSecond :
          `0` DecimalDigit
          `1` DecimalDigit
          `2` DecimalDigit
          `3` DecimalDigit
          `4` DecimalDigit
          `5` DecimalDigit

      DecimalSeparator : one of
          `.` `,`

      DaysDesignator : one of
          `D` `d`

      HoursDesignator : one of
          `H` `h`

      MinutesDesignator : one of
          `M` `m`

      MonthsDesignator : one of
          `M` `m`

      DurationDesignator : one of
          `P` `p`

      SecondsDesignator : one of
          `S` `s`

      DateTimeSeparator :
          &lt;SP&gt;
          `T`
          `t`

      TimeDesignator : one of
          `T` `t`

      WeeksDesignator : one of
          `W` `w`

      YearsDesignator : one of
          `Y` `y`

      UTCDesignator : one of
          `Z` `z`

      AnnotationCriticalFlag :
          `!`

      DateFourDigitYear :
          DecimalDigit DecimalDigit DecimalDigit DecimalDigit

      DateExtendedYear :
          Sign DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

      DateYear :
          DateFourDigitYear
          DateExtendedYear

      DateMonth :
          `0` NonZeroDigit
          `10`
          `11`
          `12`

      DateMonthWithThirtyOneDays : one of
          `01` `03` `05` `07` `08` `10` `12`

      DateDay :
          `0` NonZeroDigit
          `1` DecimalDigit
          `2` DecimalDigit
          `30`
          `31`

      DateSpecYearMonth :
          DateYear `-`? DateMonth

      TwoDashes :
          `--`

      DateSpecMonthDay :
          TwoDashes? DateMonth `-`? DateDay

      ValidMonthDay :
          DateMonth `-`? `0` NonZeroDigit
          DateMonth `-`? `1` DecimalDigit
          DateMonth `-`? `2` DecimalDigit
          DateMonth `-`? `30` but not one of `0230` or `02-30`
          DateMonthWithThirtyOneDays `-`? `31`

      Date :
          DateYear `-` DateMonth `-` DateDay
          DateYear DateMonth DateDay

      TimeHour :
          Hour

      TimeMinute :
          MinuteSecond

      TimeSecond :
          MinuteSecond
          `60`

      Fraction :
          > Readability note: This production matches a decimal separator followed by 1 to 9 digits
          DecimalSeparator DecimalDigit
          DecimalSeparator DecimalDigit DecimalDigit
          DecimalSeparator DecimalDigit DecimalDigit DecimalDigit
          DecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit
          DecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
          DecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
          DecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
          DecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
          DecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

      TimeFraction :
          Fraction

      TimeZoneUTCOffset :
          UTCOffset
          UTCDesignator

      TimeZoneUTCOffsetName :
          Sign Hour
          Sign Hour `:` MinuteSecond
          Sign Hour MinuteSecond
          Sign Hour `:` MinuteSecond `:` MinuteSecond Fraction?
          Sign Hour MinuteSecond MinuteSecond Fraction?

      TZLeadingChar :
          Alpha
          `.`
          `_`

      TZChar[Legacy] :
          Alpha
          `.`
          `-`
          `_`
          [+Legacy] `+`
          [+Legacy] DecimalDigit

      TimeZoneIANANameComponent[Legacy] :
          > Readability note: This production matches 1 to 14 characters.
          TZLeadingChar but not `.`
          TZLeadingChar TZChar[?Legacy] but not `..`
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]
          TZLeadingChar TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy] TZChar[?Legacy]

      TimeZoneIANANameTail[Legacy] :
          TimeZoneIANANameComponent[?Legacy]
          TimeZoneIANANameComponent[?Legacy] `/` TimeZoneIANANameTail[?Legacy]

      TimeZoneIANALegacyName :
          TimeZoneIANANameTail[+Legacy] [&gt; but only if `etc/gmt` |ASCIISign| |UnpaddedHour| matches the ASCII-lowercase of the sequence of code points matched by (|TimeZoneIANANameTail|)]
          TimeZoneIANANameTail[+Legacy] [&gt; but only if the sequence of code points matched by |TimeZoneIANANameTail| is an ASCII-case-insensitive match for an element of « *"Etc/GMT0"*, *"GMT0"*, *"GMT-0"*, *"GMT+0"*, *"EST5EDT"*, *"CST6CDT"*, *"MST7MDT"*, *"PST8PDT"* »]

      TimeZoneIANAName :
          TimeZoneIANANameTail[~Legacy]
          TimeZoneIANALegacyName

      TimeZoneIdentifier :
          TimeZoneIANAName
          TimeZoneUTCOffsetName

      TimeZoneAnnotation :
          `[` AnnotationCriticalFlag? TimeZoneIdentifier `]`

      AKeyLeadingChar :
          LowercaseAlpha
          `_`

      AKeyChar :
          AKeyLeadingChar
          DecimalDigit
          `-`

      AValChar :
          Alpha
          DecimalDigit

      AnnotationKeyTail :
          AKeyChar AnnotationKeyTail?

      AnnotationKey :
          AKeyLeadingChar AnnotationKeyTail?

      AnnotationValueComponent :
          AValChar AnnotationValueComponent?

      AnnotationValueTail :
          AnnotationValueComponent
          AnnotationValueComponent `-` AnnotationValueTail

      AnnotationValue :
          AnnotationValueTail

      Annotation :
          `[` AnnotationCriticalFlag? AnnotationKey `=` AnnotationValue `]`

      Annotations :
          Annotation Annotations?

      TimeSpec :
          TimeHour
          TimeHour `:` TimeMinute
          TimeHour TimeMinute
          TimeHour `:` TimeMinute `:` TimeSecond TimeFraction?
          TimeHour TimeMinute TimeSecond TimeFraction?

      TimeSpecWithOptionalOffsetNotAmbiguous :
          TimeSpec TimeZoneUTCOffset? but not one of ValidMonthDay or DateSpecYearMonth

      DateTime :
          Date
          Date DateTimeSeparator TimeSpec TimeZoneUTCOffset?

      AnnotatedTime :
          TimeDesignator TimeSpec TimeZoneUTCOffset? TimeZoneAnnotation? Annotations?
          TimeSpecWithOptionalOffsetNotAmbiguous TimeZoneAnnotation? Annotations?

      AnnotatedDateTime:
          DateTime TimeZoneAnnotation? Annotations?

      AnnotatedDateTimeTimeRequired :
          Date DateTimeSeparator TimeSpec TimeZoneUTCOffset? TimeZoneAnnotation? Annotations?

      AnnotatedYearMonth:
          DateSpecYearMonth TimeZoneAnnotation? Annotations?

      AnnotatedMonthDay:
          DateSpecMonthDay TimeZoneAnnotation? Annotations?

      DurationWholeSeconds :
          DecimalDigits[~Sep]

      DurationSecondsFraction :
          TimeFraction

      DurationSecondsPart :
          DurationWholeSeconds DurationSecondsFraction? SecondsDesignator

      DurationWholeMinutes :
          DecimalDigits[~Sep]

      DurationMinutesFraction :
          TimeFraction

      DurationMinutesPart :
          DurationWholeMinutes DurationMinutesFraction? MinutesDesignator DurationSecondsPart?

      DurationWholeHours :
          DecimalDigits[~Sep]

      DurationHoursFraction :
          TimeFraction

      DurationHoursPart :
          DurationWholeHours DurationHoursFraction? HoursDesignator DurationMinutesPart
          DurationWholeHours DurationHoursFraction? HoursDesignator DurationSecondsPart?

      DurationTime :
          TimeDesignator DurationHoursPart
          TimeDesignator DurationMinutesPart
          TimeDesignator DurationSecondsPart

      DurationDays :
          DecimalDigits[~Sep]

      DurationDaysPart :
          DurationDays DaysDesignator

      DurationWeeks :
          DecimalDigits[~Sep]

      DurationWeeksPart :
          DurationWeeks WeeksDesignator DurationDaysPart?

      DurationMonths :
          DecimalDigits[~Sep]

      DurationMonthsPart :
          DurationMonths MonthsDesignator DurationWeeksPart
          DurationMonths MonthsDesignator DurationDaysPart?

      DurationYears :
          DecimalDigits[~Sep]

      DurationYearsPart :
          DurationYears YearsDesignator DurationMonthsPart
          DurationYears YearsDesignator DurationWeeksPart
          DurationYears YearsDesignator DurationDaysPart?

      DurationDate :
          DurationYearsPart DurationTime?
          DurationMonthsPart DurationTime?
          DurationWeeksPart DurationTime?
          DurationDaysPart DurationTime?

      Duration :
          Sign? DurationDesignator DurationDate
          Sign? DurationDesignator DurationTime

      TemporalInstantString :
          Date DateTimeSeparator TimeSpec TimeZoneUTCOffset TimeZoneAnnotation? Annotations?

      TemporalDateTimeString :
          AnnotatedDateTime

      TemporalDurationString :
          Duration

      TemporalMonthDayString :
          AnnotatedMonthDay
          AnnotatedDateTime

      TemporalTimeString :
          AnnotatedTime
          AnnotatedDateTimeTimeRequired

      TemporalYearMonthString :
          AnnotatedYearMonth
          AnnotatedDateTime

      TemporalZonedDateTimeString :
          DateTime TimeZoneAnnotation Annotations?
    </emu-grammar>

    <emu-clause id="sec-temporal-iso8601grammar-early-errors">
      <h1>Early errors</h1>
      <emu-grammar>
        DateExtendedYear :
          Sign DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if |DateExtendedYear| is *"-000000"* or *"−000000"* (U+2212 MINUS SIGN followed by `000000`).
        </li>
      </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-parseisodatetime" type="abstract operation">
    <h1>
      ParseISODateTime (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component as a distinct field.</dd>
    </dl>
    <emu-note>The value of ! ToIntegerOrInfinity(*undefined*) is 0.</emu-note>
    <emu-alg>
      1. Let _parseResult_ be ~empty~.
      1. For each nonterminal _goal_ of &laquo; |TemporalDateTimeString|, |TemporalInstantString|, |TemporalTimeString|, |TemporalZonedDateTimeString| &raquo;, do
        1. If _parseResult_ is not a Parse Node, set _parseResult_ to ParseText(StringToCodePoints(_isoString_), _goal_).
      1. For each nonterminal _goal_ of &laquo; |TemporalMonthDayString|, |TemporalYearMonthString| &raquo;, do
        1. If _parseResult_ is not a Parse Node, then
          1. Set _parseResult_ to ParseText(StringToCodePoints(_isoString_), _goal_).
          1. If _parseResult_ is a Parse Node, then
            1. For each |Annotation| Parse Node _annotation_ contained within _parseResult_, do
              1. Let _key_ be the source text matched by the |AnnotationKey| Parse Node contained within _annotation_.
              1. Let _value_ be the source text matched by the |AnnotationValue| Parse Node contained within _annotation_.
              1. If CodePointsToString(_key_) is *"u-ca"* and the ASCII-lowercase of CodePointsToString(_value_) is not *"iso8601"*, throw a *RangeError* exception.
      1. If _parseResult_ is not a Parse Node, throw a *RangeError* exception.
      1. Let each of _year_, _month_, _day_, _hour_, _minute_, _second_, and _fSeconds_ be the source text matched by the respective |DateYear|, |DateMonth|, |DateDay|, |TimeHour|, |TimeMinute|, |TimeSecond|, and |TimeFraction| Parse Node contained within _parseResult_, or an empty sequence of code points if not present.
      1. If the first code point of _year_ is U+2212 (MINUS SIGN), replace the first code point with U+002D (HYPHEN-MINUS).
      1. Let _yearMV_ be ! ToIntegerOrInfinity(CodePointsToString(_year_)).
      1. If _month_ is empty, then
        1. Let _monthMV_ be 1.
      1. Else,
        1. Let _monthMV_ be ! ToIntegerOrInfinity(CodePointsToString(_month_)).
      1. If _day_ is empty, then
        1. Let _dayMV_ be 1.
      1. Else,
        1. Let _dayMV_ be ! ToIntegerOrInfinity(CodePointsToString(_day_)).
      1. Let _hourMV_ be ! ToIntegerOrInfinity(CodePointsToString(_hour_)).
      1. Let _minuteMV_ be ! ToIntegerOrInfinity(CodePointsToString(_minute_)).
      1. Let _secondMV_ be ! ToIntegerOrInfinity(CodePointsToString(_second_)).
      1. If _secondMV_ is 60, then
        1. Set _secondMV_ to 59.
      1. If _fSeconds_ is not empty, then
        1. Let _fSecondsDigits_ be the substring of CodePointsToString(_fSeconds_) from 1.
        1. Let _fSecondsDigitsExtended_ be the string-concatenation of _fSecondsDigits_ and *"000000000"*.
        1. Let _millisecond_ be the substring of _fSecondsDigitsExtended_ from 0 to 3.
        1. Let _microsecond_ be the substring of _fSecondsDigitsExtended_ from 3 to 6.
        1. Let _nanosecond_ be the substring of _fSecondsDigitsExtended_ from 6 to 9.
        1. Let _millisecondMV_ be ! ToIntegerOrInfinity(_millisecond_).
        1. Let _microsecondMV_ be ! ToIntegerOrInfinity(_microsecond_).
        1. Let _nanosecondMV_ be ! ToIntegerOrInfinity(_nanosecond_).
      1. Else,
        1. Let _millisecondMV_ be 0.
        1. Let _microsecondMV_ be 0.
        1. Let _nanosecondMV_ be 0.
      1. If IsValidISODate(_yearMV_, _monthMV_, _dayMV_) is *false*, throw a *RangeError* exception.
      1. If IsValidTime(_hourMV_, _minuteMV_, _secondMV_, _millisecondMV_, _microsecondMV_, _nanosecondMV_) is *false*, throw a *RangeError* exception.
      1. Let _timeZoneResult_ be the Record { [[Z]]: *false*, [[OffsetString]]: *undefined*, [[Name]]: *undefined* }.
      1. If _parseResult_ contains a |TimeZoneIdentifier| Parse Node, then
        1. Let _name_ be the source text matched by the |TimeZoneIdentifier| Parse Node contained within _parseResult_.
        1. Set _timeZoneResult_.[[Name]] to CodePointsToString(_name_).
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, then
        1. Set _timeZoneResult_.[[Z]] to *true*.
      1. Else,
        1. If _parseResult_ contains a |UTCOffset| Parse Node, then
          1. Let _offset_ be the source text matched by the |UTCOffset| Parse Node contained within _parseResult_.
          1. Set _timeZoneResult_.[[OffsetString]] to CodePointsToString(_offset_).
      1. Let _calendar_ be *undefined*.
      1. For each |Annotation| Parse Node _annotation_ contained within _parseResult_, do
        1. Let _key_ be the source text matched by the |AnnotationKey| Parse Node contained within _annotation_.
        1. If CodePointsToString(_key_) is *"u-ca"*, then
          1. If _calendar_ is *undefined*, then
            1. Let _value_ be the source text matched by the |AnnotationValue| Parse Node contained within _annotation_.
            1. Let _calendar_ be CodePointsToString(_value_).
        1. Else,
          1. If _annotation_ contains an |AnnotationCriticalFlag| Parse Node, throw a *RangeError* exception.
      1. Return the Record {
          [[Year]]: _yearMV_,
          [[Month]]: _monthMV_,
          [[Day]]: _dayMV_,
          [[Hour]]: _hourMV_,
          [[Minute]]: _minuteMV_,
          [[Second]]: _secondMV_,
          [[Millisecond]]: _millisecondMV_,
          [[Microsecond]]: _microsecondMV_,
          [[Nanosecond]]: _nanosecondMV_,
          [[TimeZone]]: _timeZoneResult_,
          [[Calendar]]: _calendar_
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalinstantstring" type="abstract operation">
    <h1>
      ParseTemporalInstantString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.Instant instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. If ParseText(StringToCodePoints(_isoString_), |TemporalInstantString|) is a List of errors, throw a *RangeError* exception.
      1. Let _result_ be ? ParseISODateTime(_isoString_).
      1. Let _offsetString_ be _result_.[[TimeZone]].[[OffsetString]].
      1. If _result_.[[TimeZone]].[[Z]] is *true*, then
        1. Set _offsetString_ to *"+00:00"*.
      1. Assert: _offsetString_ is not *undefined*.
      1. Return the Record {
        [[Year]]: _result_.[[Year]],
        [[Month]]: _result_.[[Month]],
        [[Day]]: _result_.[[Day]],
        [[Hour]]: _result_.[[Hour]],
        [[Minute]]: _result_.[[Minute]],
        [[Second]]: _result_.[[Second]],
        [[Millisecond]]: _result_.[[Millisecond]],
        [[Microsecond]]: _result_.[[Microsecond]],
        [[Nanosecond]]: _result_.[[Nanosecond]],
        [[TimeZoneOffsetString]]: _offsetString_
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalzoneddatetimestring" type="abstract operation">
    <h1>
      ParseTemporalZonedDateTimeString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.ZonedDateTime instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. If ParseText(StringToCodePoints(_isoString_), |TemporalZonedDateTimeString|) is a List of errors, throw a *RangeError* exception.
      1. Return ? ParseISODateTime(_isoString_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalcalendarstring" type="abstract operation">
    <h1>
      ParseTemporalCalendarString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns the calendar identifier, or *undefined* if there is none.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be Completion(ParseISODateTime(_isoString_)).
      1. If _parseResult_ is a normal completion, then
        1. Let _calendar_ be _parseResult_.[[Value]].[[Calendar]].
        1. If _calendar_ is *undefined*, return *"iso8601"*.
        1. Else, return _calendar_.
      1. Else,
        1. Set _parseResult_ to ParseText(StringToCodePoints(_isoString_), |AnnotationValue|).
        1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
        1. Else, return _isoString_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaldatestring" type="abstract operation">
    <h1>
      ParseTemporalDateString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as a full or partial ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.PlainDate instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. Let _parts_ be ? ParseTemporalDateTimeString(_isoString_).
      1. Return the Record {
        [[Year]]: _parts_.[[Year]],
        [[Month]]: _parts_.[[Month]],
        [[Day]]: _parts_.[[Day]],
        [[Calendar]]: _parts_.[[Calendar]]
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaldatetimestring" type="abstract operation">
    <h1>
      ParseTemporalDateTimeString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.PlainDateTime instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalDateTimeString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, throw a *RangeError* exception.
      1. Return ? ParseISODateTime(_isoString_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaldurationstring" type="abstract operation">
    <h1>
      ParseTemporalDurationString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 duration string and returns a Duration Record.</dd>
    </dl>
    <emu-note>The value of ToIntegerWithTruncation(*""*) is 0.</emu-note>
    <emu-note>Use of mathematical values rather than approximations is important to avoid off-by-one errors with input like "PT46H66M71.50040904S".</emu-note>
    <emu-alg>
      1. Let _duration_ be ParseText(StringToCodePoints(_isoString_), |TemporalDurationString|).
      1. If _duration_ is a List of errors, throw a *RangeError* exception.
      1. Let each of _sign_, _years_, _months_, _weeks_, _days_, _hours_, _fHours_, _minutes_, _fMinutes_, _seconds_, and _fSeconds_ be the source text matched by the respective |Sign|, |DurationYears|, |DurationMonths|, |DurationWeeks|, |DurationDays|, |DurationWholeHours|, |DurationHoursFraction|, |DurationWholeMinutes|, |DurationMinutesFraction|, |DurationWholeSeconds|, and |DurationSecondsFraction| Parse Node contained within _duration_, or an empty sequence of code points if not present.
      1. Let _yearsMV_ be ? ToIntegerWithTruncation(CodePointsToString(_years_)).
      1. Let _monthsMV_ be ? ToIntegerWithTruncation(CodePointsToString(_months_)).
      1. Let _weeksMV_ be ? ToIntegerWithTruncation(CodePointsToString(_weeks_)).
      1. Let _daysMV_ be ? ToIntegerWithTruncation(CodePointsToString(_days_)).
      1. Let _hoursMV_ be ? ToIntegerWithTruncation(CodePointsToString(_hours_)).
      1. If _fHours_ is not empty, then
        1. If any of _minutes_, _fMinutes_, _seconds_, _fSeconds_ is not empty, throw a *RangeError* exception.
        1. Let _fHoursDigits_ be the substring of CodePointsToString(_fHours_) from 1.
        1. Let _fHoursScale_ be the length of _fHoursDigits_.
        1. Let _minutesMV_ be ? ToIntegerWithTruncation(_fHoursDigits_) / 10<sup>_fHoursScale_</sup> &times; 60.
      1. Else,
        1. Let _minutesMV_ be ? ToIntegerWithTruncation(CodePointsToString(_minutes_)).
      1. If _fMinutes_ is not empty, then
        1. If any of _seconds_, _fSeconds_ is not empty, throw a *RangeError* exception.
        1. Let _fMinutesDigits_ be the substring of CodePointsToString(_fMinutes_) from 1.
        1. Let _fMinutesScale_ be the length of _fMinutesDigits_.
        1. Let _secondsMV_ be ? ToIntegerWithTruncation(_fMinutesDigits_) / 10<sup>_fMinutesScale_</sup> &times; 60.
      1. Else if _seconds_ is not empty, then
        1. Let _secondsMV_ be ? ToIntegerWithTruncation(CodePointsToString(_seconds_)).
      1. Else,
        1. Let _secondsMV_ be remainder(_minutesMV_, 1) &times; 60.
      1. If _fSeconds_ is not empty, then
        1. Let _fSecondsDigits_ be the substring of CodePointsToString(_fSeconds_) from 1.
        1. Let _fSecondsScale_ be the length of _fSecondsDigits_.
        1. Let _millisecondsMV_ be ? ToIntegerWithTruncation(_fSecondsDigits_) / 10<sup>_fSecondsScale_</sup> &times; 1000.
      1. Else,
        1. Let _millisecondsMV_ be remainder(_secondsMV_, 1) &times; 1000.
      1. Let _microsecondsMV_ be remainder(_millisecondsMV_, 1) &times; 1000.
      1. Let _nanosecondsMV_ be remainder(_microsecondsMV_, 1) &times; 1000.
      1. If _sign_ contains the code point U+002D (HYPHEN-MINUS) or U+2212 (MINUS SIGN), then
        1. Let _factor_ be -1.
      1. Else,
        1. Let _factor_ be 1.
      1. Return ! CreateDurationRecord(_yearsMV_ &times; _factor_, _monthsMV_ &times; _factor_, _weeksMV_ &times; _factor_, _daysMV_ &times; _factor_, _hoursMV_ &times; _factor_, floor(_minutesMV_) &times; _factor_, floor(_secondsMV_) &times; _factor_, floor(_millisecondsMV_) &times; _factor_, floor(_microsecondsMV_) &times; _factor_, floor(_nanosecondsMV_) &times; _factor_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalmonthdaystring" type="abstract operation">
    <h1>
      ParseTemporalMonthDayString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.PlainMonthDay instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalMonthDayString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, throw a *RangeError* exception.
      1. Let _result_ be ? ParseISODateTime(_isoString_).
      1. Let _year_ be _result_.[[Year]].
      1. If _parseResult_ does not contain a |DateYear| Parse Node, then
        1. Set _year_ to *undefined*.
      1. Return the Record {
        [[Year]]: _year_,
        [[Month]]: _result_.[[Month]],
        [[Day]]: _result_.[[Day]],
        [[Calendar]]: _result_.[[Calendar]]
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalrelativetostring" type="abstract operation">
    <h1>
      ParseTemporalRelativeToString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 string and returns the information needed to construct either a Temporal.ZonedDateTime or a Temporal.PlainDate instance, e.g. as the value of a `relativeTo` option.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalDateTimeString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| ParseNode but no |TimeZoneAnnotation| Parse Node, throw a *RangeError* exception.
      1. Return ? ParseISODateTime(_isoString_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaltimestring" type="abstract operation">
    <h1>
      ParseTemporalTimeString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as an ISO 8601 time of day and returns the information needed to construct a Temporal.PlainTime instance.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalTimeString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, throw a *RangeError* exception.
      1. Let _result_ be ? ParseISODateTime(_isoString_).
      1. Return the Record {
        [[Hour]]: _result_.[[Hour]],
        [[Minute]]: _result_.[[Minute]],
        [[Second]]: _result_.[[Second]],
        [[Millisecond]]: _result_.[[Millisecond]],
        [[Microsecond]]: _result_.[[Microsecond]],
        [[Nanosecond]]: _result_.[[Nanosecond]],
        }.
    </emu-alg>
    <emu-note>
      <p>A successful parse using |TemporalTimeString| guarantees absence of ambiguity with respect to any ISO 8601 date-only, year-month, or month-day representation.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporaltimezonestring" type="abstract operation">
    <h1>
      ParseTemporalTimeZoneString (
        _timeZoneString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as either a time zone identifier or an ISO 8601 string and returns a Record representing information about the time zone.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_timeZoneString_), |TimeZoneIdentifier|).
      1. If _parseResult_ is a Parse Node, then
        1. Return the Record { [[Z]]: *false*, [[OffsetString]]: *undefined*, [[Name]]: _timeZoneString_ }.
      1. Let _result_ be ? ParseISODateTime(_timeZoneString_).
      1. Let _timeZoneResult_ be _result_.[[TimeZone]].
      1. If _timeZoneResult_.[[Z]] is *false*, _timeZoneResult_.[[OffsetString]] is *undefined*, and _timeZoneResult_.[[Name]] is *undefined*, throw a *RangeError* exception.
      1. Return _timeZoneResult_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-parsetemporalyearmonthstring" type="abstract operation">
    <h1>
      ParseTemporalYearMonthString (
        _isoString_: a String,
      )
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It parses the argument as a full or partial ISO 8601 string and returns a Record representing each date and time component needed to construct a Temporal.PlainYearMonth instance as a distinct field.</dd>
    </dl>
    <emu-alg>
      1. Let _parseResult_ be ParseText(StringToCodePoints(_isoString_), |TemporalYearMonthString|).
      1. If _parseResult_ is a List of errors, throw a *RangeError* exception.
      1. If _parseResult_ contains a |UTCDesignator| Parse Node, throw a *RangeError* exception.
      1. Let _result_ be ? ParseISODateTime(_isoString_).
      1. Return the Record {
        [[Year]]: _result_.[[Year]],
        [[Month]]: _result_.[[Month]],
        [[Day]]: _result_.[[Day]],
        [[Calendar]]: _result_.[[Calendar]]
        }.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-topositiveintegerwithtruncation" type="abstract operation">
    <h1>
      ToPositiveIntegerWithTruncation (
        _argument_: an ECMAScript language value,
      ): either a normal completion containing a positive integer, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It converts _argument_ to an integer representing its Number value with fractional part truncated, or throws a *RangeError* when that value is not finite or not positive.</dd>
    </dl>
    <emu-alg>
      1. Let _integer_ be ? ToIntegerWithTruncation(_argument_).
      1. If _integer_ &le; 0, throw a *RangeError* exception.
      1. Return _integer_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-tointegerwithtruncation" type="abstract operation">
    <h1>
      ToIntegerWithTruncation (
        _argument_: an ECMAScript language value,
      ): either a normal completion containing an integer, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It converts _argument_ to an integer representing its Number value with fractional part truncated, or throws a *RangeError* when that value is not finite.</dd>
    </dl>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If _number_ is *NaN*, *+&infin;*<sub>𝔽</sub> or *-&infin;*<sub>𝔽</sub>, throw a *RangeError* exception.
      1. Return truncate(ℝ(_number_)).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-tointegerifintegral" type="abstract operation">
    <h1>
      ToIntegerIfIntegral (
        _argument_: an ECMAScript language value,
      ): either a normal completion containing an integer, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It converts _argument_ to an integer representing its Number value, or throws a *RangeError* when that value is not <emu-xref href="#integral-number">integral</emu-xref>.</dd>
    </dl>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If IsIntegralNumber(_number_) is *false*, throw a *RangeError* exception.
      1. Return ℝ(_number_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-temporal-preparetemporalfields" type="abstract operation">
    <h1>
      PrepareTemporalFields (
        _fields_: an Object,
        _fieldNames_: a List of property names,
        _requiredFields_: ~partial~ or a List of property names,
      ): either a normal completion containing an Object, or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        The returned Object has a null prototype, and an own data property for each element of _fieldNames_ that corresponds with a non-*undefined* property of the same name on _fields_ used as the input for relevant conversion.
        When _requiredFields_ is ~partial~, this operation throws if none of the properties are present with a non-*undefined* value.
        When _requiredFields_ is a List, this operation throws if any of the properties named by it are absent or undefined, and otherwise substitutes a relevant default for any absent or undefined non-required property (ensuring that the returned object has a property for each element of _fieldNames_).
      </dd>
    </dl>
    <emu-alg>
      1. Let _result_ be OrdinaryObjectCreate(*null*).
      1. Let _any_ be *false*.
      1. Let _sortedFieldNames_ be SortStringListByCodeUnit(_fieldNames_).
      1. For each property name _property_ of _sortedFieldNames_, do
        1. Let _value_ be ? Get(_fields_, _property_).
        1. If _value_ is not *undefined*, then
          1. Set _any_ to *true*.
          1. If _property_ is in the Property column of <emu-xref href="#table-temporal-field-requirements"></emu-xref> and there is a Conversion value in the same row, then
            1. Let _Conversion_ be the Conversion value of the same row.
            1. If _Conversion_ is ~ToIntegerWithTruncation~, then
              1. Set _value_ to ? ToIntegerWithTruncation(_value_).
              1. Set _value_ to 𝔽(_value_).
            1. Else if _Conversion_ is ~ToPositiveIntegerWithTruncation~, then
              1. Set _value_ to ? ToPositiveIntegerWithTruncation(_value_).
              1. Set _value_ to 𝔽(_value_).
            1. Else,
              1. Assert: _Conversion_ is ~ToString~.
              1. Set _value_ to ? ToString(_value_).
          1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
        1. Else if _requiredFields_ is a List, then
          1. If _requiredFields_ contains _property_, then
            1. Throw a *TypeError* exception.
          1. If _property_ is in the Property column of <emu-xref href="#table-temporal-field-requirements"></emu-xref>, then
            1. Set _value_ to the corresponding Default value of the same row.
          1. Perform ! CreateDataPropertyOrThrow(_result_, _property_, _value_).
      1. If _requiredFields_ is ~partial~ and _any_ is *false*, then
        1. Throw a *TypeError* exception.
      1. Return _result_.
    </emu-alg>
    <emu-table id="table-temporal-field-requirements">
      <emu-caption>Temporal field requirements</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Property</th>
            <th>Conversion</th>
            <th>Default</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>*"year"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"month"*</td>
            <td>~ToPositiveIntegerWithTruncation~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"monthCode"*</td>
            <td>~ToString~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"day"*</td>
            <td>~ToPositiveIntegerWithTruncation~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"hour"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>𝔽</sub></td>
          </tr>
          <tr>
            <td>*"minute"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>𝔽</sub></td>
          </tr>
          <tr>
            <td>*"second"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>𝔽</sub></td>
          </tr>
          <tr>
            <td>*"millisecond"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>𝔽</sub></td>
          </tr>
          <tr>
            <td>*"microsecond"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>𝔽</sub></td>
          </tr>
          <tr>
            <td>*"nanosecond"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*+0*<sub>𝔽</sub></td>
          </tr>
          <tr>
            <td>*"offset"*</td>
            <td>~ToString~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"era"*</td>
            <td>~ToString~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"eraYear"*</td>
            <td>~ToIntegerWithTruncation~</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>*"timeZone"*</td>
            <td></td>
            <td>*undefined*</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-getdifferencesettings" type="abstract operation">
    <h1>
      GetDifferenceSettings (
        _operation_: ~since~ or ~until~,
        _options_: an Object,
        _unitGroup_: ~date~, ~time~, or ~datetime~,
        _disallowedUnits_: a List of Strings,
        _fallbackSmallestUnit_: a String,
        _smallestLargestDefaultUnit_: a String,
      ): either a normal completion containing a Record or an abrupt completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It reads unit and rounding options needed by difference operations.</dd>
    </dl>
    <emu-alg>
      1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalRoundingIncrement reads *"roundingIncrement"* and ToTemporalRoundingMode reads *"roundingMode"*).
      1. Let _largestUnit_ be ? GetTemporalUnit(_options_, *"largestUnit"*, _unitGroup_, *"auto"*).
      1. If _disallowedUnits_ contains _largestUnit_, throw a *RangeError* exception.
      1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_).
      1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
      1. If _operation_ is ~since~, then
        1. Set _roundingMode_ to ! NegateTemporalRoundingMode(_roundingMode_).
      1. Let _smallestUnit_ be ? GetTemporalUnit(_options_, *"smallestUnit"*, _unitGroup_, _fallbackSmallestUnit_).
      1. If _disallowedUnits_ contains _smallestUnit_, throw a *RangeError* exception.
      1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalUnits(_smallestLargestDefaultUnit_, _smallestUnit_).
      1. If _largestUnit_ is *"auto"*, set _largestUnit_ to _defaultLargestUnit_.
      1. If LargerOfTwoTemporalUnits(_largestUnit_, _smallestUnit_) is not _largestUnit_, throw a *RangeError* exception.
      1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
      1. If _maximum_ is not *undefined*, perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, *false*).
      1. Return the Record {
            [[SmallestUnit]]: _smallestUnit_,
            [[LargestUnit]]: _largestUnit_,
            [[RoundingMode]]: _roundingMode_,
            [[RoundingIncrement]]: _roundingIncrement_,
            }.
    </emu-alg>
  </emu-clause>
</emu-clause>
