<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-calendar-objects">
  <h1>Temporal.Calendar Objects</h1>
  <p>A Temporal.Calendar object is an Object representing a calendar.</p>

  <emu-clause id="sec-calendar-types">
    <h1>Calendar Types</h1>

    <!-- See https://github.com/tc39/ecma402/issues/828 and https://github.com/tc39/ecma402/issues/852 -->
    <p>
      At a minimum, ECMAScript implementations must support a built-in calendar named *"iso8601"*, representing the ISO 8601 calendar.
      In addition, implementations may support any number of other built-in calendars corresponding with those of the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
    </p>
    <p>
      ECMAScript implementations identify built-in calendars using a <dfn variants="calendar types">calendar type</dfn> as defined by <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Elements">Unicode Technical Standard #35, Part 4, Section 2</a>.
      Their canonical form is a string containing only Unicode Basic Latin lowercase letters (U+0061 LATIN SMALL LETTER A through U+007A LATIN SMALL LETTER Z, inclusive) and/or digits (U+0030 DIGIT ZERO through U+0039 DIGIT NINE, inclusive), with zero or more medial hyphens (U+002D HYPHEN-MINUS).
    </p>
    <p>
      <emu-xref href="#sec-temporal-calendar-constructor">The `Temporal.Calendar` constructor</emu-xref>, when called with the name of a built-in calendar as the argument, will return a valid `Temporal.Calendar` object.
      When called with any other string, it will throw a *RangeError* exception.
    </p>

    <emu-clause id="sec-temporal-isbuiltincalendar" type="abstract operation">
      <h1>
        IsBuiltinCalendar (
          _id_: a String,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned value is *true* if _id_ is a calendar type denoting a built-in calendar, and *false* otherwise.</dd>
      </dl>
      <emu-alg>
        1. Let _calendars_ be AvailableCalendars().
        1. If _calendars_ contains the ASCII-lowercase of _id_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-availablecalendars" type="implementation-defined abstract operation">
      <h1>
        AvailableCalendars (
        ): a List of Strings
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Each element in the returned List represents a calendar type supported by the implementation.</dd>
      </dl>
      <emu-alg>
        1. Let _calendars_ be the List of String values representing calendar types supported by the implementation.
        1. Assert: _calendars_ contains *"iso8601"*.
        1. [declared="S"] Assert: _calendars_ does not contain any element _S_ for which the ASCII-lowercase of _S_ is not _S_.
        1. Assert: _calendars_ does not contain any element that does not identify a calendar type in the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
        1. Return SortStringListByCodeUnit(_calendars_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-calendar-abstract-ops">
    <h1>Abstract Operations for Temporal.Calendar Objects</h1>

    <emu-clause id="sec-temporal-calendar-methods-records">
      <h1>Calendar Methods Records</h1>
      <p>
        A <dfn variants="Calendar Methods Records">Calendar Methods Record</dfn> is a Record value used to store a Temporal.Calendar object, or an Object implementing the calendar protocol, along with any methods that have been observably looked up on that object during the current operation.
        Calendar Methods Records are produced by the abstract operation CreateCalendarMethodsRecord.
      </p>
      <p>
        Calendar Methods Records have the fields listed in <emu-xref href="#table-temporal-calendar-methods-record-fields"></emu-xref>.
      </p>
      <emu-table id="table-temporal-calendar-methods-record-fields" caption="Calendar Methods Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Receiver]]</td>
            <td>a String or Object</td>
            <td>
              The calendar object, or a string indicating a built-in time zone.
            </td>
          </tr>
          <tr>
            <td>[[DateAdd]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The calendar's `dateAdd` method.
              For a built-in calendar this is always %Temporal.Calendar.prototype.dateAdd%.
            </td>
          </tr>
          <tr>
            <td>[[DateFromFields]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The calendar's `dateFromFields` method.
              For a built-in calendar this is always %Temporal.Calendar.prototype.dateFromFields%.
            </td>
          </tr>
          <tr>
            <td>[[DateUntil]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The calendar's `dateUntil` method.
              For a built-in calendar this is always %Temporal.Calendar.prototype.dateUntil%.
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The calendar's `day` method.
              For a built-in calendar this is always %Temporal.Calendar.prototype.day%.
            </td>
          </tr>
          <tr>
            <td>[[Fields]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The calendar's `fields` method.
              For a built-in calendar this is always %Temporal.Calendar.prototype.fields%.
            </td>
          </tr>
          <tr>
            <td>[[MergeFields]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The calendar's `mergeFields` method.
              For a built-in calendar this is always %Temporal.Calendar.prototype.mergeFields%.
            </td>
          </tr>
          <tr>
            <td>[[MonthDayFromFields]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The calendar's `monthDayFromFields` method.
              For a built-in calendar this is always %Temporal.Calendar.prototype.monthDayFromFields%.
            </td>
          </tr>
          <tr>
            <td>[[YearMonthFromFields]]</td>
            <td>a function object or *undefined*</td>
            <td>
              The calendar's `yearMonthFromFields` method.
              For a built-in calendar this is always %Temporal.Calendar.prototype.yearMonthFromFields%.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-createcalendarmethodsrecord" type="abstract operation">
      <h1>
        CreateCalendarMethodsRecord (
          _calendar_: a String or Object,
          _methods_: a List of one of ~date-add~, ~date-from-fields~, ~date-until~, ~day~, ~fields~, ~merge-fields~, ~month-day-from-fields~, or ~year-month-from-fields~,
        ): either a normal completion containing a Calendar Methods Record, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Calendar Methods Record from the given _calendar_, looking up the methods given in _methods_.</dd>
      </dl>
      <emu-alg>
        1. Let _record_ be the Calendar Methods Record {
            [[Receiver]]: _calendar_,
            [[DateAdd]]: *undefined*,
            [[DateFromFields]]: *undefined*,
            [[DateUntil]]: *undefined*,
            [[Day]]: *undefined*,
            [[Fields]]: *undefined*,
            [[MergeFields]]: *undefined*,
            [[MonthDayFromFields]]: *undefined*,
            [[YearMonthFromFields]]: *undefined*
          }.
        1. For each element _methodName_ in _methods_, do
          1. Perform ? CalendarMethodsRecordLookup(_record_, _methodName_).
        1. Return _record_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createcalendarmethodsrecordfromrelativeto" type="abstract operation">
      <h1>
        CreateCalendarMethodsRecordFromRelativeTo (
          _plainRelativeTo_: a `Temporal.PlainDate` or *undefined*,
          _zonedRelativeTo_: a `Temporal.ZonedDateTime` or *undefined*,
          _methods_: a List of one of ~date-add~, ~date-from-fields~, ~date-until~, ~day~, ~fields~, ~merge-fields~, ~month-day-from-fields~, or ~year-month-from-fields~,
        ): either a normal completion containing either a Calendar Methods Record or *undefined*, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Calendar Methods Record from the calendar of the given `relativeTo` object, looking up the methods given in _methods_. If no `relativeTo` object is given, it returns *undefined* instead of a Calendar Methods Record.</dd>
      </dl>
      <emu-alg>
        1. If _zonedRelativeTo_ is not *undefined*, return ? CreateCalendarMethodsRecord(_zonedRelativeTo_.[[Calendar]], _methods_).
        1. If _plainRelativeTo_ is not *undefined*, return ? CreateCalendarMethodsRecord(_plainRelativeTo_.[[Calendar]], _methods_).
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmethodsrecordlookup" type="abstract operation">
      <h1>
        CalendarMethodsRecordLookup (
          _calendarRec_: a Calendar Methods Record,
          _methodName_: one of ~date-add~, ~date-from-fields~, ~date-until~, ~day~, ~fields~, ~merge-fields~, ~month-day-from-fields~, or ~year-month-from-fields~,
        ): either a normal completion containing ~unused~, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It looks up the given method on the given calendar.
          For a built-in calendar, this lookup is unobservable and results in the intrinsic method.
          If the calendar is an Object, the lookup is observable and may result in a user-code method.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: CalendarMethodsRecordHasLookedUp(_calendarRec_, _methodName_) is *false*.
        1. If _methodName_ is ~date-add~, then
          1. If _calendarRec_.[[Receiver]] is a String, then
            1. Set _calendarRec_.[[DateAdd]] to %Temporal.Calendar.prototype.dateAdd%.
          1. Else,
            1. Set _calendarRec_.[[DateAdd]] to ? GetMethod(_calendarRec_.[[Receiver]], *"dateAdd"*).
            1. If _calendarRec_.[[DateAdd]] is *undefined*, throw a *TypeError* exception.
        1. Else if _methodName_ is ~date-from-fields~, then
          1. If _calendarRec_.[[Receiver]] is a String, then
            1. Set _calendarRec_.[[DateFromFields]] to %Temporal.Calendar.prototype.dateFromFields%.
          1. Else,
            1. Set _calendarRec_.[[DateFromFields]] to ? GetMethod(_calendarRec_.[[Receiver]], *"dateFromFields"*).
            1. If _calendarRec_.[[DateFromFields]] is *undefined*, throw a *TypeError* exception.
        1. Else if _methodName_ is ~date-until~, then
          1. If _calendarRec_.[[Receiver]] is a String, then
            1. Set _calendarRec_.[[DateUntil]] to %Temporal.Calendar.prototype.dateUntil%.
          1. Else,
            1. Set _calendarRec_.[[DateUntil]] to ? GetMethod(_calendarRec_.[[Receiver]], *"dateUntil"*).
            1. If _calendarRec_.[[DateUntil]] is *undefined*, throw a *TypeError* exception.
        1. Else if _methodName_ is ~day~, then
          1. If _calendarRec_.[[Receiver]] is a String, then
            1. Set _calendarRec_.[[Day]] to %Temporal.Calendar.prototype.day%.
          1. Else,
            1. Set _calendarRec_.[[Day]] to ? GetMethod(_calendarRec_.[[Receiver]], *"day"*).
            1. If _calendarRec_.[[Day]] is *undefined*, throw a *TypeError* exception.
        1. Else if _methodName_ is ~fields~, then
          1. If _calendarRec_.[[Receiver]] is a String, then
            1. Set _calendarRec_.[[Fields]] to %Temporal.Calendar.prototype.fields%.
          1. Else,
            1. Set _calendarRec_.[[Fields]] to ? GetMethod(_calendarRec_.[[Receiver]], *"fields"*).
            1. If _calendarRec_.[[Fields]] is *undefined*, throw a *TypeError* exception.
        1. Else if _methodName_ is ~merge-fields~, then
          1. If _calendarRec_.[[Receiver]] is a String, then
            1. Set _calendarRec_.[[MergeFields]] to %Temporal.Calendar.prototype.mergeFields%.
          1. Else,
            1. Set _calendarRec_.[[MergeFields]] to ? GetMethod(_calendarRec_.[[Receiver]], *"mergeFields"*).
            1. If _calendarRec_.[[MergeFields]] is *undefined*, throw a *TypeError* exception.
        1. Else if _methodName_ is ~month-day-from-fields~, then
          1. If _calendarRec_.[[Receiver]] is a String, then
            1. Set _calendarRec_.[[MonthDayFromFields]] to %Temporal.Calendar.prototype.monthDayFromFields%.
          1. Else,
            1. Set _calendarRec_.[[MonthDayFromFields]] to ? GetMethod(_calendarRec_.[[Receiver]], *"monthDayFromFields"*).
            1. If _calendarRec_.[[MonthDayFromFields]] is *undefined*, throw a *TypeError* exception.
        1. Else if _methodName_ is ~year-month-from-fields~, then
          1. If _calendarRec_.[[Receiver]] is a String, then
            1. Set _calendarRec_.[[YearMonthFromFields]] to %Temporal.Calendar.prototype.yearMonthFromFields%.
          1. Else,
            1. Set _calendarRec_.[[YearMonthFromFields]] to ? GetMethod(_calendarRec_.[[Receiver]], *"yearMonthFromFields"*).
            1. If _calendarRec_.[[YearMonthFromFields]] is *undefined*, throw a *TypeError* exception.
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmethodsrecordhaslookedup" type="abstract operation">
      <h1>
        CalendarMethodsRecordHasLookedUp (
          _calendarRec_: a Calendar Methods Record,
          _methodName_: one of ~date-add~, ~date-from-fields~, ~date-until~, ~day~, ~fields~, ~merge-fields~, ~month-day-from-fields~, or ~year-month-from-fields~,
        ): *true* or *false*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines whether the given Calendar Methods Record has already looked up the given method.</dd>
      </dl>
      <emu-alg>
        1. If _methodName_ is ~date-add~, then
          1. Let _method_ be _calendarRec_.[[DateAdd]].
        1. Else if _methodName_ is ~date-from-fields~, then
          1. Let _method_ be _calendarRec_.[[DateFromFields]].
        1. Else if _methodName_ is ~date-until~, then
          1. Let _method_ be _calendarRec_.[[DateUntil]].
        1. Else if _methodName_ is ~day~, then
          1. Let _method_ be _calendarRec_.[[Day]].
        1. Else if _methodName_ is ~fields~, then
          1. Let _method_ be _calendarRec_.[[Fields]].
        1. Else if _methodName_ is ~merge-fields~, then
          1. Let _method_ be _calendarRec_.[[MergeFields]].
        1. Else if _methodName_ is ~month-day-from-fields~, then
          1. Let _method_ be _calendarRec_.[[MonthDayFromFields]].
        1. Else if _methodName_ is ~year-month-from-fields~, then
          1. Let _method_ be _calendarRec_.[[YearMonthFromFields]].
        1. If _method_ is *undefined*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmethodsrecordisbuiltin" type="abstract operation">
      <h1>
        CalendarMethodsRecordIsBuiltin (
          _calendarRec_: a Calendar Methods Record,
        ): *true* or *false*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines whether the given Calendar Methods Record represents a built-in calendar (that is never exposed to user code.)</dd>
      </dl>
      <emu-alg>
        1. If _calendarRec_.[[Receiver]] is a String, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmethodsrecordcall" type="abstract operation">
      <h1>
        CalendarMethodsRecordCall (
          _calendarRec_: a Calendar Methods Record,
          _methodName_: one of ~date-add~, ~date-from-fields~, ~date-until~, ~day~, ~fields~, ~merge-fields~, ~month-day-from-fields~, or ~year-month-from-fields~,
          _arguments_: a List of ECMAScript language values,
        ): either a normal completion containing an ECMAScript language value, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the method _methodName_ stored in the Calendar Methods Record, with the stored receiver as the receiver, and the given _arguments_, and returns the result.</dd>
      </dl>
      <emu-alg>
        1. Assert: CalendarMethodsRecordHasLookedUp(_calendarRec_, _methodName_) is *true*.
        1. Let _receiver_ be _calendarRec_.[[Receiver]].
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, then
          1. Set _receiver_ to ! CreateTemporalCalendar(_calendarRec_.[[Receiver]]).
        1. If _methodName_ is ~date-add~, then
          1. Return ? Call(_calendarRec_.[[DateAdd]], _receiver_, _arguments_).
        1. If _methodName_ is ~date-from-fields~, then
          1. Return ? Call(_calendarRec_.[[DateFromFields]], _receiver_, _arguments_).
        1. If _methodName_ is ~date-until~, then
          1. Return ? Call(_calendarRec_.[[DateUntil]], _receiver_, _arguments_).
        1. If _methodName_ is ~day~, then
          1. Return ? Call(_calendarRec_.[[Day]], _receiver_, _arguments_).
        1. If _methodName_ is ~fields~, then
          1. Return ? Call(_calendarRec_.[[Fields]], _receiver_, _arguments_).
        1. If _methodName_ is ~merge-fields~, then
          1. Return ? Call(_calendarRec_.[[MergeFields]], _receiver_, _arguments_).
        1. If _methodName_ is ~month-day-from-fields~, then
          1. Return ? Call(_calendarRec_.[[MonthDayFromFields]], _receiver_, _arguments_).
        1. If _methodName_ is ~year-month-from-fields~, then
          1. Return ? Call(_calendarRec_.[[YearMonthFromFields]], _receiver_, _arguments_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalcalendar" type="abstract operation">
      <h1>
        CreateTemporalCalendar (
          _identifier_: a String,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.Calendar, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.Calendar instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsBuiltinCalendar(_identifier_) is *true*.
        1. If _newTarget_ is not provided, set _newTarget_ to %Temporal.Calendar%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.Calendar.prototype%"*, « [[InitializedTemporalCalendar]], [[Identifier]] »).
        1. Set _object_.[[Identifier]] to the ASCII-lowercase of _identifier_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarfields" type="abstract operation">
      <h1>
        CalendarFields (
          _calendarRec_: a Calendar Methods Record,
          _fieldNames_: a List of Strings,
        ): either a normal completion containing a List of Strings, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the `fields` method of the given calendar with an array representation of _fieldNames_, and returns a List representation of the result.</dd>
      </dl>
      <emu-alg>
        1. Assert: _fieldNames_ contains zero or one of each of the Strings *"day"*, *"month"*, *"monthCode"*, and *"year"*, in that order.
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, then
          1. NOTE: %Temporal.Calendar.prototype.fields% is not called in this clause in order to avoid an unnecessary observable Array iteration.
          1. If _calendarRec_.[[Receiver]] is *"iso8601"*, return _fieldNames_.
          1. Let _extraFieldDescriptors_ be CalendarFieldDescriptors(_calendarRec_.[[Receiver]], _fieldNames_).
          1. For each Calendar Field Descriptor Record _desc_ of _extraFieldDescriptors_, do
            1. Append _desc_.[[Property]] to _fieldNames_.
          1. Return _fieldNames_.
        1. Let _fieldsArray_ be ? CalendarMethodsRecordCall(_calendarRec_, ~fields~, « CreateArrayFromList(_fieldNames_) »).
        1. Let _iteratorRecord_ be ? GetIterator(_fieldsArray_, ~sync~).
        1. Return ? IteratorToListOfType(_iteratorRecord_, « String »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmergefields" type="abstract operation">
      <h1>
        CalendarMergeFields (
          _calendarRec_: a Calendar Methods Record,
          _fields_: an Object,
          _additionalFields_: an Object,
        ): either a normal completion containing an Object, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It merges the properties of _fields_ and _additionalFields_ by calling the `mergeFields` method of the given calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? CalendarMethodsRecordCall(_calendarRec_, ~merge-fields~, « _fields_, _additionalFields_ »).
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, return _result_.
        1. If Type(_result_) is not Object, throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateadd" type="abstract operation">
      <h1>
        CalendarDateAdd (
          _calendarRec_: a Calendar Methods Record,
          _date_: a Temporal.PlainDate,
          _duration_: a Temporal.Duration,
          optional _options_: an Object or *undefined*,
        ): either a normal completion containing a Temporal.PlainDate, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds _duration_ to _date_ by calling the `dateAdd` method of the given calendar.
        </dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _addedDate_ be ? CalendarMethodsRecordCall(_calendarRec_, ~date-add~, « _date_, _duration_, _options_ »).
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, return _addedDate_.
        1. Perform ? RequireInternalSlot(_addedDate_, [[InitializedTemporalDate]]).
        1. Return _addedDate_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateuntil" type="abstract operation">
      <h1>
        CalendarDateUntil (
          _calendarRec_: a Calendar Methods Record,
          _one_: a Temporal.PlainDate,
          _two_: a Temporal.PlainDate,
          _options_: an Object or *undefined*,
        ): either a normal completion containing a Temporal.Duration, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines the difference between the dates _one_ and _two_ by calling the `dateUntil` method of the given calendar.
        </dd>
      </dl>
      <emu-alg>
        1. Let _duration_ be ? CalendarMethodsRecordCall(_calendarRec_, ~date-until~, « _one_, _two_, _options_ »).
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, return _duration_.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryear" type="abstract operation">
      <h1>
        CalendarYear (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `year()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.year%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"year"*, « _dateLike_ »).
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonth" type="abstract operation">
      <h1>
        CalendarMonth (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `month()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.month%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"month"*, « _dateLike_ »).
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthcode" type="abstract operation">
      <h1>
        CalendarMonthCode (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
        ): either a normal completion containing a String, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `monthCode()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.monthCode%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"monthCode"*, « _dateLike_ »).
        1. If Type(_result_) is not String, throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarday" type="abstract operation">
      <h1>
        CalendarDay (
          _calendarRec_: a Calendar Methods Record,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainMonthDay,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given calendar's `day()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? CalendarMethodsRecordCall(_calendarRec_, ~day~, « _dateLike_ »).
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, return _result_.
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofweek" type="abstract operation">
      <h1>
        CalendarDayOfWeek (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `dayOfWeek()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.dayOfWeek%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"dayOfWeek"*, « _dateLike_ »).
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofyear" type="abstract operation">
      <h1>
        CalendarDayOfYear (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `dayOfYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.dayOfYear%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"dayOfYear"*, « _dateLike_ »).
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarweekofyear" type="abstract operation">
      <h1>
        CalendarWeekOfYear (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `weekOfYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.weekOfYear%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"weekOfYear"*, « _dateLike_ »).
        1. If _result_ is *undefined*, return *undefined*.
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryearofweek" type="abstract operation">
      <h1>
        CalendarYearOfWeek (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `yearOfWeek()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.yearOfWeek%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"yearOfWeek"*, « _dateLike_ »).
        1. If _result_ is *undefined*, return *undefined*.
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinweek" type="abstract operation">
      <h1>
        CalendarDaysInWeek (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `daysInWeek()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.daysInWeek%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"daysInWeek"*, « _dateLike_ »).
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinmonth" type="abstract operation">
      <h1>
        CalendarDaysInMonth (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `daysInMonth()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.daysInMonth%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"daysInMonth"*, « _dateLike_ »).
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinyear" type="abstract operation">
      <h1>
        CalendarDaysInYear (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `daysInYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.daysInYear%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"daysInYear"*, « _dateLike_ »).
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthsinyear" type="abstract operation">
      <h1>
        CalendarMonthsInYear (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `monthsInYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.monthsInYear%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"monthsInYear"*, « _dateLike_ »).
        1. If Type(_result_) is not Number, throw a *TypeError* exception.
        1. If IsIntegralNumber(_result_) is *false*, throw a *RangeError* exception.
        1. If _result_ &lt; *1*<sub>𝔽</sub>, throw a *RangeError* exception.
        1. Return ℝ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarinleapyear" type="abstract operation">
      <h1>
        CalendarInLeapYear (
          _calendar_: a String or Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing a Boolean, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `inLeapYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is a String, then
          1. Set _calendar_ to ! CreateTemporalCalendar(_calendar_).
          1. Return ! Call(%Temporal.Calendar.prototype.inLeapYear%, _calendar_, « _dateLike_ »).
        1. Let _result_ be ? Invoke(_calendar_, *"inLeapYear"*, « _dateLike_ »).
        1. If Type(_result_) is not Boolean, throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-objectimplementstemporalcalendarprotocol" type="abstract operation">
      <h1>
        ObjectImplementsTemporalCalendarProtocol (
          _object_: an Object,
        ): either a normal completion containing a Boolean, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines whether the given _object_ is a Temporal.Calendar instance or implements the required methods from the Temporal.Calendar protocol.
          For ordinary objects, and some exotic objects, this operation is infallible and will always return a normal completion.
          However, if _object_ is a Proxy or has one in its prototype chain, it may call into user code.
        </dd>
      </dl>
      <emu-alg>
        1. If _object_ has an [[InitializedTemporalCalendar]] internal slot, return *true*.
        1. For each property key _key_ of « *"dateAdd"*, *"dateFromFields"*, *"dateUntil"*, *"day"*, *"dayOfWeek"*, *"dayOfYear"*, *"daysInMonth"*, *"daysInWeek"*, *"daysInYear"*, *"fields"*, *"id"*, *"inLeapYear"*, *"mergeFields"*, *"month"*, *"monthCode"*, *"monthDayFromFields"*, *"monthsInYear"*, *"weekOfYear"*, *"year"*, *"yearMonthFromFields"*, *"yearOfWeek"* », do
          1. If ? HasProperty(_object_, _key_) is *false*, return *false*.
        1. Return *true*.
      </emu-alg>
      <emu-note>
        This operation is a convenience which makes it easier to catch bugs in custom calendars.
        For web compatibility reasons, the list of required property keys will not be extended in future editions, even if the Temporal.Calendar protocol gains more methods.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendarslotvalue" type="abstract operation">
      <h1>
        ToTemporalCalendarSlotValue (
          _temporalCalendarLike_: an ECMAScript value,
          optional _default_: a String,
        ): either a normal completion containing either a String or an Object, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It attempts to derive a value from _temporalCalendarLike_ that is suitable for storing in a Temporal object's [[Calendar]] internal slot, and returns that value if found or throws an exception if not.
          An optional _default_ built-in calendar identifier may be provided, which is returned if _temporalCalendarLike_ is *undefined*.
        </dd>
      </dl>
      <emu-alg>
        1. If _temporalCalendarLike_ is *undefined* and _default_ is present, then
          1. Assert: IsBuiltinCalendar(_default_) is *true*.
          1. Return _default_.
        1. If Type(_temporalCalendarLike_) is Object, then
          1. If _temporalCalendarLike_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _temporalCalendarLike_.[[Calendar]].
          1. If ? ObjectImplementsTemporalCalendarProtocol(_temporalCalendarLike_) is *false*, throw a *TypeError* exception.
          1. Return _temporalCalendarLike_.
        1. If _temporalCalendarLike_ is not a String, throw a *TypeError* exception.
        1. Let _identifier_ be ? ParseTemporalCalendarString(_temporalCalendarLike_).
        1. If IsBuiltinCalendar(_identifier_) is *false*, throw a *RangeError* exception.
        1. Return the ASCII-lowercase of _identifier_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-gettemporalcalendarslotvaluewithisodefault" type="abstract operation">
      <h1>
        GetTemporalCalendarSlotValueWithISODefault (
          _item_: an Object,
        ): either a normal completion containing either a String or an Object, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It looks for a `calendar` property on the given _item_ and converts its value into another value suitable for storing in a Temporal object's [[Calendar]] internal slot.
          If no such property is present, the built-in ISO 8601 calendar is returned.
        </dd>
      </dl>
      <emu-alg>
        1. If _item_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return _item_.[[Calendar]].
        1. Let _calendarLike_ be ? Get(_item_, *"calendar"*).
        1. Return ? ToTemporalCalendarSlotValue(_calendarLike_, *"iso8601"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendaridentifier" type="abstract operation">
      <h1>
        ToTemporalCalendarIdentifier (
          _calendarSlotValue_: a String or Object,
        ): either a normal completion containing a String, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It obtains the identifier string for a value _calendarSlotValue_ stored in a Temporal object's [[Calendar]] internal slot.</dd>
      </dl>
      <emu-alg>
        1. If _calendarSlotValue_ is a String, then
          1. Assert: IsBuiltinCalendar(_calendarSlotValue_) is *true*.
          1. Return _calendarSlotValue_.
        1. Let _identifier_ be ? Get(_calendarSlotValue_, *"id"*).
        1. If _identifier_ is not a String, throw a *TypeError* exception.
        1. Return _identifier_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendarobject" type="abstract operation">
      <h1>
        ToTemporalCalendarObject (
          _calendarSlotValue_: a String or Object,
        ): an Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It obtains a calendar object for a value _calendarSlotValue_ stored in a Temporal object's [[Calendar]] internal slot.</dd>
      </dl>
      <emu-alg>
        1. If _calendarSlotValue_ is an Object, return _calendarSlotValue_.
        1. Return ! CreateTemporalCalendar(_calendarSlotValue_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatefromfields" type="abstract operation">
      <h1>
        CalendarDateFromFields (
          _calendarRec_: a Calendar Methods Record,
          _fields_: an Object,
          optional _options_: an Object or *undefined*,
        ): either a normal completion containing a `Temporal.PlainDate` or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It calls the given calendar's `dateFromFields()` method and validates the result.
        </dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _date_ be ? CalendarMethodsRecordCall(_calendarRec_, ~date-from-fields~, « _fields_, _options_ »).
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, return _date_.
        1. Perform ? RequireInternalSlot(_date_, [[InitializedTemporalDate]]).
        1. Return _date_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryearmonthfromfields" type="abstract operation">
      <h1>
        CalendarYearMonthFromFields (
          _calendarRec_: a Calendar Methods Record,
          _fields_: an Object,
          optional _options_: an Object or *undefined*,
        ): either a normal completion containing a `Temporal.PlainYearMonth` or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given calendar's `yearMonthFromFields()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _yearMonth_ be ? CalendarMethodsRecordCall(_calendarRec_, ~year-month-from-fields~, « _fields_, _options_ »).
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, return _yearMonth_.
        1. Perform ? RequireInternalSlot(_yearMonth_, [[InitializedTemporalYearMonth]]).
        1. Return _yearMonth_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthdayfromfields" type="abstract operation">
      <h1>
        CalendarMonthDayFromFields (
          _calendarRec_: a Calendar Methods Record,
          _fields_: an Object,
          optional _options_: an Object or *undefined*,
        ): either a normal completion containing a `Temporal.PlainMonthDay` or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given calendar's `monthDayFromFields()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _monthDay_ be ? CalendarMethodsRecordCall(_calendarRec_, ~month-day-from-fields~, « _fields_, _options_ »).
        1. If CalendarMethodsRecordIsBuiltin(_calendarRec_) is *true*, return _monthDay_.
        1. Perform ? RequireInternalSlot(_monthDay_, [[InitializedTemporalMonthDay]]).
        1. Return _monthDay_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-maybeformatcalendarannotation" type="abstract operation">
      <h1>
        MaybeFormatCalendarAnnotation (
          _calendar_: a String or Object,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): either a normal completion containing a String, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
          Depending on the given _calendar_ and the value of _showCalendar_, the string may be empty if no calendar annotation need be included.
          This operation may invoke an observable Get operation on _calendar_ if it is a custom calendar, but not if _showCalendar_ is *"never"*.
        </dd>
      </dl>
      <emu-alg>
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. Let _calendarIdentifier_ be ? ToTemporalCalendarIdentifier(_calendar_).
        1. Return FormatCalendarAnnotation(_calendarIdentifier_, _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatcalendarannotation" type="abstract operation">
      <h1>
        FormatCalendarAnnotation (
          _id_: a String,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
          Depending on the given _id_ and value of _showCalendar_, the string may be empty if no calendar annotation need be included.
        </dd>
      </dl>
      <emu-alg>
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. If _showCalendar_ is *"auto"* and _id_ is *"iso8601"*, return the empty String.
        1. If _showCalendar_ is *"critical"*, let _flag_ be *"!"*; else, let flag be the empty String.
        1. Return the string-concatenation of *"["*, _flag_, *"u-ca="*, _id_, and *"]"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarequals" type="abstract operation">
      <h1>
        CalendarEquals (
          _one_: a String or Object,
          _two_: a String or Object,
        ): either a normal completion containing either *true* or *false*, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns *true* if its arguments represent calendars using the same identifier.</dd>
      </dl>
      <emu-alg>
        1. If _one_ and _two_ are the same Object value, return *true*.
        1. Let _calendarOne_ be ? ToTemporalCalendarIdentifier(_one_).
        1. Let _calendarTwo_ be ? ToTemporalCalendarIdentifier(_two_).
        1. If _calendarOne_ is _calendarTwo_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-consolidatecalendars" type="abstract operation">
      <h1>
        ConsolidateCalendars (
          _one_: a String or Object,
          _two_: a String or Object,
        ): either a normal completion containing either a String or Object, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns the calendar that should take priority when combining two Temporal objects with different calendars, or throws an exception if the calendars cannot be combined.
          Calendars can be combined when they have the same identifier or exactly one of them has identifier *"iso8601"*, and _calendarTwo_ takes priority in any combination unless it is the calendar with that identifier.
        </dd>
      </dl>
      <emu-alg>
        1. If _one_ and _two_ are the same Object value, return _two_.
        1. Let _calendarOne_ be ? ToTemporalCalendarIdentifier(_one_).
        1. Let _calendarTwo_ be ? ToTemporalCalendarIdentifier(_two_).
        1. If _calendarOne_ is _calendarTwo_, return _two_.
        1. If _calendarOne_ is *"iso8601"*, return _two_.
        1. If _calendarTwo_ is *"iso8601"*, return _one_.
        1. Throw a *RangeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodaysinmonth" type="abstract operation">
      <h1>
        ISODaysInMonth (
          _year_: an integer,
          _month_: an integer in the inclusive interval from 1 to 12,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the number of days in the given year and month in the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. If _month_ is 1, 3, 5, 7, 8, 10, or 12, return 31.
        1. If _month_ is 4, 6, 9, or 11, return 30.
        1. Assert: _month_ is 2.
        1. Return 28 + MathematicalInLeapYear(EpochTimeForYear(_year_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisoweekofyear" type="abstract operation">
      <h1>
        ToISOWeekOfYear (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): a Year-Week Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines where a calendar day falls in the ISO 8601 week calendar and calculates its <em>calendar week of year</em>, which is the 1-based ordinal number of its calendar week within the corresponding <em>week calendar year</em> (which may differ from _year_ by up to 1 in either direction).</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _wednesday_ be 3.
        1. Let _thursday_ be 4.
        1. Let _friday_ be 5.
        1. Let _saturday_ be 6.
        1. Let _daysInWeek_ be 7.
        1. Let _maxWeekNumber_ be 53.
        1. Let _dayOfYear_ be ToISODayOfYear(_year_, _month_, _day_).
        1. Let _dayOfWeek_ be ToISODayOfWeek(_year_, _month_, _day_).
        1. Let _week_ be floor((_dayOfYear_ + _daysInWeek_ - _dayOfWeek_ + _wednesday_ ) / _daysInWeek_).
        1. If _week_ &lt; 1, then
          1. NOTE: This is the last week of the previous year.
          1. Let _dayOfJan1st_ be ToISODayOfWeek(_year_, 1, 1).
          1. If _dayOfJan1st_ is _friday_, then
            1. Return the Year-Week Record { [[Week]]: _maxWeekNumber_, [[Year]]: _year_ - 1 }.
          1. If _dayOfJan1st_ is _saturday_, and MathematicalInLeapYear(EpochTimeForYear(_year_ - 1)) is 1, then
            1. Return the Year-Week Record { [[Week]]: _maxWeekNumber_. [[Year]]: _year_ - 1 }.
          1. Return the Year-Week Record { [[Week]]: _maxWeekNumber_ - 1, [[Year]]: _year_ - 1 }.
        1. If _week_ is _maxWeekNumber_, then
          1. Let _daysInYear_ be MathematicalDaysInYear(_year_).
          1. Let _daysLaterInYear_ be _daysInYear_ - _dayOfYear_.
          1. Let _daysAfterThursday_ be _thursday_ - _dayOfWeek_.
          1. If _daysLaterInYear_ &lt; _daysAfterThursday_, then
            1. Return the Year-Week Record { [[Week]]: 1, [[Year]]: _year_ + 1 }.
        1. Return the Year-Week Record { [[Week]]: _week_, [[Year]]: _year_ }.
      </emu-alg>
      <emu-note>In the ISO 8601 week calendar, calendar week number 1 of a calendar year is the week including the first Thursday of that year (based on the principle that a week belongs to the same calendar year as the majority of its calendar days), which always includes January 4 and starts on the Monday on or immediately before then. Because of this, some calendar days of the first calendar week of a calendar year may be part of the _preceding_ [proleptic Gregorian] date calendar year, and some calendar days of the last calendar week of a calendar year may be part of the _following_ [proleptic Gregorian] date calendar year. See ISO 8601 for details.</emu-note>
      <emu-note>For example, week calendar year 2020 includes both 31 December 2019 (a Tuesday belonging to its calendar week 1) and 1 January 2021 (a Friday belonging to its calendar week 53).</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthcode" type="abstract operation">
      <h1>
        ISOMonthCode (
          _month_: an integer in the inclusive interval from 1 to 12,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the string month code for a month in the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _numberPart_ be ToZeroPaddedDecimalString(_month_, 2).
        1. Return the string-concatenation of *"M"* and _numberPart_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoresolvemonth" type="abstract operation">
      <h1>
        ISOResolveMonth (
          _fields_: an Object,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It ensures that the *"month"* property of _fields_, if *undefined*, is set to the integral Number value in the inclusive interval from 1 to 12 that corresponds to the *"monthCode"* property of _fields_.
          It throws an exception if both properties are *undefined*, or if either property is invalid, or if the properties are inconsistent.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: _fields_ is an ordinary Object that is not directly observable from ECMAScript code and for which the value of the [[Prototype]] internal slot is *null* and every property is a data property.
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Assert: _month_ is *undefined* or _month_ is a Number.
        1. Let _monthCode_ be ! Get(_fields_, *"monthCode"*).
        1. If _monthCode_ is *undefined*, then
          1. If _month_ is *undefined*, throw a *TypeError* exception.
          1. Return ~unused~.
        1. Assert: _monthCode_ is a String.
        1. NOTE: The ISO 8601 calendar does not include leap months.
        1. If the length of _monthCode_ is not 3, throw a *RangeError* exception.
        1. If the first code unit of _monthCode_ is not 0x004D (LATIN CAPITAL LETTER M), throw a *RangeError* exception.
        1. Let _monthCodeDigits_ be the substring of _monthCode_ from 1.
        1. If ParseText(StringToCodePoints(_monthCodeDigits_), |DateMonth|) is a List of errors, throw a *RangeError* exception.
        1. Let _monthCodeInteger_ be ℝ(StringToNumber(_monthCodeDigits_)).
        1. Assert: SameValue(_monthCode_, ISOMonthCode(_monthCodeInteger_)) is *true*.
        1. If _month_ is not *undefined* and ℝ(_month_) ≠ _monthCodeInteger_, throw a *RangeError* exception.
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"month"*, 𝔽(_monthCodeInteger_)).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatefromfields" aoid="ISODateFromFields">
      <h1>ISODateFromFields ( _fields_, _overflow_ )</h1>
      <p>
        The ISODateFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.prototype.dateFromFields` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Let _day_ be ! Get(_fields_, *"day"*).
        1. Assert: _year_, _month_, and _day_ are all Numbers.
        1. Return ? RegulateISODate(ℝ(_year_), ℝ(_month_), ℝ(_day_), _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoyearmonthfromfields" aoid="ISOYearMonthFromFields">
      <h1>ISOYearMonthFromFields ( _fields_, _overflow_ )</h1>
      <p>
        The ISOYearMonthFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.prototype.yearMonthFromFields` method for the ISO 8601 calendar.
        It returns a Record with three fields ([[Year]], [[Month]], and [[ReferenceISODay]]). [[Month]], and [[ReferenceISODay]] are positive integers, while [[Year]] is a signed integer.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Assert: _year_ and _month_ are Numbers.
        1. Let _result_ be ? RegulateISOYearMonth(ℝ(_year_), ℝ(_month_), _overflow_).
        1. Return the Record {
            [[Year]]: _result_.[[Year]],
            [[Month]]: _result_.[[Month]],
            [[ReferenceISODay]]: 1
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthdayfromfields" aoid="ISOMonthDayFromFields">
      <h1>ISOMonthDayFromFields ( _fields_, _overflow_ )</h1>
      <p>
        The ISOMonthDayFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.prototype.monthDayFromFields` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Let _day_ be ! Get(_fields_, *"day"*).
        1. Assert: _month_ and _day_ are Numbers.
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. Let _referenceISOYear_ be 1972 (the first ISO 8601 leap year after the epoch).
        1. If _year_ is *undefined*, then
          1. Let _result_ be ? RegulateISODate(_referenceISOYear_, ℝ(_month_), ℝ(_day_), _overflow_).
        1. Else,
          1. Assert: _year_ is a Number.
          1. Let _result_ be ? RegulateISODate(ℝ(_year_), ℝ(_month_), ℝ(_day_), _overflow_).
        1. Return the Record {
            [[Month]]: _result_.[[Month]],
            [[Day]]: _result_.[[Day]],
            [[ReferenceISOYear]]: _referenceISOYear_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isofieldkeystoignore" type="abstract operation">
      <h1>
        ISOFieldKeysToIgnore (
          _keys_: a List of property keys,
        ): a List of property keys
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the ISO 8601 calendar.
        </dd>
      </dl>
      <emu-alg>
        1. Let _ignoredKeys_ be an empty List.
        1. For each element _key_ of _keys_, do
          1. Append _key_ to _ignoredKeys_.
          1. If _key_ is *"month"*, append *"monthCode"* to _ignoredKeys_.
          1. Else if _key_ is *"monthCode"*, append *"month"* to _ignoredKeys_.
        1. NOTE: While _ignoredKeys_ can have duplicate elements, this is not intended to be meaningful. This specification only checks whether particular keys are or are not members of the list.
        1. Return _ignoredKeys_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofyear" type="abstract operation">
      <h1>
        ToISODayOfYear (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the ISO 8601 <em>calendar day of year</em> of a calendar day, which is its 1-based ordinal number within its ISO 8601 calendar year.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _epochDays_ be ISODateToEpochDays(_year_, _month_ - 1, _day_).
        1. Return EpochTimeToDayInYear(EpochDaysToEpochMs(_epochDays_, 0)) + 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofweek" type="abstract operation">
      <h1>
        ToISODayOfWeek (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the ISO 8601 <em>calendar day of week</em> of a calendar day, which is its 1-based ordinal position within the sequence of week calendar days that starts with Monday at 1 and ends with Sunday at 7.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _epochDays_ be ISODateToEpochDays(_year_, _month_ - 1, _day_).
        1. Let _dayOfWeek_ be EpochTimeToWeekDay(EpochDaysToEpochMs(_epochDays_, 0)).
        1. If _dayOfWeek_ = 0, return 7.
        1. Return _dayOfWeek_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-calendar-constructor">
    <h1>The Temporal.Calendar Constructor</h1>
    <p>The Temporal.Calendar constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.Calendar object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.Calendar behaviour must
        include a super call to the %Temporal.Calendar% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.calendar">
      <h1>Temporal.Calendar ( _id_ )</h1>
      <p>
        The `Temporal.Calendar` function performs the following steps when called:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If _id_ is not a String, throw a *TypeError* exception.
        1. If IsBuiltinCalendar(_id_) is *false*, then
          1. Throw a *RangeError* exception.
        1. Return ? CreateTemporalCalendar(_id_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-calendar-constructor">
    <h1>Properties of the Temporal.Calendar Constructor</h1>
    <p>The Temporal.Calendar prototype:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-clause id="sec-temporal.calendar.prototype">
      <h1>Temporal.Calendar.prototype</h1>
      <p>The initial value of `Temporal.Calendar.prototype` is %Temporal.Calendar.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.from">
      <h1>Temporal.Calendar.from ( _calendarLike_ )</h1>
      <p>
        The `Temporal.Calendar.from` function performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendarSlotValue_ be ? ToTemporalCalendarSlotValue(_calendarLike_).
        1. Return ToTemporalCalendarObject(_calendarSlotValue_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-calendar-prototype-object">
    <h1>Properties of the Temporal.Calendar Prototype Object</h1>

    <p>The Temporal.Calendar prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.Calendar instance and does not have a [[InitializedTemporalCalendar]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-note>
      An ECMAScript implementation that includes the ECMA-402 Internationalization API extends this prototype with additional properties in order to represent calendar data.
    </emu-note>

    <emu-clause id="sec-temporal.calendar.prototype.constructor">
      <h1>Temporal.Calendar.prototype.constructor</h1>
      <p>The initial value of `Temporal.Calendar.prototype.constructor` is %Temporal.Calendar%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype-@@tostringtag">
      <h1>Temporal.Calendar.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the String value *"Temporal.Calendar"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.calendar.prototype.id">
      <h1>get Temporal.Calendar.prototype.id</h1>
      <p>
        `Temporal.Calendar.prototype.id` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return _calendar_.[[Identifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.datefromfields">
      <h1>Temporal.Calendar.prototype.dateFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dateFromFields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"day"*, *"month"*, *"monthCode"*, *"year"* », « *"year"*, *"day"* »).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Perform ? ISOResolveMonth(_fields_).
        1. Let _result_ be ? ISODateFromFields(_fields_, _overflow_).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], *"iso8601"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.yearmonthfromfields">
      <h1>Temporal.Calendar.prototype.yearMonthFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.yearMonthFromFields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"month"*, *"monthCode"*, *"year"* », « *"year"* »).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Perform ? ISOResolveMonth(_fields_).
        1. Let _result_ be ? ISOYearMonthFromFields(_fields_, _overflow_).
        1. Return ? CreateTemporalYearMonth(_result_.[[Year]], _result_.[[Month]], *"iso8601"*, _result_.[[ReferenceISODay]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthdayfromfields">
      <h1>Temporal.Calendar.prototype.monthDayFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.monthDayFromFields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"day"*, *"month"*, *"monthCode"*, *"year"* », « *"day"* »).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Perform ? ISOResolveMonth(_fields_).
        1. Let _result_ be ? ISOMonthDayFromFields(_fields_, _overflow_).
        1. Return ? CreateTemporalMonthDay(_result_.[[Month]], _result_.[[Day]], *"iso8601"*, _result_.[[ReferenceISOYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dateadd">
      <h1>Temporal.Calendar.prototype.dateAdd ( _date_, _duration_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dateAdd` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Set _date_ to ? ToTemporalDate(_date_).
        1. Set _duration_ to ? ToTemporalDuration(_duration_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _norm_ be NormalizeTimeDuration(_duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _balanceResult_ be BalanceTimeDuration(_norm_, *"day"*).
        1. Let _result_ be ? AddISODate(_date_.[[ISOYear]], _date_.[[ISOMonth]], _date_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]] + _balanceResult_.[[Days]], _overflow_).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], *"iso8601"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dateuntil">
      <h1>Temporal.Calendar.prototype.dateUntil ( _one_, _two_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dateUntil` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Set _one_ to ? ToTemporalDate(_one_).
        1. Set _two_ to ? ToTemporalDate(_two_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _largestUnit_ be ? GetTemporalUnit(_options_, *"largestUnit"*, ~date~, *"auto"*).
        1. If _largestUnit_ is *"auto"*, set _largestUnit_ to *"day"*.
        1. Let _result_ be DifferenceISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _largestUnit_).
        1. Return ! CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.year">
      <h1>Temporal.Calendar.prototype.year ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.year` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Assert: _temporalDateLike_ has an [[ISOYear]] internal slot.
        1. Return 𝔽(_temporalDateLike_.[[ISOYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.month">
      <h1>Temporal.Calendar.prototype.month ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.month` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is Object and _temporalDateLike_ has an [[InitializedTemporalMonthDay]] internal slot, then
          1. Throw a *TypeError* exception.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Assert: _temporalDateLike_ has an [[ISOMonth]] internal slot.
        1. Return 𝔽(_temporalDateLike_.[[ISOMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthcode">
      <h1>Temporal.Calendar.prototype.monthCode ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.monthCode` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Assert: _temporalDateLike_ has an [[ISOMonth]] internal slot.
        1. Return ISOMonthCode(_temporalDateLike_.[[ISOMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.day">
      <h1>Temporal.Calendar.prototype.day ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.day` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalMonthDay]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Assert: _temporalDateLike_ has an [[ISODay]] internal slot.
        1. Return 𝔽(_temporalDateLike_.[[ISODay]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dayofweek">
      <h1>Temporal.Calendar.prototype.dayOfWeek ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dayOfWeek` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(ToISODayOfWeek(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dayofyear">
      <h1>Temporal.Calendar.prototype.dayOfYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dayOfYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(ToISODayOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.weekofyear">
      <h1>Temporal.Calendar.prototype.weekOfYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.weekOfYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Let _isoYearWeek_ be ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
        1. Return 𝔽(_isoYearWeek_.[[Week]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.yearofweek">
      <h1>Temporal.Calendar.prototype.yearOfWeek ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Let _isoYearWeek_ be ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
        1. Return 𝔽(_isoYearWeek_.[[Year]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinweek">
      <h1>Temporal.Calendar.prototype.daysInWeek ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.daysInWeek` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Perform ? ToTemporalDate(_temporalDateLike_).
        1. Return *7*<sub>𝔽</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinmonth">
      <h1>Temporal.Calendar.prototype.daysInMonth ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.daysInMonth` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slots, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(ISODaysInMonth(_temporalDateLike_.[[ISOYear]], _temporalDateLike_.[[ISOMonth]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinyear">
      <h1>Temporal.Calendar.prototype.daysInYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.daysInYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(MathematicalDaysInYear(_temporalDateLike_.[[ISOYear]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthsinyear">
      <h1>Temporal.Calendar.prototype.monthsInYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.monthsInYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Perform ? ToTemporalDate(_temporalDateLike_).
        1. Return *12*<sub>𝔽</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.inleapyear">
      <h1>Temporal.Calendar.prototype.inLeapYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.inLeapYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. If MathematicalInLeapYear(EpochTimeForYear(_temporalDateLike_.[[ISOYear]])) is 1, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.fields">
      <h1>Temporal.Calendar.prototype.fields ( _fields_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.fields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _iteratorRecord_ be ? GetIterator(_fields_, ~sync~).
        1. Let _fieldNames_ be a new empty List.
        1. Repeat,
          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
          1. If _next_ is ~done~, then
            1. Return CreateArrayFromList(_fieldNames_).
          1. If _next_ is not a String, then
            1. Let _completion_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iteratorRecord_, _completion_).
          1. If _fieldNames_ contains _next_, then
            1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iteratorRecord_, _completion_).
          1. If _next_ is not one of *"year"*, *"month"*, *"monthCode"*, or *"day"*, then
            1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iteratorRecord_, _completion_).
          1. Append _next_ to the end of the List _fieldNames_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.mergefields">
      <h1>Temporal.Calendar.prototype.mergeFields ( _fields_, _additionalFields_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.mergeFields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Let _fieldsCopy_ be ? SnapshotOwnProperties(? ToObject(_fields_), *null*, « », « *undefined* »).
        1. Let _additionalFieldsCopy_ be ? SnapshotOwnProperties(? ToObject(_additionalFields_), *null*, « », « *undefined* »).
        1. NOTE: Every property of _fieldsCopy_ and _additionalFieldsCopy_ is an enumerable data property with a non-*undefined* value, but some property keys may be Symbols.
        1. Let _additionalKeys_ be ! _additionalFieldsCopy_.[[OwnPropertyKeys]]().
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _overriddenKeys_ be ISOFieldKeysToIgnore(_additionalKeys_).
        1. Let _merged_ be OrdinaryObjectCreate(*null*).
        1. NOTE: The following steps ensure that property iteration order of _merged_ matches that of _fields_ as modified by omitting overridden properties and appending non-overlapping properties from _additionalFields_ in iteration order.
        1. Let _fieldsKeys_ be ! _fieldsCopy_.[[OwnPropertyKeys]]().
        1. For each element _key_ of _fieldsKeys_, do
          1. If _overriddenKeys_ contains _key_, then
            1. Let _propValue_ be ! Get(_additionalFieldsCopy_, _key_).
          1. Else,
            1. Let _propValue_ be ! Get(_fieldsCopy_, _key_).
          1. If _propValue_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_merged_, _key_, _propValue_).
        1. Perform ! CopyDataProperties(_merged_, _additionalFieldsCopy_, « »).
        1. Return _merged_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.tostring">
      <h1>Temporal.Calendar.prototype.toString ( )</h1>
      <p>
        The `Temporal.Calendar.prototype.toString` method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return _calendar_.[[Identifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.tojson">
      <h1>Temporal.Calendar.prototype.toJSON ( )</h1>
      <p>
        The `Temporal.Calendar.prototype.toJSON` method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return _calendar_.[[Identifier]].
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-calendar-instances">
    <h1>Properties of Temporal.Calendar Instances</h1>

    <p>Temporal.Calendar instances are ordinary objects that inherit properties from the %Temporal.Calendar.prototype%. Temporal.Calendar instances also have a [[Identifier]] internal slot. The value of this internal slot is a string.</p>
  </emu-clause>
</emu-clause>
