<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-calendar-objects">
  <h1>Temporal.Calendar Objects</h1>
  <p>A Temporal.Calendar object is an Object representing a calendar.</p>

  <emu-clause id="sec-temporal-calendar-abstract-ops">
    <h1>Abstract Operations for Temporal.Calendar Objects</h1>

    <emu-clause id="sec-temporal-createtemporalcalendar" aoid="CreateTemporalCalendar">
      <h1>CreateTemporalCalendar ( _identifier_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. Assert: ! IsBuiltinCalendar(_identifier_) is *true*.
        1. If _newTarget_ is not provided, set _newTarget_ to %Temporal.Calendar%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.Calendar.prototype%"*, « [[InitializedTemporalCalendar]], [[Identifier]] »).
        1. Set _object_.[[Identifier]] to _identifier_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isbuiltincalendar" aoid="IsBuiltinCalendar">
      <h1>IsBuiltinCalendar ( _id_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the *IsBuiltinCalendar* abstract operation as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the *IsBuiltinCalendar* abstract operation is used.
      </p>
      <emu-alg>
        1. If _id_ is not *"iso8601"*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getbuiltincalendar" aoid="GetBuiltinCalendar">
      <h1>GetBuiltinCalendar ( _id_ )</h1>
      <emu-alg>
        1. If ! IsBuiltinCalendar(_id_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalCalendar(_id_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getiso8601calendar" aoid="GetISO8601Calendar">
      <h1>GetISO8601Calendar ( )</h1>
      <emu-alg>
        1. Return ! GetBuiltinCalendar(*"iso8601"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarfields" aoid="CalendarFields">
      <h1>CalendarFields ( _calendar_, _fieldNames_ )</h1>
      <p>
        The CalendarFields abstract operation transforms a List of String values _fieldNames_ into another List of String values by calling the `fields` method of the given _calendar_ Object, falling back to a default operation if not present.
      </p>
      <emu-alg>
        1. Let _fields_ be ? GetMethod(_calendar_, *"fields"*).
        1. Let _fieldsArray_ be CreateArrayFromList(_fieldNames_).
        1. If _fields_ is not *undefined*, then
          1. Set _fieldsArray_ to ? Call(_fields_, _calendar_, « _fieldsArray_ »).
        1. Return ? IterableToListOfType(_fieldsArray_, « String »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmergefields" aoid="CalendarMergeFields">
      <h1>CalendarMergeFields ( _calendar_, _fields_, _additionalFields_ )</h1>
      <p>
        The CalendarMergeFields abstract operation merges the properties of two Objects _fields_ and _additionalFields_ by calling the `mergeFields` method of the given _calendar_ Object, falling back to a default operation if not present.
      </p>
      <emu-alg>
        1. Let _mergeFields_ be ? GetMethod(_calendar_, *"mergeFields"*).
        1. If _mergeFields_ is *undefined*, then
          1. Return ? DefaultMergeFields(_fields_, _additionalFields_).
        1. Let _result_ be ? Call(_mergeFields_, _calendar_, « _fields_, _additionalFields_ »).
        1. If Type(_result_) is not Object, throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateadd" aoid="CalendarDateAdd">
      <h1>CalendarDateAdd ( _calendar_, _date_, _duration_, _options_ [ , _dateAdd_ ] )</h1>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. If _dateAdd_ is not present, set _dateAdd_ to ? GetMethod(_calendar_, *"dateAdd"*).
        1. Let _addedDate_ be ? Call(_dateAdd_, _calendar_, « _date_, _duration_, _options_ »).
        1. Perform ? RequireInternalSlot(_addedDate_, [[InitializedTemporalDate]]).
        1. Return _addedDate_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateuntil" aoid="CalendarDateUntil">
      <h1>CalendarDateUntil ( _calendar_, _one_, _two_, _options_ [ , _dateUntil_ ] )</h1>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. If _dateUntil_ is not present, set _dateUntil_ to ? GetMethod(_calendar_, *"dateUntil"*).
        1. Let _duration_ be ? Call(_dateUntil_, _calendar_, « _one_, _two_, _options_ »).
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryear" aoid="CalendarYear">
      <h1>CalendarYear ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarYear calls the given _calendar_'s `year()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Let _result_ be ? Invoke(_calendar_, *"year"*, « _dateLike_ »).
        1. If _result_ is *undefined*, throw a *RangeError* exception.
        1. Return ? ToIntegerThrowOnInfinity(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonth" aoid="CalendarMonth">
      <h1>CalendarMonth ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarMonth calls the given _calendar_'s `month()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Let _result_ be ? Invoke(_calendar_, *"month"*, « _dateLike_ »).
        1. If _result_ is *undefined*, throw a *RangeError* exception.
        1. Return ? ToPositiveInteger(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthcode" aoid="CalendarMonthCode">
      <h1>CalendarMonthCode ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarMonthCode calls the given _calendar_'s `monthCode()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Let _result_ be ? Invoke(_calendar_, *"monthCode"*, « _dateLike_ »).
        1. If _result_ is *undefined*, throw a *RangeError* exception.
        1. Return ? ToString(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarday" aoid="CalendarDay">
      <h1>CalendarDay ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarDay calls the given _calendar_'s `day()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Let _result_ be ? Invoke(_calendar_, *"day"*, « _dateLike_ »).
        1. If _result_ is *undefined*, throw a *RangeError* exception.
        1. Return ? ToPositiveInteger(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofweek" aoid="CalendarDayOfWeek">
      <h1>CalendarDayOfWeek ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarDayOfWeek calls the given _calendar_'s `dayOfWeek()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Return ? Invoke(_calendar_, *"dayOfWeek"*, « _dateLike_ »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofyear" aoid="CalendarDayOfYear">
      <h1>CalendarDayOfYear ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarDayOfYear calls the given _calendar_'s `dayOfYear()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Return ? Invoke(_calendar_, *"dayOfYear"*, « _dateLike_ »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarweekofyear" aoid="CalendarWeekOfYear">
      <h1>CalendarWeekOfYear ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarWeekOfYear calls the given _calendar_'s `weekOfYear()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Return ? Invoke(_calendar_, *"weekOfYear"*, « _dateLike_ »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinweek" aoid="CalendarDaysInWeek">
      <h1>CalendarDaysInWeek ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarDaysInWeek calls the given _calendar_'s `daysInWeek()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Return ? Invoke(_calendar_, *"daysInWeek"*, « _dateLike_ »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinmonth" aoid="CalendarDaysInMonth">
      <h1>CalendarDaysInMonth ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarDaysInMonth calls the given _calendar_'s `daysInMonth()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Return ? Invoke(_calendar_, *"daysInMonth"*, « _dateLike_ »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinyear" aoid="CalendarDaysInYear">
      <h1>CalendarDaysInYear ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarDaysInYear calls the given _calendar_'s `daysInYear()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Return ? Invoke(_calendar_, *"daysInYear"*, « _dateLike_ »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthsinyear" aoid="CalendarMonthsInYear">
      <h1>CalendarMonthsInYear ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarMonthsInYear calls the given _calendar_'s `monthsInYear()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Return ? Invoke(_calendar_, *"monthsInYear"*, « _dateLike_ »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarinleapyear" aoid="CalendarInLeapYear">
      <h1>CalendarInLeapYear ( _calendar_, _dateLike_ )</h1>
      <p>
        The abstract operation CalendarInLeapYear calls the given _calendar_'s `inLeapYear()` method and validates the result.
      </p>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Return ? Invoke(_calendar_, *"inLeapYear"*, « _dateLike_ »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendar" aoid="ToTemporalCalendar">
      <h1>ToTemporalCalendar ( _temporalCalendarLike_ )</h1>
      <emu-alg>
        1. If Type(_temporalCalendarLike_) is Object, then
          1. If _temporalCalendarLike_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalTime]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _temporalCalendarLike_.[[Calendar]].
          1. If ? HasProperty(_temporalCalendarLike_, *"calendar"*) is *false*, return _temporalCalendarLike_.
          1. Set _temporalCalendarLike_ to ? Get(_temporalCalendarLike_, *"calendar"*).
          1. If Type(_temporalCalendarLike_) is Object and ? HasProperty(_temporalCalendarLike_, *"calendar"*) is *false*, return _temporalCalendarLike_.
        1. Let _identifier_ be ? ToString(_temporalCalendarLike_).
        1. If ! IsBuiltinCalendar(_identifier_) is *false*, then
          1. Set _identifier_ to ? ParseTemporalCalendarString(_identifier_).
          1. If ! IsBuiltinCalendar(_identifier_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalCalendar(_identifier_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendarwithisodefault" aoid="ToTemporalCalendarWithISODefault">
      <h1>ToTemporalCalendarWithISODefault ( _temporalCalendarLike_ )</h1>
      <p>
        The abstract operation ToTemporalCalendarWithISODefault converts a value into an Object suitable for use as a calendar.
        If the value is *undefined*, the ISO 8601 calendar is returned.
      </p>
      <emu-alg>
        1. If _temporalCalendarLike_ is *undefined*, then
          1. Return ! GetISO8601Calendar().
        1. Return ? ToTemporalCalendar(_temporalCalendarLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-gettemporalcalendarwithisodefault" aoid="GetTemporalCalendarWithISODefault">
      <h1>GetTemporalCalendarWithISODefault ( _item_ )</h1>
      <p>
        The abstract operation GetTemporalCalendarWithISODefault looks for a `calendar` property on the given _item_ and converts its value to an Object suitable for use as a calendar.
        If no such property is present, the ISO 8601 calendar is returned.
      </p>
      <emu-alg>
        1. If _item_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalTime]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return _item_.[[Calendar]].
        1. Let _calendarLike_ be ? Get(_item_, *"calendar"*).
        1. Return ? ToTemporalCalendarWithISODefault(_calendarLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-datefromfields" aoid="DateFromFields">
      <h1>DateFromFields ( _calendar_, _fields_, _options_ )</h1>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Assert: Type(_fields_) is Object.
        1. Let _date_ be ? Invoke(_calendar_, *"dateFromFields"*, « _fields_, _options_ »).
        1. Perform ? RequireInternalSlot(_date_, [[InitializedTemporalDate]]).
        1. Return _date_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-yearmonthfromfields" aoid="YearMonthFromFields">
      <h1>YearMonthFromFields ( _calendar_, _fields_ [ , _options_ ] )</h1>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Assert: Type(_fields_) is Object.
        1. If _options_ is not present, then
          1. Set _options_ to *undefined*.
        1. Else,
          1. Assert: Type(_options_) is Object.
        1. Let _yearMonth_ be ? Invoke(_calendar_, *"yearMonthFromFields"*, « _fields_, _options_ »).
        1. Perform ? RequireInternalSlot(_yearMonth_, [[InitializedTemporalYearMonth]]).
        1. Return _yearMonth_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-monthdayfromfields" aoid="MonthDayFromFields">
      <h1>MonthDayFromFields ( _calendar_, _fields_ [ , _options_ ] )</h1>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. Assert: Type(_fields_) is Object.
        1. If _options_ is not present, then
          1. Set _options_ to *undefined*.
        1. Else,
          1. Assert: Type(_options_) is Object.
        1. Let _monthDay_ be ? Invoke(_calendar_, *"monthDayFromFields"*, « _fields_, _options_ »).
        1. Perform ? RequireInternalSlot(_monthDay_, [[InitializedTemporalMonthDay]]).
        1. Return _monthDay_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatcalendarannotation" aoid="FormatCalendarAnnotation">
      <h1>FormatCalendarAnnotation ( _id_, _showCalendar_ )</h1>
      <p>
        The abstract operation FormatCalendarAnnotation returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
        Depending on the given _id_ and value of _showCalendar_, the string may be empty if no calendar annotation need be included.
      </p>
      <emu-note type="editor">
        The exact form this annotation will take is undergoing a standardization process in the IETF; it is being discussed in the Internet Draft <a href="https://ryzokuken.dev/draft-ryzokuken-datetime-extended/documents/rfc-3339.html#name-internet-date-time-format">Date and Time on the Internet: Timestamps with additional information</a>.
      </emu-note>
      <emu-alg>
        1. Assert: _showCalendar_ is *"auto"*, *"always"*, or *"never"*.
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. If _showCalendar_ is *"auto"* and _id_ is *"iso8601"*, return the empty String.
        1. Return the string-concatenation of *"[u-ca="*, _id_, and *"]"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarequals" aoid="CalendarEquals">
      <h1>CalendarEquals ( _one_, _two_ )</h1>
      <p>
        The abstract operation CalendarEquals takes two arguments _one_ and _two_, which must be Objects.
        It returns *true* if its arguments represent the same calendar.
        It performs the following steps:
      </p>
      <emu-alg>
        1. If _one_ and _two_ are the same Object value, return *true*.
        1. Let _calendarOne_ be ? ToString(_one_).
        1. Let _calendarTwo_ be ? ToString(_two_).
        1. If _calendarOne_ is _calendarTwo_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-consolidatecalendars" aoid="ConsolidateCalendars">
      <h1>ConsolidateCalendars ( _one_, _two_ )</h1>
      <p>
        The abstract operation ConsolidateCalendars takes two arguments _one_ and _two_, which must be Objects.
        It returns the calendar that should take priority when combining two Temporal objects with different calendars, or throws an exception if the calendars cannot be combined.
        It performs the following steps:
      </p>
      <emu-alg>
        1. If _one_ and _two_ are the same Object value, return _two_.
        1. Let _calendarOne_ be ? ToString(_one_).
        1. Let _calendarTwo_ be ? ToString(_two_).
        1. If _calendarOne_ is _calendarTwo_, return _two_.
        1. If _calendarOne_ is *"iso8601"*, return _two_.
        1. If _calendarTwo_ is *"iso8601"*, return _one_.
        1. Throw a *RangeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isisoleapyear" aoid="IsISOLeapYear">
      <h1>IsISOLeapYear ( _year_ )</h1>
      <emu-alg>
        1. Assert: _year_ is an integer.
        1. If _year_ modulo 4 ≠ 0, return *false*.
        1. If _year_ modulo 400 = 0, return *true*.
        1. If _year_ modulo 100 = 0, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodaysinyear" aoid="ISODaysInYear">
      <h1>ISODaysInYear ( _year_ )</h1>
      <emu-alg>
        1. Assert: _year_ is an integer.
        1. If ! IsISOLeapYear(_year_) is *true*, then
          1. Return 366.
        1. Return 365.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodaysinmonth" aoid="ISODaysInMonth">
      <h1>ISODaysInMonth ( _year_, _month_ )</h1>
      <emu-alg>
        1. Assert: _year_ is an integer.
        1. Assert: _month_ is an integer, _month_ ≥ 1, and _month_ ≤ 12.
        1. If _month_ is 1, 3, 5, 7, 8, 10, or 12, return 31.
        1. If _month_ is 4, 6, 9, or 11, return 30.
        1. If ! IsISOLeapYear(_year_) is *true*, return 29.
        1. Return 28.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofweek" aoid="ToISODayOfWeek">
      <h1>ToISODayOfWeek ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_ is an integer.
        1. Assert: _month_ is an integer.
        1. Assert: _day_ is an integer.
        1. Let _date_ be the date given by _year_, _month_, and _day_.
        1. Return _date_'s day of the week according to ISO-8601 as an integer.
      </emu-alg>
      <emu-note>Monday is 1 and Sunday is 7.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofyear" aoid="ToISODayOfYear">
      <h1>ToISODayOfYear ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_ is an integer.
        1. Assert: _month_ is an integer.
        1. Assert: _day_ is an integer.
        1. Let _date_ be the date given by _year_, _month_, and _day_.
        1. Return _date_'s ordinal date in the year according to ISO-8601 as an integer.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisoweekofyear" aoid="ToISOWeekOfYear">
      <h1>ToISOWeekOfYear ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_ is an integer.
        1. Assert: _month_ is an integer.
        1. Assert: _day_ is an integer.
        1. Let _date_ be the date given by _year_, _month_, and _day_.
        1. Return _date_'s week number according to ISO-8601 as an integer.
      </emu-alg>
      <emu-note>Beware that dates at the beginning of a year may be part of a week from the preceding year, and dates at the end of a year may be part of a week at the beginning of the next year, as the first week of any year is defined as the week that contains the first Thursday of the year.</emu-note>
    </emu-clause>

    <emu-clause id="sec-buildisomonthcode" aoid="BuildISOMonthCode">
      <h1>BuildISOMonthCode ( _month_ )</h1>
      <p>
        The abstract operation BuildISOMonthCode returns the corresponding string month code, given the numeric ISO calendar month _month_, which must be an integer between 1 and 12, inclusive.
      </p>
      <emu-alg>
        1. Let _numberPart_ be the String representation of _month_, formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.
        1. Return the string-concatenation of *"M"* and _numberPart_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-resolveisomonth" aoid="ResolveISOMonth">
      <h1>ResolveISOMonth ( _fields_ )</h1>
      <p>
        The abstract operation ResolveISOMonth merges the `month` and `monthCode` properties of the given _fields_ Object into an integer month, and validates that they match.
        It returns the integer month.
      </p>
      <emu-alg>
        1. Assert: _fields_ is an ordinary object with no more and no less than the own data properties listed in <emu-xref href="#table-temporal-field-requirements"></emu-xref>.
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Let _monthCode_ be ! Get(_fields_, *"monthCode"*).
        1. If _monthCode_ is *undefined*, then
          1. If _month_ is *undefined*, throw a *TypeError* exception.
          1. Return _month_.
        1. Assert: Type(_monthCode_) is String.
        1. Let _monthLength_ be the length of _monthCode_.
        1. If _monthLength_ is not 3, throw a *RangeError* exception.
        1. Let _numberPart_ be the substring of _monthCode_ from 1.
        1. Set _numberPart_ to ! ToIntegerOrInfinity(_numberPart_).
        1. If _numberPart_ &lt; 1 or _numberPart_ &gt; 12, throw a *RangeError* exception.
        1. If _month_ is not *undefined*, and _month_ ≠ _numberPart_, then
          1. Throw a *RangeError* exception.
        1. If SameValueNonNumeric(_monthCode_, ! BuildISOMonthCode(_numberPart_)) is *false*, then
          1. Throw a *RangeError* exception.
        1. Return _numberPart_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatefromfields" aoid="ISODateFromFields">
      <h1>ISODateFromFields ( _fields_, _options_ )</h1>
      <p>
        The ISODateFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.dateFromFields` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"day"*, *"month"*, *"monthCode"*, *"year"* », «»).
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. If _year_ is *undefined*, throw a *TypeError* exception.
        1. Let _month_ be ? ResolveISOMonth(_fields_).
        1. Let _day_ be ! Get(_fields_, *"day"*).
        1. If _day_ is *undefined*, throw a *TypeError* exception.
        1. Return ? RegulateISODate(_year_, _month_, _day_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoyearmonthfromfields" aoid="ISOYearMonthFromFields">
      <h1>ISOYearMonthFromFields ( _fields_, _options_ )</h1>
      <p>
        The ISOYearMonthFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.yearMonthFromFields` method for the ISO 8601 calendar.
        It returns a Record with three fields ([[Year]], [[Month]], and [[ReferenceISODay]]). All are integers.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"month"*, *"monthCode"*, *"year"* », «»).
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. If _year_ is *undefined*, throw a *TypeError* exception.
        1. Let _month_ be ? ResolveISOMonth(_fields_).
        1. Let _result_ be ? RegulateISOYearMonth(_year_, _month_, _overflow_).
        1. Return the Record {
            [[Year]]: _result_.[[Year]],
            [[Month]]: _result_.[[Month]],
            [[ReferenceISODay]]: 1
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthdayfromfields" aoid="ISOMonthDayFromFields">
      <h1>ISOMonthDayFromFields ( _fields_, _options_ )</h1>
      <p>
        The ISOMonthDayFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.monthDayFromFields` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"day"*, *"month"*, *"monthCode"*, *"year"* », «»).
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Let _monthCode_ be ! Get(_fields_, *"monthCode"*).
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. If _month_ is not *undefined*, and _monthCode_ and _year_ are both *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _month_ to ? ResolveISOMonth(_fields_).
        1. Let _day_ be ! Get(_fields_, *"day"*).
        1. If _day_ is *undefined*, throw a *TypeError* exception.
        1. Let _referenceISOYear_ be 1972 (the first leap year after the Unix epoch).
        1. If _monthCode_ is *undefined*, then
          1. Let _result_ be ? RegulateISODate(_year_, _month_, _day_, _overflow_).
        1. Else,
          1. Let _result_ be ? RegulateISODate(_referenceISOYear_, _month_, _day_, _overflow_).
        1. Return the Record {
            [[Month]]: _result_.[[Month]],
            [[Day]]: _result_.[[Day]],
            [[ReferenceISOYear]]: _referenceISOYear_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoyear" aoid="ISOYear">
      <h1>ISOYear ( _temporalObject_ )</h1>
      <p>
        The ISOYear abstract operation implements the calendar-specific logic in the `Temporal.Calendar.year` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: _temporalObject_ has an [[ISOYear]] internal slot.
        1. Return 𝔽(_temporalObject_.[[ISOYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonth" aoid="ISOMonth">
      <h1>ISOMonth ( _temporalObject_ )</h1>
      <p>
        The ISOMonth abstract operation implements the calendar-specific logic in the `Temporal.Calendar.month` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: _temporalObject_ has an [[ISOMonth]] internal slot.
        1. Return 𝔽(_temporalObject_.[[ISOMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthcode" aoid="ISOMonthCode">
      <h1>ISOMonthCode ( _temporalObject_ )</h1>
      <p>
        The ISOMonthCode abstract operation implements the calendar-specific logic in the `Temporal.Calendar.monthCode` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: _temporalObject_ has an [[ISOMonth]] internal slot.
        1. Return ! BuildISOMonthCode(_temporalObject_.[[ISOMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoday" aoid="ISODay">
      <h1>ISODay ( _temporalObject_ )</h1>
      <p>
        The ISODay abstract operation implements the calendar-specific logic in the `Temporal.Calendar.day` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: _temporalObject_ has an [[ISODay]] internal slot.
        1. Return 𝔽(_temporalObject_.[[ISODay]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-defaultmergefields" aoid="DefaultMergeFields">
      <h1>DefaultMergeFields ( _fields_, _additionalFields_ )</h1>
      <p>
        The abstract operation DefaultMergeFields implements the default logic for the `Temporal.Calendar.mergeFields` method, which is used as a fallback if the method is not present on a calendar, and also for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Let _merged_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Let _originalKeys_ be ? EnumerableOwnPropertyNames(_fields_, ~key~).
        1. For each element _nextKey_ of _originalKeys_, do
          1. If _nextKey_ is not *"month"* or *"monthCode"*, then
            1. Let _propValue_ be ? Get(_fields_, _nextKey_).
            1. If _propValue_ is not *undefined*, then
              1. Perform ! CreateDataPropertyOrThrow(_merged_, _nextKey_, _propValue_).
        1. Let _newKeys_ be ? EnumerableOwnPropertyNames(_additionalFields_, ~key~).
        1. For each element _nextKey_ of _newKeys_, do
          1. Let _propValue_ be ? Get(_additionalFields_, _nextKey_).
          1. If _propValue_ is not *undefined*, then
            1. Perform ! CreateDataPropertyOrThrow(_merged_, _nextKey_, _propValue_).
        1. If _newKeys_ does not contain either *"month"* or *"monthCode"*, then
          1. Let _month_ be ? Get(_fields_, *"month"*).
          1. If _month_ is not *undefined*, then
            1. Perform ! CreateDataPropertyOrThrow(_merged_, *"month"*, _month_).
          1. Let _monthCode_ be ? Get(_fields_, *"monthCode"*).
          1. If _monthCode_ is not *undefined*, then
            1. Perform ! CreateDataPropertyOrThrow(_merged_, *"monthCode"*, _monthCode_).
        1. Return _merged_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-calendar-constructor">
    <h1>The Temporal.Calendar Constructor</h1>
    <p>The Temporal.Calendar constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.Calendar object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.Calendar behaviour must
        include a super call to the %Temporal.Calendar% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.calendar">
      <h1>Temporal.Calendar ( _id_ )</h1>
      <p>
        When the `Temporal.Calendar` function is called, the following steps are taken:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _id_ to ? ToString(_id_).
        1. If ! IsBuiltinCalendar(_id_) is *false*, then
          1. Throw a *RangeError* exception.
        1. Return ? CreateTemporalCalendar(_id_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-calendar-constructor">
    <h1>Properties of the Temporal.Calendar Constructor</h1>
    <p>The Temporal.Calendar prototype:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-clause id="sec-temporal-calendar-prototype">
      <h1>Temporal.Calendar.prototype</h1>
      <p>The initial value of `Temporal.Calendar.prototype` is %Temporal.Calendar.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.from">
      <h1>Temporal.Calendar.from ( _calendarLike_ )</h1>
      <p>
        The `from` method takes one argument _calendarLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Return ? ToTemporalCalendar(_calendarLike_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-calendar-prototype-object">
    <h1>Properties of the Temporal.Calendar Prototype Object</h1>

    <p>The Temporal.Calendar prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.Calendar instance and does not have a [[InitializedTemporalCalendar]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.calendar.prototype.constructor">
      <h1>Temporal.Calendar.prototype.constructor</h1>
      <p>The initial value of `Temporal.Calendar.prototype.constructor` is %Temporal.Calendar%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype-@@tostringtag">
      <h1>Temporal.Calendar.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.Calendar"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.calendar.prototype.id">
      <h1>get Temporal.Calendar.prototype.id</h1>
      <p>
        `Temporal.Calendar.prototype.id` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return ? ToString(_calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.datefromfields">
      <h1>Temporal.Calendar.prototype.dateFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `dateFromFields` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `dateFromFields` method is used.
      </p>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _result_ be ? ISODateFromFields(_fields_, _options_).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.yearmonthfromfields">
      <h1>Temporal.Calendar.prototype.yearMonthFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `yearMonthFromFields` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `yearMonthFromFields` method is used.
      </p>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _result_ be ? ISOYearMonthFromFields(_fields_, _options_).
        1. Return ? CreateTemporalYearMonth(_result_.[[Year]], _result_.[[Month]], _calendar_, _result_.[[ReferenceISODay]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthdayfromfields">
      <h1>Temporal.Calendar.prototype.monthDayFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `monthDayFromFields` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `monthDayFromFields` method is used.
      </p>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _result_ be ? ISOMonthDayFromFields(_fields_, _options_).
        1. Return ? CreateTemporalMonthDay(_result_.[[Month]], _result_.[[Day]], _calendar_, _result_.[[ReferenceISOYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dateadd">
      <h1>Temporal.Calendar.prototype.dateAdd ( _date_, _duration_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `dateAdd` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `dateAdd` method is used.
      </p>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Set _date_ to ? ToTemporalDate(_date_).
        1. Set _duration_ to ? ToTemporalDuration(_duration_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _balanceResult_ be ! BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"day"*).
        1. Let _result_ be ? AddISODate(_date_.[[ISOYear]], _date_.[[ISOMonth]], _date_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]], _overflow_).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dateuntil">
      <h1>Temporal.Calendar.prototype.dateUntil ( _one_, _two_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `dateUntil` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `dateUntil` method is used.
      </p>
      <p>
        The `dateUntil` method takes three arguments, _one_, _two_, and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Set _one_ to ? ToTemporalDate(_one_).
        1. Set _two_ to ? ToTemporalDate(_two_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, « *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"* », *"auto"*, *"day"*).
        1. Let _result_ be ! DifferenceISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _largestUnit_).
        1. Return ! CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.year">
      <h1>Temporal.Calendar.prototype.year ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `year` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `year` method is used.
      </p>
      <p>
        The `year` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]] or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return ! ISOYear(_temporalDateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.month">
      <h1>Temporal.Calendar.prototype.month ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `month` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `month` method is used.
      </p>
      <p>
        The `month` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is Object and _temporalDateLike_ has an [[InitializedTemporalMonthDay]] internal slot, then
          1. Throw a *TypeError* exception.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]] or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return ! ISOMonth(_temporalDateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthcode">
      <h1>Temporal.Calendar.prototype.monthCode ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `monthCode` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `monthCode` method is used.
      </p>
      <p>
        The `monthCode` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return ! ISOMonthCode(_temporalDateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.day">
      <h1>Temporal.Calendar.prototype.day ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `day` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `day` method is used.
      </p>
      <p>
        The `day` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]] or [[InitializedTemporalMonthDay]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return ! ISODay(_temporalDateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dayofweek">
      <h1>Temporal.Calendar.prototype.dayOfWeek ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `dayOfWeek` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `dayOfWeek` method is used.
      </p>
      <p>
        The `dayOfWeek` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(! ToISODayOfWeek(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dayofyear">
      <h1>Temporal.Calendar.prototype.dayOfYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `dayOfYear` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `dayOfYear` method is used.
      </p>
      <p>
        The `dayOfYear` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(! ToISODayOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.weekofyear">
      <h1>Temporal.Calendar.prototype.weekOfYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `weekOfYear` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `weekOfYear` method is used.
      </p>
      <p>
        The `weekOfYear` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(! ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinweek">
      <h1>Temporal.Calendar.prototype.daysInWeek ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `daysInWeek` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `daysInWeek` method is used.
      </p>
      <p>
        The `daysInWeek` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Perform ? ToTemporalDate(_temporalDateLike_).
        1. Return *7*<sub>𝔽</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinmonth">
      <h1>Temporal.Calendar.prototype.daysInMonth ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `daysInMonth` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `daysInMonth` method is used.
      </p>
      <p>
        The `daysInMonth` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]] or [[InitializedTemporalYearMonth]] internal slots, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(! ISODaysInMonth(_temporalDateLike_.[[ISOYear]], _temporalDateLike_.[[ISOMonth]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinyear">
      <h1>Temporal.Calendar.prototype.daysInYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `daysInYear` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `daysInYear` method is used.
      </p>
      <p>
        The `daysInYear` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]] or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(! ISODaysInYear(_temporalDateLike_.[[ISOYear]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthsinyear">
      <h1>Temporal.Calendar.prototype.monthsInYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `monthsInYear` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `monthsInYear` method is used.
      </p>
      <p>
        The `monthsInYear` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]] or [[InitializedTemporalYearMonth]] internal slot, then
          1. Perform ? ToTemporalDate(_temporalDateLike_).
        1. Return *12*<sub>𝔽</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.inleapyear">
      <h1>Temporal.Calendar.prototype.inLeapYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `inLeapYear` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `inLeapYear` method is used.
      </p>
      <p>
        The `inLeapYear` method takes one argument _temporalDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]] or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return ! IsISOLeapYear(_temporalDateLike_.[[ISOYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.fields">
      <h1>Temporal.Calendar.prototype.fields ( _fields_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `fields` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `fields` method is used.
      </p>
      <p>
        The `fields` method takes one argument _fields_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _iteratorRecord_ be ? Getiterator(_fields_, ~sync~).
        1. Let _fieldNames_ be a new empty List.
        1. Let _next_ be *true*.
        1. Repeat, while _next_ is not *false*,
          1. Set _next_ to ? IteratorStep(_iteratorRecord_).
          1. If _next_ is not *false*, then
            1. Let _nextValue_ be ? IteratorValue(_next_).
            1. If Type(_nextValue_) is not String, then
              1. Let _completion_ be ThrowCompletion(a newly created *TypeError* object).
              1. Return ? IteratorClose(_iteratorRecord_, _completion_).
            1. If _fieldNames_ contains _nextValue_, then
              1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
              1. Return ? IteratorClose(_iteratorRecord_, _completion_).
            1. If _nextValue_ is not one of *"year"*, *"month"*, *"monthCode"*, *"day"*, *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"*, then
                1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
                1. Return ? IteratorClose(_iteratorRecord_, _completion_).
            1. Append _nextValue_ to the end of the List _fieldNames_.
        1. Return CreateArrayFromList(_fieldNames_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.mergefields">
      <h1>Temporal.Calendar.prototype.mergeFields ( _fields_, _additionalFields_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `mergeFields` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `mergeFields` method is used.
      </p>
      <p>
        The `mergeFields` method takes two arguments, _fields_ and _additionalFields_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Set _fields_ to ? ToObject(_fields_).
        1. Set _additionalFields_ to ? ToObject(_additionalFields_).
        1. Return ? DefaultMergeFields(_fields_, _additionalFields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.tostring">
      <h1>Temporal.Calendar.prototype.toString ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return _calendar_.[[Identifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.tojson">
      <h1>Temporal.Calendar.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return ? ToString(_calendar_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-calendar-instances">
    <h1>Properties of Temporal.Calendar Instances</h1>

    <p>Temporal.Calendar instances are ordinary objects that inherit properties from the %Temporal.Calendar.prototype%. Temporal.Calendar instances also have a [[Identifier]] internal slot. The value of this internal slot is a string.</p>
  </emu-clause>
</emu-clause>
