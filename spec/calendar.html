<!DOCTYPE html>
<meta charset="utf8">

<emu-clause id="sec-temporal-calendars">
  <h1>Calendars</h1>

  <emu-clause id="sec-calendar-types">
    <h1>Calendar Types</h1>

    <!-- See https://github.com/tc39/ecma402/issues/828 and https://github.com/tc39/ecma402/issues/852 -->
    <p>
      At a minimum, ECMAScript implementations must support a built-in calendar named *"iso8601"*, representing the ISO 8601 calendar.
      In addition, implementations may support any number of other built-in calendars corresponding with those of the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
    </p>
    <p>
      ECMAScript implementations identify built-in calendars using a <dfn variants="calendar types">calendar type</dfn> as defined by <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Elements">Unicode Technical Standard #35, Part 4, Section 2</a>.
      Their canonical form is a string containing only Unicode Basic Latin lowercase letters (U+0061 LATIN SMALL LETTER A through U+007A LATIN SMALL LETTER Z, inclusive) and/or digits (U+0030 DIGIT ZERO through U+0039 DIGIT NINE, inclusive), with zero or more medial hyphens (U+002D HYPHEN-MINUS).
    </p>

    <emu-clause id="sec-temporal-isbuiltincalendar" type="abstract operation">
      <h1>
        IsBuiltinCalendar (
          _id_: a String,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned value is *true* if _id_ is a calendar type denoting a built-in calendar, and *false* otherwise.</dd>
      </dl>
      <emu-alg>
        1. Let _calendars_ be AvailableCalendars().
        1. If _calendars_ contains the ASCII-lowercase of _id_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-availablecalendars" type="implementation-defined abstract operation">
      <h1>
        AvailableCalendars (
        ): a List of Strings
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned List is sorted according to lexicographic code unit order, and contains unique calendar types in canonical form (<emu-xref href="#sec-calendar-types"></emu-xref>) identifying the calendars for which the implementation provides the functionality of Intl.DateTimeFormat objects, including their aliases (e.g., either both or neither of *"islamicc"* and *"islamic-civil"*). The List must include *"iso8601"*.</dd>
      </dl>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-calendar-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-temporal-calendar-date-records">
      <h1>Calendar Date Records</h1>
      <p>
        An <dfn variants="Calendar Date Records">Calendar Date Record</dfn> is a Record value used to represent a valid calendar date in a non-ISO 8601 calendar.
        Calendar Date Records are produced by the abstract operation CalendarISOToDate.
      </p>
      <p>Calendar Date Records have the fields listed in <emu-xref href="#table-temporal-calendar-date-record-fields"></emu-xref>.</p>
      <emu-table id="table-temporal-calendar-date-record-fields" caption="Calendar Date Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>a String or *undefined*</td>
            <td>
              A lowercase String value representing the date's era, or *undefined* for calendars that do not have eras.
            </td>
          </tr>
          <tr>
            <td>[[EraYear]]</td>
            <td>an integer or *undefined*</td>
            <td>
              The ordinal position of the date's year within its era, or *undefined* for calendars that do not have eras.
              <emu-note>
                Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer</td>
            <td>
              The date's year relative to the first day of a calendar-specific "epoch year".
              <emu-note>The year is relative to the first day of the calendar's epoch year, so if the epoch era starts in the middle of the year, the year will be the same value before and after the start date of the era.</emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's month within its year.
              <emu-note>
                When the number of months in a year of the calendar is variable, a different value can be returned for dates that are part of the same month in different years. For example, in the Hebrew calendar, 1 Nisan 5781 is associated with value 7 while 1 Nisan 5782 is associated with value 8 because 5782 is a leap year and Nisan follows the insertion of Adar I.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[MonthCode]]</td>
            <td>a String</td>
            <td>
              The month code of the date's month. The month code for a month that is not a leap month and whose 1-based ordinal position in a common year of the calendar (i.e., a year that is not a leap year) is _n_ should be the string-concatenation of *"M"* and ToZeroPaddedDecimalString(_n_, 2), and the month code for a month that is a leap month inserted after a month whose 1-based ordinal position in a common year of the calendar is _p_ should be the string-concatenation of *"M"*, ToZeroPaddedDecimalString(_p_, 2), and *"L"*.
              <emu-note>
                For example, in the Hebrew calendar, the month code of Adar (and Adar II, in leap years) is *"M06"* and the month code of Adar I (the leap month inserted before Adar II) is *"M05L"*. In a calendar with a leap month at the start of some years, the month code of that month would be *"M00L"*.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's day within its month.
            </td>
          </tr>
          <tr>
            <td>[[DayOfWeek]]</td>
            <td>a positive integer</td>
            <td>
              The day of the week corresponding to the date. The value should be 1-based, where 1 is the day corresponding to Monday in the given calendar.
            </td>
          </tr>
          <tr>
            <td>[[DayOfYear]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's day within its year.
            </td>
          </tr>
          <tr>
            <td>[[WeekOfYear]]</td>
            <td>a Year-Week Record</td>
            <td>
              <p>The date's <em>calendar week of year</em>, and the corresponding <em>week calendar year</em>.</p>
              <p>The Year-Week Record's [[Week]] field should be 1-based.</p>
              <p>The Year-Week Record's [[Year]] field is relative to the first day of a calendar-specific "epoch year", as in the Calendar Date Record's [[Year]] field, not relative to an era as in [[EraYear]].</p>
              <p>
                Usually the Year-Week Record's [[Year]] field will contain the same value as the Calendar Date Record's [[Year]] field, but may contain the previous or next year if the week number in the Year-Week Record's [[Week]] field overlaps two different years.
                See also ToISOWeekOfYear.
              </p>
              <p>The Year-Week Record contains *undefined* in [[Week]] and [[Year]] field for calendars that do not have a well-defined week calendar system.</p>
              <emu-note type="editor">
                <p>
                  More details about this field will be specified in
                  <a href="https://tc39.es/proposal-intl-era-monthcode/">the Intl era and monthCode proposal</a>.
                </p>
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[DaysInWeek]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's week.</td>
          </tr>
          <tr>
            <td>[[DaysInMonth]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's month.</td>
          </tr>
          <tr>
            <td>[[DaysInYear]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's year.</td>
          </tr>
          <tr>
            <td>[[MonthsInYear]]</td>
            <td>a positive integer</td>
            <td>The number of months in the date's year.</td>
          </tr>
          <tr>
            <td>[[InLeapYear]]</td>
            <td>a Boolean</td>
            <td>
              *true* if the date falls within a leap year, and *false* otherwise.
              <emu-note>
                A "leap year" is a year that contains more days than other years (for solar or lunar calendars) or more months than other years (for lunisolar calendars like Hebrew or Chinese).
                Some calendars, especially lunisolar ones, have further variation in year length that is not represented in the output of this operation (e.g., the Hebrew calendar includes common years with 353, 354, or 355 days and leap years with 383, 384, or 385 days).
              </emu-note>
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-calendar-fields-records">
      <h1>Calendar Fields Records</h1>
      <p>
        An <dfn variants="Calendar Fields Records">Calendar Fields Record</dfn> is a Record value used to represent full or partial input for a calendar date in a non-ISO 8601 calendar.
        Calendar Fields Records are produced by several abstract operations, such as TemporalObjectToFields and PrepareCalendarFields, and are passed to abstract operations such as CalendarDateFromFields.
      </p>
      <p>Many of the fields in a Calendar Fields Record have the same meaning as the fields of the same name in Calendar Date Records, but each field in a Calendar Fields Record may additionally be ~unset~ to indicate partial input.</p>
      <p>
        Each field has a corresponding property key.
        These property keys correspond to the properties that are read from user input objects to populate the field, in methods such as `Temporal.PlainDate.prototype.with()`.
      </p>
      <p>
        Each field has a corresponding enumeration key.
        Lists of these enumeration keys are passed to abstract operations such as PrepareCalendarFields and ISOFieldKeysToIgnore to denote a subset of fields to operate on.
      </p>
      <p>Calendar Fields Records have the fields listed in <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>.</p>
      <emu-table id="table-temporal-calendar-fields-record-fields" caption="Calendar Fields Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Default</th>
            <th>Property Key</th>
            <th>Enumeration Key</th>
            <th>Conversion</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>a String or ~unset~</td>
            <td>~unset~</td>
            <td>*"era"*</td>
            <td>~era~</td>
            <td>~to-string~</td>
            <td>
              A lowercase String value representing the era.
            </td>
          </tr>
          <tr>
            <td>[[EraYear]]</td>
            <td>an integer or ~unset~</td>
            <td>~unset~</td>
            <td>*"eraYear"*</td>
            <td>~era-year~</td>
            <td>~to-integer-with-truncation~</td>
            <td>
              The ordinal position of the year within the era.
            </td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer or ~unset~</td>
            <td>~unset~</td>
            <td>*"year"*</td>
            <td>~year~</td>
            <td>~to-integer-with-truncation~</td>
            <td>
              The year relative to the first day of a calendar-specific "epoch year".
            </td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>a positive integer or ~unset~</td>
            <td>~unset~</td>
            <td>*"month"*</td>
            <td>~month~</td>
            <td>~to-positive-integer-with-truncation~</td>
            <td>
              The 1-based ordinal position of the month within the year.
            </td>
          </tr>
          <tr>
            <td>[[MonthCode]]</td>
            <td>a String or ~unset~</td>
            <td>~unset~</td>
            <td>*"monthCode"*</td>
            <td>~month-code~</td>
            <td>~to-primitive-and-require-string~</td>
            <td>
              The month code of the month.
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>a positive integer or ~unset~</td>
            <td>~unset~</td>
            <td>*"day"*</td>
            <td>~day~</td>
            <td>~to-positive-integer-with-truncation~</td>
            <td>
              The 1-based ordinal position of the day within the month.
            </td>
          </tr>
          <tr>
            <td>[[Hour]]</td>
            <td>an integer in the inclusive interval from 0 to 23 or ~unset~</td>
            <td>0</td>
            <td>*"hour"*</td>
            <td>~hour~</td>
            <td>~to-integer-with-truncation~</td>
            <td>
              The number of the hour within the day.
            </td>
          </tr>
          <tr>
            <td>[[Minute]]</td>
            <td>an integer in the inclusive interval from 0 to 59 or ~unset~</td>
            <td>0</td>
            <td>*"minute"*</td>
            <td>~minute~</td>
            <td>~to-integer-with-truncation~</td>
            <td>
              The number of the minute within the hour.
            </td>
          </tr>
          <tr>
            <td>[[Second]]</td>
            <td>an integer in the inclusive interval from 0 to 59 or ~unset~</td>
            <td>0</td>
            <td>*"second"*</td>
            <td>~second~</td>
            <td>~to-integer-with-truncation~</td>
            <td>
              The number of the second within the minute.
            </td>
          </tr>
          <tr>
            <td>[[Millisecond]]</td>
            <td>an integer in the inclusive interval from 0 to 999 or ~unset~</td>
            <td>0</td>
            <td>*"millisecond"*</td>
            <td>~millisecond~</td>
            <td>~to-integer-with-truncation~</td>
            <td>
              The number of the millisecond within the second.
            </td>
          </tr>
          <tr>
            <td>[[Microsecond]]</td>
            <td>an integer in the inclusive interval from 0 to 999 or ~unset~</td>
            <td>0</td>
            <td>*"microsecond"*</td>
            <td>~microsecond~</td>
            <td>~to-integer-with-truncation~</td>
            <td>
              The number of the microsecond within the millisecond.
            </td>
          </tr>
          <tr>
            <td>[[Nanosecond]]</td>
            <td>an integer in the inclusive interval from 0 to 999 or ~unset~</td>
            <td>0</td>
            <td>*"nanosecond"*</td>
            <td>~nanosecond~</td>
            <td>~to-integer-with-truncation~</td>
            <td>
              The number of the nanosecond within the microsecond.
            </td>
          </tr>
          <tr>
            <td>[[OffsetString]]</td>
            <td>a String or ~unset~</td>
            <td>~unset~</td>
            <td>*"offset"*</td>
            <td>~offset~</td>
            <td>~to-primitive-and-require-string~</td>
            <td>
              A string of the form `±HH:MM` that can be parsed by ParseTimeZoneOffsetString.
            </td>
          </tr>
          <tr>
            <td>[[TimeZone]]</td>
            <td>a String or ~unset~</td>
            <td>~unset~</td>
            <td>*"timeZone"*</td>
            <td>~time-zone~</td>
            <td>~to-temporal-time-zone-identifier~</td>
            <td>
              A time zone identifier.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarfieldkeyspresent" type="abstract operation">
      <h1>
        CalendarFieldKeysPresent (
          _fields_: a Calendar Fields Record,
        ): a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned List contains the enumeration keys for all fields of _fields_ that are not ~unset~.</dd>
      </dl>
      <emu-alg>
        1. Let _list_ be « ».
        1. For each row of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>, except the header row, do
          1. Let _value_ be _fields_' field whose name is given in the Field Name column of the row.
          1. Let _enumerationKey_ be the value in the Enumeration Key column of the row.
          1. If _value_ is not ~unset~, append _enumerationKey_ to _list_.
        1. Return _list_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmergefields" type="abstract operation">
      <h1>
        CalendarMergeFields (
          _calendar_: a String,
          _fields_: a Calendar Fields Record,
          _additionalFields_: a Calendar Fields Record,
        ): a Calendar Fields Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It merges the properties of _fields_ and _additionalFields_.</dd>
      </dl>
      <emu-alg>
        1. Let _additionalKeys_ be CalendarFieldKeysPresent(_additionalFields_).
        1. If _calendar_ is *"iso8601"*, then
          1. Let _overriddenKeys_ be ISOFieldKeysToIgnore(_additionalKeys_).
        1. Else,
          1. Let _overriddenKeys_ be CalendarFieldKeysToIgnore(_calendar_, _additionalKeys_).
        1. Let _merged_ be a Calendar Fields Record with all fields set to ~unset~.
        1. Let _fieldsKeys_ be CalendarFieldKeysPresent(_fields_).
        1. For each row of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>, except the header row, do
          1. Let _key_ be the value in the Enumeration Key column of the row.
          1. If _fieldsKeys_ contains _key_ and _overriddenKeys_ does not contain _key_, then
            1. Let _propValue_ be _fields_' field whose name is given in the Field Name column of the row.
            1. Set _merged_'s field whose name is given in the Field Name column of the row to _propValue_.
          1. If _additionalKeys_ contains _key_, then
            1. Let _propValue_ be _additionalFields_' field whose name is given in the Field Name column of the row.
            1. Set _merged_'s field whose name is given in the Field Name column of the row to _propValue_.
        1. Return _merged_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateadd" type="abstract operation">
      <h1>
        CalendarDateAdd (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
          _duration_: a Date Duration Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds _dateDuration_ to _isoDate_ using the years, months, and weeks reckoning of _calendar_.
        </dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Return ? AddISODate(_isoDate_.[[Year]], _isoDate_.[[Month]], _isoDate_.[[Day]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _overflow_).
        1. 1. Return ? CalendarDateAddition(_calendar_, _isoDate_, _duration_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateuntil" type="abstract operation">
      <h1>
        CalendarDateUntil (
          _calendar_: a String,
          _one_: an ISO Date Record,
          _two_: an ISO Date Record,
          _largestUnit_: a String from the "Singular" column of <emu-xref href="#table-temporal-units"></emu-xref>,
        ): a Temporal.Duration
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines the difference between the dates _one_ and _two_ using the years, months, and weeks reckoning of _calendar_.
        </dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Return DifferenceISODate(_one_.[[Year]], _one_.[[Month]], _one_.[[Day]], _two_.[[Year]], _two_.[[Month]], _two_.[[Day]], _largestUnit_).
        1. Else,
          1. Return CalendarDateDifference(_calendar_, _one_, _two_, _largestUnit_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarera" type="abstract operation">
      <h1>
        CalendarEra (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a String or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, return *undefined*.
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[Era]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarerayear" type="abstract operation">
      <h1>
        CalendarEraYear (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): an integer or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, return *undefined*.
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[EraYear]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryear" type="abstract operation">
      <h1>
        CalendarYear (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, return _isoDate_.[[Year]].
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[Year]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonth" type="abstract operation">
      <h1>
        CalendarMonth (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, return _isoDate_.[[Month]].
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[Month]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthcode" type="abstract operation">
      <h1>
        CalendarMonthCode (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, return ISOMonthCode(_isoDate_.[[Month]]).
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[MonthCode]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarday" type="abstract operation">
      <h1>
        CalendarDay (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, return _isoDate_.[[Day]].
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[Day]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofweek" type="abstract operation">
      <h1>
        CalendarDayOfWeek (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Return ToISODayOfWeek(_isoDate_.[[Year]], _isoDate_.[[Month]], _isoDate_.[[Day]]).
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[DayOfWeek]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofyear" type="abstract operation">
      <h1>
        CalendarDayOfYear (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Return ToISODayOfYear(_isoDate_.[[Year]], _isoDate_.[[Month]], _isoDate_.[[Day]]).
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[DayOfYear]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarweekofyear" type="abstract operation">
      <h1>
        CalendarWeekOfYear (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Let _yearWeek_ be ToISOWeekOfYear(_isoDate_.[[Year]], _isoDate_.[[Month]], _isoDate_.[[Day]]).
        1. Else,
          1. Let _yearWeek_ be CalendarISOToDate(_calendar_, _isoDate_).[[WeekOfYear]].
        1. Return _yearWeek_.[[Week]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryearofweek" type="abstract operation">
      <h1>
        CalendarYearOfWeek (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Let _yearWeek_ be ToISOWeekOfYear(_isoDate_.[[Year]], _isoDate_.[[Month]], _isoDate_.[[Day]]).
        1. Else,
          1. Let _yearWeek_ be CalendarISOToDate(_calendar_, _isoDate_).[[WeekOfYear]].
        1. Return _yearWeek_.[[Year]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinweek" type="abstract operation">
      <h1>
        CalendarDaysInWeek (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, return 7.
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[DaysInWeek]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinmonth" type="abstract operation">
      <h1>
        CalendarDaysInMonth (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Return ISODaysInMonth(_isoDate_.[[Year]], _isoDate_.[[Month]]).
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[DaysInMonth]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinyear" type="abstract operation">
      <h1>
        CalendarDaysInYear (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Return MathematicalDaysInYear(_isoDate_.[[Year]]).
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[DaysInYear]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthsinyear" type="abstract operation">
      <h1>
        CalendarMonthsInYear (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, return 12.
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[MonthsInYear]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarinleapyear" type="abstract operation">
      <h1>
        CalendarInLeapYear (
          _calendar_: a String,
          _isoDate_: an ISO Date Record,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. If MathematicalInLeapYear(EpochTimeForYear(_isoDate_.[[Year]])) = 1, return *true*.
          1. Return *false*.
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[InLeapYear]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendaridentifier" type="abstract operation">
      <h1>
        ToTemporalCalendarIdentifier (
          _temporalCalendarLike_: an ECMAScript value,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It attempts to derive a value from _temporalCalendarLike_ that is a calendar identifier according to IsBuiltinCalendar, and returns that value if found or throws an exception if not.
        </dd>
      </dl>
      <emu-alg>
        1. If _temporalCalendarLike_ is an Object, then
          1. If _temporalCalendarLike_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _temporalCalendarLike_.[[Calendar]].
        1. If _temporalCalendarLike_ is not a String, throw a *TypeError* exception.
        1. Let _identifier_ be ? ParseTemporalCalendarString(_temporalCalendarLike_).
        1. If IsBuiltinCalendar(_identifier_) is *false*, throw a *RangeError* exception.
        1. Return CanonicalizeUValue(*"ca"*, _identifier_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-gettemporalcalendarslotvaluewithisodefault" type="abstract operation">
      <h1>
        GetTemporalCalendarIdentifierWithISODefault (
          _item_: an Object,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It looks for a `calendar` property on the given _item_ and converts its value into a calendar identifier.
          If no such property is present, the built-in ISO 8601 calendar is returned.
        </dd>
      </dl>
      <emu-alg>
        1. If _item_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return _item_.[[Calendar]].
        1. Let _calendarLike_ be ? Get(_item_, *"calendar"*).
        1. If _calendarLike_ is *undefined*, then
          1. Return *"iso8601"*.
        1. Return ? ToTemporalCalendarIdentifier(_calendarLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatefromfields" type="abstract operation">
      <h1>
        CalendarDateFromFields (
          _calendar_: a String,
          _fields_: a Calendar Fields Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts a calendar date in the reckoning of _calendar_, if it is uniquely determined by the fields of _fields_, into an ISO Date Record.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. If _fields_.[[Year]] is ~unset~ or _fields_.[[Day]] is ~unset~, throw a *TypeError* exception.
          1. Perform ? ISOResolveMonth(_fields_).
          1. Return ? ISODateFromFields(_fields_, _overflow_).
        1. Perform ? CalendarResolveFields(_calendar_, _fields_, ~date~).
        1. Return ? CalendarDateToISO(_calendar_, _fields_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryearmonthfromfields" type="abstract operation">
      <h1>
        CalendarYearMonthFromFields (
          _calendar_: a String,
          _fields_: a Calendar Fields Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts a calendar month in the reckoning of _calendar_, if it is uniquely determined by the properties on _fields_, into an ISO Date Record denoting the first day of that month.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. If _fields_.[[Year]] is ~unset~, throw a *TypeError* exception.
          1. Perform ? ISOResolveMonth(_fields_).
          1. Return ? ISOYearMonthFromFields(_fields_, _overflow_).
        1. Let _firstDayIndex_ be the 1-based index of the first day of the month described by _fields_ (i.e., 1 unless the month's first day is skipped by this calendar.)
        1. Set _fields_.[[Day]] to _firstDayIndex_.
        1. Perform ? CalendarResolveFields(_calendar_, _fields_, ~year-month~).
        1. Return ? CalendarDateToISO(_calendar_, _fields_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthdayfromfields" type="abstract operation">
      <h1>
        CalendarMonthDayFromFields (
          _calendar_: a String,
          _fields_: a Calendar Fields Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts a calendar month-day in the reckoning of _calendar_, if it is uniquely determined by the properties on _fields_, into an ISO Date Record denoting that day in an appropriate reference year.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. If _fields_.[[Day]] is ~unset~, throw a *TypeError* exception.
          1. Perform ? ISOResolveMonth(_fields_).
          1. Return ? ISOMonthDayFromFields(_fields_, _overflow_).
        1. Perform ? CalendarResolveFields(_calendar_, _fields_, ~month-day~).
        1. Return ? CalendarMonthDayToISOReferenceDate(_calendar_, _fields_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-maybeformatcalendarannotation" type="abstract operation">
      <h1>
        MaybeFormatCalendarAnnotation (
          _calendar_: a String,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
          Depending on the given _calendar_ and the value of _showCalendar_, the string may be empty if no calendar annotation need be included.
        </dd>
      </dl>
      <emu-alg>
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. Return FormatCalendarAnnotation(_calendar_, _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatcalendarannotation" type="abstract operation">
      <h1>
        FormatCalendarAnnotation (
          _id_: a String,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
          Depending on the given _id_ and value of _showCalendar_, the string may be empty if no calendar annotation need be included.
        </dd>
      </dl>
      <emu-alg>
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. If _showCalendar_ is *"auto"* and _id_ is *"iso8601"*, return the empty String.
        1. If _showCalendar_ is *"critical"*, let _flag_ be *"!"*; else, let flag be the empty String.
        1. Return the string-concatenation of *"["*, _flag_, *"u-ca="*, _id_, and *"]"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarequals" type="abstract operation">
      <h1>
        CalendarEquals (
          _one_: a String,
          _two_: a String,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns *true* if its arguments represent calendars using the same identifier.</dd>
      </dl>
      <emu-alg>
        1. If CanonicalizeUValue(*"ca"*, _one_) is CanonicalizeUValue(*"ca"*, _two_), return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodaysinmonth" type="abstract operation">
      <h1>
        ISODaysInMonth (
          _year_: an integer,
          _month_: an integer in the inclusive interval from 1 to 12,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the number of days in the given year and month in the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. If _month_ is 1, 3, 5, 7, 8, 10, or 12, return 31.
        1. If _month_ is 4, 6, 9, or 11, return 30.
        1. Assert: _month_ = 2.
        1. Return 28 + MathematicalInLeapYear(EpochTimeForYear(_year_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisoweekofyear" type="abstract operation">
      <h1>
        ToISOWeekOfYear (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): a Year-Week Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines where a calendar day falls in the ISO 8601 week calendar and calculates its <em>calendar week of year</em>, which is the 1-based ordinal number of its calendar week within the corresponding <em>week calendar year</em> (which may differ from _year_ by up to 1 in either direction).</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _wednesday_ be 3.
        1. Let _thursday_ be 4.
        1. Let _friday_ be 5.
        1. Let _saturday_ be 6.
        1. Let _daysInWeek_ be 7.
        1. Let _maxWeekNumber_ be 53.
        1. Let _dayOfYear_ be ToISODayOfYear(_year_, _month_, _day_).
        1. Let _dayOfWeek_ be ToISODayOfWeek(_year_, _month_, _day_).
        1. Let _week_ be floor((_dayOfYear_ + _daysInWeek_ - _dayOfWeek_ + _wednesday_ ) / _daysInWeek_).
        1. If _week_ &lt; 1, then
          1. NOTE: This is the last week of the previous year.
          1. Let _dayOfJan1st_ be ToISODayOfWeek(_year_, 1, 1).
          1. If _dayOfJan1st_ = _friday_, then
            1. Return Year-Week Record { [[Week]]: _maxWeekNumber_, [[Year]]: _year_ - 1 }.
          1. If _dayOfJan1st_ = _saturday_, and MathematicalInLeapYear(EpochTimeForYear(_year_ - 1)) = 1, then
            1. Return Year-Week Record { [[Week]]: _maxWeekNumber_. [[Year]]: _year_ - 1 }.
          1. Return Year-Week Record { [[Week]]: _maxWeekNumber_ - 1, [[Year]]: _year_ - 1 }.
        1. If _week_ = _maxWeekNumber_, then
          1. Let _daysInYear_ be MathematicalDaysInYear(_year_).
          1. Let _daysLaterInYear_ be _daysInYear_ - _dayOfYear_.
          1. Let _daysAfterThursday_ be _thursday_ - _dayOfWeek_.
          1. If _daysLaterInYear_ &lt; _daysAfterThursday_, then
            1. Return Year-Week Record { [[Week]]: 1, [[Year]]: _year_ + 1 }.
        1. Return Year-Week Record { [[Week]]: _week_, [[Year]]: _year_ }.
      </emu-alg>
      <emu-note>In the ISO 8601 week calendar, calendar week number 1 of a calendar year is the week including the first Thursday of that year (based on the principle that a week belongs to the same calendar year as the majority of its calendar days), which always includes January 4 and starts on the Monday on or immediately before then. Because of this, some calendar days of the first calendar week of a calendar year may be part of the _preceding_ [proleptic Gregorian] date calendar year, and some calendar days of the last calendar week of a calendar year may be part of the _following_ [proleptic Gregorian] date calendar year. See ISO 8601 for details.</emu-note>
      <emu-note>For example, week calendar year 2020 includes both 31 December 2019 (a Tuesday belonging to its calendar week 1) and 1 January 2021 (a Friday belonging to its calendar week 53).</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthcode" type="abstract operation">
      <h1>
        ISOMonthCode (
          _month_: an integer in the inclusive interval from 1 to 12,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the string month code for a month in the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _numberPart_ be ToZeroPaddedDecimalString(_month_, 2).
        1. Return the string-concatenation of *"M"* and _numberPart_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoresolvemonth" type="abstract operation">
      <h1>
        ISOResolveMonth (
          _fields_: a Calendar Fields Record,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It ensures that the [[Month]] field of _fields_, if ~unset~, is set to the integral Number value in the inclusive interval from 1 to 12 that corresponds to the [[MonthCode]] field of _fields_.
          It throws an exception if both fields are ~unset~, or if either field is invalid, or if the fields are inconsistent.
        </dd>
      </dl>
      <emu-alg>
        1. Let _month_ be _fields_.[[Month]].
        1. Let _monthCode_ be _fields_.[[MonthCode]].
        1. If _monthCode_ is ~unset~, then
          1. If _month_ is ~unset~, throw a *TypeError* exception.
          1. Return ~unused~.
        1. Assert: _monthCode_ is a String.
        1. NOTE: The ISO 8601 calendar does not include leap months.
        1. If the length of _monthCode_ is not 3, throw a *RangeError* exception.
        1. If the first code unit of _monthCode_ is not 0x004D (LATIN CAPITAL LETTER M), throw a *RangeError* exception.
        1. Let _monthCodeDigits_ be the substring of _monthCode_ from 1.
        1. If ParseText(StringToCodePoints(_monthCodeDigits_), |DateMonth|) is a List of errors, throw a *RangeError* exception.
        1. Let _monthCodeInteger_ be ℝ(StringToNumber(_monthCodeDigits_)).
        1. Assert: SameValue(_monthCode_, ISOMonthCode(_monthCodeInteger_)) is *true*.
        1. If _month_ is not ~unset~ and _month_ ≠ _monthCodeInteger_, throw a *RangeError* exception.
        1. Set _fields_.[[Month]] to _monthCodeInteger_.
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatefromfields" type="abstract operation">
      <h1>
        ISODateFromFields (
          _fields_: a Calendar Fields Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs the conversion operation of a Calendar Fields Record to an ISO Date Record for the ISO 8601 calendar, as CalendarDateFromFields does for other calendars.</dd>
      </dl>
      <emu-alg>
        1. Let _year_ be _fields_.[[Year]].
        1. Let _month_ be _fields_.[[Month]].
        1. Let _day_ be _fields_.[[Day]].
        1. Assert: None of _year_, _month_, and _day_ are ~unset~.
        1. Let _result_ be ? RegulateISODate(_year_, _month_, _day_, _overflow_).
        1. If ISODateWithinLimits(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *false*, throw a *RangeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoyearmonthfromfields" type="abstract operation">
      <h1>
        ISOYearMonthFromFields (
          _fields_: a Calendar Fields Record,
          _overflow_: either *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs the conversion operation of a Calendar Fields Record to an ISO Date Record for the ISO 8601 calendar in the context of Temporal.PlainYearMonth, as CalendarYearMonthFromFields does for other calendars.</dd>
      </dl>
      <emu-alg>
        1. Let _year_ be _fields_.[[Year]].
        1. Let _month_ be _fields_.[[Month]].
        1. Assert: _year_ and _month_ are not ~unset~.
        1. Let _result_ be ? RegulateISOYearMonth(_year_, _month_, _overflow_).
        1. If ISOYearMonthWithinLimits(_result_.[[Year]], _result_.[[Month]]) is *false*, throw a *RangeError* exception.
        1. Return ISO Date Record {
            [[Year]]: _result_.[[Year]],
            [[Month]]: _result_.[[Month]],
            [[Day]]: 1
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthdayfromfields" type="abstract operation">
      <h1>
        ISOMonthDayFromFields (
          _fields_: a Calendar Fields Record,
          _overflow_: either *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs the conversion operation of a Calendar Fields Record to an ISO Date Record for the ISO 8601 calendar in the context of Temporal.PlainMonthDay, as CalendarMonthDayFromFields does for other calendars.</dd>
      </dl>
      <emu-alg>
        1. Let _month_ be _fields_.[[Month]].
        1. Let _day_ be _fields_.[[Day]].
        1. Assert: _month_ and _day_ are not ~unset~.
        1. Let _year_ be _fields_.[[Year]].
        1. Let _referenceISOYear_ be 1972 (the first ISO 8601 leap year after the epoch).
        1. If _year_ is ~unset~, then
          1. Let _result_ be ? RegulateISODate(_referenceISOYear_, _month_, _day_, _overflow_).
        1. Else,
          1. Let _result_ be ? RegulateISODate(_year_, _month_, _day_, _overflow_).
        1. Return ISO Date Record {
            [[Year]]: _referenceISOYear_,
            [[Month]]: _result_.[[Month]],
            [[Day]]: _result_.[[Day]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isofieldkeystoignore" type="abstract operation">
      <h1>
        ISOFieldKeysToIgnore (
          _keys_: a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>,
        ): a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the ISO 8601 calendar.
        </dd>
      </dl>
      <emu-alg>
        1. Let _ignoredKeys_ be an empty List.
        1. For each element _key_ of _keys_, do
          1. Append _key_ to _ignoredKeys_.
          1. If _key_ is ~month~, append ~month-code~ to _ignoredKeys_.
          1. Else if _key_ is ~month-code~, append ~month~ to _ignoredKeys_.
        1. NOTE: While _ignoredKeys_ can have duplicate elements, this is not intended to be meaningful. This specification only checks whether particular keys are or are not members of the list.
        1. Return _ignoredKeys_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofyear" type="abstract operation">
      <h1>
        ToISODayOfYear (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the ISO 8601 <em>calendar day of year</em> of a calendar day, which is its 1-based ordinal number within its ISO 8601 calendar year.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _epochDays_ be ISODateToEpochDays(_year_, _month_ - 1, _day_).
        1. Return EpochTimeToDayInYear(EpochDaysToEpochMs(_epochDays_, 0)) + 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofweek" type="abstract operation">
      <h1>
        ToISODayOfWeek (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the ISO 8601 <em>calendar day of week</em> of a calendar day, which is its 1-based ordinal position within the sequence of week calendar days that starts with Monday at 1 and ends with Sunday at 7.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _epochDays_ be ISODateToEpochDays(_year_, _month_ - 1, _day_).
        1. Let _dayOfWeek_ be EpochTimeToWeekDay(EpochDaysToEpochMs(_epochDays_, 0)).
        1. If _dayOfWeek_ = 0, return 7.
        1. Return _dayOfWeek_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatetoiso" type="implementation-defined abstract operation">
      <h1>
        CalendarDateToISO (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _fields_: a Calendar Fields Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to convert _fields_, which represents a date or year and month or month and day in the built-in calendar identified by _calendar_, to a corresponding representative date in the ISO 8601 calendar, subject to processing specified by _overflow_.
          For *"reject"*, values that do not form a valid date cause an exception to be thrown, as described below.
          For *"constrain"*, values that do not form a valid date are clamped to the correct range.
          It then returns an ISO Date Record with the corresponding ISO 8601 date.
        </dd>
      </dl>
      <p>Clamping an invalid date to the correct range when _overflow_ is *"constrain"* is a behaviour specific to each built-in calendar, but all built-in calendars follow this guideline:</p>
      <ul>
        <li>Pick the closest day in the same month. If there are two equally-close dates in that month, pick the later one.</li>
        <li>If the month is a leap month that doesn't exist in the year, pick another date according to the cultural conventions of that calendar's users. Usually this will result in the same day in the month before or after where that month would normally fall in a leap year.</li>
        <li>Otherwise, pick the closest date that is still in the same year. If there are two equally-close dates in that year, pick the later one.</li>
        <li>If the entire year doesn't exist, pick the closest date in a different year. If there are two equally-close dates, pick the later one.</li>
      </ul>
      <p>
        Like RegulateISODate, the operation throws a *RangeError* exception if _overflow_ is *"reject"* and the date described by _fields_ does not exist.
        It also throws a *RangeError* exception if the date described by _fields_ is outside the range allowed by ISODateWithinLimits.
      </p>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthdaytoisoreferencedate" type="implementation-defined abstract operation">
      <h1>
        CalendarMonthDayToISOReferenceDate (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _fields_: a Calendar Fields Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to convert _fields_, which represents a calendar date without a year (i.e., month code and day pair, or equivalent) in the built-in calendar identified by _calendar_, to a corresponding reference date in the ISO 8601 calendar as described below, subject to processing specified by _overflow_.
          For *"reject"*, values that do not form a valid date cause an exception to be thrown.
          For *"constrain"*, values that do not form a valid date are clamped to the correct range as in CalendarDateToISO.
          It then returns a Record representing the reference ISO 8601 date.
        </dd>
      </dl>
      <p>
        The fields of the returned Record represent a reference date in the ISO 8601 calendar that, when converted to the built-in calendar identified by _calendar_, corresponds to the month code and day of _fields_ in an arbitrary but deterministically chosen reference year.
        The reference date is the latest ISO 8601 date corresponding to the calendar date, that is also earlier than or equal to the ISO 8601 date December 31, 1972.
        If that calendar date never occurs on or before the ISO 8601 date December 31, 1972, then the reference date is the earliest ISO 8601 date corresponding to that calendar date.
        The reference year is almost always 1972 (the first ISO 8601 leap year after the epoch), with exceptions for calendars where some dates (e.g. leap days or days in leap months) didn't occur during that ISO 8601 year. For example, Hebrew calendar leap month Adar I was a part of calendar years 5730 and 5733 (respectively overlapping ISO 8601 February/March 1970 and February/March 1973), but did not occur between them.
      </p>
      <p>
        Like RegulateISODate, the operation throws a *RangeError* exception if _overflow_ is *"reject"* and the month and day described by _fields_ does not exist.
        For example, when _calendar_ is *"gregory"* and _overflow_ is *"reject"*, _fields_ values of { [[MonthCode]]: *"M01"*, [[Day]]: 32 } and { [[Year]]: 2001, [[Month]]: 2, [[Day]]: 29 } would both cause a *RangeError* to be thrown.
        In the latter case, even though February 29 is a date in leap years of the Gregorian calendar, 2001 was not a leap year and a month code cannot be determined from the nonexistent date 2001-02-29 with the specified month index.
      </p>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateaddition" type="implementation-defined abstract operation">
      <h1>
        CalendarDateAddition (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: an ISO Date Record,
          _duration_: a Date Duration Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to add _duration_ to _date_ in the context of the calendar represented by _calendar_ and returns the corresponding day, month and year of the result in the ISO 8601 calendar values as an ISO Date Record.
          It may throw a *RangeError* exception if _overflow_ is *"reject"* and the resulting month or day would need to be clamped in order to form a valid date in _calendar_, or if the date resulting from the addition is outside the range allowed by ISODateTimeWithinLimits.
        </dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatedifference" type="implementation-defined abstract operation">
      <h1>
        CalendarDateDifference (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _one_: an ISO Date Record,
          _two_: an ISO Date Record,
          _largestUnit_: *"year"*, *"month"*, *"week"*, or *"day"*,
        ): a Date Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the difference between the two dates _one_ and _two_ in the context of the calendar represented by _calendar_ and returns the corresponding duration.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarisotodate" type="implementation-defined abstract operation">
      <h1>
        CalendarISOToDate (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _isoDate_: an ISO Date Record,
        ): a Calendar Date Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the the date corresponding to _isoDate_ in the context of the calendar represented by _calendar_ and returns a Calendar Date Record representing that calendar date, with its fields filled in according to their descriptions.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarextrafields" type="implementation-defined abstract operation">
      <h1>
        CalendarExtraFields (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _type_: ~date~, ~year-month~, ~month-day~, or a List of property keys,
        ): a List of property keys
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It characterizes calendar-specific fields that are relevant for values of the provided _type_ in the built-in calendar identified by _calendar_ (inferring the type when _type_ is a List by interpreting its elements as field names). For example, « *"era"*, *"eraYear"* » is returned when _calendar_ is *"gregory"* or *"japanese"* and _type_ is ~date~ or ~year-month~ or a List containing *"year"*.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarfieldkeystoignore" type="implementation-defined abstract operation">
      <h1>
        CalendarFieldKeysToIgnore (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _keys_: a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>,
        ): a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the given _calendar_.
          A field always invalidates at least itself.
        </dd>
      </dl>
      <p>This operation is relevant for calendars which accept fields other than the standard set of ISO 8601 calendar fields, in order to implement the Temporal objects' `with()` methods in such a way that the result is free of ambiguity or conflicts.</p>
      <p>
        For example, given a _calendar_ that uses eras, such as *"gregory"*, a key in _keys_ being any one of ~year~, ~era~, or ~era-year~ would exclude all three.
        Passing any one of the three to a `with()` method might conflict with either of the other two properties on the receiver object, so those properties of the receiver object should be ignored.
        Given this, in addition to the ISO 8601 mutual exclusion of ~month~ and ~month-code~ as in ISOFieldKeysToIgnore, a possible implementation might produce the following results when _calendar_ is *"gregory"*:
      </p>
      <emu-table id="table-calendarfieldkeystoignore-example">
        <emu-caption>Example results of CalendarFieldKeysToIgnore</emu-caption>
        <table>
          <thead>
            <tr>
              <th>_keys_</th>
              <th>Returned List</th>
            </tr>
          </thead>
          <tr>
            <td>« ~era~ »</td>
            <td>« ~era~, ~era-year~, ~year~ »</td>
          </tr>
          <tr>
            <td>« ~era-year~ »</td>
            <td>« ~era~, ~era-year~, ~year~ »</td>
          </tr>
          <tr>
            <td>« ~year~ »</td>
            <td>« ~era~, ~era-year~, ~year~ »</td>
          </tr>
          <tr>
            <td>« ~month~ »</td>
            <td>« ~month~, ~month-code~ »</td>
          </tr>
          <tr>
            <td>« ~month-code~ »</td>
            <td>« ~month~, ~month-code~ »</td>
          </tr>
          <tr>
            <td>« ~day~ »</td>
            <td>« ~day~ »</td>
          </tr>
          <tr>
            <td>« ~year~, ~month~, ~day~ »</td>
            <td>« ~era~, ~era-year~, ~year~, ~month~, ~month-code~, ~day~ »</td>
          </tr>
        </table>
      </emu-table>
      <emu-note>
        In a _calendar_ such as *"japanese"* where eras do not start and end at year and/or month boundaries, note that the returned List should contain ~era~ and ~era-year~ if _keys_ contains ~day~, ~month~, or ~month-code~ (not only if it contains ~era~, ~era-year~, or ~year~, as in the example above) because it's possible for changing the day or month to cause a conflict with the era.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarresolvefields" type="implementation-defined abstract operation">
      <h1>
        CalendarResolveFields (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _fields_: a Calendar Fields Record,
          _type_: ~date~, ~year-month~, or ~month-day~,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to validate that _fields_ (which describes a date or partial date in the built-in calendar identified by _calendar_) is sufficiently complete to satisfy _type_ and not internally inconsistent, and mutates _fields_ into acceptable input for <emu-xref href="#sec-temporal-calendardatetoiso" title></emu-xref> or <emu-xref href="#sec-temporal-calendarmonthdaytoisoreferencedate" title></emu-xref> by merging data that can be represented in multiple forms into standard properties and removing redundant properties (for example, merging *"month"* and *"monthCode"* into *"month"* and merging *"era"* and *"eraYear"* into *"year"*).
        </dd>
      </dl>
      <p>The operation throws a *TypeError* exception if the fields of _fields_ are internally inconsistent within the calendar or insufficient to identify a unique instance of _type_ in the calendar. For example:</p>
      <ul>
        <li>If _type_ is ~date~ or ~month-day~ and ~day~ in the calendar has an interpretation analogous to ISO 8601 and _fields_.[[Day]] is ~unset~.</li>
        <li>If ~month~ and ~month-code~ in the calendar have interpretations analogous to ISO 8601 and either the corresponding values for both are ~unset~ or neither value is ~unset~ but they do not identify the same month.</li>
        <li>If _type_ is ~month-day~ and _fields_.[[MonthCode]] is ~unset~ and a year cannot be determined from _fields_.</li>
        <li>If _type_ is ~date~ or ~year-month~ and the calendar supports the usual partitioning of years into eras with their own year counting as represented by ~year~, ~era~, and ~era-year~ (as in the Gregorian or traditional Japanese calendars) and any of the following cases apply:<ul>
          <li>Each of _fields_.[[Year]], _fields_.[[Era]], and _fields_.[[EraYear]] is ~unset~.</li>
          <li>_fields_.[[Era]] is ~unset~ but _fields_.[[EraYear]] is not.</li>
          <li>_fields_.[[EraYear]] is ~unset~ but _fields_.[[Era]] is not.</li>
          <li>None of the three values are ~unset~ but _fields_.[[Era]] and _fields_.[[EraYear]] do not together identify the same year as _fields_.[[Year]].</li>
        </ul></li>
      </ul>
      <emu-note>
        When _type_ is ~month-day~ and _fields_.[[Month]] is provided without _fields_.[[MonthCode]], it is recommended that all built-in calendars other than the ISO 8601 calendar require a disambiguating year (e.g., either _fields_.[[Year]] or _fields_.[[Era]] and _fields_.[[EraYear]]), including those that always use exactly the same months as the ISO 8601 calendar (which receives special handling in this specification as a default calendar that is permanently stable for automated processing).
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>
