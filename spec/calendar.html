<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-calendar-objects">
  <h1>Temporal.Calendar Objects</h1>
  <p>A Temporal.Calendar object is an Object representing a calendar.</p>

  <emu-clause id="sec-calendar-types">
    <h1>Calendar Types</h1>

    <emu-note type="editor">
      <p>
        This section shares some text with the <a href="https://tc39.es/proposal-intl-enumeration/">Intl.Enumeration proposal</a>.
      </p>
    </emu-note>

    <p>
      At a minimum, ECMAScript implementations must support a built-in calendar named *"iso8601"*, representing the ISO 8601 calendar.
      In addition, implementations may support any number of other built-in calendars corresponding with those of the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
    </p>
    <p>
      ECMAScript implementations identify built-in calendars using a <dfn variants="calendar types">calendar type</dfn> as defined by <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Elements">Unicode Technical Standard #35, Part 4, Section 2</a>.
      Their canonical form is a string containing only Unicode Basic Latin lowercase letters (U+0061 LATIN SMALL LETTER A through U+007A LATIN SMALL LETTER Z, inclusive) and/or digits (U+0030 DIGIT ZERO through U+0039 DIGIT NINE, inclusive), with zero or more medial hyphens (U+002D HYPHEN-MINUS).
    </p>
    <p>
      <emu-xref href="#sec-temporal-calendar-constructor">The `Temporal.Calendar` constructor</emu-xref>, when called with the name of a built-in calendar as the argument, will return a valid `Temporal.Calendar` object.
      When called with any other string, it will throw a *RangeError* exception.
    </p>

    <emu-clause id="sec-temporal-isbuiltincalendar" type="abstract operation">
      <h1>
        IsBuiltinCalendar (
          _id_: a String,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned value is *true* if _id_ is a calendar type denoting a built-in calendar, and *false* otherwise.</dd>
      </dl>
      <emu-alg>
        1. Let _calendars_ be AvailableCalendars().
        1. If _calendars_ contains the ASCII-lowercase of _id_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-availablecalendars" type="implementation-defined abstract operation">
      <h1>
        AvailableCalendars (
        ): a List of Strings
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Each element in the returned List represents a calendar type supported by the implementation.</dd>
      </dl>
      <emu-alg>
        1. Let _calendars_ be the List of String values representing calendar types supported by the implementation.
        1. Assert: _calendars_ contains *"iso8601"*.
        1. [declared="S"] Assert: _calendars_ does not contain any element _S_ for which the ASCII-lowercase of _S_ is not _S_.
        1. Assert: _calendars_ does not contain any element that does not identify a calendar type in the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
        1. Return SortStringListByCodeUnit(_calendars_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-calendar-abstract-ops">
    <h1>Abstract Operations for Temporal.Calendar Objects</h1>

    <emu-clause id="sec-temporal-createtemporalcalendar" type="abstract operation">
      <h1>
        CreateTemporalCalendar (
          _identifier_: a String,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.Calendar, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.Calendar instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsBuiltinCalendar(_identifier_) is *true*.
        1. If _newTarget_ is not provided, set _newTarget_ to %Temporal.Calendar%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.Calendar.prototype%"*, « [[InitializedTemporalCalendar]], [[Identifier]] »).
        1. Set _object_.[[Identifier]] to the ASCII-lowercase of _identifier_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getbuiltincalendar" aoid="GetBuiltinCalendar">
      <h1>GetBuiltinCalendar ( _id_ )</h1>
      <emu-alg>
        1. If IsBuiltinCalendar(_id_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalCalendar(_id_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-getiso8601calendar" aoid="GetISO8601Calendar">
      <h1>GetISO8601Calendar ( )</h1>
      <emu-alg>
        1. Return ! GetBuiltinCalendar(*"iso8601"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarfields" aoid="CalendarFields">
      <h1>CalendarFields ( _calendar_, _fieldNames_ )</h1>
      <p>
        The CalendarFields abstract operation transforms a List of String values _fieldNames_ into another List of String values by calling the `fields` method of the given _calendar_ Object, falling back to a default operation if not present.
      </p>
      <emu-alg>
        1. Let _fields_ be ? GetMethod(_calendar_, *"fields"*).
        1. If _fields_ is *undefined*, return _fieldNames_.
        1. Let _fieldsArray_ be ? Call(_fields_, _calendar_, « CreateArrayFromList(_fieldNames_) »).
        1. Return ? IterableToListOfType(_fieldsArray_, « String »).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmergefields" aoid="CalendarMergeFields">
      <h1>CalendarMergeFields ( _calendar_, _fields_, _additionalFields_ )</h1>
      <p>
        The CalendarMergeFields abstract operation merges the properties of two Objects _fields_ and _additionalFields_ by calling the `mergeFields` method of the given _calendar_ Object, falling back to a default operation if not present.
      </p>
      <emu-alg>
        1. Let _mergeFields_ be ? GetMethod(_calendar_, *"mergeFields"*).
        1. If _mergeFields_ is *undefined*, then
          1. Return ? DefaultMergeCalendarFields(_fields_, _additionalFields_).
        1. Let _result_ be ? Call(_mergeFields_, _calendar_, « _fields_, _additionalFields_ »).
        1. If Type(_result_) is not Object, throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateadd" aoid="CalendarDateAdd">
      <h1>CalendarDateAdd ( _calendar_, _date_, _duration_ [ , _options_ [ , _dateAdd_ ] ] )</h1>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Assert: Type(_options_) is Object or Undefined.
        1. If _dateAdd_ is not present, set _dateAdd_ to ? GetMethod(_calendar_, *"dateAdd"*).
        1. Let _addedDate_ be ? Call(_dateAdd_, _calendar_, « _date_, _duration_, _options_ »).
        1. Perform ? RequireInternalSlot(_addedDate_, [[InitializedTemporalDate]]).
        1. Return _addedDate_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateuntil" aoid="CalendarDateUntil">
      <h1>CalendarDateUntil ( _calendar_, _one_, _two_, _options_ [ , _dateUntil_ ] )</h1>
      <emu-alg>
        1. Assert: Type(_calendar_) is Object.
        1. If _dateUntil_ is not present, set _dateUntil_ to ? GetMethod(_calendar_, *"dateUntil"*).
        1. Let _duration_ be ? Call(_dateUntil_, _calendar_, « _one_, _two_, _options_ »).
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryear" type="abstract operation">
      <h1>
        CalendarYear (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `year()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"year"*, « _dateLike_ »).
        1. Return ? ToIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonth" type="abstract operation">
      <h1>
        CalendarMonth (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `month()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"month"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthcode" type="abstract operation">
      <h1>
        CalendarMonthCode (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
        ): either a normal completion containing a String, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `monthCode()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"monthCode"*, « _dateLike_ »).
        1. If _result_ is *undefined*, throw a *RangeError* exception.
        1. Return ? ToString(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarday" type="abstract operation">
      <h1>
        CalendarDay (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainMonthDay,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `day()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"day"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofweek" type="abstract operation">
      <h1>
        CalendarDayOfWeek (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `dayOfWeek()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"dayOfWeek"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofyear" type="abstract operation">
      <h1>
        CalendarDayOfYear (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `dayOfYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"dayOfYear"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarweekofyear" type="abstract operation">
      <h1>
        CalendarWeekOfYear (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `weekOfYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"weekOfYear"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryearofweek" type="abstract operation">
      <h1>
        CalendarYearOfWeek (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `yearOfWeek()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"yearOfWeek"*, « _dateLike_ »).
        1. Return ? ToIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinweek" type="abstract operation">
      <h1>
        CalendarDaysInWeek (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `daysInWeek()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"daysInWeek"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinmonth" type="abstract operation">
      <h1>
        CalendarDaysInMonth (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `daysInMonth()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"daysInMonth"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinyear" type="abstract operation">
      <h1>
        CalendarDaysInYear (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `daysInYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"daysInYear"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthsinyear" type="abstract operation">
      <h1>
        CalendarMonthsInYear (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `monthsInYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"monthsInYear"*, « _dateLike_ »).
        1. Return ? ToPositiveIntegerWithTruncation(_result_).
      </emu-alg>
      <emu-note>ToPositiveIntegerWithTruncation(*undefined*) will throw a *RangeError*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarinleapyear" type="abstract operation">
      <h1>
        CalendarInLeapYear (
          _calendar_: an Object,
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing a Boolean, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `inLeapYear()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ? Invoke(_calendar_, *"inLeapYear"*, « _dateLike_ »).
        1. Return ToBoolean(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendar" aoid="ToTemporalCalendar">
      <h1>ToTemporalCalendar ( _temporalCalendarLike_ )</h1>
      <emu-alg>
        1. If Type(_temporalCalendarLike_) is Object, then
          1. If _temporalCalendarLike_ has an [[InitializedTemporalCalendar]] internal slot, then
            1. Return _temporalCalendarLike_.
          1. If _temporalCalendarLike_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalTime]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _temporalCalendarLike_.[[Calendar]].
          1. If _temporalCalendarLike_ has an [[InitializedTemporalTimeZone]] internal slot, throw a *RangeError* exception.
          1. If ? HasProperty(_temporalCalendarLike_, *"calendar"*) is *false*, return _temporalCalendarLike_.
          1. Set _temporalCalendarLike_ to ? Get(_temporalCalendarLike_, *"calendar"*).
          1. If Type(_temporalCalendarLike_) is Object, then
            1. If _temporalCalendarLike_ has an [[InitializedTemporalTimeZone]] internal slot, throw a *RangeError* exception.
            1. If ? HasProperty(_temporalCalendarLike_, *"calendar"*) is *false*, return _temporalCalendarLike_.
        1. Let _identifier_ be ? ToString(_temporalCalendarLike_).
        1. Set _identifier_ to ? ParseTemporalCalendarString(_identifier_).
        1. If IsBuiltinCalendar(_identifier_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalCalendar(_identifier_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendarwithisodefault" aoid="ToTemporalCalendarWithISODefault">
      <h1>ToTemporalCalendarWithISODefault ( _temporalCalendarLike_ )</h1>
      <p>
        The abstract operation ToTemporalCalendarWithISODefault converts a value into an Object suitable for use as a calendar.
        If the value is *undefined*, the ISO 8601 calendar is returned.
      </p>
      <emu-alg>
        1. If _temporalCalendarLike_ is *undefined*, then
          1. Return ! GetISO8601Calendar().
        1. Return ? ToTemporalCalendar(_temporalCalendarLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-gettemporalcalendarwithisodefault" aoid="GetTemporalCalendarWithISODefault">
      <h1>GetTemporalCalendarWithISODefault ( _item_ )</h1>
      <p>
        The abstract operation GetTemporalCalendarWithISODefault looks for a `calendar` property on the given _item_ and converts its value to an Object suitable for use as a calendar.
        If no such property is present, the ISO 8601 calendar is returned.
      </p>
      <emu-alg>
        1. If _item_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalTime]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return _item_.[[Calendar]].
        1. Let _calendarLike_ be ? Get(_item_, *"calendar"*).
        1. Return ? ToTemporalCalendarWithISODefault(_calendarLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatefromfields" type="abstract operation">
      <h1>
        CalendarDateFromFields (
          _calendar_: an Object,
          _fields_: an Object,
          optional _options_: an Object or *undefined*,
        ): either a normal completion containing a `Temporal.PlainDate` or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `dateFromFields()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _date_ be ? Invoke(_calendar_, *"dateFromFields"*, « _fields_, _options_ »).
        1. Perform ? RequireInternalSlot(_date_, [[InitializedTemporalDate]]).
        1. Return _date_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryearmonthfromfields" type="abstract operation">
      <h1>
        CalendarYearMonthFromFields (
          _calendar_: an Object,
          _fields_: an Object,
          optional _options_: an Object or *undefined*,
        ): either a normal completion containing a `Temporal.PlainYearMonth` or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `yearMonthFromFields()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _yearMonth_ be ? Invoke(_calendar_, *"yearMonthFromFields"*, « _fields_, _options_ »).
        1. Perform ? RequireInternalSlot(_yearMonth_, [[InitializedTemporalYearMonth]]).
        1. Return _yearMonth_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthdayfromfields" type="abstract operation">
      <h1>
        CalendarMonthDayFromFields (
          _calendar_: an Object,
          _fields_: an Object,
          optional _options_: an Object or *undefined*,
        ): either a normal completion containing a `Temporal.PlainMonthDay` or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It calls the given _calendar_'s `monthDayFromFields()` method and validates the result.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _monthDay_ be ? Invoke(_calendar_, *"monthDayFromFields"*, « _fields_, _options_ »).
        1. Perform ? RequireInternalSlot(_monthDay_, [[InitializedTemporalMonthDay]]).
        1. Return _monthDay_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-maybeformatcalendarannotation" type="abstract operation">
      <h1>
        MaybeFormatCalendarAnnotation (
          _calendarObject_: an Object or *undefined*,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): either a normal completion containing a String, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
          Depending on the given _calendarObject_ and the value of _showCalendar_, the string may be empty if no calendar annotation need be included.
          This operation may invoke an observable ToString operation on _calendarObject_, but not if _showCalendar_ is *"never"*.
        </dd>
      </dl>
      <emu-alg>
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. Assert: Type(_calendarObject_) is Object.
        1. Let _calendarID_ be ? ToString(_calendarObject_).
        1. Return FormatCalendarAnnotation(_calendarID_, _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatcalendarannotation" type="abstract operation">
      <h1>
        FormatCalendarAnnotation (
          _id_: a String,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
          Depending on the given _id_ and value of _showCalendar_, the string may be empty if no calendar annotation need be included.
        </dd>
      </dl>
      <emu-alg>
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. If _showCalendar_ is *"auto"* and _id_ is *"iso8601"*, return the empty String.
        1. If _showCalendar_ is *"critical"*, let _flag_ be *"!"*; else, let flag be the empty String.
        1. Return the string-concatenation of *"["*, _flag_, *"u-ca="*, _id_, and *"]"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarequals" aoid="CalendarEquals">
      <h1>CalendarEquals ( _one_, _two_ )</h1>
      <p>
        The abstract operation CalendarEquals takes two arguments _one_ and _two_, which must be Objects.
        It returns *true* if its arguments represent the same calendar.
        It performs the following steps:
      </p>
      <emu-alg>
        1. If _one_ and _two_ are the same Object value, return *true*.
        1. Let _calendarOne_ be ? ToString(_one_).
        1. Let _calendarTwo_ be ? ToString(_two_).
        1. If _calendarOne_ is _calendarTwo_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-consolidatecalendars" aoid="ConsolidateCalendars">
      <h1>ConsolidateCalendars ( _one_, _two_ )</h1>
      <p>
        The abstract operation ConsolidateCalendars takes two arguments _one_ and _two_, which must be Objects.
        It returns the calendar that should take priority when combining two Temporal objects with different calendars, or throws an exception if the calendars cannot be combined.
        It performs the following steps:
      </p>
      <emu-alg>
        1. If _one_ and _two_ are the same Object value, return _two_.
        1. Let _calendarOne_ be ? ToString(_one_).
        1. Let _calendarTwo_ be ? ToString(_two_).
        1. If _calendarOne_ is _calendarTwo_, return _two_.
        1. If _calendarOne_ is *"iso8601"*, return _two_.
        1. If _calendarTwo_ is *"iso8601"*, return _one_.
        1. Throw a *RangeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodaysinmonth" type="abstract operation">
      <h1>
        ISODaysInMonth (
          _year_: an integer,
          _month_: an integer in the inclusive interval from 1 to 12,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the number of days in the given year and month in the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. If _month_ is 1, 3, 5, 7, 8, 10, or 12, return 31.
        1. If _month_ is 4, 6, 9, or 11, return 30.
        1. Assert: _month_ is 2.
        1. Return 28 + ℝ(InLeapYear(TimeFromYear(𝔽(_year_)))).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisoweekofyear" type="abstract operation">
      <h1>
        ToISOWeekOfYear (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): a Year-Week Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines where a calendar day falls in the ISO 8601 week calendar and calculates its <em>calendar week of year</em>, which is the 1-based ordinal number of its calendar week within the corresponding <em>week calendar year</em> (which may differ from _year_ by up to 1 in either direction).</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _wednesday_ be 3.
        1. Let _thursday_ be 4.
        1. Let _friday_ be 5.
        1. Let _saturday_ be 6.
        1. Let _daysInWeek_ be 7.
        1. Let _maxWeekNumber_ be 53.
        1. Let _dayOfYear_ be ToISODayOfYear(_year_, _month_, _day_).
        1. Let _dayOfWeek_ be ToISODayOfWeek(_year_, _month_, _day_).
        1. Let _week_ be floor((_dayOfYear_ + _daysInWeek_ - _dayOfWeek_ + _wednesday_ ) / _daysInWeek_).
        1. If _week_ &lt; 1, then
          1. NOTE: This is the last week of the previous year.
          1. Let _dayOfJan1st_ be ToISODayOfWeek(_year_, 1, 1).
          1. If _dayOfJan1st_ is _friday_, then
            1. Return the Year-Week Record { [[Week]]: _maxWeekNumber_, [[Year]]: _year_ - 1 }.
          1. If _dayOfJan1st_ is _saturday_, and InLeapYear(TimeFromYear(𝔽(_year_ - 1))) is *1*<sub>𝔽</sub>, then
            1. Return the Year-Week Record { [[Week]]: _maxWeekNumber_. [[Year]]: _year_ - 1 }.
          1. Return the Year-Week Record { [[Week]]: _maxWeekNumber_ - 1, [[Year]]: _year_ - 1 }.
        1. If _week_ is _maxWeekNumber_, then
          1. Let _daysInYear_ be DaysInYear(𝔽(_year_)).
          1. Let _daysLaterInYear_ be _daysInYear_ - _dayOfYear_.
          1. Let _daysAfterThursday_ be _thursday_ - _dayOfWeek_.
          1. If _daysLaterInYear_ &lt; _daysAfterThursday_, then
            1. Return the Year-Week Record { [[Week]]: 1, [[Year]]: _year_ + 1 }.
        1. Return the Year-Week Record { [[Week]]: _week_, [[Year]]: _year_ }.
      </emu-alg>
      <emu-note>In the ISO 8601 week calendar, calendar week number 1 of a calendar year is the week including the first Thursday of that year (based on the principle that a week belongs to the same calendar year as the majority of its calendar days), which always includes January 4 and starts on the Monday on or immediately before then. Because of this, some calendar days of the first calendar week of a calendar year may be part of the _preceding_ [proleptic Gregorian] date calendar year, and some calendar days of the last calendar week of a calendar year may be part of the _following_ [proleptic Gregorian] date calendar year. See ISO 8601 for details.</emu-note>
      <emu-note>For example, week calendar year 2020 includes both 31 December 2019 (a Tuesday belonging to its calendar week 1) and 1 January 2021 (a Friday belonging to its calendar week 53).</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthcode" type="abstract operation">
      <h1>
        ISOMonthCode (
          _month_: an integer in the inclusive interval from 1 to 12,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the string month code for a month in the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _numberPart_ be ToZeroPaddedDecimalString(_month_, 2).
        1. Return the string-concatenation of *"M"* and _numberPart_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-resolveisomonth" aoid="ResolveISOMonth">
      <h1>ResolveISOMonth ( _fields_ )</h1>
      <p>
        The abstract operation ResolveISOMonth merges the `month` and `monthCode` properties of the given _fields_ Object into an integer month, and validates that they match.
        It returns the integer month.
      </p>
      <emu-alg>
        1. Assert: _fields_ is an ordinary object with no more and no less than the own data properties listed in <emu-xref href="#table-temporal-field-requirements"></emu-xref>.
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Assert: _month_ is *undefined* or _month_ is a Number.
        1. Let _monthCode_ be ! Get(_fields_, *"monthCode"*).
        1. If _monthCode_ is *undefined*, then
          1. If _month_ is *undefined*, throw a *TypeError* exception.
          1. Return ℝ(_month_).
        1. Assert: Type(_monthCode_) is String.
        1. If the length of _monthCode_ is not 3, throw a *RangeError* exception.
        1. If the first code unit of _monthCode_ is not 0x004D (LATIN CAPITAL LETTER M), throw a *RangeError* exception.
        1. Let _monthCodeDigits_ be the substring of _monthCode_ from 1.
        1. If ParseText(StringToCodePoints(_monthCodeDigits_), |DateMonth|) is a List of errors, throw a *RangeError* exception.
        1. Let _monthCodeNumber_ be ! ToIntegerOrInfinity(_monthCodeDigits_).
        1. Assert: SameValue(_monthCode_, ISOMonthCode(_monthCodeNumber_)) is *true*.
        1. If _month_ is not *undefined* and SameValue(_month_, _monthCodeNumber_) is *false*, throw a *RangeError* exception.
        1. Return _monthCodeNumber_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatefromfields" aoid="ISODateFromFields">
      <h1>ISODateFromFields ( _fields_, _options_ )</h1>
      <p>
        The ISODateFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.prototype.dateFromFields` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"day"*, *"month"*, *"monthCode"*, *"year"* », « *"year"*, *"day"* »).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. Assert: Type(_year_) is Number.
        1. Let _month_ be ? ResolveISOMonth(_fields_).
        1. Let _day_ be ! Get(_fields_, *"day"*).
        1. Assert: Type(_day_) is Number.
        1. Return ? RegulateISODate(ℝ(_year_), _month_, ℝ(_day_), _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoyearmonthfromfields" aoid="ISOYearMonthFromFields">
      <h1>ISOYearMonthFromFields ( _fields_, _options_ )</h1>
      <p>
        The ISOYearMonthFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.prototype.yearMonthFromFields` method for the ISO 8601 calendar.
        It returns a Record with three fields ([[Year]], [[Month]], and [[ReferenceISODay]]). All are integers.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"month"*, *"monthCode"*, *"year"* », « *"year"* »).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. Assert: Type(_year_) is Number.
        1. Let _month_ be ? ResolveISOMonth(_fields_).
        1. Let _result_ be ? RegulateISOYearMonth(ℝ(_year_), _month_, _overflow_).
        1. Return the Record {
            [[Year]]: _result_.[[Year]],
            [[Month]]: _result_.[[Month]],
            [[ReferenceISODay]]: 1
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthdayfromfields" aoid="ISOMonthDayFromFields">
      <h1>ISOMonthDayFromFields ( _fields_, _options_ )</h1>
      <p>
        The ISOMonthDayFromFields abstract operation implements the calendar-specific logic in the `Temporal.Calendar.prototype.monthDayFromFields` method for the ISO 8601 calendar.
      </p>
      <emu-alg>
        1. Assert: Type(_fields_) is Object.
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, « *"day"*, *"month"*, *"monthCode"*, *"year"* », « *"day"* »).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Let _monthCode_ be ! Get(_fields_, *"monthCode"*).
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. If _month_ is not *undefined*, and _monthCode_ and _year_ are both *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _month_ to ? ResolveISOMonth(_fields_).
        1. Let _day_ be ! Get(_fields_, *"day"*).
        1. Assert: Type(_day_) is Number.
        1. Let _referenceISOYear_ be 1972 (the first leap year after the Unix epoch).
        1. If _monthCode_ is *undefined*, then
          1. Assert: Type(_year_) is Number.
          1. Let _result_ be ? RegulateISODate(ℝ(_year_), _month_, ℝ(_day_), _overflow_).
        1. Else,
          1. Let _result_ be ? RegulateISODate(_referenceISOYear_, _month_, ℝ(_day_), _overflow_).
        1. Return the Record {
            [[Month]]: _result_.[[Month]],
            [[Day]]: _result_.[[Day]],
            [[ReferenceISOYear]]: _referenceISOYear_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-defaultmergecalendarfields" type="abstract operation">
      <h1>
        DefaultMergeCalendarFields (
          _fields_: an Object,
          _additionalFields_: an Object,
        ): either a normal completion containing an Object or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It implements the default logic for the `Temporal.Calendar.prototype.mergeFields` method, which is used for the ISO 8601 calendar and as a fallback if the method is not present on a calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _merged_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ? CopyDataProperties(_merged_, _fields_, « », « *undefined* »).
        1. Let _additionalFieldsCopy_ be OrdinaryObjectCreate(*null*).
        1. Perform ? CopyDataProperties(_additionalFieldsCopy_, _additionalFields_, « », « *undefined* »).
        1. NOTE: Every property of _additionalFieldsCopy_ is a data property with non-*undefined* value, but some property keys may be Symbols.
        1. If ! _additionalFieldsCopy_.[[OwnPropertyKeys]]() contains *"month"* or *"monthCode"*, then
          1. Perform ! DeletePropertyOrThrow(_merged_, *"month"*).
          1. Perform ! DeletePropertyOrThrow(_merged_, *"monthCode"*).
        1. Perform ? CopyDataProperties(_merged_, _additionalFieldsCopy_, « »).
        1. Return _merged_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofyear" type="abstract operation">
      <h1>
        ToISODayOfYear (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the ISO 8601 <em>calendar day of year</em> of a calendar day, which is its 1-based ordinal number within its ISO 8601 calendar year.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _epochDays_ be MakeDay(𝔽(year), 𝔽(month - 1), 𝔽(day)).
        1. Assert: _epochDays_ is finite.
        1. Return ℝ(DayWithinYear(MakeDate(_epochDays_, *+0*<sub>𝔽</sub>))) + 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofweek" type="abstract operation">
      <h1>
        ToISODayOfWeek (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the ISO 8601 <em>calendar day of week</em> of a calendar day, which is its 1-based ordinal position within the sequence of week calendar days that starts with Monday at 1 and ends with Sunday at 7.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _epochDays_ be MakeDay(𝔽(year), 𝔽(month - 1), 𝔽(day)).
        1. Assert: _epochDays_ is finite.
        1. Let _dayOfWeek_ be WeekDay(MakeDate(_epochDays_, *+0*<sub>𝔽</sub>)).
        1. If _dayOfWeek_ = *+0*<sub>𝔽</sub>, return 7.
        1. Return ℝ(_dayOfWeek_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-calendar-constructor">
    <h1>The Temporal.Calendar Constructor</h1>
    <p>The Temporal.Calendar constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.Calendar object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.Calendar behaviour must
        include a super call to the %Temporal.Calendar% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.calendar">
      <h1>Temporal.Calendar ( _id_ )</h1>
      <p>
        The `Temporal.Calendar` function performs the following steps when called:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _id_ to ? ToString(_id_).
        1. If IsBuiltinCalendar(_id_) is *false*, then
          1. Throw a *RangeError* exception.
        1. Return ? CreateTemporalCalendar(_id_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-calendar-constructor">
    <h1>Properties of the Temporal.Calendar Constructor</h1>
    <p>The Temporal.Calendar prototype:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-clause id="sec-temporal.calendar.prototype">
      <h1>Temporal.Calendar.prototype</h1>
      <p>The initial value of `Temporal.Calendar.prototype` is %Temporal.Calendar.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.from">
      <h1>Temporal.Calendar.from ( _calendarLike_ )</h1>
      <p>
        The `Temporal.Calendar.from` function performs the following steps when called:
      </p>
      <emu-alg>
        1. Return ? ToTemporalCalendar(_calendarLike_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-calendar-prototype-object">
    <h1>Properties of the Temporal.Calendar Prototype Object</h1>

    <p>The Temporal.Calendar prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.Calendar instance and does not have a [[InitializedTemporalCalendar]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.calendar.prototype.constructor">
      <h1>Temporal.Calendar.prototype.constructor</h1>
      <p>The initial value of `Temporal.Calendar.prototype.constructor` is %Temporal.Calendar%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype-@@tostringtag">
      <h1>Temporal.Calendar.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.Calendar"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.calendar.prototype.id">
      <h1>get Temporal.Calendar.prototype.id</h1>
      <p>
        `Temporal.Calendar.prototype.id` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return _calendar_.[[Identifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.datefromfields">
      <h1>Temporal.Calendar.prototype.dateFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dateFromFields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _result_ be ? ISODateFromFields(_fields_, _options_).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.yearmonthfromfields">
      <h1>Temporal.Calendar.prototype.yearMonthFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.yearMonthFromFields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _result_ be ? ISOYearMonthFromFields(_fields_, _options_).
        1. Return ? CreateTemporalYearMonth(_result_.[[Year]], _result_.[[Month]], _calendar_, _result_.[[ReferenceISODay]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthdayfromfields">
      <h1>Temporal.Calendar.prototype.monthDayFromFields ( _fields_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.monthDayFromFields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_fields_) is not Object, throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _result_ be ? ISOMonthDayFromFields(_fields_, _options_).
        1. Return ? CreateTemporalMonthDay(_result_.[[Month]], _result_.[[Day]], _calendar_, _result_.[[ReferenceISOYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dateadd">
      <h1>Temporal.Calendar.prototype.dateAdd ( _date_, _duration_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dateAdd` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Set _date_ to ? ToTemporalDate(_date_).
        1. Set _duration_ to ? ToTemporalDuration(_duration_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _balanceResult_ be ? <emu-meta suppress-effects="user-code">BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"day"*)</emu-meta>.
        1. Let _result_ be ? AddISODate(_date_.[[ISOYear]], _date_.[[ISOMonth]], _date_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]], _overflow_).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dateuntil">
      <h1>Temporal.Calendar.prototype.dateUntil ( _one_, _two_ [ , _options_ ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dateUntil` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Set _one_ to ? ToTemporalDate(_one_).
        1. Set _two_ to ? ToTemporalDate(_two_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _largestUnit_ be ? GetTemporalUnit(_options_, *"largestUnit"*, ~date~, *"auto"*).
        1. If _largestUnit_ is *"auto"*, set _largestUnit_ to *"day"*.
        1. Let _result_ be DifferenceISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _largestUnit_).
        1. Return ! CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.year">
      <h1>Temporal.Calendar.prototype.year ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.year` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Assert: _temporalDateLike_ has an [[ISOYear]] internal slot.
        1. Return 𝔽(_temporalDateLike_.[[ISOYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.month">
      <h1>Temporal.Calendar.prototype.month ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.month` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is Object and _temporalDateLike_ has an [[InitializedTemporalMonthDay]] internal slot, then
          1. Throw a *TypeError* exception.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Assert: _temporalDateLike_ has an [[ISOMonth]] internal slot.
        1. Return 𝔽(_temporalDateLike_.[[ISOMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthcode">
      <h1>Temporal.Calendar.prototype.monthCode ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.monthCode` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Assert: _temporalDateLike_ has an [[ISOMonth]] internal slot.
        1. Return ISOMonthCode(_temporalDateLike_.[[ISOMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.day">
      <h1>Temporal.Calendar.prototype.day ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.day` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalMonthDay]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Assert: _temporalDateLike_ has an [[ISODay]] internal slot.
        1. Return 𝔽(_temporalDateLike_.[[ISODay]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dayofweek">
      <h1>Temporal.Calendar.prototype.dayOfWeek ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dayOfWeek` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(ToISODayOfWeek(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.dayofyear">
      <h1>Temporal.Calendar.prototype.dayOfYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.dayOfYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(ToISODayOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.weekofyear">
      <h1>Temporal.Calendar.prototype.weekOfYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.weekOfYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Let _isoYearWeek_ be ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
        1. Return 𝔽(_isoYearWeek_.[[Week]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.yearofweek">
      <h1>Temporal.Calendar.prototype.yearOfWeek ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Let _isoYearWeek_ be ToISOWeekOfYear(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
        1. Return 𝔽(_isoYearWeek_.[[Year]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinweek">
      <h1>Temporal.Calendar.prototype.daysInWeek ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.daysInWeek` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Perform ? ToTemporalDate(_temporalDateLike_).
        1. Return *7*<sub>𝔽</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinmonth">
      <h1>Temporal.Calendar.prototype.daysInMonth ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.daysInMonth` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slots, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return 𝔽(ISODaysInMonth(_temporalDateLike_.[[ISOYear]], _temporalDateLike_.[[ISOMonth]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.daysinyear">
      <h1>Temporal.Calendar.prototype.daysInYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.daysInYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. Return DaysInYear(𝔽(_temporalDateLike_.[[ISOYear]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.monthsinyear">
      <h1>Temporal.Calendar.prototype.monthsInYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.monthsInYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Perform ? ToTemporalDate(_temporalDateLike_).
        1. Return *12*<sub>𝔽</sub>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.inleapyear">
      <h1>Temporal.Calendar.prototype.inLeapYear ( _temporalDateLike_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.inLeapYear` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. If Type(_temporalDateLike_) is not Object or _temporalDateLike_ does not have an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], or [[InitializedTemporalYearMonth]] internal slot, then
          1. Set _temporalDateLike_ to ? ToTemporalDate(_temporalDateLike_).
        1. If InLeapYear(TimeFromYear(𝔽(_temporalDateLike_.[[ISOYear]]))) is *1*<sub>𝔽</sub>, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.fields">
      <h1>Temporal.Calendar.prototype.fields ( _fields_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.fields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Let _iteratorRecord_ be ? GetIterator(_fields_, ~sync~).
        1. Let _fieldNames_ be a new empty List.
        1. Let _next_ be *true*.
        1. Repeat, while _next_ is not *false*,
          1. Set _next_ to ? IteratorStep(_iteratorRecord_).
          1. If _next_ is not *false*, then
            1. Let _nextValue_ be ? IteratorValue(_next_).
            1. If Type(_nextValue_) is not String, then
              1. Let _completion_ be ThrowCompletion(a newly created *TypeError* object).
              1. Return ? IteratorClose(_iteratorRecord_, _completion_).
            1. If _fieldNames_ contains _nextValue_, then
              1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
              1. Return ? IteratorClose(_iteratorRecord_, _completion_).
            1. If _nextValue_ is not one of *"year"*, *"month"*, *"monthCode"*, *"day"*, *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"*, then
                1. Let _completion_ be ThrowCompletion(a newly created *RangeError* object).
                1. Return ? IteratorClose(_iteratorRecord_, _completion_).
            1. Append _nextValue_ to the end of the List _fieldNames_.
        1. Return CreateArrayFromList(_fieldNames_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.mergefields">
      <h1>Temporal.Calendar.prototype.mergeFields ( _fields_, _additionalFields_ )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Calendar.prototype.mergeFields` method as specified in the ECMA-402 specification.
      </p>
      <p>
        An ECMAScript implementation that does not include the ECMA-402 API, may still include support for built-in calendars (see <emu-xref href="#sec-calendar-types"></emu-xref>).
        The minimum implementation of this method for ECMAScript implementations that do not include the ECMA-402 API and do not support built-in calendars other than *"iso8601"* performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Set _fields_ to ? ToObject(_fields_).
        1. Set _additionalFields_ to ? ToObject(_additionalFields_).
        1. Assert: _calendar_.[[Identifier]] is *"iso8601"*.
        1. Return ? DefaultMergeCalendarFields(_fields_, _additionalFields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.tostring">
      <h1>Temporal.Calendar.prototype.toString ( )</h1>
      <p>
        The `Temporal.Calendar.prototype.toString` method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return _calendar_.[[Identifier]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.calendar.prototype.tojson">
      <h1>Temporal.Calendar.prototype.toJSON ( )</h1>
      <p>
        The `Temporal.Calendar.prototype.toJSON` method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _calendar_ be the *this* value.
        1. Perform ? RequireInternalSlot(_calendar_, [[InitializedTemporalCalendar]]).
        1. Return ? ToString(_calendar_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-calendar-instances">
    <h1>Properties of Temporal.Calendar Instances</h1>

    <p>Temporal.Calendar instances are ordinary objects that inherit properties from the %Temporal.Calendar.prototype%. Temporal.Calendar instances also have a [[Identifier]] internal slot. The value of this internal slot is a string.</p>
  </emu-clause>
</emu-clause>
