<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-calendars">
  <h1>Calendars</h1>

  <emu-clause id="sec-calendar-types">
    <h1>Calendar Types</h1>

    <!-- See https://github.com/tc39/ecma402/issues/828 and https://github.com/tc39/ecma402/issues/852 -->
    <p>
      At a minimum, ECMAScript implementations must support a built-in calendar named *"iso8601"*, representing the ISO 8601 calendar.
      In addition, implementations may support any number of other built-in calendars corresponding with those of the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
    </p>
    <p>
      ECMAScript implementations identify built-in calendars using a <dfn variants="calendar types">calendar type</dfn> as defined by <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Elements">Unicode Technical Standard #35, Part 4, Section 2</a>.
      Their canonical form is a string containing only Unicode Basic Latin lowercase letters (U+0061 LATIN SMALL LETTER A through U+007A LATIN SMALL LETTER Z, inclusive) and/or digits (U+0030 DIGIT ZERO through U+0039 DIGIT NINE, inclusive), with zero or more medial hyphens (U+002D HYPHEN-MINUS).
    </p>

    <emu-clause id="sec-temporal-isbuiltincalendar" type="abstract operation">
      <h1>
        IsBuiltinCalendar (
          _id_: a String,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned value is *true* if _id_ is a calendar type denoting a built-in calendar, and *false* otherwise.</dd>
      </dl>
      <emu-alg>
        1. Let _calendars_ be AvailableCalendars().
        1. If _calendars_ contains the ASCII-lowercase of _id_, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-availablecalendars" type="implementation-defined abstract operation">
      <h1>
        AvailableCalendars (
        ): a List of Strings
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Each element in the returned List represents a calendar type supported by the implementation.</dd>
      </dl>
      <emu-alg>
        1. Let _calendars_ be the List of String values representing calendar types supported by the implementation, sorted according to lexicographic code unit order.
        1. Assert: _calendars_ contains *"iso8601"*.
        1. [declared="S"] Assert: _calendars_ does not contain any element _S_ for which the ASCII-lowercase of _S_ is not _S_.
        1. Assert: _calendars_ does not contain any element that does not identify a calendar type in the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-calendar-abstract-ops">
    <h1>Abstract Operations for Temporal.Calendar Objects</h1>

    <emu-clause id="sec-temporal-createtemporalcalendar" type="abstract operation">
      <h1>
        CreateTemporalCalendar (
          _identifier_: a String,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.Calendar or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.Calendar instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsBuiltinCalendar(_identifier_) is *true*.
        1. If _newTarget_ is not provided, set _newTarget_ to %Temporal.Calendar%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.Calendar.prototype%"*, ¬´ [[InitializedTemporalCalendar]], [[Identifier]] ¬ª).
        1. Set _object_.[[Identifier]] to the ASCII-lowercase of _identifier_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmergefields" type="abstract operation">
      <h1>
        CalendarMergeFields (
          _calendar_: a String,
          _fields_: an Object,
          _additionalFields_: an Object,
        ): either a normal completion containing an Object or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It merges the properties of _fields_ and _additionalFields_.</dd>
      </dl>
      <emu-alg>
        1. Let _fieldsCopy_ be ? SnapshotOwnProperties(? ToObject(_fields_), *null*, ¬´ ¬ª, ¬´ *undefined* ¬ª).
        1. Let _additionalFieldsCopy_ be ? SnapshotOwnProperties(? ToObject(_additionalFields_), *null*, ¬´ ¬ª, ¬´ *undefined* ¬ª).
        1. NOTE: Every property of _fieldsCopy_ and _additionalFieldsCopy_ is an enumerable data property with a non-*undefined* value, but some property keys may be Symbols.
        1. Let _additionalKeys_ be ! _additionalFieldsCopy_.[[OwnPropertyKeys]]().
        1. If _calendar_ is *"iso8601"*, then
          1. Let _overriddenKeys_ be ISOFieldKeysToIgnore(_additionalKeys_).
        1. Else,
          1. Let _overriddenKeys_ be CalendarFieldKeysToIgnore(_calendar_, _additionalKeys_).
        1. Let _merged_ be OrdinaryObjectCreate(*null*).
        1. NOTE: The following steps ensure that property iteration order of _merged_ matches that of _fields_ as modified by omitting overridden properties and appending non-overlapping properties from _additionalFields_ in iteration order.
        1. Let _fieldsKeys_ be ! _fieldsCopy_.[[OwnPropertyKeys]]().
        1. For each element _key_ of _fieldsKeys_, do
          1. If _overriddenKeys_ contains _key_, then
            1. Let _propValue_ be ! Get(_additionalFieldsCopy_, _key_).
          1. Else,
            1. Let _propValue_ be ! Get(_fieldsCopy_, _key_).
          1. If _propValue_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_merged_, _key_, _propValue_).
        1. Perform ! CopyDataProperties(_merged_, _additionalFieldsCopy_, ¬´ ¬ª).
        1. Return _merged_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateadd" type="abstract operation">
      <h1>
        CalendarDateAdd (
          _date_: a Temporal.PlainDate,
          _duration_: a Temporal.Duration,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing a Temporal.PlainDate or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds _duration_ to _date_.
        </dd>
      </dl>
      <emu-alg>
        1. Let _norm_ be NormalizeTimeDuration(_duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _balanceResult_ be ! BalanceTimeDuration(_norm_, *"day"*).
        1. If _date_.[[Calendar]] is *"iso8601"*, then
          1. Let _result_ be ? AddISODate(_date_.[[ISOYear]], _date_.[[ISOMonth]], _date_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]] + _balanceResult_.[[Days]], _overflow_).
        1. Else,
          1. Let _balancedDuration_ be ! CreateDateDurationRecord(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]] + _balanceResult_.[[Days]]).
          1. Let _result_ be ? CalendarDateAddition(_date_.[[Calendar]], _date_, _balancedDuration_, _overflow_).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _date_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateuntil" type="abstract operation">
      <h1>
        CalendarDateUntil (
          _one_: a Temporal.PlainDate,
          _two_: a Temporal.PlainDate,
          _largestUnit_: a String from the "Singular" column of <emu-xref href="#table-temporal-units"></emu-xref>,
        ): either a normal completion containing a Temporal.Duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines the difference between the dates _one_ and _two_.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: _one_.[[Calendar]] is _two_.[[Calendar]].
        1. If _one_.[[Calendar]] is *"iso8601"*, then
          1. Let _result_ be DifferenceISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _largestUnit_).
        1. Else,
          1. Let _result_ be CalendarDateDifference(_one_.[[Calendar]], _one_, _two_, _largestUnit_).
        1. Return ! CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarera" type="abstract operation">
      <h1>
        CalendarEra (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing either a String or *undefined*, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, return *undefined*.
        1. Return CalendarDateEra(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarerayear" type="abstract operation">
      <h1>
        CalendarEraYear (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing either an integer or *undefined*, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, return *undefined*.
        1. Return CalendarDateEraYear(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryear" type="abstract operation">
      <h1>
        CalendarYear (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, return _dateLike_.[[ISOYear]].
        1. Return CalendarDateYear(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonth" type="abstract operation">
      <h1>
        CalendarMonth (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, return _dateLike_.[[ISOMonth]].
        1. Return CalendarDateMonth(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthcode" type="abstract operation">
      <h1>
        CalendarMonthCode (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, return ISOMonthCode(_dateLike_.[[ISOMonth]]).
        1. Return CalendarDateMonthCode(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarday" type="abstract operation">
      <h1>
        CalendarDay (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainMonthDay,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, return _dateLike_.[[ISODay]].
        1. Return CalendarDateDay(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofweek" type="abstract operation">
      <h1>
        CalendarDayOfWeek (
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, then
          1. Return ToISODayOfWeek(_dateLike_.[[ISOYear]], _dateLike_.[[ISOMonth]], _dateLike_.[[ISODay]]).
        1. Return CalendarDateDayOfWeek(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardayofyear" type="abstract operation">
      <h1>
        CalendarDayOfYear (
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, then
          1. Return ToISODayOfYear(_dateLike_.[[ISOYear]], _dateLike_.[[ISOMonth]], _dateLike_.[[ISODay]]).
        1. Return CalendarDateDayOfYear(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarweekofyear" type="abstract operation">
      <h1>
        CalendarWeekOfYear (
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing either an integer or *undefined*, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, then
          1. Let _yearWeek_ be ToISOWeekOfYear(_dateLike_.[[ISOYear]], _dateLike_.[[ISOMonth]], _dateLike_.[[ISODay]]).
        1. Else,
          1. Let _yearWeek_ be CalendarDateWeekOfYear(_dateLike_.[[Calendar]], _dateLike_).
        1. Return _yearWeek_.[[Week]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryearofweek" type="abstract operation">
      <h1>
        CalendarYearOfWeek (
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing either an integer or *undefined*, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, then
          1. Let _yearWeek_ be ToISOWeekOfYear(_dateLike_.[[ISOYear]], _dateLike_.[[ISOMonth]], _dateLike_.[[ISODay]]).
        1. Else,
          1. Let _yearWeek_ be CalendarDateWeekOfYear(_dateLike_.[[Calendar]], _dateLike_).
        1. Return _yearWeek_.[[Year]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinweek" type="abstract operation">
      <h1>
        CalendarDaysInWeek (
          _dateLike_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, return 7.
        1. Return CalendarDateDaysInWeek(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinmonth" type="abstract operation">
      <h1>
        CalendarDaysInMonth (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, then
          1. Return ISODaysInMonth(_dateLike_.[[ISOYear]], _dateLike_.[[ISOMonth]]).
        1. Return CalendarDateDaysInMonth(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinyear" type="abstract operation">
      <h1>
        CalendarDaysInYear (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, then
          1. Return MathematicalDaysInYear(_dateLike_.[[ISOYear]]).
        1. Return CalendarDateDaysInYear(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthsinyear" type="abstract operation">
      <h1>
        CalendarMonthsInYear (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, return 12.
        1. Return CalendarDateMonthsInYear(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarinleapyear" type="abstract operation">
      <h1>
        CalendarInLeapYear (
          _dateLike_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): either a normal completion containing a Boolean or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _dateLike_.[[Calendar]] is *"iso8601"*, then
          1. If MathematicalInLeapYear(EpochTimeForYear(_dateLike_.[[ISOYear]])) = 1, return *true*.
          1. Return *false*.
        1. Return CalendarDateInLeapYear(_dateLike_.[[Calendar]], _dateLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalcalendarslotvalue" type="abstract operation">
      <h1>
        ToTemporalCalendarSlotValue (
          _temporalCalendarLike_: an ECMAScript value,
          optional _default_: a String,
        ): either a normal completion containing either a String or an Object, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It attempts to derive a value from _temporalCalendarLike_ that is suitable for storing in a Temporal object's [[Calendar]] internal slot, and returns that value if found or throws an exception if not.
          An optional _default_ built-in calendar identifier may be provided, which is returned if _temporalCalendarLike_ is *undefined*.
        </dd>
      </dl>
      <emu-alg>
        1. If _temporalCalendarLike_ is *undefined* and _default_ is present, then
          1. Assert: IsBuiltinCalendar(_default_) is *true*.
          1. Return _default_.
        1. If _temporalCalendarLike_ is an Object, then
          1. If _temporalCalendarLike_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _temporalCalendarLike_.[[Calendar]].
        1. If _temporalCalendarLike_ is not a String, throw a *TypeError* exception.
        1. Let _identifier_ be ? ParseTemporalCalendarString(_temporalCalendarLike_).
        1. If IsBuiltinCalendar(_identifier_) is *false*, throw a *RangeError* exception.
        1. Return the ASCII-lowercase of _identifier_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-gettemporalcalendarslotvaluewithisodefault" type="abstract operation">
      <h1>
        GetTemporalCalendarSlotValueWithISODefault (
          _item_: an Object,
        ): either a normal completion containing either a String or an Object, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It looks for a `calendar` property on the given _item_ and converts its value into another value suitable for storing in a Temporal object's [[Calendar]] internal slot.
          If no such property is present, the built-in ISO 8601 calendar is returned.
        </dd>
      </dl>
      <emu-alg>
        1. If _item_ has an [[InitializedTemporalDate]], [[InitializedTemporalDateTime]], [[InitializedTemporalMonthDay]], [[InitializedTemporalYearMonth]], or [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return _item_.[[Calendar]].
        1. Let _calendarLike_ be ? Get(_item_, *"calendar"*).
        1. Return ? ToTemporalCalendarSlotValue(_calendarLike_, *"iso8601"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatefromfields" type="abstract operation">
      <h1>
        CalendarDateFromFields (
          _calendar_: a String,
          _fields_: an Object,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing a Temporal.PlainDate or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
        </dd>
      </dl>
      <emu-alg>
        1. Let _relevantFieldNames_ be ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª.
        1. If _calendar_ is *"iso8601"*, then
          1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, ¬´ *"year"*, *"day"* ¬ª).
          1. Perform ? ISOResolveMonth(_fields_).
          1. Let _result_ be ? ISODateFromFields(_fields_, _overflow_).
        1. Else,
          1. Let _calendarRelevantFieldDescriptors_ be CalendarFieldDescriptors(_calendar_, ~date~).
          1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, ¬´ ¬ª, _calendarRelevantFieldDescriptors_).
          1. Perform ? CalendarResolveFields(_calendar_, _fields_, ~date~).
          1. Let _result_ be ? CalendarDateToISO(_calendar_, _fields_, _overflow_).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendaryearmonthfromfields" type="abstract operation">
      <h1>
        CalendarYearMonthFromFields (
          _calendar_: a String,
          _fields_: an Object,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing a Temporal.PlainYearMonth or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Let _relevantFieldNames_ be ¬´ *"month"*, *"monthCode"*, *"year"* ¬ª.
        1. If _calendar_ is *"iso8601"*, then
          1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, ¬´ *"year"* ¬ª).
          1. Perform ? ISOResolveMonth(_fields_).
          1. Let _result_ be ? ISOYearMonthFromFields(_fields_, _overflow_).
        1. Else,
          1. Let _calendarRelevantFieldDescriptors_ be CalendarFieldDescriptors(_calendar_, ~year-month~).
          1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, ¬´ ¬ª, _calendarRelevantFieldDescriptors_).
          1. Let _firstDayIndex_ be the 1-based index of the first day of the month described by _fields_ (i.e., 1 unless the month's first day is skipped by this calendar.)
          1. Perform ! CreateDataPropertyOrThrow(_fields_, *"day"*, ùîΩ(_firstDayIndex_)).
          1. Perform ? CalendarResolveFields(_calendar_, _fields_, ~year-month~).
          1. Let _result_ be ? CalendarDateToISO(_calendar_, _fields_, _overflow_).
        1. Return ? CreateTemporalYearMonth(_result_.[[Year]], _result_.[[Month]], _calendar_, _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthdayfromfields" type="abstract operation">
      <h1>
        CalendarMonthDayFromFields (
          _calendar_: a String,
          _fields_: an Object,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing a Temporal.PlainMonthDay or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Let _relevantFieldNames_ be ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª.
        1. If _calendar_ is *"iso8601"*, then
          1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, ¬´ *"day"* ¬ª).
          1. Perform ? ISOResolveMonth(_fields_).
          1. Let _result_ be ? ISOMonthDayFromFields(_fields_, _overflow_).
        1. Else,
          1. Let _calendarRelevantFieldDescriptors_ be CalendarFieldDescriptors(_calendar_, ~month-day~).
          1. Set _fields_ to ? PrepareTemporalFields(_fields_, _relevantFieldNames_, ¬´ ¬ª, _calendarRelevantFieldDescriptors_).
          1. Perform ? CalendarResolveFields(_calendar_, _fields_, ~month-day~).
          1. Let _result_ be ? CalendarMonthDayToISOReferenceDate(_calendar_, _fields_, _overflow_).
        1. Return ? CreateTemporalMonthDay(_result_.[[Month]], _result_.[[Day]], _calendar_, _result_.[[Year]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-maybeformatcalendarannotation" type="abstract operation">
      <h1>
        MaybeFormatCalendarAnnotation (
          _calendar_: a String,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
          Depending on the given _calendar_ and the value of _showCalendar_, the string may be empty if no calendar annotation need be included.
        </dd>
      </dl>
      <emu-alg>
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. Return FormatCalendarAnnotation(_calendar_, _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatcalendarannotation" type="abstract operation">
      <h1>
        FormatCalendarAnnotation (
          _id_: a String,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a string with a calendar annotation suitable for concatenating to the end of an ISO 8601 string.
          Depending on the given _id_ and value of _showCalendar_, the string may be empty if no calendar annotation need be included.
        </dd>
      </dl>
      <emu-alg>
        1. If _showCalendar_ is *"never"*, return the empty String.
        1. If _showCalendar_ is *"auto"* and _id_ is *"iso8601"*, return the empty String.
        1. If _showCalendar_ is *"critical"*, let _flag_ be *"!"*; else, let flag be the empty String.
        1. Return the string-concatenation of *"["*, _flag_, *"u-ca="*, _id_, and *"]"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarequals" type="abstract operation">
      <h1>
        CalendarEquals (
          _one_: a String,
          _two_: a String,
        ): either a normal completion containing a Boolean or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns *true* if its arguments represent calendars using the same identifier.</dd>
      </dl>
      <emu-alg>
        1. If CanonicalizeCalendar(_one_) is CanonicalizeCalendar(_two_), return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodaysinmonth" type="abstract operation">
      <h1>
        ISODaysInMonth (
          _year_: an integer,
          _month_: an integer in the inclusive interval from 1 to 12,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the number of days in the given year and month in the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. If _month_ is 1, 3, 5, 7, 8, 10, or 12, return 31.
        1. If _month_ is 4, 6, 9, or 11, return 30.
        1. Assert: _month_ = 2.
        1. Return 28 + MathematicalInLeapYear(EpochTimeForYear(_year_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisoweekofyear" type="abstract operation">
      <h1>
        ToISOWeekOfYear (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): a Year-Week Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines where a calendar day falls in the ISO 8601 week calendar and calculates its <em>calendar week of year</em>, which is the 1-based ordinal number of its calendar week within the corresponding <em>week calendar year</em> (which may differ from _year_ by up to 1 in either direction).</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _wednesday_ be 3.
        1. Let _thursday_ be 4.
        1. Let _friday_ be 5.
        1. Let _saturday_ be 6.
        1. Let _daysInWeek_ be 7.
        1. Let _maxWeekNumber_ be 53.
        1. Let _dayOfYear_ be ToISODayOfYear(_year_, _month_, _day_).
        1. Let _dayOfWeek_ be ToISODayOfWeek(_year_, _month_, _day_).
        1. Let _week_ be floor((_dayOfYear_ + _daysInWeek_ - _dayOfWeek_ + _wednesday_ ) / _daysInWeek_).
        1. If _week_ &lt; 1, then
          1. NOTE: This is the last week of the previous year.
          1. Let _dayOfJan1st_ be ToISODayOfWeek(_year_, 1, 1).
          1. If _dayOfJan1st_ = _friday_, then
            1. Return Year-Week Record { [[Week]]: _maxWeekNumber_, [[Year]]: _year_ - 1 }.
          1. If _dayOfJan1st_ = _saturday_, and MathematicalInLeapYear(EpochTimeForYear(_year_ - 1)) = 1, then
            1. Return Year-Week Record { [[Week]]: _maxWeekNumber_. [[Year]]: _year_ - 1 }.
          1. Return Year-Week Record { [[Week]]: _maxWeekNumber_ - 1, [[Year]]: _year_ - 1 }.
        1. If _week_ = _maxWeekNumber_, then
          1. Let _daysInYear_ be MathematicalDaysInYear(_year_).
          1. Let _daysLaterInYear_ be _daysInYear_ - _dayOfYear_.
          1. Let _daysAfterThursday_ be _thursday_ - _dayOfWeek_.
          1. If _daysLaterInYear_ &lt; _daysAfterThursday_, then
            1. Return Year-Week Record { [[Week]]: 1, [[Year]]: _year_ + 1 }.
        1. Return Year-Week Record { [[Week]]: _week_, [[Year]]: _year_ }.
      </emu-alg>
      <emu-note>In the ISO 8601 week calendar, calendar week number 1 of a calendar year is the week including the first Thursday of that year (based on the principle that a week belongs to the same calendar year as the majority of its calendar days), which always includes January 4 and starts on the Monday on or immediately before then. Because of this, some calendar days of the first calendar week of a calendar year may be part of the _preceding_ [proleptic Gregorian] date calendar year, and some calendar days of the last calendar week of a calendar year may be part of the _following_ [proleptic Gregorian] date calendar year. See ISO 8601 for details.</emu-note>
      <emu-note>For example, week calendar year 2020 includes both 31 December 2019 (a Tuesday belonging to its calendar week 1) and 1 January 2021 (a Friday belonging to its calendar week 53).</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthcode" type="abstract operation">
      <h1>
        ISOMonthCode (
          _month_: an integer in the inclusive interval from 1 to 12,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the string month code for a month in the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _numberPart_ be ToZeroPaddedDecimalString(_month_, 2).
        1. Return the string-concatenation of *"M"* and _numberPart_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoresolvemonth" type="abstract operation">
      <h1>
        ISOResolveMonth (
          _fields_: an Object,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It ensures that the *"month"* property of _fields_, if *undefined*, is set to the integral Number value in the inclusive interval from 1 to 12 that corresponds to the *"monthCode"* property of _fields_.
          It throws an exception if both properties are *undefined*, or if either property is invalid, or if the properties are inconsistent.
        </dd>
      </dl>
      <emu-alg>
        1. Assert: _fields_ is an ordinary Object that is not directly observable from ECMAScript code and for which the value of the [[Prototype]] internal slot is *null* and every property is a data property.
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Assert: _month_ is *undefined* or _month_ is a Number.
        1. Let _monthCode_ be ! Get(_fields_, *"monthCode"*).
        1. If _monthCode_ is *undefined*, then
          1. If _month_ is *undefined*, throw a *TypeError* exception.
          1. Return ~unused~.
        1. Assert: _monthCode_ is a String.
        1. NOTE: The ISO 8601 calendar does not include leap months.
        1. If the length of _monthCode_ is not 3, throw a *RangeError* exception.
        1. If the first code unit of _monthCode_ is not 0x004D (LATIN CAPITAL LETTER M), throw a *RangeError* exception.
        1. Let _monthCodeDigits_ be the substring of _monthCode_ from 1.
        1. If ParseText(StringToCodePoints(_monthCodeDigits_), |DateMonth|) is a List of errors, throw a *RangeError* exception.
        1. Let _monthCodeInteger_ be ‚Ñù(StringToNumber(_monthCodeDigits_)).
        1. Assert: SameValue(_monthCode_, ISOMonthCode(_monthCodeInteger_)) is *true*.
        1. If _month_ is not *undefined* and ‚Ñù(_month_) ‚â† _monthCodeInteger_, throw a *RangeError* exception.
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"month"*, ùîΩ(_monthCodeInteger_)).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatefromfields" type="abstract operation">
      <h1>
        ISODateFromFields (
          _fields_: an Object,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It implements the calendar-specific logic in the `Temporal.Calendar.prototype.dateFromFields` method for the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Let _day_ be ! Get(_fields_, *"day"*).
        1. Assert: _year_, _month_, and _day_ are all Numbers.
        1. Return ? RegulateISODate(‚Ñù(_year_), ‚Ñù(_month_), ‚Ñù(_day_), _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isoyearmonthfromfields" type="abstract operation">
      <h1>
        ISOYearMonthFromFields (
          _fields_: an Object,
          _overflow_: either *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It implements the calendar-specific logic in the `Temporal.Calendar.prototype.yearMonthFromFields` method for the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Assert: _year_ and _month_ are Numbers.
        1. Let _result_ be ? RegulateISOYearMonth(‚Ñù(_year_), ‚Ñù(_month_), _overflow_).
        1. Return ISO Date Record {
            [[Year]]: _result_.[[Year]],
            [[Month]]: _result_.[[Month]],
            [[Day]]: 1
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isomonthdayfromfields" type="abstract operation">
      <h1>
        ISOMonthDayFromFields (
          _fields_: an Object,
          _overflow_: either *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It implements the calendar-specific logic in the `Temporal.Calendar.prototype.monthDayFromFields` method for the ISO 8601 calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _month_ be ! Get(_fields_, *"month"*).
        1. Let _day_ be ! Get(_fields_, *"day"*).
        1. Assert: _month_ and _day_ are Numbers.
        1. Let _year_ be ! Get(_fields_, *"year"*).
        1. Let _referenceISOYear_ be 1972 (the first ISO 8601 leap year after the epoch).
        1. If _year_ is *undefined*, then
          1. Let _result_ be ? RegulateISODate(_referenceISOYear_, ‚Ñù(_month_), ‚Ñù(_day_), _overflow_).
        1. Else,
          1. Assert: _year_ is a Number.
          1. Let _result_ be ? RegulateISODate(‚Ñù(_year_), ‚Ñù(_month_), ‚Ñù(_day_), _overflow_).
        1. Return ISO Date Record {
            [[Year]]: _referenceISOYear_,
            [[Month]]: _result_.[[Month]],
            [[Day]]: _result_.[[Day]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isofieldkeystoignore" type="abstract operation">
      <h1>
        ISOFieldKeysToIgnore (
          _keys_: a List of property keys,
        ): a List of property keys
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the ISO 8601 calendar.
        </dd>
      </dl>
      <emu-alg>
        1. Let _ignoredKeys_ be an empty List.
        1. For each element _key_ of _keys_, do
          1. Append _key_ to _ignoredKeys_.
          1. If _key_ is *"month"*, append *"monthCode"* to _ignoredKeys_.
          1. Else if _key_ is *"monthCode"*, append *"month"* to _ignoredKeys_.
        1. NOTE: While _ignoredKeys_ can have duplicate elements, this is not intended to be meaningful. This specification only checks whether particular keys are or are not members of the list.
        1. Return _ignoredKeys_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofyear" type="abstract operation">
      <h1>
        ToISODayOfYear (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the ISO 8601 <em>calendar day of year</em> of a calendar day, which is its 1-based ordinal number within its ISO 8601 calendar year.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _epochDays_ be ISODateToEpochDays(_year_, _month_ - 1, _day_).
        1. Return EpochTimeToDayInYear(EpochDaysToEpochMs(_epochDays_, 0)) + 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-toisodayofweek" type="abstract operation">
      <h1>
        ToISODayOfWeek (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the ISO 8601 <em>calendar day of week</em> of a calendar day, which is its 1-based ordinal position within the sequence of week calendar days that starts with Monday at 1 and ends with Sunday at 7.</dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _epochDays_ be ISODateToEpochDays(_year_, _month_ - 1, _day_).
        1. Let _dayOfWeek_ be EpochTimeToWeekDay(EpochDaysToEpochMs(_epochDays_, 0)).
        1. If _dayOfWeek_ = 0, return 7.
        1. Return _dayOfWeek_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatetoiso" type="implementation-defined abstract operation">
      <h1>
        CalendarDateToISO (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _fields_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to convert _fields_, which represents a date or year and month or month and day in the built-in calendar identified by _calendar_, to a corresponding representative date in the ISO 8601 calendar, subject to processing specified by _overflow_.
          For *"reject"*, values that do not form a valid date cause an exception to be thrown, as described below.
          For *"constrain"*, values that do not form a valid date are clamped to the correct range.
          It then returns an ISO Date Record with the corresponding ISO 8601 date.
        </dd>
      </dl>
      <p>
        Clamping an invalid date to the correct range when _overflow_ is *"constrain"* is a behaviour specific to each built-in calendar, but all built-in calendars follow this guideline:
      </p>
      <ul>
        <li>Pick the closest day in the same month. If there are two equally-close dates in that month, pick the later one.</li>
        <li>If the month is a leap month that doesn't exist in the year, pick another date according to the cultural conventions of that calendar's users. Usually this will result in the same day in the month before or after where that month would normally fall in a leap year.</li>
        <li>Otherwise, pick the closest date that is still in the same year. If there are two equally-close dates in that year, pick the later one.</li>
        <li>If the entire year doesn't exist, pick the closest date in a different year. If there are two equally-close dates, pick the later one.</li>
      </ul>
      <p>
        Like RegulateISODate, the operation throws a *RangeError* exception if the date described by _fields_ is outside the range allowed by ISODateTimeWithinLimits, or if _overflow_ is *"reject"* and the date described by _fields_ does not exist.
      </p>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthdaytoisoreferencedate" type="implementation-defined abstract operation">
      <h1>
        CalendarMonthDayToISOReferenceDate (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _fields_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to convert _fields_, which represents a calendar date without a year (i.e., month code and day pair, or equivalent) in the built-in calendar identified by _calendar_, to a corresponding reference date in the ISO 8601 calendar as described below, subject to processing specified by _overflow_.
          For *"reject"*, values that do not form a valid date cause an exception to be thrown.
          For *"constrain"*, values that do not form a valid date are clamped to the correct range as in CalendarDateToISO.
          It then returns a Record representing the reference ISO 8601 date.
        </dd>
      </dl>
      <p>
        The fields of the returned Record represent a reference date in the ISO 8601 calendar that, when converted to the built-in calendar identified by _calendar_, corresponds to the month code and day of _fields_ in an arbitrary but deterministically chosen reference year.
        The reference date is the latest ISO 8601 date corresponding to the calendar date, that is also earlier than or equal to the ISO 8601 date December 31, 1972.
        If that calendar date never occurs on or before the ISO 8601 date December 31, 1972, then the reference date is the earliest ISO 8601 date corresponding to that calendar date.
        The reference year is almost always 1972 (the first ISO 8601 leap year after the epoch), with exceptions for calendars where some dates (e.g. leap days or days in leap months) didn't occur during that ISO 8601 year. For example, Hebrew calendar leap month Adar I was a part of calendar years 5730 and 5733 (respectively overlapping ISO 8601 February/March 1970 and February/March 1973), but did not occur between them.
      </p>
      <p>
        Like RegulateISODate, the operation throws a *RangeError* exception if _overflow_ is *"reject"* and the month and day described by _fields_ does not exist.
        For example, when _calendar_ is *"gregory"* and _overflow_ is *"reject"*, _fields_ values of `{ monthCode: "M01", day: "32" }` and `{ "year": 2001, "month": 2, "day": 29 }` would both cause a *RangeError* to be thrown.
        In the latter case, even though February 29 is a date in leap years of the Gregorian calendar, 2001 was not a leap year and a month code cannot be determined from the nonexistent date 2001-02-29 with the specified month index.
      </p>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateaddition" type="implementation-defined abstract operation">
      <h1>
        CalendarDateAddition (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDate,
          _duration_: a Date Duration Record,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to add _duration_ to _date_ in the context of the calendar represented by _calendar_ and returns the corresponding day, month and year of the result in the ISO 8601 calendar values as an ISO Date Record.
          It may throw a *RangeError* exception if _overflow_ is *"reject"* and the resulting month or day would need to be clamped in order to form a valid date in _calendar_, or if the date resulting from the addition is outside the range allowed by ISODateTimeWithinLimits.
        </dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatedifference" type="implementation-defined abstract operation">
      <h1>
        CalendarDateDifference (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _one_: a Temporal.PlainDate,
          _two_: a Temporal.PlainDate,
          _largestUnit_: *"year"*, *"month"*, *"week"*, or *"day"*,
        ): a Date Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the difference between the two dates _one_ and _two_ in the context of the calendar represented by _calendar_ and returns the corresponding duration.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateera" type="implementation-defined abstract operation">
      <h1>
        CalendarDateEra (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): a String or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns a lowercase String value representing that era, or *undefined* for calendars that do not have eras.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateerayear" type="implementation-defined abstract operation">
      <h1>
        CalendarDateEraYear (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): an integer or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the ordinal position of the year of _date_ in that era, or *undefined* for calendars that do not have eras.</dd>
      </dl>
      <emu-note>
        Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateyear" type="implementation-defined abstract operation">
      <h1>
        CalendarDateYear (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the year for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns it. The value should be a signed integer relative to the first day of a calendar-specific "epoch year".</dd>
      </dl>

      <emu-note>The year is relative to the first day of the calendar's epoch year, so if the epoch era starts in the middle of the year, the year will be the same value before and after the start date of the era.</emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatemonth" type="implementation-defined abstract operation">
      <h1>
        CalendarDateMonth (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the 1-based ordinal position of that month in the corresponding year of the calendar.</dd>
      </dl>
      <emu-note>
        When the number of months in a year of the identified calendar is variable, a different value can be returned for dates that are part of the same month in different years. For example, in the Hebrew calendar, 1 Nisan 5781 is associated with value 7 while 1 Nisan 5782 is associated with value 8 because 5782 is a leap year and Nisan follows the insertion of Adar I.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatemonthcode" type="implementation-defined abstract operation">
      <h1>
        CalendarDateMonthCode (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, Temporal.PlainYearMonth, or Temporal.PlainMonthDay,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns its month code. The month code for a month that is not a leap month and whose 1-based ordinal position in a common year of the calendar (i.e., a year that is not a leap year) is _n_ should be the string-concatenation of *"M"* and ToZeroPaddedDecimalString(_n_, 2), and the month code for a month that is a leap month inserted after a month whose 1-based ordinal position in a common year of the calendar is _p_ should be the string-concatenation of *"M"*, ToZeroPaddedDecimalString(_p_, 2), and *"L"*.</dd>
      </dl>
      <emu-note>
        For example, in the Hebrew calendar, the month code of Adar (and Adar II, in leap years) is *"M06"* and the month code of Adar I (the leap month inserted before Adar II) is *"M05L"*. In a calendar with a leap month at the start of some years, the month code of that month would be *"M00L"*.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateday" type="implementation-defined abstract operation">
      <h1>
        CalendarDateDay (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainMonthDay,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the day of the month for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the 1-based ordinal position of that day in the corresponding month.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatedayofweek" type="implementation-defined abstract operation">
      <h1>
        CalendarDateDayOfWeek (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It takes a date-like object _date_ and returns the day of the week in the calendar represented by _calendar_. The return value should be 1-based, where 1 is the day corresponding to Monday in the given calendar.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatedayofyear" type="implementation-defined abstract operation">
      <h1>
        CalendarDateDayOfYear (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It takes a date-like object _date_ and returns the day of the year in the calendar represented by _calendar_. The return value should be 1-based.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateweekofyear" type="implementation-defined abstract operation">
      <h1>
        CalendarDateWeekOfYear (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): a Year-Week Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It takes a date-like object _date_ and calculates the <em>calendar week of year</em>, and the corresponding <em>week calendar year</em>, in the calendar represented by _calendar_.</dd>
      </dl>
      <p>
        The value in the [[Week]] field should be 1-based.
      </p>
      <p>
        The value in the [[Year]] field is relative to the first day of a calendar-specific "epoch year", as in CalendarDateYear, not relative to an era as in CalendarDateEraYear.
      </p>
      <p>
        Usually the [[Year]] field will contain the same value given by CalendarDateYear, but may contain the previous or next year if the week number in the [[Week]] field overlaps two different years.
        See also ToISOWeekOfYear.
      </p>
      <p>
        It returns *undefined* in [[Week]] and [[Year]] field for calendars that do not have a well-defined week calendar system.
      </p>
      <emu-note type="editor">
        <p>
          More details about this function will be specified in
          <a href="https://tc39.es/proposal-intl-era-monthcode/">the Intl era and monthCode proposal</a>.
        </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatedaysinweek" type="implementation-defined abstract operation">
      <h1>
        CalendarDateDaysInWeek (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime or Temporal.PlainDate,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It takes a date-like object _date_ and returns the number of days in the given week in the calendar represented by _calendar_.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatedaysinmonth" type="implementation-defined abstract operation">
      <h1>
        CalendarDateDaysInMonth (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It identifies the month in the specified calendar that contains _date_ and returns the number of days in that month.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatedaysinyear" type="implementation-defined abstract operation">
      <h1>
        CalendarDateDaysInYear (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It takes a date-like object _date_ and returns the number of days in the given year in the calendar represented by _calendar_.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatemonthsinyear" type="implementation-defined abstract operation">
      <h1>
        CalendarDateMonthsInYear (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It takes a date-like object _date_ and returns the number of months in the given year in the calendar represented by _calendar_.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateinleapyear" type="implementation-defined abstract operation">
      <h1>
        CalendarDateInLeapYear (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate or Temporal.PlainYearMonth,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It takes a date-like object _date_ and returns *true* if it falls within a leap year for the calendar represented by _calendar_ and *false* otherwise.</dd>
      </dl>
      <emu-note>
        A "leap year" is a year that contains more days than other years (for solar or lunar calendars) or more months than other years (for lunisolar calendars like Hebrew or Chinese).
        Some calendars, especially lunisolar ones, have further variation in year length that is not represented in the output of this operation (e.g., the Hebrew calendar includes common years with 353, 354, or 355 days and leap years with 383, 384, or 385 days).
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarfielddescriptors" type="implementation-defined abstract operation">
      <h1>
        CalendarFieldDescriptors (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _type_: ~date~, ~year-month~, ~month-day~, or a List of Strings,
        ): a List of Calendar Field Descriptor Records
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It characterizes calendar-specific fields that are relevant for values of the provided _type_ in the built-in calendar identified by _calendar_ (inferring the type when _type_ is a List by interpreting its elements as field names). For example, *"era"* (with ToString conversion) and *"eraYear"* (with ToIntegerWithTruncation conversion) are returned when _calendar_ is *"gregory"* or *"japanese"* and _type_ is ~date~ or ~year-month~ or a List containing *"year"*.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarfieldkeystoignore" type="implementation-defined abstract operation">
      <h1>
        CalendarFieldKeysToIgnore (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _keys_: a List of property keys,
        ): a List of property keys
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the given _calendar_.
          A field always invalidates at least itself.
        </dd>
      </dl>
      <p>
        This operation is relevant for calendars which accept fields other than the standard set of ISO 8601 calendar fields, in order to implement the Temporal objects' `with()` methods, and `Temporal.Calendar.prototype.mergeFields()` in such a way that the result is free of ambiguity or conflicts.
      </p>
      <p>
        For example, given a _calendar_ that uses eras, such as *"gregory"*, a key in _keys_ being any one of *"year"*, *"era"*, or *"eraYear"* would exclude all three.
        Passing any one of the three to a `with()` method might conflict with either of the other two properties on the receiver object, so those properties of the receiver object should be ignored.
        Given this, in addition to the ISO 8601 mutual exclusion of *"month"* and *"monthCode"* as in ISOFieldKeysToIgnore, a possible implementation might produce the following results when _calendar_ is *"gregory"*:
      </p>
      <emu-table id="table-calendarfieldkeystoignore-example">
        <emu-caption>Example results of CalendarFieldKeysToIgnore</emu-caption>
        <table>
          <thead>
            <tr>
              <th>_keys_</th>
              <th>Returned List</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>¬´ *"era"* ¬ª</td>
              <td>¬´ *"era"*, *"eraYear"*, *"year*" ¬ª</td>
            </tr>
            <tr>
              <td>¬´ *"eraYear"* ¬ª</td>
              <td>¬´ *"era"*, *"eraYear"*, *"year"* ¬ª</td>
            </tr>
            <tr>
              <td>¬´ *"year"* ¬ª</td>
              <td>¬´ *"era"*, *"eraYear"*, *"year"* ¬ª</td>
            </tr>
            <tr>
              <td>¬´ *"month"* ¬ª</td>
              <td>¬´ *"month"*, *"monthCode*" ¬ª</td>
            </tr>
            <tr>
              <td>¬´ *"monthCode"* ¬ª</td>
              <td>¬´ *"month"*, *"monthCode"* ¬ª</td>
            </tr>
            <tr>
              <td>¬´ *"day"* ¬ª</td>
              <td>¬´ *"day"* ¬ª</td>
            </tr>
            <tr>
              <td>¬´ *"year"*, *"month"*, *"day"* ¬ª</td>
              <td>¬´ *"era"*, *"eraYear"*, *"year"*, *"month"*, *"monthCode"*, *"day"* ¬ª</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
      <emu-note>
        In a _calendar_ such as *"japanese"* where eras do not start and end at year and/or month boundaries, note that the returned List should contain *"era"* and *"eraYear"* if _keys_ contains *"day"*, *"month"*, or *"monthCode"* (not only if it contains *"era"*, *"eraYear"*, or *"year"*, as in the example above) because it's possible for changing the day or month to cause a conflict with the era.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarresolvefields" type="implementation-defined abstract operation">
      <h1>
        CalendarResolveFields (
          _calendar_: a String that is not *"iso8601"* for which IsBuiltinCalendar returns *true*,
          _fields_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
          _type_: ~date~, ~year-month~, or ~month-day~,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to validate that _fields_ (which describes a date or partial date in the built-in calendar identified by _calendar_) is sufficiently complete to satisfy _type_ and not internally inconsistent, and mutates _fields_ into acceptable input for <emu-xref href="#sec-temporal-calendardatetoiso" title></emu-xref> or <emu-xref href="#sec-temporal-calendarmonthdaytoisoreferencedate" title></emu-xref> by merging data that can be represented in multiple forms into standard properties and removing redundant properties (for example, merging *"month"* and *"monthCode"* into *"month"* and merging *"era"* and *"eraYear"* into *"year"*).
        </dd>
      </dl>
      <p>
        The operation throws a *TypeError* exception if the properties of _fields_ are internally inconsistent within the calendar or insufficient to identify a unique instance of _type_ in the calendar. For example:
      </p>
      <ul>
        <li>If _type_ is ~date~ or ~month-day~ and *"day"* in the calendar has an interpretation analogous to ISO 8601 and its corresponding value is *undefined*.</li>
        <li>If *"month"* and *"monthCode"* in the calendar have interpretations analogous to ISO 8601 and either the corresponding values for both are *undefined* or neither value is *undefined* but they do not identify the same month.</li>
        <li>If _type_ is ~month-day~ and the value for *"monthCode"* is *undefined* and a year cannot be determined from _fields_.</li>
        <li>If _type_ is ~date~ or ~year-month~ and the calendar supports the usual partitioning of years into eras with their own year counting as represented by *"year"*, *"era"*, and *"eraYear"* (as in the Gregorian or traditional Japanese calendars) and any of the following cases apply:<ul>
          <li>The value for each of *"year"* and *"era"* and *"eraYear"* is *undefined*.</li>
          <li>The value for *"era"* is *undefined* but the value for *"eraYear"* is not.</li>
          <li>The value for *"eraYear"* is *undefined* but the value for *"era"* is not.</li>
          <li>None of the three values are *undefined* but the values for *"era"* and *"eraYear"* do not together identify the same year as the value for *"year"*.</li>
        </ul></li>
      </ul>
      <emu-note>
        When _type_ is ~month-day~ and *"month"* is provided without *"monthCode"*, it is recommended that all built-in calendars other than the ISO 8601 calendar require a disambiguating year (e.g., either *"year"* or *"era"* and *"eraYear"*), including those that always use exactly the same months as the ISO 8601 calendar (which receives special handling in this specification as a default calendar that is permanently stable for automated processing).
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>
