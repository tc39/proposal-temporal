<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-instant-objects">
  <h1>Temporal.Instant Objects</h1>
  <p>A Temporal.Instant object is an Object referencing a fixed point in time with nanoseconds precision.</p>

  <emu-clause id="sec-temporal-instant-constructor">
    <h1>The Temporal.Instant Constructor</h1>
    <p>The Temporal.Instant constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.Instant object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.Instant behaviour must
        include a super call to the %Temporal.Instant% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.instant">
      <h1>Temporal.Instant ( _epochNanoseconds_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _epochNanoseconds_ be ? ToBigInt(_epochNanoseconds_).
        1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Return ? CreateTemporalInstant(_epochNanoseconds_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-instant-constructor">
    <h1>Properties of the Temporal.Instant Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.Instant constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.Instant constructor has the following properties:</p>

    <emu-clause id="sec-temporal.instant.prototype">
      <h1>Temporal.Instant.prototype</h1>
      <p>The initial value of `Temporal.Instant.prototype` is %Temporal.Instant.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.from">
      <h1>Temporal.Instant.from ( _item_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalInstant]] internal slot, then
          1. Return ! CreateTemporalInstant(_item_.[[Nanoseconds]]).
        1. Return ? ToTemporalInstant(_item_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.fromepochseconds">
      <h1>Temporal.Instant.fromEpochSeconds ( _epochSeconds_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _epochSeconds_ to ? ToNumber(_epochSeconds_).
        1. Set _epochSeconds_ to ? NumberToBigInt(_epochSeconds_).
        1. Let _epochNanoseconds_ be _epochSeconds_ &times; ‚Ñ§(10<sup>9</sup>).
        1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalInstant(_epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.fromepochmilliseconds">
      <h1>Temporal.Instant.fromEpochMilliseconds ( _epochMilliseconds_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _epochMilliseconds_ to ? ToNumber(_epochMilliseconds_).
        1. Set _epochMilliseconds_ to ? NumberToBigInt(_epochMilliseconds_).
        1. Let _epochNanoseconds_ be _epochMilliseconds_ &times; ‚Ñ§(10<sup>6</sup>).
        1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalInstant(_epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.fromepochmicroseconds">
      <h1>Temporal.Instant.fromEpochMicroseconds ( _epochMicroseconds_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _epochMicroseconds_ to ? ToBigInt(_epochMicroseconds_).
        1. Let _epochNanoseconds_ be _epochMicroseconds_ &times; *1000*<sub>‚Ñ§</sub>.
        1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalInstant(_epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.fromepochnanoseconds">
      <h1>Temporal.Instant.fromEpochNanoseconds ( _epochNanoseconds_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _epochNanoseconds_ to ? ToBigInt(_epochNanoseconds_).
        1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalInstant(_epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.compare">
      <h1>Temporal.Instant.compare ( _one_, _two_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalInstant(_one_).
        1. Set _two_ to ? ToTemporalInstant(_two_).
        1. Return ùîΩ(CompareEpochNanoseconds(_one_.[[Nanoseconds]], _two_.[[Nanoseconds]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-instant-prototype-object">
    <h1>Properties of the Temporal.Instant Prototype Object</h1>

    <p>The Temporal.Instant prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.Instant instance and does not have a [[InitializedTemporalInstant]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.instant.prototype.constructor">
      <h1>Temporal.Instant.prototype.constructor</h1>
      <p>The initial value of `Temporal.Instant.prototype.constructor` is %Temporal.Instant%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype-@@tostringtag">
      <h1>Temporal.Instant.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.Instant"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant.prototype.epochseconds">
      <h1>get Temporal.Instant.prototype.epochSeconds</h1>
      <p>
        `Temporal.Instant.prototype.epochSeconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _ns_ be _instant_.[[Nanoseconds]].
        1. Let _s_ be floor(‚Ñù(_ns_) / 10<sup>9</sup>).
        1. Return ùîΩ(_s_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant.prototype.epochmilliseconds">
      <h1>get Temporal.Instant.prototype.epochMilliseconds</h1>
      <p>
        `Temporal.Instant.prototype.epochMilliseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _ns_ be _instant_.[[Nanoseconds]].
        1. Let _ms_ be floor(‚Ñù(_ns_) / 10<sup>6</sup>).
        1. Return ùîΩ(_ms_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant.prototype.epochmicroseconds">
      <h1>get Temporal.Instant.prototype.epochMicroseconds</h1>
      <p>
        `Temporal.Instant.prototype.epochMicroseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _ns_ be _instant_.[[Nanoseconds]].
        1. Let _¬µs_ be floor(‚Ñù(_ns_) / 10<sup>3</sup>).
        1. Return ‚Ñ§(_¬µs_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant.prototype.epochnanoseconds">
      <h1>get Temporal.Instant.prototype.epochNanoseconds</h1>
      <p>
        `Temporal.Instant.prototype.epochNanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _ns_ be _instant_.[[Nanoseconds]].
        1. Return _ns_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.add">
      <h1>Temporal.Instant.prototype.add ( _temporalDurationLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Return ? AddDurationToOrSubtractDurationFromInstant(~add~, _instant_, _temporalDurationLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.subtract">
      <h1>Temporal.Instant.prototype.subtract ( _temporalDurationLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Return ? AddDurationToOrSubtractDurationFromInstant(~subtract~, _instant_, _temporalDurationLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.until">
      <h1>Temporal.Instant.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Return ? DifferenceTemporalInstant(~until~, _instant_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.since">
      <h1>Temporal.Instant.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Return ? DifferenceTemporalInstant(~since~, _instant_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.round">
      <h1>Temporal.Instant.prototype.round ( _roundTo_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. If _roundTo_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If Type(_roundTo_) is String, then
          1. Let _paramString_ be _roundTo_.
          1. Set _roundTo_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_roundTo_, *"smallestUnit"*, _paramString_).
        1. Else,
          1. Set _roundTo_ to ? GetOptionsObject(_roundTo_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalRoundingIncrement reads *"roundingIncrement"* and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_roundTo_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_roundTo_, *"halfExpand"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_roundTo_, *"smallestUnit"*, ~time~, ~required~).
        1. If _smallestUnit_ is *"hour"*, then
          1. Let _maximum_ be HoursPerDay.
        1. Else if _smallestUnit_ is *"minute"*, then
          1. Let _maximum_ be MinutesPerHour &times; HoursPerDay.
        1. Else if _smallestUnit_ is *"second"*, then
          1. Let _maximum_ be SecondsPerMinute &times; MinutesPerHour &times; HoursPerDay.
        1. Else if _smallestUnit_ is *"millisecond"*, then
          1. Let _maximum_ be ‚Ñù(msPerDay).
        1. Else if _smallestUnit_ is *"microsecond"*, then
          1. Let _maximum_ be 10<sup>3</sup> &times; ‚Ñù(msPerDay).
        1. Else,
          1. Assert: _smallestUnit_ is *"nanosecond"*.
          1. Let _maximum_ be nsPerDay.
        1. Perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, *true*).
        1. Let _roundedNs_ be RoundTemporalInstant(_instant_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Return ! CreateTemporalInstant(_roundedNs_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.equals">
      <h1>Temporal.Instant.prototype.equals ( _other_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Set _other_ to ? ToTemporalInstant(_other_).
        1. If _instant_.[[Nanoseconds]] &ne; _other_.[[Nanoseconds]], return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tostring">
      <h1>Temporal.Instant.prototype.toString ( [ _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToFractionalSecondDigits reads *"fractionalSecondDigits"* and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _digits_ be ? ToFractionalSecondDigits(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_options_, *"smallestUnit"*, ~time~, *undefined*).
        1. If _smallestUnit_ is *"hour"*, throw a *RangeError* exception.
        1. Let _timeZone_ be ? Get(_options_, *"timeZone"*).
        1. If _timeZone_ is not *undefined*, then
          1. Set _timeZone_ to ? ToTemporalTimeZoneSlotValue(_timeZone_).
        1. Let _precision_ be ToSecondsStringPrecisionRecord(_smallestUnit_, _digits_).
        1. Let _roundedNs_ be RoundTemporalInstant(_instant_.[[Nanoseconds]], _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. Let _roundedInstant_ be ! CreateTemporalInstant(_roundedNs_).
        1. Return ? TemporalInstantToString(_roundedInstant_, _timeZone_, _precision_.[[Precision]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tolocalestring">
      <h1>Temporal.Instant.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>
        The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
      </p>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Return ? TemporalInstantToString(_instant_, *undefined*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tojson">
      <h1>Temporal.Instant.prototype.toJSON ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Return ? TemporalInstantToString(_instant_, *undefined*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.valueof">
      <h1>Temporal.Instant.prototype.valueOf ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tozoneddatetime">
      <h1>Temporal.Instant.prototype.toZonedDateTime ( _item_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. If Type(_item_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _calendarLike_ be ? Get(_item_, *"calendar"*).
        1. If _calendarLike_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _calendar_ be ? ToTemporalCalendarSlotValue(_calendarLike_).
        1. Let _temporalTimeZoneLike_ be ? Get(_item_, *"timeZone"*).
        1. If _temporalTimeZoneLike_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _timeZone_ be ? ToTemporalTimeZoneSlotValue(_temporalTimeZoneLike_).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tozoneddatetimeiso">
      <h1>Temporal.Instant.prototype.toZonedDateTimeISO ( _timeZone_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Set _timeZone_ to ? ToTemporalTimeZoneSlotValue(_timeZone_).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, *"iso8601"*).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-instant-instances">
    <h1>Properties of Temporal.Instant Instances</h1>

    <p>
      Temporal.Instant instances are ordinary objects that inherit properties from the %Temporal.Instant.prototype% intrinsic object.
      Temporal.Instant instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporalinstant-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporalinstant-instances" caption="Internal Slots of Temporal.Instant Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalInstant]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.Instant instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[Nanoseconds]]
            </td>
            <td>
              A BigInt value representing the number of nanoseconds since the epoch.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <emu-clause id="sec-temporal-instant-range">
      <h1>Temporal.Instant range</h1>

      <p>
        The [[Nanoseconds]] internal slot of a Temporal.Instant object supports a range of exactly -100,000,000 to 100,000,000 days relative to midnight at the beginning of 1 January 1970 UTC, as in <emu-xref href="#sec-time-values-and-time-range"></emu-xref>.
      </p>
      <p>
        The exact moment of midnight at the beginning of 1 January 1970 UTC is represented by the value *0*<sub>‚Ñ§</sub>.
      </p>

      <p>The maximum value is ‚Ñ§(nsMaxInstant), where</p>
      <emu-eqn id="eqn-nsMaxInstant" aoid="nsMaxInstant">nsMaxInstant = 10<sup>8</sup> &times; nsPerDay = 8.64 &times; 10<sup>21</sup></emu-eqn>
      <p>where the number of nanoseconds per day is</p>
      <emu-eqn id="eqn-nsPerDay" aoid="nsPerDay">nsPerDay = 10<sup>6</sup> &times; ‚Ñù(msPerDay) = 8.64 &times; 10<sup>13</sup></emu-eqn>

      <p>The minimum value is ‚Ñ§(nsMinInstant), where</p>
      <emu-eqn id="eqn-nsMinInstant" aoid="nsMinInstant">nsMinInstant = -nsMaxInstant = -8.64 &times; 10<sup>21</sup></emu-eqn>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-instant-abstract-ops">
    <h1>Abstract operations</h1>

    <emu-clause id="sec-temporal-isvalidepochnanoseconds" aoid="IsValidEpochNanoseconds">
      <h1>IsValidEpochNanoseconds ( _epochNanoseconds_ )</h1>
      <p>
        The abstract operation IsValidEpochNanoseconds returns *true* if its argument _epochNanoseconds_ is within the allowed range of nanoseconds since the epoch for a Temporal.Instant and Temporal.ZonedDateTime, and *false* otherwise.
      </p>
      <emu-alg>
        1. Assert: Type(_epochNanoseconds_) is BigInt.
        1. If ‚Ñù(_epochNanoseconds_) &lt; nsMinInstant or ‚Ñù(_epochNanoseconds_) &gt; nsMaxInstant, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalinstant" type="abstract operation">
      <h1>
        CreateTemporalInstant (
          _epochNanoseconds_: a BigInt,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.Instant, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.Instant instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. Assert: ! IsValidEpochNanoseconds(_epochNanoseconds_) is *true*.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.Instant%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.Instant.prototype%"*, ¬´ [[InitializedTemporalInstant]], [[Nanoseconds]] ¬ª).
        1. Set _object_.[[Nanoseconds]] to _epochNanoseconds_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalinstant" aoid="ToTemporalInstant">
      <h1>ToTemporalInstant ( _item_ )</h1>
      <p>
        The abstract operation ToTemporalInstant returns its argument _item_ if it is already a Temporal.Instant instance, converts _item_ to a new Temporal.Instant instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalInstant]] internal slot, then
            1. Return _item_.
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return ! CreateTemporalInstant(_item_.[[Nanoseconds]]).
          1. NOTE: This use of ToPrimitive allows Instant-like objects to be converted.
          1. Set _item_ to ? ToPrimitive(_item_, ~string~).
        1. If _item_ is not a String, throw a *TypeError* exception.
        1. Let _parsed_ be ? ParseTemporalInstantString(_item_).
        1. If _parsed_.[[Z]] is *true*, let _offsetNanoseconds_ be 0; otherwise, let _offsetNanoseconds_ be ! ParseDateTimeUTCOffset(_parsed_.[[OffsetString]]).
        1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_parsed_.[[Year]], _parsed_.[[Month]], _parsed_.[[Day]], _parsed_.[[Hour]], _parsed_.[[Minute]], _parsed_.[[Second]], _parsed_.[[Millisecond]], _parsed_.[[Microsecond]], _parsed_.[[Nanosecond]], _offsetNanoseconds_).
        1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Return ! CreateTemporalInstant(_epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-compareepochnanoseconds" type="abstract operation">
      <h1>
        CompareEpochNanoseconds (
          _epochNanosecondsOne_: a BigInt,
          _epochNanosecondsTwo_: a BigInt,
        ): either -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If _epochNanosecondsOne_ &gt; _epochNanosecondsTwo_, return 1.
        1. If _epochNanosecondsOne_ &lt; _epochNanosecondsTwo_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addinstant" type="abstract operation">
      <h1>
        AddInstant (
          _epochNanoseconds_: a BigInt value,
          _hours_: an integer,
          _minutes_: an integer,
          _seconds_: an integer,
          _milliseconds_: an integer,
          _microseconds_: an integer,
          _nanoseconds_: an integer,
        )
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds a duration in various time units to a number of nanoseconds since the epoch, and returns the result as a BigInt value.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be _epochNanoseconds_ + ‚Ñ§(_nanoseconds_) +
            ‚Ñ§(_microseconds_) &times; *1000*<sub>‚Ñ§</sub> +
            ‚Ñ§(_milliseconds_) &times; ‚Ñ§(10<sup>6</sup>) +
            ‚Ñ§(_seconds_) &times; ‚Ñ§(10<sup>9</sup>) +
            ‚Ñ§(_minutes_) &times; *60*<sub>‚Ñ§</sub> &times; ‚Ñ§(10<sup>9</sup>) +
            ‚Ñ§(_hours_) &times; *3600*<sub>‚Ñ§</sub> &times; ‚Ñ§(10<sup>9</sup>).
        1. If IsValidEpochNanoseconds(_result_) is *false*, throw a *RangeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differenceinstant" type="abstract operation">
      <h1>
        DifferenceInstant (
          _ns1_: a BigInt,
          _ns2_: a BigInt,
          _roundingIncrement_: a positive integer,
          _smallestUnit_: a String,
          _largestUnit_: a String,
          _roundingMode_: a String,
        ): a Time Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between two exact times _ns1_ and _ns2_ expressed in nanoseconds since the epoch, and rounds the result according to the parameters _roundingIncrement_, _smallestUnit_, _largestUnit_, and _roundingMode_.</dd>
      </dl>
      <emu-alg>
        1. Let _difference_ be ‚Ñù(_ns2_) - ‚Ñù(_ns1_).
        1. Let _nanoseconds_ be remainder(_difference_, 1000).
        1. Let _microseconds_ be remainder(truncate(_difference_ / 1000), 1000).
        1. Let _milliseconds_ be remainder(truncate(_difference_ / 10<sup>6</sup>), 1000).
        1. Let _seconds_ be truncate(_difference_ / 10<sup>9</sup>).
        1. If _smallestUnit_ is *"nanosecond"* and _roundingIncrement_ is 1, then
          1. Return ! BalanceTimeDuration(0, 0, 0, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, _largestUnit_).
        1. Let _roundResult_ be ! RoundDuration(0, 0, 0, 0, 0, 0, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Assert: _roundResult_.[[Days]] is 0.
        1. Return ! BalanceTimeDuration(0, _roundResult_.[[Hours]], _roundResult_.[[Minutes]], _roundResult_.[[Seconds]], _roundResult_.[[Milliseconds]], _roundResult_.[[Microseconds]], _roundResult_.[[Nanoseconds]], _largestUnit_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundtemporalinstant" type="abstract operation">
      <h1>
        RoundTemporalInstant (
          _ns_: a BigInt,
          _increment_: a positive integer,
          _unit_: a String,
          _roundingMode_: a String,
        ): a BigInt
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It rounds a number of nanoseconds _ns_ since the epoch to the given rounding increment.</dd>
      </dl>
      <emu-alg>
        1. If _unit_ is *"hour"*, then
          1. Let _incrementNs_ be _increment_ &times; 3.6 &times; 10<sup>12</sup>.
        1. Else if _unit_ is *"minute"*, then
          1. Let _incrementNs_ be _increment_ &times; 6 &times; 10<sup>10</sup>.
        1. Else if _unit_ is *"second"*, then
          1. Let _incrementNs_ be _increment_ &times; 10<sup>9</sup>.
        1. Else if _unit_ is *"millisecond"*, then
          1. Let _incrementNs_ be _increment_ &times; 10<sup>6</sup>.
        1. Else if _unit_ is *"microsecond"*, then
          1. Let _incrementNs_ be _increment_ &times; 10<sup>3</sup>.
        1. Else,
          1. Assert: _unit_ is *"nanosecond"*.
          1. Let _incrementNs_ be _increment_.
        1. Return ‚Ñ§(RoundNumberToIncrementAsIfPositive(‚Ñù(_ns_), _incrementNs_, _roundingMode_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporalinstanttostring" aoid="TemporalInstantToString">
      <h1>TemporalInstantToString ( _instant_, _timeZone_, _precision_ )</h1>
      <emu-alg>
        1. Assert: Type(_instant_) is Object.
        1. Assert: _instant_ has an [[InitializedTemporalInstant]] internal slot.
        1. Let _outputTimeZone_ be _timeZone_.
        1. If _outputTimeZone_ is *undefined*, set _outputTimeZone_ to *"UTC"*.
        1. Let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_outputTimeZone_, _instant_).
        1. Let _dateTime_ be ! GetPlainDateTimeFor(_outputTimeZone_, _instant_, *"iso8601"*, _offsetNanoseconds_).
        1. Let _dateTimeString_ be ! TemporalDateTimeToString(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], *"iso8601"*, _precision_, *"never"*).
        1. If _timeZone_ is *undefined*, then
          1. Let _timeZoneString_ be *"Z"*.
        1. Else,
          1. Let _timeZoneString_ be FormatDateTimeUTCOffsetRounded(_offsetNanoseconds_).
        1. Return the string-concatenation of _dateTimeString_ and _timeZoneString_.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-differencetemporalinstant" type="abstract operation">
      <h1>
        DifferenceTemporalInstant (
          _operation_: ~since~ or ~until~,
          _instant_: a Temporal.Instant,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _instant_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~since~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Set _other_ to ? ToTemporalInstant(_other_).
        1. Let _resolvedOptions_ be ? SnapshotOwnProperties(? GetOptionsObject(_options_), *null*).
        1. Let _settings_ be ? GetDifferenceSettings(_operation_, _resolvedOptions_, ~time~, &laquo; &raquo;, *"nanosecond"*, *"second"*).
        1. Let _result_ be DifferenceInstant(_instant_.[[Nanoseconds]], _other_.[[Nanoseconds]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[LargestUnit]], _settings_.[[RoundingMode]]).
        1. Return ! CreateTemporalDuration(0, 0, 0, 0, _sign_ &times; _result_.[[Hours]], _sign_ &times; _result_.[[Minutes]], _sign_ &times; _result_.[[Seconds]], _sign_ &times; _result_.[[Milliseconds]], _sign_ &times; _result_.[[Microseconds]], _sign_ &times; _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-adddurationtoorsubtractdurationfrominstant" type="abstract operation">
     <h1>
        AddDurationToOrSubtractDurationFromInstant (
          _operation_: ~add~ or ~subtract~,
          _instant_: a Temporal.Instant,
          _temporalDurationLike_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Instant or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds/subtracts _temporalDurationLike_ to/from _instant_.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~subtract~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Let _duration_ be ? ToTemporalDurationRecord(_temporalDurationLike_).
        1. If _duration_.[[Days]] is not 0, throw a *RangeError* exception.
        1. If _duration_.[[Months]] is not 0, throw a *RangeError* exception.
        1. If _duration_.[[Weeks]] is not 0, throw a *RangeError* exception.
        1. If _duration_.[[Years]] is not 0, throw a *RangeError* exception.
        1. Let _ns_ be ? AddInstant(_instant_.[[Nanoseconds]], _sign_ &times; _duration_.[[Hours]], _sign_ &times; _duration_.[[Minutes]], _sign_ &times; _duration_.[[Seconds]], _sign_ &times; _duration_.[[Milliseconds]], _sign_ &times; _duration_.[[Microseconds]], _sign_ &times; _duration_.[[Nanoseconds]]).
        1. Return ! CreateTemporalInstant(_ns_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
