<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-duration-objects">
  <h1>Temporal.Duration Objects</h1>

  <p>
    A Temporal.Duration object describes the difference between two like Date,
    Time, or DateTime objects. Objects of this type are only created via the
    <i>.difference()</i> methods of these objects.
  </p>

  <emu-clause id="sec-temporal-duration-constructor">
    <h1>The Temporal.Duration Constructor</h1>
    <p>
      The Temporal.Duration constructor is the %Temporal.Duration% intrinsic
      object. When called as a constructor, it creates and initializes a new
      Temporal.Duration object.
    </p>
    <p>
      The Temporal.Duration constructor is designed to be subclassable. It may
      be used as the value of an extends clause of a class definition. Subclass
      constructors that intend to inherit the specified Duration behaviour must
      include a super call to the %Temporal.Duration% constructor to create and
      initialize subclass instances with the necessary internal slots.
    </p>
    <emu-clause id="sec-temporal.duration">
      <h1>Temporal.Duration ( [ _years_ [ , _months_ [ , _weeks_ [ , _days_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _milliseconds_ [ , _microseconds_ [ , _nanoseconds_ ] ] ] ] ] ] ] ] ] ] )</h1>
      <p>
        When the `Temporal.Duration` function is called, the following steps are taken:
      </p>
      <emu-note>The value of ? ToInteger(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _y_ be ? ToInteger(_years_).
        1. Let _mo_ be ? ToInteger(_months_).
        1. Let _w_ be ? ToInteger(_weeks_).
        1. Let _d_ be ? ToInteger(_days_).
        1. Let _h_ be ? ToInteger(_hours_).
        1. Let _m_ be ? ToInteger(_minutes_).
        1. Let _s_ be ? ToInteger(_seconds_).
        1. Let _ms_ be ? ToInteger(_milliseconds_).
        1. Let _mis_ be ? ToInteger(_microseconds_).
        1. Let _ns_ be ? ToInteger(_nanoseconds_).
        1. Return ? CreateTemporalDuration(_y_, _mo_, _w_, _d_, _h_, _m_, _s_, _ms_, _mis_, _ns_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-duration-constructor">
    <h1>Properties of the Temporal.Duration Constructor</h1>
    <p>
      The value of the [[Prototype]] internal slot of the Temporal.Duration
      constructor is the intrinsic object %Function.prototype%.
    </p>
    <p>The Temporal.Duration constructor has the following properties:</p>

    <emu-clause id="sec-temporal-duration-prototype">
      <h1>Temporal.Duration.prototype</h1>
      <p>
        The initial value of `Temporal.Duration.prototype` is
        %Temporal.Duration.prototype%.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]:
        *false*, [[Configurable]]: *false* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration-@@species">
      <h1>get Temporal.Duration [ @@species ]</h1>
      <p>
        `Temporal.Duration[@@species]` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>

      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.from">
      <h1>Temporal.Duration.from ( _item_ )</h1>
      <p>
        The `from` method takes one argument _item_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _constructor_ be the *this* value.
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalDuration]] internal slot, then
          1. Return ? CreateTemporalDurationFromStatic(_constructor_, _item_.[[Years]], _item_.[[Months]], _item_.[[Weeks]], _item_.[[Days]], _item_.[[Hours]], _item_.[[Minutes]], _item_.[[Seconds]], _item_.[[Milliseconds]], _item_.[[Microseconds]], _item_.[[Nanoseconds]]).
        1. Return ? ToTemporalDuration(_item_, _constructor_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-duration-prototype-object">
    <h1>Properties of the Temporal.Duration Prototype Object</h1>

    <p>The Temporal.Duration prototype object</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.Duration.prototype%</dfn>.</li>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.Duration instance and doesn't have an [[InitializedTemporalDuration]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal-duration-prototype-constructor">
      <h1>Temporal.Duration.prototype.constructor</h1>
      <p>The initial value of `Temporal.Duration.prototype.constructor` is %Temporal.Duration%.</p>
    </emu-clause>

    <emu-clause id="sec-intl-segmenter-prototype-@@tostringtag">
      <h1>Temporal.Date.prototype[ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the string value `"Temporal.Duration"`.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.years">
      <h1>get Temporal.Duration.prototype.years</h1>
      <p>
        `Temporal.Duration.prototype.years` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Years]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.months">
      <h1>get Temporal.Duration.prototype.months</h1>
      <p>
        `Temporal.Duration.prototype.months` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Months]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.weeks">
      <h1>get Temporal.Duration.prototype.weeks</h1>
      <p>
        `Temporal.Duration.prototype.weeks` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Weeks]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.days">
      <h1>get Temporal.Duration.prototype.days</h1>
      <p>
        `Temporal.Duration.prototype.days` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Days]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.hours">
      <h1>get Temporal.Duration.prototype.hours</h1>
      <p>
        `Temporal.Duration.prototype.hours` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Hours]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.minutes">
      <h1>get Temporal.Duration.prototype.minutes</h1>
      <p>
        `Temporal.Duration.prototype.minutes` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Minutes]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.seconds">
      <h1>get Temporal.Duration.prototype.seconds</h1>
      <p>
        `Temporal.Duration.prototype.seconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Seconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.milliseconds">
      <h1>get Temporal.Duration.prototype.milliseconds</h1>
      <p>
        `Temporal.Duration.prototype.milliseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Milliseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.microseconds">
      <h1>get Temporal.Duration.prototype.microseconds</h1>
      <p>
        `Temporal.Duration.prototype.microseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Microseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.nanoseconds">
      <h1>get Temporal.Duration.prototype.nanoseconds</h1>
      <p>
        `Temporal.Duration.prototype.nanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return _duration_.[[Nanoseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.sign">
      <h1>get Temporal.Duration.prototype.sign</h1>
      <p>
        `Temporal.Duration.prototype.sign` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ! DurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.with">
      <h1>Temporal.Duration.prototype.with ( _temporalDurationLike_ )</h1>
      <p>
        The `with` method takes one argument _temporalDurationLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Let _temporalDurationLike_ be ? ToPartialDuration(_temporalDurationLike_).
        1. If _temporalDurationLike_.[[Years]] is not *undefined*, then
          1. Let _years_ be _temporalDurationLike_.[[Years]].
        1. Else,
          1. Let _year_ be _duration_.[[Year]].
        1. If _temporalDurationLike_.[[Months]] is not *undefined*, then
          1. Let _months_ be _temporalDurationLike_.[[Months]].
        1. Else,
          1. Let _months_ be _duration_.[[Months]].
        1. If _temporalDurationLike_.[[Weeks]] is not *undefined*, then
          1. Let _weeks_ be _temporalDurationLike_.[[Weeks]].
        1. Else,
          1. Let _weeks_ be _duration_.[[Weeks]].
        1. If _temporalDurationLike_.[[Days]] is not *undefined*, then
          1. Let _days_ be _temporalDurationLike_.[[Days]].
        1. Else,
          1. Let _days_ be _duration_.[[Days]].
        1. If _temporalDurationLike_.[[Hours]] is not *undefined*, then
          1. Let _hours_ be _temporalDurationLike_.[[Hours]].
        1. Else,
          1. Let _hours_ be _duration_.[[Hours]].
        1. If _temporalDurationLike_.[[Minutes]] is not *undefined*, then
          1. Let _minutes_ be _temporalDurationLike_.[[Minutes]].
        1. Else,
          1. Let _minutes_ be _duration_.[[Minutes]].
        1. If _temporalDurationLike_.[[Seconds]] is not *undefined*, then
          1. Let _seconds_ be _temporalDurationLike_.[[Seconds]].
        1. Else,
          1. Let _seconds_ be _duration_.[[Seconds]].
        1. If _temporalDurationLike_.[[Milliseconds]] is not *undefined*, then
          1. Let _milliseconds_ be _temporalDurationLike_.[[Milliseconds]].
        1. Else,
          1. Let _milliseconds_ be _duration_.[[Milliseconds]].
        1. If _temporalDurationLike_.[[Microseconds]] is not *undefined*, then
          1. Let _microseconds_ be _temporalDurationLike_.[[Microseconds]].
        1. Else,
          1. Let _microseconds_ be _duration_.[[Microseconds]].
        1. If _temporalDurationLike_.[[Nanoseconds]] is not *undefined*, then
          1. Let _nanoseconds_ be _temporalDurationLike_.[[Nanoseconds]].
        1. Else,
          1. Let _nanoseconds_ be _duration_.[[Nanoseconds]].
        1. Return ? CreateTemporalDurationFromInstance(_duration_, _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.negated">
      <h1>Temporal.Duration.prototype.negated ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ? CreateTemporalDurationFromInstance(_duration_, −_duration_.[[Years]], −_duration_.[[Months]], −_duration_.[[Weeks]], −_duration_.[[Days]], −_duration_.[[Hours]], −_duration_.[[Minutes]], −_duration_.[[Seconds]], −_duration_.[[Milliseconds]], −_duration_.[[Microseconds]], −_duration_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.abs">
      <h1>Temporal.Duration.prototype.abs ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ? CreateTemporalDurationFromInstance(_duration_, abs(_duration_.[[Years]]), abs(_duration_.[[Months]]), abs(_duration_.[[Weeks]]), abs(_duration_.[[Days]]), abs(_duration_.[[Hours]]), abs(_duration_.[[Minutes]]), abs(_duration_.[[Seconds]]), abs(_duration_.[[Milliseconds]]), abs(_duration_.[[Microseconds]]), abs(_duration_.[[Nanoseconds]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.iszero">
      <h1>Temporal.Duration.prototype.isZero ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Let _sign_ be ! DurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. If _sign_ = 0, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.add">
      <h1>Temporal.Duration.prototype.add ( _other_ [ , _options_ ] )</h1>
      <p>
        The `add` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Set _other_ to ? ToLimitedTemporalDuration(_other_, « »).
        1. Perform ? RejectDurationSign(_other_.[[Years]], _other_.[[Months]], _other_.[[Weeks]], _other_.[[Days]], _other_.[[Hours]], _other_.[[Minutes]], _other_.[[Seconds]], _other_.[[Milliseconds]], _other_.[[Microseconds]], _other_.[[Nanoseconds]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalDurationOverflow(_options_).
        1. Let _result_ be ? DurationArithmetic(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], _other_.[[Years]], _other_.[[Months]], _other_.[[Weeks]], _other_.[[Days]], _other_.[[Hours]], _other_.[[Minutes]], _other_.[[Seconds]], _other_.[[Milliseconds]], _other_.[[Microseconds]], _other_.[[Nanoseconds]], _overflow_).
        1. Return ? CreateTemporalDurationFromInstance(_duration_, _result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.subtract">
      <h1>Temporal.Duration.prototype.subtract ( _other_ [ , _options_ ] )</h1>
      <p>
        The `subtract` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Set _other_ to ? ToLimitedTemporalDuration(_other_, « »).
        1. Perform ? RejectDurationSign(_other_.[[Years]], _other_.[[Months]], _other_.[[Weeks]], _other_.[[Days]], _other_.[[Hours]], _other_.[[Minutes]], _other_.[[Seconds]], _other_.[[Milliseconds]], _other_.[[Microseconds]], _other_.[[Nanoseconds]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalDurationOverflow(_options_).
        1. Let _result_ be ? DurationArithmetic(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], −_other_.[[Years]], −_other_.[[Months]], −_other_.[[Weeks]], −_other_.[[Days]], −_other_.[[Hours]], −_other_.[[Minutes]], −_other_.[[Seconds]], −_other_.[[Milliseconds]], −_other_.[[Microseconds]], −_other_.[[Nanoseconds]], _overflow_).
        1. Return ? CreateTemporalDurationFromInstance(_duration_, _result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.round">
      <h1>Temporal.Duration.prototype.round ( _options_ )</h1>
      <p>
        The `round` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, *"nanoseconds"*).
        1. Let _defaultLargestUnit_ be ! DefaultTemporalLargestUnitForRounding(_duration_).
        1. Set _default_largestUnit_ to ! LargerOfTwoTemporalDurationUnits(_defaultLargestUnit_, _smallestUnit_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, _defaultLargestUnit_).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. Let _relativeTo_ be ? ToRelativeTemporalObject(_options_).
        1. Let _unbalanceResult_ be ? UnbalanceDurationRelative(_years_, _months_, _weeks_, days_, _largestUnit_, _relativeTo_).
        1. Let _roundResult_ be ? RoundDuration(_unbalanceResult_.[[Years]], _unbalanceResult_.[[Months]], _unbalanceResult_.[[Weeks]], _unbalanceResult_.[[Days]], _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, _roundingIncrement_, _smallestUnit_, _roundingMode_, _relativeTo_).
        1. Let _balanceResult_ be ? BalanceDurationRelative(_roundResult_.[[Years]], _roundResult_.[[Months]], _roundResult_.[[Weeks]], _roundResult_.[[Days]], _largestUnit_, _relativeTo_).
        1. Let _result_ be ? BalanceDuration(_balanceResult_.[[Days]], _roundResult_.[[Hours]], _roundResult_.[[Minutes]], _roundResult_.[[Seconds]], _roundResult_.[[Milliseconds]], _roundResult_.[[Microseconds]], _roundResult.[[Nanoseconds]]).
        1. Return ? CreateTemporalDurationFromInstance(_duration_, _balanceResult_.[[Years]], _balanceResult_.[[Months]], _balanceResult_.[[Weeks]], _result_.[[Days]], _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.getfields">
      <h1>Temporal.Duration.prototype.getFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Let _record_ be ? ToPartialDuration(_duration_).
        1. Let _fields_ be ? ObjectCreate(%ObjectPrototype%).
        1. For each row of <emu-xref href="#table-temporal-temporaldurationlike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _p_ be the Property value of the current row.
          1. Let _v_ be the value of _record_'s field whose name is the Internal Slot value of the current row.
          1. Perform ! CreateDataPropertyOrThrow(_fields_, _p_, _v_).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.tostring">
      <h1>Temporal.Duration.prototype.toString ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ! TemporalDurationToString(_duration_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.tojson">
      <h1>Temporal.Duration.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ! TemporalDurationToString(_duration_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.tolocalestring">
      <h1>Temporal.Duration.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. If the implementation does not include the ECMA-402 Internationalization API, then
          1. Return ! TemporalDurationToString(_duration_).
        1. If the implementation does not include the `Intl.DurationFormat` API, then
          1. Return ! TemporalDurationToString(_duration_).
        1. Let _durationFormat_ be ? Construct(%Intl.DurationFormat%, « _locales_, _options_ »).
        1. Return ? FormatDuration(_durationFormat_, _duration_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.valueof">
      <h1>Temporal.Duration.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-duration-instances">
    <h1>Properties of Temporal.Duration Instances</h1>
    <p>
      Temporal.Duration instances are ordinary objects that inherit properties from the %Temporal.Duration.prototype% intrinsic object.
      Temporal.Duration instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporalduration-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporalduration-instances" caption="Internal Slots of Temporal.Duration Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalDuration]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.Duration instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[Years]]
            </td>
            <td>
              An integer Number value representing the number of years in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Months]]
            </td>
            <td>
              An integer Number value representing the number of months in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Weeks]]
            </td>
            <td>
              An integer Number value representing the number of weeks in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Days]]
            </td>
            <td>
              An integer Number value representing the number of days in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Hours]]
            </td>
            <td>
              An integer Number value representing the number of hours in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Minutes]]
            </td>
            <td>
              An integer Number value representing the number of minutes in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Seconds]]
            </td>
            <td>
              An integer Number value representing the number of seconds in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Milliseconds]]
            </td>
            <td>
              An integer Number value representing the number of milliseconds in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Microseconds]]
            </td>
            <td>
              An integer Number value representing the number of microseconds in the duration.
            </td>
          </tr>
          <tr>
            <td>
              [[Nanoseconds]]
            </td>
            <td>
              An integer Number value representing the number of nanoseconds in the duration.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-duration-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-temporal-totemporalduration" aoid="ToTemporalDuration">
      <h1>ToTemporalDuration ( _item_ [ , _constructor_ ] )</h1>
      <p>
        The abstract operation ToTemporalDuration returns its argument _item_ if it is already a Temporal.Duration instance, converts _item_ to a new Temporal.Duration instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _constructor_ is not given, set it to %Temporal.Duration%.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalDuration]] internal slot, then
            1. Return _item_.
          1. Let _result_ be ? ToTemporalDurationRecord(_item_).
        1. Else,
          1. Let _string_ be ? ToString(_item_).
          1. Let _result_ be ? ParseTemporalDurationString(_string_).
        1. Return ? CreateTemporalDurationFromStatic(_constructor_, _result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]],
        _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldurationrecord" aoid="ToTemporalDurationRecord">
      <h1>ToTemporalDurationRecord ( _temporalDurationLike_ )</h1>
      <emu-note>The value of ? ToInteger(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. Assert: Type(_temporalDurationLike_) is Object.
        1. If _temporalDurationLike_ has an [[InitializedTemporalDuration]] internal slot, then
          1. Return the Record {
              [[Years]]: _temporalDurationLike_.[[Years]],
              [[Months]]: _temporalDurationLike_.[[Months]],
              [[Weeks]]: _temporalDurationLike_.[[Weeks]],
              [[Days]]: _temporalDurationLike_.[[Days]],
              [[Hours]]: _temporalDurationLike_.[[Hours]],
              [[Minutes]]: _temporalDurationLike_.[[Minutes]],
              [[Seconds]]: _temporalDurationLike_.[[Seconds]],
              [[Milliseconds]]: _temporalDurationLike_.[[Milliseconds]],
              [[Microseconds]]: _temporalDurationLike_.[[Microseconds]],
              [[Nanoseconds]]: _temporalDurationLike_.[[Nanoseconds]]
            }.
        1. Let _result_ be a new Record with all the internal slots given in the Internal Slot column in <emu-xref href="#table-temporal-temporaldurationlike-properties"></emu-xref>.
        1. Let _any_ be *false*.
        1. For each row of <emu-xref href="#table-temporal-temporaldurationlike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _prop_ be the Property value of the current row.
          1. Let _val_ be ? Get(_temporalDurationLike_, _prop_).
          1. If _val_ is not *undefined*, then
            1. Set _any_ to *true*.
          1. Let _val_ be ? ToInteger(_val_).
          1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _val_.
        1. If _any_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-durationsign" aoid="DurationSign">
      <h1>DurationSign ( _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ )</h1>
      <emu-alg>
        1. For each value _v_ of _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, do
          1. If _v_ &lt; 0, return −1.
          1. If _v_ &gt; 0, return 1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-rejectdurationsign" aoid="RejectDurationSign">
      <h1>RejectDurationSign ( _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ )</h1>
      <emu-alg>
        1. Let _sign_ be ! DurationSign(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. For each value _v_ of _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, do
          1. If _v_ &lt; 0 and _sign_ &gt; 0, throw a *RangeError* exception.
          1. If _v_ &gt; 0 and _sign_ &lt; 0, throw a *RangeError* exception.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-validatetemporalduration" aoid="ValidateTemporalDuration">
      <h1>ValidateTemporalDuration ( _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ )</h1>
      <emu-alg>
        1. Let _sign_ be ! DurationSign(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. For each value _v_ of _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, do
          1. If _v_ is infinite, return *false*.
          1. If _v_ &lt; 0 and _sign_ &gt; 0, return *false*.
          1. If _v_ &gt; 0 and _sign_ &lt; 0, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-defaulttemporallargestunitforrounding" aoid="DefaultTemporalLargestUnitForRounding">
      <h1>DefaultTemporalLargestUnitForRounding ( _duration_ )</h1>
      <p>
        The abstract operation DefaultTemporalLargestUnitForRounding implements the logic used in the `Temporal.Duration.prototype.round()` method, where the `largestUnit` option, if not given explicitly, is set to the largest non-zero unit in the input Temporal.Duration.
      </p>
      <emu-alg>
        1. Assert: _duration_ has an [[InitializedTemporalDuration]] internal slot.
        1. If _duration_.[[Years]] is not zero, return *"years"*.
        1. If _duration_.[[Months]] is not zero, return *"months"*.
        1. If _duration_.[[Weeks]] is not zero, return *"weeks"*.
        1. If _duration_.[[Days]] is not zero, return *"days"*.
        1. If _duration_.[[Hours]] is not zero, return *"hours"*.
        1. If _duration_.[[Minutes]] is not zero, return *"minutes"*.
        1. If _duration_.[[Seconds]] is not zero, return *"seconds"*.
        1. If _duration_.[[Milliseconds]] is not zero, return *"milliseconds"*.
        1. If _duration_.[[Microseconds]] is not zero, return *"microseconds"*.
        1. Return *"nanoseconds"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-topartialduration" aoid="ToPartialDuration">
      <h1>ToPartialDuration ( _temporalDurationLike_ )</h1>
      <emu-alg>
        1. If Type(_temporalDurationLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be the new Record {
            [[Years]]: *undefined*,
            [[Months]]: *undefined*,
            [[Weeks]]: *undefined*,
            [[Days]]: *undefined*,
            [[Hours]]: *undefined*,
            [[Minutes]]: *undefined*,
            [[Seconds]]: *undefined*,
            [[Milliseconds]]: *undefined*,
            [[Microseconds]]: *undefined*,
            [[Nanoseconds]]: *undefined*
          }.
        1. Let _any_ be *false*.
        1. For each row of <emu-xref href="#table-temporal-temporaldurationlike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalDurationLike_, _property_).
          1. If _value_ is not *undefined*, then
            1. Set _any_ to *true*.
            1. Set _value_ to ? ToInteger(_value_).
            1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
        1. If _any_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalduration" aoid="CreateTemporalDuration">
      <h1>CreateTemporalDuration ( _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. If ! ValidateTemporalDuration(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_) is *false*, then
          1. Throw a *RangeError* exception.
        1. If _newTarget_ is not given, set it to %Temporal.Duration%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%Temporal.Duration.prototype%"`, « [[InitializedTemporalDuration]], [[Years]], [[Months]], [[Weeks]], [[Days]], [[Hours]], [[Minutes]], [[Seconds]], [[Milliseconds]], [[Microseconds]], [[Nanoseconds]] »).
        1. Set _object_.[[Years]] to _years_.
        1. Set _object_.[[Months]] to _months_.
        1. Set _object_.[[Weeks]] to _weeks_.
        1. Set _object_.[[Days]] to _days_.
        1. Set _object_.[[Hours]] to _hours_.
        1. Set _object_.[[Minutes]] to _minutes_.
        1. Set _object_.[[Seconds]] to _seconds_.
        1. Set _object_.[[Milliseconds]] to _milliseconds_.
        1. Set _object_.[[Microseconds]] to _microseconds_.
        1. Set _object_.[[Nanoseconds]] to _nanoseconds_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldurationfrominstance" aoid="CreateTemporalDurationFromInstance">
      <h1>CreateTemporalDurationFromInstance ( _duration_, _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ )</h1>
      <emu-alg>
        1. Assert: Type(_duration_) is Object and _duration_ has an [[InitializedTemporalDuration]] internal slot.
        1. Assert: ! ValidateDuration(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_) is *true*.
        1. Let _constructor_ be ? SpeciesConstructor(_duration_, %Temporal.Duration%).
        1. Let _result_ be ? Construct(_constructor_, « _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ »).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDuration]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldurationfromstatic" aoid="CreateTemporalDurationFromStatic">
      <h1>CreateTemporalDurationFromStatic ( _constructor_, _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ )</h1>
      <emu-alg>
        1. Assert: ! ValidateDuration(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_) is *true*.
        1. If ! IsConstructor(_constructor_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? Construct(_constructor_, « _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ »).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDuration]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balanceduration" aoid="BalanceDuration">
      <h1>BalanceDuration ( _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, _largestUnit_ )</h1>
      <emu-alg>
        1. Let _sign_ be ! DurationSign(0, 0, 0, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Let _bt_ be ? BalanceTime(abs(_hours_), abs(_minutes_), abs(_seconds_), abs(_milliseconds_), abs(_microseconds_), abs(_nanoseconds_)).
        1. Increment _days_ by _bt_.[[Days]].
        1. Set _hours_ to _bt_.[[Hour]].
        1. Set _minutes_ to _bt_.[[Minute]].
        1. Set _seconds_ to _bt_.[[Second]].
        1. Set _milliseconds_ to _bt_.[[Millisecond]].
        1. Set _microseconds_ to _bt_.[[Microsecond]].
        1. Set _nanoseconds_ to _bt_.[[Nanosecond]].
        1. If _largestUnit_ is *"hours"*, *"minutes"*, *"seconds"*, *"milliseconds"*, *"microseconds"*, or *"nanoseconds"*, then
          1. Increment _hours_ by 24 × _days_.
          1. Set _days_ to 0.
        1. If _largestUnit_ is *"minutes"*, *"seconds"*, *"milliseconds"*, *"microseconds"*, or *"nanoseconds"*, then
          1. Increment _minutes_ by 60 × _hours_.
          1. Set _hours_ to 0.
        1. If _largestUnit_ is *"seconds"*, *"milliseconds"*, *"microseconds"*, or *"nanoseconds"*, then
          1. Increment _seconds_ by 60 × _minutes_.
          1. Set _minutes_ to 0.
        1. If _largestUnit_ is *"milliseconds"*, *"microseconds"*, or *"nanoseconds"*, then
          1. Increment _milliseconds_ by 1000 × _seconds_.
          1. Set _seconds_ to 0.
        1. If _largestUnit_ is *"microseconds"* or *"nanoseconds"*, then
          1. Increment _microseconds_ by 1000 × _milliseconds_.
          1. Set _milliseconds_ to 0.
        1. If _largestUnit_ is *"nanoseconds"*, then
          1. Increment _nanoseconds_ by 1000 × _microseconds_.
          1. Set _microseconds_ to 0.
        1. Return the new Record {
          [[Days]]: _days_ × _sign_,
          [[Hours]]: _hours_ × _sign_,
          [[Minutes]]: _minutes_ × _sign_,
          [[Seconds]]: _seconds_ × _sign_,
          [[Milliseconds]]: _milliseconds_ × _sign_,
          [[Microseconds]]: _microseconds_ × _sign_,
          [[Nanoseconds]]: _nanoseconds_ × _sign_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-unbalancedurationrelative" aoid="UnbalanceDurationRelative">
      <h1>UnbalanceDurationRelative ( _years_, _months_, _weeks_, _days_, _largestUnit_, _relativeTo_ )</h1>
      <p>The abstract operation UnbalanceDurationRelative converts the calendar units of a Temporal.Duration into a form where no unit is larger than _largestUnit_.</p>
      <emu-alg>
        1. If _largestUnit_ is *"years"*, then
          1. Return the new Record {
            [[Years]]: _years_,
            [[Months]]: _months_,
            [[Weeks]]: _weeks_,
            [[Days]]: _days_
            }.
        1. Let _sign_ be ! DurationSign(_years_, _months_, _weeks_, _days_, 0, 0, 0, 0, 0, 0).
        1. Set _years_ to abs(_years_).
        1. Set _months_ to abs(_months_).
        1. Set _weeks_ to abs(_weeks_).
        1. Set _days_ to abs(_days_).
        1. Let _oneYear_ be ! CreateTemporalDuration(1, 0, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _oneMonth_ be ! CreateTemporalDuration(0, 1, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _oneWeek_ be ! CreateTemporalDuration(0, 0, 1, 0, 0, 0, 0, 0, 0, 0).
        1. Let _addOptions_ be ! OrdinaryObjectCreate(%Object.prototype%).
        1. If _relativeTo_ is not *undefined*, then
          1. Assert: _relativeTo_ has a [[Calendar]] internal slot.
          1. Let _calendar_ be _relativeTo_.[[Calendar]].
        1. Else,
          1. Let _calendar_ be *undefined*.
        1. If _largestUnit_ is *"months"*, then
          1. If _calendar_is *undefined*, then
            1. Throw a *RangeError* exception.
          1. Let _monthsInYear_ be ? Get(_calendar_, *"monthsInYear"*).
          1. Let _datePlus_ be ? Get(_calendar_, *"datePlus"*).
          1. Repeat, while _years_ &gt; 0,
            1. Let _oneYearMonths_ be ? Call(_monthsInYear_, _calendar_, « _relativeTo_ »).
            1. Set _years_ to _years_ − 1.
            1. Set _months_ to _months_ + _oneYearMonths_.
            1. Set _relativeTo_ to ? Call(_datePlus_, _calendar_, « _relativeTo_, _oneYear_, _addOptions_, %Temporal.Date%).
        1. Else if _largestUnit_ is *"weeks"*, then
          1. If _calendar_ is *undefined*, then
            1. Throw a *RangeError* exception.
          1. Let _daysInYear_ be ? Get(_calendar_, *"daysInYear"*).
          1. Let _daysInMonth_ be ? Get(_calendar_, *"daysInMonth"*).
          1. Let _datePlus_ be ? Get(_calendar_, *"datePlus"*).
          1. Repeat, while _years_ &gt; 0,
            1. Let _oneYearDays_ be ? Call(_daysInYear_, _calendar_, « _relativeTo_ »).
            1. Set _years_ to _years_ − 1.
            1. Set _days_ to _days_ + _oneYearDays_.
            1. Set _relativeTo_ to ? Call(_datePlus_, _calendar_, « _relativeTo_, _oneYear_, _addOptions_, %Temporal.Date%).
          1. Repeat, while _months_ &gt; 0,
            1. Let _oneMonthDays_ be ? Call(_daysInMonth_, _calendar_, « _relativeTo_ »).
            1. Set _months_ to _months_ − 1.
            1. Set _days_ to _days_ + _oneMonthDays_.
            1. Set _relativeTo_ to ? Call(_datePlus_, _calendar_, « _relativeTo_, _oneMonth_, _addOptions_, %Temporal.Date%).
        1. Else,
          1. If any of _years_, _months_, and _days_ are not zero, then
            1. If _calendar_ is *undefined*, then
              1. Throw a *RangeError* exception.
            1. Let _daysInYear_ be ? Get(_calendar_, *"daysInYear"*).
            1. Let _daysInMonth_ be ? Get(_calendar_, *"daysInMonth"*).
            1. Let _daysInWeek_ be ? Get(_calendar_, *"daysInWeek"*).
            1. Let _datePlus_ be ? Get(_calendar_, *"datePlus"*).
            1. Repeat, while _years_ &gt; 0,
              1. Let _oneYearDays_ be ? Call(_daysInYear_, _calendar_, « _relativeTo_ »).
              1. Set _years_ to _years_ − 1.
              1. Set _days_ to _days_ + _oneYearDays_.
              1. Set _relativeTo_ to ? Call(_datePlus_, _calendar_, « _relativeTo_, _oneYear_, _addOptions_, %Temporal.Date%).
            1. Repeat, while _months_ &gt; 0,
              1. Let _oneMonthDays_ be ? Call(_daysInMonth_, _calendar_, « _relativeTo_ »).
              1. Set _months_ to _months_ − 1.
              1. Set _days_ to _days_ + _oneMonthDays_.
              1. Set _relativeTo_ to ? Call(_datePlus_, _calendar_, « _relativeTo_, _oneMonth_, _addOptions_, %Temporal.Date%).
            1. Repeat, while _weeks_ &gt; 0,
              1. Let _oneWeekDays_ be ? Call(_daysInWeek_, _calendar_, « _relativeTo_ »).
              1. Set _weeks_ to _weeks_ − 1.
              1. Set _days_ to _days_ + _oneWeekDays_.
              1. Set _relativeTo_ to ? Call(_datePlus_, _calendar_, « _relativeTo_, _oneWeek_, _addOptions_, %Temporal.Date%).
        1. Return the new Record {
          [[Years]]: _years_ × _sign_,
          [[Months]]: _months_ × _sign_,
          [[Weeks]]: _weeks_ × _sign,
          [[Days]]: _days_ × _sign_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancedurationrelative" aoid="BalanceDurationRelative">
      <h1>BalanceDurationRelative ( _years_, _months_, _weeks_, _days_, _largestUnit_, _relativeTo_ )</h1>
      <p>The abstract operation BalanceDurationRelative converts the calendar units of a duration into a form where lower units are converted into higher units as much as possible, up to _largestUnit_.</p>
      <emu-alg>
        1. If _largestUnit_ is not one of *"years"*, *"months"*, or *"weeks"*, then
          1. Return the new Record {
            [[Years]]: _years_,
            [[Months]]: _months_,
            [[Weeks]]: _weeks_,
            [[Days]]: _days_
            }.
        1. Let _sign_ be ! DurationSign(_years_, _months_, _weeks_, _days_, 0, 0, 0, 0, 0, 0).
        1. Set _years_ to abs(_years_).
        1. Set _months_ to abs(_months_).
        1. Set _weeks_ to abs(_weeks_).
        1. Set _days_ to abs(_days_).
        1. Let _oneYear_ be ! CreateTemporalDuration(1, 0, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _oneMonth_ be ! CreateTemporalDuration(0, 1, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _oneWeek_ be ! CreateTemporalDuration(0, 0, 1, 0, 0, 0, 0, 0, 0, 0).
        1. Let _subtractOptions_ be ! OrdinaryObjectCreate(%Object.prototype%).
        1. If _relativeTo_ is *undefined*, then
          1. Throw a *RangeError* exception.
        1. Assert: _relativeTo_ has a [[Calendar]] internal slot.
        1. Let _calendar_ be _relativeTo_.[[Calendar]].
        1. If _largestUnit_ is *"years"*, then
          1. Let _daysInYear_ be ? Get(_calendar_, *"daysInYear"*).
          1. Let _daysInMonth_ be ? Get(_calendar_, *"daysInMonth"*).
          1. Let _monthsInYear_ be ? Get(_calendar_, *"monthsInYear"*).
          1. Let _dateMinus_ be ? Get(_calendar_, *"dateMinus"*).
          1. Let _oneYearDays_ be ? Call(_daysInYear_, _calendar_, « _relativeTo_ »).
          1. Repeat, while _days_ &gt; _oneYearDays_,
            1. Set _days_ to _days_ − _oneYearDays_.
            1. Set _years_ to _years_ + 1.
            1. Set _relativeTo_ to ? Call(_dateMinus_, _calendar_, « _relativeTo_, _oneYear_, _subtractOptions_, %Temporal.Date%).
            1. Set _oneYearDays_ to ? Call(_daysInYear_, _calendar_, « _relativeTo_ »).
          1. Let _oneMonthDays_ be ? Call(_daysInMonth_, _calendar_, « _relativeTo_ »).
          1. Repeat, while _days_ &gt; _oneMonthDays_,
            1. Set _days_ to _days_ − _oneMonthDays_.
            1. Set _months_ to _months_ + 1.
            1. Set _relativeTo_ to ? Call(_dateMinus_, _calendar_, « _relativeTo_, _oneMonth_, _subtractOptions_, %Temporal.Date%).
            1. Set _oneMonthDays_ to ? Call(_daysInMonth_, _calendar_, « _relativeTo_ »).
          1. Let _oneYearMonths_ be ? Call(_monthsInYear_, _calendar_, « _relativeTo_ »).
          1. Repeat, while _months_ &gt; _oneYearMonths_,
            1. Set _months_ to _months_ − _oneYearMonths_.
            1. Set _years_ to _years_ + 1.
            1. Set _relativeTo_ to ? Call(_dateMinus_, _calendar_, « _relativeTo_, _oneYear_, _subtractOptions_, %Temporal.Date%).
            1. Set _oneYearMonths_ to ? Call(_monthsInYear_, _calendar_, « _relativeTo_ »).
        1. Else if _largestUnit_ is *"months"*, then
          1. Let _daysInMonth_ be ? Get(_calendar_, *"daysInMonth"*).
          1. Let _dateMinus_ be ? Get(_calendar_, *"dateMinus"*).
          1. Let _oneMonthDays_ be ? Call(_daysInMonth_, _calendar_, « _relativeTo_ »).
          1. Repeat, while _days_ &gt; _oneMonthDays_,
            1. Set _days_ to _days_ − _oneMonthDays_.
            1. Set _months_ to _months_ + 1.
            1. Set _relativeTo_ to ? Call(_dateMinus_, _calendar_, « _relativeTo_, _oneMonth_, _subtractOptions_, %Temporal.Date%).
            1. Set _oneMonthDays_ to ? Call(_daysInMonth_, _calendar_, « _relativeTo_ »).
        1. Else,
          1. Assert: _largestUnit_ is *"weeks"*.
          1. Let _daysInWeek_ be ? Get(_calendar_, *"daysInWeek"*).
          1. Let _dateMinus_ be ? Get(_calendar_, *"dateMinus"*).
          1. Let _oneWeekDays_ be ? Call(_daysInWeek_, _calendar_, « _relativeTo_ »).
          1. Repeat, while _days_ &gt; _oneWeekDays_,
            1. Set _days_ to _days_ − _oneWeekDays_.
            1. Set _weeks_ to _weeks_ + 1.
            1. Set _relativeTo_ to ? Call(_dateMinus_, _calendar_, « _relativeTo_, _oneWeek_, _subtractOptions_, %Temporal.Date%).
            1. Set _oneWeekDays_ to ? Call(_daysInWeek_, _calendar_, « _relativeTo_ »).
        1. Return the new Record {
          [[Years]]: _years_ × _sign_,
          [[Months]]: _months_ × _sign_,
          [[Weeks]]: _weeks_ × _sign_,
          [[Days]]: _days_ × _sign_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-regulateduration" aoid="RegulateDuration">
      <h1>RegulateDuration ( _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _overflow_ is either *"constrain"* or *"balance"*.
        1. If ! ValidateTemporalDuration(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_) is *false*, then
          1. Throw a *RangeError* exception.
        1. If _overflow_ is *"balance"*, then
          1. Let _bd_ be ! BalanceDuration(_days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, *"days"*).
          1. Set _days_ to _bd_.[[Days]].
          1. Set _hours_ to _bd_.[[Hours]].
          1. Set _minutes_ to _bd_.[[Minutes]].
          1. Set _seconds_ to _bd_.[[Seconds]].
          1. Set _milliseconds_ to _bd_.[[Milliseconds]].
          1. Set _microseconds_ to _bd_.[[Microseconds]].
          1. Set _nanoseconds_ to _bd_.[[Nanoseconds]].
          1. If ! ValidateTemporalDuration(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_) is *false*, then
            1. Throw a *RangeError* exception.
        1. Return the new Record {
          [[Years]]: _years_,
          [[Months]]: _months_,
          [[Weeks]]: _weeks_,
          [[Days]]: _days_,
          [[Hours]]: _hours_,
          [[Minutes]]: _minutes_,
          [[Seconds]]: _seconds_,
          [[Milliseconds]]: _milliseconds_,
          [[Microseconds]]: _microseconds_,
          [[Nanoseconds]]: _nanoseconds_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-durationarithmetic" aoid="DurationArithmetic">
      <h1>DurationArithmetic ( _y1_, _mon1_, _w1_, _d1_, _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _y2_, _mon2_, _w2_, _d2_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _y1_, _mon1_, _w1_, _d1_, _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _y2_, _mon2_, _w2_, _d2_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_ are integer Number values.
        1. Assert: _overflow_ is either *"balance"* or *"constrain"*.
        1. Let _nanoseconds_ be _ns1_ + _ns2_.
        1. Let _microseconds_ be _mus1_ + _mus2_.
        1. Let _milliseconds_ be _ms1_ + _ms2_.
        1. Let _seconds_ be _s1_ + _s2_.
        1. Let _minutes_ be _min1_ + _min2_.
        1. Let _hours_ be _h1_ + _h2_.
        1. Let _days_ be _d1_ + _d2_.
        1. Let _weeks_ be _w1_ + _w2_.
        1. Let _months_ be _mon1_ + _mon2_.
        1. Let _years_ be _y1_ + _y2_.
        1. Let _sign_ be ! DurationSign(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Set _years_ to _years_ × _sign_.
        1. Set _months_ to _months_ × _sign_.
        1. Set _weeks_ to _weeks_ × _sign_.
        1. Set _days_ to _days_ × _sign_.
        1. Set _hours_ to _hours_ × _sign_.
        1. Set _minutes_ to _minutes_ × _sign_.
        1. Set _seconds_ to _seconds_ × _sign_.
        1. Set _milliseconds_ to _milliseconds_ × _sign_.
        1. Set _microseconds_ to _microseconds_ × _sign_.
        1. Set _nanoseconds_ to _nanoseconds_ × _sign_.
        1. If _nanoseconds_ &lt; 0, then
          1. Set _microseconds_ to _microseconds_ + floor(_nanoseconds_ / 1000).
          1. Set _nanoseconds_ to ! NonNegativeModulo(_nanoseconds_, 1000).
        1. If _microseconds_ &lt; 0, then
          1. Set _milliseconds_ to _milliseconds_ + floor(_microseconds_ / 1000).
          1. Set _microseconds_ to ! NonNegativeModulo(_microseconds_, 1000).
        1. If _milliseconds_ &lt; 0, then
          1. Set _seconds_ to _seconds_ + floor(_milliseconds_ / 1000).
          1. Set _milliseconds_ to ! NonNegativeModulo(_milliseconds_, 1000).
        1. If _seconds_ &lt; 0, then
          1. Set _minutes_ to _minutes_ + floor(_seconds_ / 60).
          1. Set _seconds_ to ! NonNegativeModulo(_seconds_, 60).
        1. If _minutes_ &lt; 0, then
          1. Set _hours_ to _hours_ + floor(_minutes_ / 60).
          1. Set _minutes_ to ! NonNegativeModulo(_minutes_, 60).
        1. If _hours_ &lt; 0, then
          1. Set _days_ to _days_ + floor(_hours_ / 24).
          1. Set _hours_ to ! NonNegativeModulo(_hours_, 24).
        1. If any of _months_, _weeks_, _days_ is negative, then
          1. Throw a *RangeError*.
        1. Set _years_ to _years_ × _sign_.
        1. Set _months_ to _months_ × _sign_.
        1. Set _weeks_ to _weeks_ × _sign_.
        1. Set _days_ to _days_ × _sign_.
        1. Set _hours_ to _hours_ × _sign_.
        1. Set _minutes_ to _minutes_ × _sign_.
        1. Set _seconds_ to _seconds_ × _sign_.
        1. Set _milliseconds_ to _milliseconds_ × _sign_.
        1. Set _microseconds_ to _microseconds_ × _sign_.
        1. Set _nanoseconds_ to _nanoseconds_ × _sign_.
        1. Return ? RegulateDuration(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundduration" aoid="RoundDuration">
      <h1>RoundDuration ( _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, _increment_, _unit_, _roundingMode_ [ , _relativeTo_ ] )</h1>
      <emu-alg>
        1. Let _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_, and _increment_ each be the mathematical values of themselves.
        1. If _unit_ is *"years"*, *"months"*, or *"weeks"*, then
          1. If _relativeTo_ is not given, then
            1. Throw a *RangeError* exception.
          1. Else,
            1. Perform ? RequireInternalSlot(_relativeTo_, [[InitializedTemporalDateTime]]).
            1. Let _calendar_ be _relativeTo_.[[Calendar]].
            1. Let _dateSubtract_ be ? Get(_calendar_, *"dateSubtract"*).
            1. Let _options_ be ? ObjectCreate(%Object.prototype%).
        1. Let _fractionalSeconds_ be _nanoseconds_ × 10<sup>−9</sup> + _microseconds_ × 10<sup>−6</sup> + _milliseconds_ × 10<sup>−3</sup> + _seconds_.
        1. Let _fractionalDays_ be ((_fractionalSeconds_ / 60 + _minutes_) / 60 + _hours_) / 24 + _days_.
        1. If _unit_ is *"years"*, then
          1. Let _yearsDuration_ be ? CreateTemporalDuration(_years_, 0, 0, 0, 0, 0, 0, 0, 0, 0).
          1. Let _yearsBefore_ be ? Call(_dateSubtract_, _calendar_, « _relativeTo_, _yearsDuration_, _options_, %Temporal.Date%).
          1. Let _yearsMonthsWeeks_ be ? CreateTemporalDuration(_years_, _months_, _weeks_, 0, 0, 0, 0, 0, 0, 0).
          1. Let _yearsMonthsWeeksBefore_ be ? Call(_dateSubtract_, _calendar_, « _relativeTo_, _yearsMonthsWeeks_, _options_, %Temporal.Date%).
          1. Let _monthsWeeksInDays_ be ? DifferenceDate(_yearsMonthsWeeksBefore_.[[ISOYear]], _yearsMonthsWeeksBefore_.[[ISOMonth]], _yearsMonthsWeeksBefore_.[[ISODay]], _yearsBefore_.[[ISOYear]], _yearsBefore_.[[ISOMonth]], _yearsBefore_.[[ISODay]], *"days"*).
          1. Let _days_ be _days_ + _monthsWeeksInDays_.[[Days]].
          1. Let _oneYear_ be ? CreateTemporalDuration(1, 0, 0, 0, 0, 0, 0, 0, 0, 0).
          1. Let _sign_ be ! Sign(_days_).
          1. Set _relativeTo_ to ? Call(_dateSubtract_, _calendar_, « _relativeTo_, _oneYear_, _options_, %Temporal.Date% »).
          1. Let _daysInYear_ be ? Get(_calendar_, *"daysInYear"*).
          1. Let _oneYearDays_ be ? Call(_daysInYear_, _calendar_, « _relativeTo_ »).
          1. Repeat, while _days_ ≥ _oneYearDays_,
            1. Set _years_ to _years_ + _sign_.
            1. Set _days_ to _days_ − _oneYearDays_ × _sign_.
            1. Set _relativeTo_ to ? Call(_dateMinus_, _calendar_, « _relativeTo_, _oneYear_, _options_, %Temporal.Date% »).
            1. Set _oneYearDays_ to ? Call(_daysInYear_, _calendar_, « _relativeTo_ »).
          1. Let _fractionalYears_ be _years_ + _days_ / _oneYearDays_.
          1. Set _years_ to ? RoundNumberToIncrement(_fractionalYears_, _increment_, _roundingMode_).
          1. Set _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ to 0.
        1. Else if _unit_ is *"months"*, then
          1. Let _yearsMonths_ be ? CreateTemporalDuration(_years_, _months_, 0, 0, 0, 0, 0, 0, 0, 0).
          1. Let _yearsMonthsBefore_ be ? Call(_dateSubtract_, _calendar_, « _relativeTo_, _yearsMonths_, _options_, %Temporal.Date%).
          1. Let _yearsMonthsWeeks_ be ? CreateTemporalDuration(_years_, _months_, _weeks_, 0, 0, 0, 0, 0, 0, 0).
          1. Let _yearsMonthsWeeksBefore_ be ? Call(_dateSubtract_, _calendar_, « _relativeTo_, _yearsMonthsWeeks_, _options_, %Temporal.Date%).
          1. Let _weeksInDays_ be ? DifferenceDate(_yearsMonthsWeeksBefore_.[[ISOYear]], _yearsMonthsWeeksBefore_.[[ISOMonth]], _yearsMonthsWeeksBefore_.[[ISODay]], _yearsMonthsBefore_.[[ISOYear]], _yearsMonthsBefore_.[[ISOMonth]], _yearsMonthsBefore_.[[ISODay]], *"days"*).
          1. Let _days_ be _days_ + _weeksInDays_.[[Days]].
          1. Let _oneMonth_ be ? CreateTemporalDuration(0, 1, 0, 0, 0, 0, 0, 0, 0, 0).
          1. Let _sign_ be ! Sign(_days_).
          1. Set _relativeTo_ to ? Call(_dateSubtract_, _calendar_, « _relativeTo_, _oneMonth_, _options_, %Temporal.Date% »).
          1. Let _daysInMonth_ be ? Get(_calendar_, *"daysInMonth"*).
          1. Let _oneMonthDays_ be ? Call(_daysInMonth_, _calendar_, « _relativeTo_ »).
          1. Repeat, while _days_ ≥ _oneMonthDays_,
            1. Set _months_ to _months_ + _sign_.
            1. Set _days_ to _days_ − _oneMonthDays_ × _sign_.
            1. Set _relativeTo_ to ? Call(_dateMinus_, _calendar_, « _relativeTo_, _oneMonth_, _options_, %Temporal.Date% »).
            1. Set _oneMonthDays_ to ? Call(_daysInMonth_, _calendar_, « _relativeTo_ »).
          1. Let _fractionalMonths_ be _months_ + _days_ / _oneMonthDays_.
          1. Set _months_ to ? RoundNumberToIncrement(_fractionalMonths_, _increment_, _roundingMode_).
          1. Set _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ to 0.
        1. Else if _unit_ is *"weeks"*, then
          1. Let _oneWeek_ be ? CreateTemporalDuration(0, 0, 1, 0, 0, 0, 0, 0, 0, 0).
          1. Let _sign_ be ! Sign(_days_).
          1. Set _relativeTo_ to ? Call(_dateSubtract_, _calendar_, « _relativeTo_, _oneWeek_, _options_, %Temporal.Date% »).
          1. Let _daysInWeek_ be ? Get(_calendar_, *"daysInWeek"*).
          1. Let _oneWeekDays_ be ? Call(_daysInWeek_, _calendar_, « _relativeTo_ »).
          1. Repeat, while _days_ ≥ _oneWeekDays_,
            1. Set _weeks_ to _weeks_ + _sign_.
            1. Set _days_ to _days_ − _oneWeekDays_ × _sign_.
            1. Set _relativeTo_ to ? Call(_dateMinus_, _calendar_, « _relativeTo_, _oneWeek_, _options_, %Temporal.Date% »).
            1. Set _oneWeekDays_ to ? Call(_daysInWeek_, _calendar_, « _relativeTo_ »).
          1. Let _fractionalWeeks_ be _weeks_ + _fractionalDays_ / _oneWeekDays_.
          1. Set _weeks_ to ? RoundNumberToIncrement(_fractionalWeeks_, _increment_, _roundingMode_).
          1. Set _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ to 0.
        1. Else if _unit_ is *"days"*, then
          1. Set _days_ to ? RoundNumberToIncrement(_fractionalDays_, _increment_, _roundingMode_).
          1. Set _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ to 0.
        1. Else if _unit_ is *"hours"*, then
          1. Let _fractionalHours_ be (_fractionalSeconds_ / 60 + _minutes_) / 60 + _hours_.
          1. Set _hours_ to ? RoundNumberToIncrement(_fractionalHours_, _increment_, _roundingMode_).
          1. Set _minutes_, _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ to 0.
        1. Else if _unit_ is *"minutes"*, then
          1. Let _fractionalMinutes_ be _fractionalSeconds_ / 60 + _minutes_.
          1. Set _minutes_ to ? RoundNumberToIncrement(_fractionalMinutes_, _increment_, _roundingMode_).
          1. Set _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ to 0.
        1. Else if _unit_ is *"seconds"*, then
          1. Set _seconds_ to ? RoundNumberToIncrement(_fractionalSeconds_, _increment_, _roundingMode_).
          1. Set _milliseconds_, _microseconds_, and _nanoseconds_ to 0.
        1. Else if _unit_ is *"milliseconds"*, then
          1. Let _fractionalMilliseconds_ be _nanoseconds_ × 10<sup>−6</sup> + _microseconds_ × 10<sup>−3</sup> + _milliseconds_.
          1. Set _milliseconds_ to ? RoundNumberToIncrement(_fractionalMilliseconds_, _increment_, _roundingMode_).
          1. Set _microseconds_ and _nanoseconds_ to 0.
        1. Else if _unit_ is *"microseconds"*, then
          1. Let _fractionalMicroseconds_ be _nanoseconds_ × 10<sup>−3</sup> + _microseconds_.
          1. Set _microseconds_ to ? RoundNumberToIncrement(_fractionalMicroseconds_, _increment_, _roundingMode_).
          1. Set _nanoseconds_ to 0.
        1. Else,
          1. Assert: _unit_ is *"nanoseconds"*.
          1. Set _nanoseconds_ to ? RoundNumberToIncrement(_nanoseconds_, _increment_, _roundingMode_).
        1. Return the new Record {
          [[Years]]: _years_,
          [[Months]]: _months_,
          [[Weeks]]: _weeks_,
          [[Days]]: _days_,
          [[Hours]]: _hours_,
          [[Minutes]]: _minutes_,
          [[Seconds]]: _seconds_,
          [[Milliseconds]]: _milliseconds_,
          [[Microseconds]]: _microseconds_,
          [[Nanoseconds]]: _nanoseconds_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-tolimitedtemporalduration" aoid="ToLimitedTemporalDuration">
      <h1>ToLimitedTemporalDuration ( _temporalDurationLike_, _disallowedFields_ )</h1>
      <emu-alg>
        1. If Type(_temporalDurationLike_) is not Object, then
          1. Let _str_ be ? ToString(_temporalDurationLike_).
          1. Let _duration_ be ? ParseTemporalDurationString(_str_).
        1. Else,
          1. Let _duration_ be ? ToTemporalDurationRecord(_temporalDurationLike_).
        1. If ! ValidateTemporalDuration(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. For each row of <emu-xref href="#table-temporal-temporaldurationlike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _prop_ be the Property value of the current row.
          1. Let _value_ be _duration_'s internal slot whose name is the Internal Slot value of the current row.
          1. If _value_ is not 0 and _disallowedFields_ contains _prop_, then
            1. Throw a *RangeError* exception.
        1. Return _duration_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldurationtostring" aoid="TemporalDurationToString">
      <h1>TemporalDurationToString ( _duration_ )</h1>
      <emu-alg>
        1. Let _years_ be _duration_.[[Years]].
        1. Let _months_ be _duration_.[[Months]].
        1. Let _weeks_ be _duration_.[[Weeks]].
        1. Let _days_ be _duration_.[[Days]].
        1. Let _hours_ _duration_.[[Hours]].
        1. Let _minutes_ _duration_.[[Minutes]].
        1. Let _seconds_ be the mathematical value of _duration_.[[Seconds]].
        1. Let _milliseconds_ be the mathematical value of _duration_.[[Milliseconds]].
        1. Let _microseconds_ be the mathematical value of _duration_.[[Microseconds]].
        1. Let _nanoseconds_ be the mathematical value of _duration_.[[Nanoseconds]].
        1. Let _sign_ be ! DurationSign(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Set _microseconds_ to _microseconds_ + the integral part of _nanoseconds_ / 1000.
        1. Set _nanoseconds_ to _nanoseconds_ modulo 1000.
        1. Set _milliseconds_ to _milliseconds_ + the integral part of _microseconds_ / 1000.
        1. Set _microseconds_ to _microseconds_ modulo 1000.
        1. Set _seconds_ to _seconds_ + the integral part of _milliseconds_ / 1000.
        1. Set _milliseconds_ to _milliseconds_ modulo 1000.
        1. If _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ are all 0, then
          1. Return the string `"PT0S"`.
        1. Let _datePart_ be `""`.
        1. If _years_ is not 0, then
          1. Set _datePart_ to the string concatenation of abs(_years_) formatted as a decimal number and the code unit 0x0059 (LATIN CAPITAL LETTER Y).
        1. If _months_ is not 0, then
          1. Set _datePart_ to the string concatenation of _datePart_, abs(_months_) formatted as a decimal number, and the code unit 0x004D (LATIN CAPITAL LETTER M).
        1. If _weeks_ is not 0, then
          1. Set _datePart_ to the string concatenation of _datePart_, abs(_weeks_) formatted as a decimal number, and the code unit 0x0057 (LATIN CAPITAL LETTER W).
        1. If _days_ is not 0, then
          1. Set _datePart_ to the string concatenation of _datePart_, abs(_days_) formatted as a decimal number, and the code unit 0x0044 (LATIN CAPITAL LETTER D).
        1. Let _timePart_ be `""`.
        1. If _hours_ is not 0, then
          1. Set _timePart_ to the string concatenation of abs(_hours_) formatted as a decimal number and the code unit 0x0048 (LATIN CAPITAL LETTER H).
        1. If _minutes_ is not 0, then
          1. Set _timePart_ to the string concatenation of _timePart_, abs(_minutes_) formatted as a decimal number, and the code unit 0x004D (LATIN CAPITAL LETTER M).
        1. If any of _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ are not 0, then
          1. Let _nanosecondsPart_, _microsecondsPart_, and _millisecondsPart_ be *""*.
          1. If _nanoseconds_ is not 0, then
            1. Set _nanosecondsPart_ to _nanoseconds_ formatted as a three-digit decimal number, padded to the left with zeroes if necessary.
            1. Set _microsecondsPart_ and _millisecondsPart_ to *"000"*.
          1. If _microseconds_ is not 0, then
            1. Set _microsecondsPart_ be _microseconds_ formatted as a three-digit decimal number, padded to the left with zeroes if necessary.
            1. Set _millisecondsPart_ to *"000"*.
          1. If _milliseconds_ is not 0, then
            1. Set _millisecondsPart_ to _milliseconds_ formatted as a three-digit decimal number, padded to the left with zeroes if necessary.
          1. Let _decimalPart_ be the string-concatenation of _millisecondsPart_, _microsecondsPart_, and _nanosecondsPart_.
          1. Let _secondsPart_ be _seconds_ formatted as a decimal number.
          1. If _decimalPart_ is not *""*, then
            1. Set _secondsPart_ to the string-concatenation of _secondsPart_, the code unit 0x002E (FULL STOP), and _decimalPart_.
          1. Set _timePart_ to the string concatenation of _timePart_, _secondsPart_, and the code unit 0x0053 (LATIN CAPITAL LETTER S).
        1. Let _signPart_ be the code unit 0x002D (HYPHEN-MINUS) if _sign_ &lt; 0, and otherwise the empty String.
        1. Let _result_ be the string concatenation of _signPart_, the code unit 0x0050 (LATIN CAPITAL LETTER P) and _datePart_.
        1. If _timePart_ is not `""`, then
          1. Set _result_ to the string concatenation of _result_, the code unit 0x0054 (LATIN CAPITAL LETTER T), _timePart_, and _secondsPart_.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-formatduration" aoid="FormatDuration">
      <h1>FormatDuration ( _durationFormat_, _duration_ )</h1>
      <emu-alg>
        1. Let _record_ be ? ToPartialDuration(_duration_).
        1. Let _formatted_ be ? PartitionDurationFormatPattern(_df_, _record_).
        1. Let _result_ be the empty String.
        1. For each Record _part_ in _formatted_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-table id="table-temporal-temporaldurationlike-properties">
      <emu-caption>Properties of a TemporalDurationLike</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Internal Slot</th>
            <th>Property</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>[[Days]]</td>
            <td>*"days"*</td>
          </tr>
          <tr>
            <td>[[Hours]]</td>
            <td>*"hours"*</td>
          </tr>
          <tr>
            <td>[[Microseconds]]</td>
            <td>*"microseconds"*</td>
          </tr>
          <tr>
            <td>[[Milliseconds]]</td>
            <td>*"milliseconds"*</td>
          </tr>
          <tr>
            <td>[[Minutes]]</td>
            <td>*"minutes"*</td>
          </tr>
          <tr>
            <td>[[Months]]</td>
            <td>*"months"*</td>
          </tr>
          <tr>
            <td>[[Nanoseconds]]</td>
            <td>*"nanoseconds"*</td>
          </tr>
          <tr>
            <td>[[Seconds]]</td>
            <td>*"seconds"*</td>
          </tr>
          <tr>
            <td>[[Weeks]]</td>
            <td>*"weeks"*</td>
          </tr>
          <tr>
            <td>[[Years]]</td>
            <td>*"years"*</td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>
</emu-clause>
