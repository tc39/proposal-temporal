<!DOCTYPE html>
<meta charset="utf8">

<emu-clause id="sec-temporal-duration-objects">
  <h1>Temporal.Duration Objects</h1>

  <p>
    A Temporal.Duration object describes the difference in elapsed time between
    two other Temporal objects of the same type: Instant, PlainDate,
    PlainDateTime, PlainTime, PlainYearMonth, or ZonedDateTime. Objects of this
    type are only created via the <i>.since()</i> and <i>.until()</i> methods of
    these objects.
  </p>

  <emu-clause id="sec-temporal-duration-constructor">
    <h1>The Temporal.Duration Constructor</h1>
    <p>The Temporal.Duration constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.Duration object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.Duration behaviour must
        include a super call to the %Temporal.Duration% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.duration">
      <h1>Temporal.Duration ( [ _years_ [ , _months_ [ , _weeks_ [ , _days_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _milliseconds_ [ , _microseconds_ [ , _nanoseconds_ ] ] ] ] ] ] ] ] ] ] )</h1>
      <p>The `Temporal.Duration` function performs the following steps when called:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If _years_ is *undefined*, let _y_ be 0; else let _y_ be ? ToIntegerIfIntegral(_years_).
        1. If _months_ is *undefined*, let _mo_ be 0; else let _mo_ be ? ToIntegerIfIntegral(_months_).
        1. If _weeks_ is *undefined*, let _w_ be 0; else let _w_ be ? ToIntegerIfIntegral(_weeks_).
        1. If _days_ is *undefined*, let _d_ be 0; else let _d_ be ? ToIntegerIfIntegral(_days_).
        1. If _hours_ is *undefined*, let _h_ be 0; else let _h_ be ? ToIntegerIfIntegral(_hours_).
        1. If _minutes_ is *undefined*, let _m_ be 0; else let _m_ be ? ToIntegerIfIntegral(_minutes_).
        1. If _seconds_ is *undefined*, let _s_ be 0; else let _s_ be ? ToIntegerIfIntegral(_seconds_).
        1. If _milliseconds_ is *undefined*, let _ms_ be 0; else let _ms_ be ? ToIntegerIfIntegral(_milliseconds_).
        1. If _microseconds_ is *undefined*, let _mis_ be 0; else let _mis_ be ? ToIntegerIfIntegral(_microseconds_).
        1. If _nanoseconds_ is *undefined*, let _ns_ be 0; else let _ns_ be ? ToIntegerIfIntegral(_nanoseconds_).
        1. Return ? CreateTemporalDuration(_y_, _mo_, _w_, _d_, _h_, _m_, _s_, _ms_, _mis_, _ns_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-duration-constructor">
    <h1>Properties of the Temporal.Duration Constructor</h1>
    <p>
      The value of the [[Prototype]] internal slot of the Temporal.Duration
      constructor is the intrinsic object %Function.prototype%.
    </p>
    <p>The Temporal.Duration constructor has the following properties:</p>

    <emu-clause id="sec-temporal.duration.prototype">
      <h1>Temporal.Duration.prototype</h1>
      <p>
        The initial value of `Temporal.Duration.prototype` is
        %Temporal.Duration.prototype%.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]:
        *false*, [[Configurable]]: *false* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.from">
      <h1>Temporal.Duration.from ( _item_ )</h1>
      <p>The `Temporal.Duration.from` function performs the following steps when called:</p>
      <emu-alg>
        1. Return ? ToTemporalDuration(_item_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.compare">
      <h1>Temporal.Duration.compare ( _one_, _two_ [ , _options_ ] )</h1>
      <p>The `Temporal.Duration.compare` function performs the following steps when called:</p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDuration(_one_).
        1. Set _two_ to ? ToTemporalDuration(_two_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _relativeToRecord_ be ? GetTemporalRelativeToOption(_resolvedOptions_).
        1. If _one_.[[Years]] = _two_.[[Years]], and _one_.[[Months]] = _two_.[[Months]], and _one_.[[Weeks]] = _two_.[[Weeks]], and _one_.[[Days]] = _two_.[[Days]], and _one_.[[Hours]] = _two_.[[Hours]], and _one_.[[Minutes]] = _two_.[[Minutes]], and _one_.[[Seconds]] = _two_.[[Seconds]], and _one_.[[Milliseconds]] = _two_.[[Milliseconds]], and _one_.[[Microseconds]] = _two_.[[Microseconds]], and _one_.[[Nanoseconds]] = _two_.[[Nanoseconds]], then
          1. Return *+0*<sub>ùîΩ</sub>.
        1. Let _zonedRelativeTo_ be _relativeToRecord_.[[ZonedRelativeTo]].
        1. Let _plainRelativeTo_ be _relativeToRecord_.[[PlainRelativeTo]].
        1. Let _largestUnit1_ be DefaultTemporalLargestUnit(_one_).
        1. Let _largestUnit2_ be DefaultTemporalLargestUnit(_two_).
        1. Let _duration1_ be ToInternalDurationRecord(_one_).
        1. Let _duration2_ be ToInternalDurationRecord(_two_).
        1. If _zonedRelativeTo_ is not *undefined*, and either TemporalUnitCategory(_largestUnit1_) or TemporalUnitCategory(_largestUnit2_) is ~date~, then
          1. Let _timeZone_ be _zonedRelativeTo_.[[TimeZone]].
          1. Let _calendar_ be _zonedRelativeTo_.[[Calendar]].
          1. Let _after1_ be ? AddZonedDateTime(_zonedRelativeTo_.[[EpochNanoseconds]], _timeZone_, _calendar_, _duration1_, ~constrain~).
          1. Let _after2_ be ? AddZonedDateTime(_zonedRelativeTo_.[[EpochNanoseconds]], _timeZone_, _calendar_, _duration2_, ~constrain~).
          1. If _after1_ > _after2_, return *1*<sub>ùîΩ</sub>.
          1. If _after1_ &lt; _after2_, return *-1*<sub>ùîΩ</sub>.
          1. Return *+0*<sub>ùîΩ</sub>.
        1. If IsCalendarUnit(_largestUnit1_) is *true* or IsCalendarUnit(_largestUnit2_) is *true*, then
          1. If _plainRelativeTo_ is *undefined*, throw a *RangeError* exception.
          1. Let _days1_ be ? DateDurationDays(_duration1_.[[Date]], _plainRelativeTo_).
          1. Let _days2_ be ? DateDurationDays(_duration2_.[[Date]], _plainRelativeTo_).
        1. Else,
          1. Let _days1_ be _one_.[[Days]].
          1. Let _days2_ be _two_.[[Days]].
        1. Let _timeDuration1_ be ? Add24HourDaysToTimeDuration(_duration1_.[[Time]], _days1_).
        1. Let _timeDuration2_ be ? Add24HourDaysToTimeDuration(_duration2_.[[Time]], _days2_).
        1. Return ùîΩ(CompareTimeDuration(_timeDuration1_, _timeDuration2_)).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-duration-prototype-object">
    <h1>Properties of the Temporal.Duration Prototype Object</h1>

    <p>The Temporal.Duration prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.Duration instance and doesn't have an [[InitializedTemporalDuration]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.duration.prototype.constructor">
      <h1>Temporal.Duration.prototype.constructor</h1>
      <p>The initial value of `Temporal.Duration.prototype.constructor` is %Temporal.Duration%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype-%symbol.tostringtag%">
      <h1>Temporal.Duration.prototype[ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Temporal.Duration"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.years">
      <h1>get Temporal.Duration.prototype.years</h1>
      <p>
        `Temporal.Duration.prototype.years` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Years]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.months">
      <h1>get Temporal.Duration.prototype.months</h1>
      <p>
        `Temporal.Duration.prototype.months` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Months]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.weeks">
      <h1>get Temporal.Duration.prototype.weeks</h1>
      <p>
        `Temporal.Duration.prototype.weeks` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Weeks]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.days">
      <h1>get Temporal.Duration.prototype.days</h1>
      <p>
        `Temporal.Duration.prototype.days` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Days]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.hours">
      <h1>get Temporal.Duration.prototype.hours</h1>
      <p>
        `Temporal.Duration.prototype.hours` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Hours]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.minutes">
      <h1>get Temporal.Duration.prototype.minutes</h1>
      <p>
        `Temporal.Duration.prototype.minutes` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Minutes]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.seconds">
      <h1>get Temporal.Duration.prototype.seconds</h1>
      <p>
        `Temporal.Duration.prototype.seconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Seconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.milliseconds">
      <h1>get Temporal.Duration.prototype.milliseconds</h1>
      <p>
        `Temporal.Duration.prototype.milliseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Milliseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.microseconds">
      <h1>get Temporal.Duration.prototype.microseconds</h1>
      <p>
        `Temporal.Duration.prototype.microseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Microseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.nanoseconds">
      <h1>get Temporal.Duration.prototype.nanoseconds</h1>
      <p>
        `Temporal.Duration.prototype.nanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(_duration_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.sign">
      <h1>get Temporal.Duration.prototype.sign</h1>
      <p>
        `Temporal.Duration.prototype.sign` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ùîΩ(DurationSign(_duration_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.duration.prototype.blank">
      <h1>get Temporal.Duration.prototype.blank</h1>
      <p>
        `Temporal.Duration.prototype.blank` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. If DurationSign(_duration_) = 0, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.with">
      <h1>Temporal.Duration.prototype.with ( _temporalDurationLike_ )</h1>
      <p>The `Temporal.Duration.prototype.with` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Let _temporalDurationLike_ be ? ToTemporalPartialDurationRecord(_temporalDurationLike_).
        1. If _temporalDurationLike_.[[Years]] is not *undefined*, then
          1. Let _years_ be _temporalDurationLike_.[[Years]].
        1. Else,
          1. Let _years_ be _duration_.[[Years]].
        1. If _temporalDurationLike_.[[Months]] is not *undefined*, then
          1. Let _months_ be _temporalDurationLike_.[[Months]].
        1. Else,
          1. Let _months_ be _duration_.[[Months]].
        1. If _temporalDurationLike_.[[Weeks]] is not *undefined*, then
          1. Let _weeks_ be _temporalDurationLike_.[[Weeks]].
        1. Else,
          1. Let _weeks_ be _duration_.[[Weeks]].
        1. If _temporalDurationLike_.[[Days]] is not *undefined*, then
          1. Let _days_ be _temporalDurationLike_.[[Days]].
        1. Else,
          1. Let _days_ be _duration_.[[Days]].
        1. If _temporalDurationLike_.[[Hours]] is not *undefined*, then
          1. Let _hours_ be _temporalDurationLike_.[[Hours]].
        1. Else,
          1. Let _hours_ be _duration_.[[Hours]].
        1. If _temporalDurationLike_.[[Minutes]] is not *undefined*, then
          1. Let _minutes_ be _temporalDurationLike_.[[Minutes]].
        1. Else,
          1. Let _minutes_ be _duration_.[[Minutes]].
        1. If _temporalDurationLike_.[[Seconds]] is not *undefined*, then
          1. Let _seconds_ be _temporalDurationLike_.[[Seconds]].
        1. Else,
          1. Let _seconds_ be _duration_.[[Seconds]].
        1. If _temporalDurationLike_.[[Milliseconds]] is not *undefined*, then
          1. Let _milliseconds_ be _temporalDurationLike_.[[Milliseconds]].
        1. Else,
          1. Let _milliseconds_ be _duration_.[[Milliseconds]].
        1. If _temporalDurationLike_.[[Microseconds]] is not *undefined*, then
          1. Let _microseconds_ be _temporalDurationLike_.[[Microseconds]].
        1. Else,
          1. Let _microseconds_ be _duration_.[[Microseconds]].
        1. If _temporalDurationLike_.[[Nanoseconds]] is not *undefined*, then
          1. Let _nanoseconds_ be _temporalDurationLike_.[[Nanoseconds]].
        1. Else,
          1. Let _nanoseconds_ be _duration_.[[Nanoseconds]].
        1. Return ? CreateTemporalDuration(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.negated">
      <h1>Temporal.Duration.prototype.negated ( )</h1>
      <p>The `Temporal.Duration.prototype.negated` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return CreateNegatedTemporalDuration(_duration_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.abs">
      <h1>Temporal.Duration.prototype.abs ( )</h1>
      <p>The `Temporal.Duration.prototype.abs` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ! CreateTemporalDuration(abs(_duration_.[[Years]]), abs(_duration_.[[Months]]), abs(_duration_.[[Weeks]]), abs(_duration_.[[Days]]), abs(_duration_.[[Hours]]), abs(_duration_.[[Minutes]]), abs(_duration_.[[Seconds]]), abs(_duration_.[[Milliseconds]]), abs(_duration_.[[Microseconds]]), abs(_duration_.[[Nanoseconds]])).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.add">
      <h1>Temporal.Duration.prototype.add ( _other_ )</h1>
      <p>The `Temporal.Duration.prototype.add` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ? AddDurations(~add~, _duration_, _other_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.subtract">
      <h1>Temporal.Duration.prototype.subtract ( _other_ )</h1>
      <p>The `Temporal.Duration.prototype.subtract` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return ? AddDurations(~subtract~, _duration_, _other_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.round">
      <h1>Temporal.Duration.prototype.round ( _roundTo_ )</h1>
      <p>The `Temporal.Duration.prototype.round` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. If _roundTo_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If _roundTo_ is a String, then
          1. Let _paramString_ be _roundTo_.
          1. Set _roundTo_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_roundTo_, *"smallestUnit"*, _paramString_).
        1. Else,
          1. Set _roundTo_ to ? GetOptionsObject(_roundTo_).
        1. Let _smallestUnitPresent_ be *true*.
        1. Let _largestUnitPresent_ be *true*.
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (GetTemporalRelativeToOption reads *"relativeTo"*, GetRoundingIncrementOption reads *"roundingIncrement"* and GetRoundingModeOption reads *"roundingMode"*).
        1. Let _largestUnit_ be ? GetTemporalUnitValuedOption(_roundTo_, *"largestUnit"*, ~datetime~, ~unset~, ¬´ ~auto~ ¬ª).
        1. Let _relativeToRecord_ be ? GetTemporalRelativeToOption(_roundTo_).
        1. Let _zonedRelativeTo_ be _relativeToRecord_.[[ZonedRelativeTo]].
        1. Let _plainRelativeTo_ be _relativeToRecord_.[[PlainRelativeTo]].
        1. Let _roundingIncrement_ be ? GetRoundingIncrementOption(_roundTo_).
        1. Let _roundingMode_ be ? GetRoundingModeOption(_roundTo_, ~half-expand~).
        1. Let _smallestUnit_ be ? GetTemporalUnitValuedOption(_roundTo_, *"smallestUnit"*, ~datetime~, ~unset~).
        1. If _smallestUnit_ is ~unset~, then
          1. Set _smallestUnitPresent_ to *false*.
          1. Set _smallestUnit_ to ~nanosecond~.
        1. Let _existingLargestUnit_ be DefaultTemporalLargestUnit(_duration_).
        1. Let _defaultLargestUnit_ be LargerOfTwoTemporalUnits(_existingLargestUnit_, _smallestUnit_).
        1. If _largestUnit_ is ~unset~, then
          1. Set _largestUnitPresent_ to *false*.
          1. Set _largestUnit_ to _defaultLargestUnit_.
        1. Else if _largestUnit_ is ~auto~, then
          1. Set _largestUnit_ to _defaultLargestUnit_.
        1. If _smallestUnitPresent_ is *false* and _largestUnitPresent_ is *false*, then
          1. Throw a *RangeError* exception.
        1. If LargerOfTwoTemporalUnits(_largestUnit_, _smallestUnit_) is not _largestUnit_, throw a *RangeError* exception.
        1. Let _maximum_ be MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. If _maximum_ is not ~unset~, perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, *false*).
        1. If _roundingIncrement_ > 1, and _largestUnit_ is not _smallestUnit_, and TemporalUnitCategory(_smallestUnit_) is ~date~, throw a *RangeError* exception.
        1. If _zonedRelativeTo_ is not *undefined*, then
          1. Let _internalDuration_ be ToInternalDurationRecord(_duration_).
          1. Let _timeZone_ be _zonedRelativeTo_.[[TimeZone]].
          1. Let _calendar_ be _zonedRelativeTo_.[[Calendar]].
          1. Let _relativeEpochNs_ be _zonedRelativeTo_.[[EpochNanoseconds]].
          1. Let _targetEpochNs_ be ? AddZonedDateTime(_relativeEpochNs_, _timeZone_, _calendar_, _internalDuration_, ~constrain~).
          1. Set _internalDuration_ to ? DifferenceZonedDateTimeWithRounding(_relativeEpochNs_, _targetEpochNs_, _timeZone_, _calendar_, _largestUnit_, _roundingIncrement_, _smallestUnit_, _roundingMode_).
          1. If TemporalUnitCategory(_largestUnit_) is ~date~, set _largestUnit_ to ~hour~.
          1. Return ? TemporalDurationFromInternal(_internalDuration_, _largestUnit_).
        1. If _plainRelativeTo_ is not *undefined*, then
          1. Let _internalDuration_ be ToInternalDurationRecordWith24HourDays(_duration_).
          1. Let _targetTime_ be AddTime(MidnightTimeRecord(), _internalDuration_.[[Time]]).
          1. Let _calendar_ be _plainRelativeTo_.[[Calendar]].
          1. Let _dateDuration_ be ! AdjustDateDurationRecord(_internalDuration_.[[Date]], _targetTime_.[[Days]]).
          1. Let _targetDate_ be ? CalendarDateAdd(_calendar_, _plainRelativeTo_.[[ISODate]], _dateDuration_, ~constrain~).
          1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_plainRelativeTo_.[[ISODate]], MidnightTimeRecord()).
          1. Let _targetDateTime_ be CombineISODateAndTimeRecord(_targetDate_, _targetTime_).
          1. Set _internalDuration_ to ? DifferencePlainDateTimeWithRounding(_isoDateTime_, _targetDateTime_, _calendar_, _largestUnit_, _roundingIncrement_, _smallestUnit_, _roundingMode_).
          1. Return ? TemporalDurationFromInternal(_internalDuration_, _largestUnit_).
        1. If IsCalendarUnit(_existingLargestUnit_) is *true*, or IsCalendarUnit(_largestUnit_) is *true*, throw a *RangeError* exception.
        1. Assert: IsCalendarUnit(_smallestUnit_) is *false*.
        1. Let _internalDuration_ be ToInternalDurationRecordWith24HourDays(_duration_).
        1. If _smallestUnit_ is ~day~, then
          1. Let _fractionalDays_ be TotalTimeDuration(_internalDuration_.[[Time]], ~day~).
          1. Let _days_ be RoundNumberToIncrement(_fractionalDays_, _roundingIncrement_, _roundingMode_).
          1. Let _dateDuration_ be ? CreateDateDurationRecord(0, 0, 0, _days_).
          1. Set _internalDuration_ to ! CombineDateAndTimeDuration(_dateDuration_, 0).
        1. Else,
          1. Let _timeDuration_ be ? RoundTimeDuration(_internalDuration_.[[Time]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
          1. Set _internalDuration_ to ! CombineDateAndTimeDuration(ZeroDateDuration(), _timeDuration_).
        1. Return ? TemporalDurationFromInternal(_internalDuration_, _largestUnit_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.total">
      <h1>Temporal.Duration.prototype.total ( _totalOf_ )</h1>
      <p>The `Temporal.Duration.prototype.total` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. If _totalOf_ is *undefined*, throw a *TypeError* exception.
        1. If _totalOf_ is a String, then
          1. Let _paramString_ be _totalOf_.
          1. Set _totalOf_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_totalOf_, *"unit"*, _paramString_).
        1. Else,
          1. Set _totalOf_ to ? GetOptionsObject(_totalOf_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (GetTemporalRelativeToOption reads *"relativeTo"*).
        1. Let _relativeToRecord_ be ? GetTemporalRelativeToOption(_totalOf_).
        1. Let _zonedRelativeTo_ be _relativeToRecord_.[[ZonedRelativeTo]].
        1. Let _plainRelativeTo_ be _relativeToRecord_.[[PlainRelativeTo]].
        1. Let _unit_ be ? GetTemporalUnitValuedOption(_totalOf_, *"unit"*, ~datetime~, ~required~).
        1. If _zonedRelativeTo_ is not *undefined*, then
          1. Let _internalDuration_ be ToInternalDurationRecord(_duration_).
          1. Let _timeZone_ be _zonedRelativeTo_.[[TimeZone]].
          1. Let _calendar_ be _zonedRelativeTo_.[[Calendar]].
          1. Let _relativeEpochNs_ be _zonedRelativeTo_.[[EpochNanoseconds]].
          1. Let _targetEpochNs_ be ? AddZonedDateTime(_relativeEpochNs_, _timeZone_, _calendar_, _internalDuration_, ~constrain~).
          1. Let _total_ be ? DifferenceZonedDateTimeWithTotal(_relativeEpochNs_, _targetEpochNs_, _timeZone_, _calendar_, _unit_).
        1. Else if _plainRelativeTo_ is not *undefined*, then
          1. Let _internalDuration_ be ToInternalDurationRecordWith24HourDays(_duration_).
          1. Let _targetTime_ be AddTime(MidnightTimeRecord(), _internalDuration_.[[Time]]).
          1. Let _calendar_ be _plainRelativeTo_.[[Calendar]].
          1. Let _dateDuration_ be ! AdjustDateDurationRecord(_internalDuration_.[[Date]], _targetTime_.[[Days]]).
          1. Let _targetDate_ be ? CalendarDateAdd(_calendar_, _plainRelativeTo_.[[ISODate]], _dateDuration_, ~constrain~).
          1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_plainRelativeTo_.[[ISODate]], MidnightTimeRecord()).
          1. Let _targetDateTime_ be CombineISODateAndTimeRecord(_targetDate_, _targetTime_).
          1. Let _total_ be ? DifferencePlainDateTimeWithTotal(_isoDateTime_, _targetDateTime_, _calendar_, _unit_).
        1. Else,
          1. Let _largestUnit_ be DefaultTemporalLargestUnit(_duration_).
          1. If IsCalendarUnit(_largestUnit_) is *true*, or IsCalendarUnit(_unit_) is *true*, throw a *RangeError* exception.
          1. Let _internalDuration_ be ToInternalDurationRecordWith24HourDays(_duration_).
          1. Let _total_ be TotalTimeDuration(_internalDuration_.[[Time]], _unit_).
        1. Return ùîΩ(_total_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.tostring">
      <h1>Temporal.Duration.prototype.toString ( [ _options_ ] )</h1>
      <p>The `Temporal.Duration.prototype.toString` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (GetTemporalFractionalSecondDigitsOption reads *"fractionalSecondDigits"* and GetRoundingModeOption reads *"roundingMode"*).
        1. Let _digits_ be ? GetTemporalFractionalSecondDigitsOption(_resolvedOptions_).
        1. Let _roundingMode_ be ? GetRoundingModeOption(_resolvedOptions_, ~trunc~).
        1. Let _smallestUnit_ be ? GetTemporalUnitValuedOption(_resolvedOptions_, *"smallestUnit"*, ~time~, ~unset~).
        1. If _smallestUnit_ is ~hour~ or ~minute~, throw a *RangeError* exception.
        1. Let _precision_ be ToSecondsStringPrecisionRecord(_smallestUnit_, _digits_).
        1. If _precision_.[[Unit]] is ~nanosecond~ and _precision_.[[Increment]] = 1, then
          1. Return TemporalDurationToString(_duration_, _precision_.[[Precision]]).
        1. Let _largestUnit_ be DefaultTemporalLargestUnit(_duration_).
        1. Let _internalDuration_ be ToInternalDurationRecord(_duration_).
        1. Let _timeDuration_ be ? RoundTimeDuration(_internalDuration_.[[Time]], _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. Set _internalDuration_ to ! CombineDateAndTimeDuration(_internalDuration_.[[Date]], _timeDuration_).
        1. Let _roundedLargestUnit_ be LargerOfTwoTemporalUnits(_largestUnit_, ~second~).
        1. Let _roundedDuration_ be ? TemporalDurationFromInternal(_internalDuration_, _roundedLargestUnit_).
        1. Return TemporalDurationToString(_roundedDuration_, _precision_.[[Precision]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.tojson">
      <h1>Temporal.Duration.prototype.toJSON ( )</h1>
      <p>The `Temporal.Duration.prototype.toJSON` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return TemporalDurationToString(_duration_, ~auto~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.tolocalestring">
      <h1>Temporal.Duration.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.Duration.prototype.toLocaleString` method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `Temporal.Duration.prototype.toLocaleString` method is used.
      </p>
      <p>The `Temporal.Duration.prototype.toLocaleString` method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Return TemporalDurationToString(_duration_, ~auto~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.duration.prototype.valueof">
      <h1>Temporal.Duration.prototype.valueOf ( )</h1>
      <p>The `Temporal.Duration.prototype.valueOf` method performs the following steps when called:</p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-note>
        <p>
          This method always throws, because in the absence of `valueOf()`, expressions with arithmetic operators such as `duration1 > duration2` would fall back to being equivalent to `duration1.toString() > duration2.toString()`.
          Lexicographical comparison of serialized strings might not seem obviously wrong, because the result would sometimes be correct.
          Implementations are encouraged to phrase the error message to point users to `Temporal.Duration.compare()` and/or `Temporal.Duration.prototype.toString()`.
        </p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-duration-instances">
    <h1>Properties of Temporal.Duration Instances</h1>
    <p>
      Temporal.Duration instances are ordinary objects that inherit properties from the %Temporal.Duration.prototype% intrinsic object.
      Temporal.Duration instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporalduration-instances"></emu-xref>.
    </p>
    <p>
      A <dfn variants="float64-representable integers">float64-representable integer</dfn> is an integer that is exactly representable as a Number value.
      That is, for a float64-representable integer _x_, it must hold that ‚Ñù(ùîΩ(_x_)) = _x_.
    </p>
    <emu-note>
      The use of float64-representable integers here is intended so that implementations can store and do arithmetic on Duration fields using 64-bit floating-point values.
    </emu-note>
    <emu-table id="table-internal-slots-of-temporalduration-instances" caption="Internal Slots of Temporal.Duration Instances">
      <table>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[InitializedTemporalDuration]]
          </td>
          <td>
            The only specified use of this slot is for distinguishing Temporal.Duration instances from other objects.
          </td>
        </tr>
        <tr>
          <td>
            [[Years]]
          </td>
          <td>
            A float64-representable integer representing the number of years in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Months]]
          </td>
          <td>
            A float64-representable integer representing the number of months in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Weeks]]
          </td>
          <td>
            A float64-representable integer representing the number of weeks in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Days]]
          </td>
          <td>
            A float64-representable integer representing the number of days in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Hours]]
          </td>
          <td>
            A float64-representable integer representing the number of hours in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Minutes]]
          </td>
          <td>
            A float64-representable integer representing the number of minutes in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Seconds]]
          </td>
          <td>
            A float64-representable integer representing the number of seconds in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Milliseconds]]
          </td>
          <td>
            A float64-representable integer representing the number of milliseconds in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Microseconds]]
          </td>
          <td>
            A float64-representable integer representing the number of microseconds in the duration.
          </td>
        </tr>
        <tr>
          <td>
            [[Nanoseconds]]
          </td>
          <td>
            A float64-representable integer representing the number of nanoseconds in the duration.
          </td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-duration-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-temporal-date-duration-records">
      <h1>Date Duration Records</h1>
      <p>
        A <dfn variants="Date Duration Records">Date Duration Record</dfn> is a Record value used to represent the portion of a Temporal.Duration object that deals with calendar date units.
        Date Duration Records are produced by the abstract operation CreateDateDurationRecord, among others.
      </p>
      <p>Date Duration Records have the fields listed in <emu-xref href="#table-temporal-date-duration-record-fields"></emu-xref>.</p>
      <emu-table id="table-temporal-date-duration-record-fields" caption="Date Duration Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Years]]</td>
            <td>a float64-representable integer</td>
            <td>
              The number of years in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Months]]</td>
            <td>a float64-representable integer</td>
            <td>
              The number of months in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Weeks]]</td>
            <td>a float64-representable integer</td>
            <td>
              The number of weeks in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Days]]</td>
            <td>a float64-representable integer</td>
            <td>
              The number of days in the duration.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-partial-duration-records">
      <h1>Partial Duration Records</h1>
      <p>A <dfn variants="partial Duration Records">partial Duration Record</dfn> is a Record value used to represent a portion of a Temporal.Duration object, in which it is not required that all the fields be specified.</p>
      <p>
        Partial Duration Records have the fields listed in <emu-xref href="#table-temporal-partial-duration-record-fields"></emu-xref>.
        Additionally, Partial Duration Records must have at least one field that is not *undefined*.
      </p>
      <emu-table id="table-temporal-partial-duration-record-fields" caption="Partial Duration Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Years]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of years in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Months]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of months in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Weeks]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of weeks in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Days]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of days in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Hours]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of hours in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Minutes]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of minutes in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Seconds]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of seconds in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Milliseconds]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of milliseconds in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Microseconds]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of microseconds in the duration.
            </td>
          </tr>
          <tr>
            <td>[[Nanoseconds]]</td>
            <td>a float64-representable integer or *undefined*</td>
            <td>
              The number of nanoseconds in the duration.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-internal-duration-records">
      <h1>Internal Duration Records</h1>
      <p>
        A <dfn variants="Internal Duration Records">Internal Duration Record</dfn> is a Record value used to represent the combination of a Date Duration Record with a time duration.
        Such Records are used by operations that deal with both date and time portions of durations, such as RoundTimeDuration.
      </p>
      <p>
        A <dfn>time duration</dfn> is an integer in the inclusive interval from -maxTimeDuration to maxTimeDuration, where
        <emu-eqn id="eqn-maxTimeDuration" aoid="maxTimeDuration">
          maxTimeDuration = 2<sup>53</sup> √ó 10<sup>9</sup> - 1 = 9,007,199,254,740,991,999,999,999
        </emu-eqn>
        It represents the portion of a Temporal.Duration object that deals with time units, but as a combined value of total nanoseconds.
      </p>
      <p>Internal Duration Records have the fields listed in <emu-xref href="#table-temporal-normalized-duration-record-fields"></emu-xref>.</p>
      <emu-table id="table-temporal-normalized-duration-record-fields" caption="Internal Duration Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Date]]</td>
            <td>a Date Duration Record</td>
            <td>
              The date portion of the duration.
            </td>
          </tr>
          <tr>
            <td>[[Time]]</td>
            <td>a time duration</td>
            <td>
              The time portion of the duration.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-zerodateduration" type="abstract operation">
      <h1>ZeroDateDuration ( ): a Date Duration Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned Record represents a duration with length 0.</dd>
      </dl>
      <emu-alg>
        1. Return ! CreateDateDurationRecord(0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-tointernaldurationrecord" type="abstract operation">
      <h1>
        ToInternalDurationRecord (
          _duration_: a Temporal.Duration,
        ): an Internal Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts _duration_ into its internal form, for use in duration calculations that may involve time zones. The duration's days are kept separate and not converted into the [[Time]] field.</dd>
      </dl>
      <emu-alg>
        1. Let _dateDuration_ be ! CreateDateDurationRecord(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]]).
        1. Let _timeDuration_ be TimeDurationFromComponents(_duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Return ! CombineDateAndTimeDuration(_dateDuration_, _timeDuration_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-tointernaldurationrecordwith24hourdays" type="abstract operation">
      <h1>
        ToInternalDurationRecordWith24HourDays (
          _duration_: a Temporal.Duration,
        ): an Internal Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts _duration_ into its internal form, for use in duration calculations that do not involve time zones. The duration's days are assumed to be uniformly 24 hours, and the [[Date]].[[Days]] field of the returned Record is set to 0, while the [[Time]] field includes the days.</dd>
      </dl>
      <emu-alg>
        1. Let _timeDuration_ be TimeDurationFromComponents(_duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Set _timeDuration_ to ! Add24HourDaysToTimeDuration(_timeDuration_, _duration_.[[Days]]).
        1. Let _dateDuration_ be ! CreateDateDurationRecord(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], 0).
        1. Return ! CombineDateAndTimeDuration(_dateDuration_, _timeDuration_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-todatedurationrecordwithouttime" type="abstract operation">
      <h1>
        ToDateDurationRecordWithoutTime (
          _duration_: a Temporal.Duration,
        ): either a normal completion containing a Date Duration Record, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts _duration_ into only a date part, for use in date-only calculations. The duration's days are assumed to be uniformly 24 hours, and the [[Days]] field of the returned Record is set to the [[Days]] internal slot of _duration_, incremented by any whole days that _duration_'s time units added up to.</dd>
      </dl>
      <emu-alg>
        1. Let _internalDuration_ be ToInternalDurationRecordWith24HourDays(_duration_).
        1. Let _days_ be truncate(_internalDuration_.[[Time]] / nsPerDay).
        1. Return ? CreateDateDurationRecord(_internalDuration_.[[Date]].[[Years]], _internalDuration_.[[Date]].[[Months]], _internalDuration_.[[Date]].[[Weeks]], _days_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldurationfrominternal" type="abstract operation">
      <h1>
        TemporalDurationFromInternal (
          _internalDuration_: an Internal Duration Record,
          _largestUnit_: a Temporal unit,
        ): either a normal completion containing a Temporal.Duration, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It converts _internalDuration_ back into the form of a `Temporal.Duration` object, with each component stored separately.
          The time units are balanced up to _largestUnit_.
          The conversion may be lossy if _largestUnit_ is ~millisecond~, ~microsecond~, or ~nanosecond~.
          In that case, the internal slots of the returned Temporal.Duration may contain unsafe (but float64-representable) integers.
          The result of a lossy conversion may be outside the allowed range for Durations, even if the input was not.
        </dd>
      </dl>
      <emu-alg>
        1. Let _days_, _hours_, _minutes_, _seconds_, _milliseconds_, and _microseconds_ be 0.
        1. Let _sign_ be TimeDurationSign(_internalDuration_.[[Time]]).
        1. Let _nanoseconds_ be abs(_internalDuration_.[[Time]]).
        1. If TemporalUnitCategory(_largestUnit_) is ~date~, then
          1. Set _microseconds_ to floor(_nanoseconds_ / 1000).
          1. Set _nanoseconds_ to _nanoseconds_ modulo 1000.
          1. Set _milliseconds_ to floor(_microseconds_ / 1000).
          1. Set _microseconds_ to _microseconds_ modulo 1000.
          1. Set _seconds_ to floor(_milliseconds_ / 1000).
          1. Set _milliseconds_ to _milliseconds_ modulo 1000.
          1. Set _minutes_ to floor(_seconds_ / 60).
          1. Set _seconds_ to _seconds_ modulo 60.
          1. Set _hours_ to floor(_minutes_ / 60).
          1. Set _minutes_ to _minutes_ modulo 60.
          1. Set _days_ to floor(_hours_ / 24).
          1. Set _hours_ to _hours_ modulo 24.
        1. Else if _largestUnit_ is ~hour~, then
          1. Set _microseconds_ to floor(_nanoseconds_ / 1000).
          1. Set _nanoseconds_ to _nanoseconds_ modulo 1000.
          1. Set _milliseconds_ to floor(_microseconds_ / 1000).
          1. Set _microseconds_ to _microseconds_ modulo 1000.
          1. Set _seconds_ to floor(_milliseconds_ / 1000).
          1. Set _milliseconds_ to _milliseconds_ modulo 1000.
          1. Set _minutes_ to floor(_seconds_ / 60).
          1. Set _seconds_ to _seconds_ modulo 60.
          1. Set _hours_ to floor(_minutes_ / 60).
          1. Set _minutes_ to _minutes_ modulo 60.
        1. Else if _largestUnit_ is ~minute~, then
          1. Set _microseconds_ to floor(_nanoseconds_ / 1000).
          1. Set _nanoseconds_ to _nanoseconds_ modulo 1000.
          1. Set _milliseconds_ to floor(_microseconds_ / 1000).
          1. Set _microseconds_ to _microseconds_ modulo 1000.
          1. Set _seconds_ to floor(_milliseconds_ / 1000).
          1. Set _milliseconds_ to _milliseconds_ modulo 1000.
          1. Set _minutes_ to floor(_seconds_ / 60).
          1. Set _seconds_ to _seconds_ modulo 60.
        1. Else if _largestUnit_ is ~second~, then
          1. Set _microseconds_ to floor(_nanoseconds_ / 1000).
          1. Set _nanoseconds_ to _nanoseconds_ modulo 1000.
          1. Set _milliseconds_ to floor(_microseconds_ / 1000).
          1. Set _microseconds_ to _microseconds_ modulo 1000.
          1. Set _seconds_ to floor(_milliseconds_ / 1000).
          1. Set _milliseconds_ to _milliseconds_ modulo 1000.
        1. Else if _largestUnit_ is ~millisecond~, then
          1. Set _microseconds_ to floor(_nanoseconds_ / 1000).
          1. Set _nanoseconds_ to _nanoseconds_ modulo 1000.
          1. Set _milliseconds_ to floor(_microseconds_ / 1000).
          1. Set _microseconds_ to _microseconds_ modulo 1000.
        1. Else if _largestUnit_ is ~microsecond~, then
          1. Set _microseconds_ to floor(_nanoseconds_ / 1000).
          1. Set _nanoseconds_ to _nanoseconds_ modulo 1000.
        1. Else,
          1. Assert: _largestUnit_ is ~nanosecond~.
        1. NOTE: When _largestUnit_ is ~millisecond~, ~microsecond~, or ~nanosecond~, _milliseconds_, _microseconds_, or _nanoseconds_ may be an unsafe integer. In this case, care must be taken when implementing the calculation using floating point arithmetic. It can be implemented in C++ using `std::fma()`. String manipulation will also give an exact result, since the multiplication is by a power of 10.
        1. Return ? CreateTemporalDuration(_internalDuration_.[[Date]].[[Years]], _internalDuration_.[[Date]].[[Months]], _internalDuration_.[[Date]].[[Weeks]], _internalDuration_.[[Date]].[[Days]] + _days_ √ó _sign_, _hours_ √ó _sign_, _minutes_ √ó _sign_, _seconds_ √ó _sign_, _milliseconds_ √ó _sign_, _microseconds_ √ó _sign_, _nanoseconds_ √ó _sign_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createdatedurationrecord" type="abstract operation">
      <h1>
        CreateDateDurationRecord (
          _years_: an integer,
          _months_: an integer,
          _weeks_: an integer,
          _days_: an integer,
        ): either a normal completion containing a Date Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. If IsValidDuration(_years_, _months_, _weeks_, _days_, 0, 0, 0, 0, 0, 0) is *false*, throw a *RangeError* exception.
        1. Return Date Duration Record {
          [[Years]]: ‚Ñù(ùîΩ(_years_)),
          [[Months]]: ‚Ñù(ùîΩ(_months_)),
          [[Weeks]]: ‚Ñù(ùîΩ(_weeks_)),
          [[Days]]: ‚Ñù(ùîΩ(_days_))
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adjustdatedurationrecord" type="abstract operation">
      <h1>
        AdjustDateDurationRecord (
          _dateDuration_: a Date Duration Record,
          _days_: an integer,
          optional _weeks_: an integer,
          optional _months_: an integer,
        ): either a normal completion containing a Date Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a new Date Duration Record that is a copy of _dateDuration_, with one or more fields replaced with new values.</dd>
      </dl>
      <emu-alg>
        1. If _weeks_ is not present, set _weeks_ to _dateDuration_.[[Weeks]].
        1. If _months_ is not present, set _months_ to _dateDuration_.[[Months]].
        1. Return ? CreateDateDurationRecord(_dateDuration_.[[Years]], _months_, _weeks_, _days_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-combinedateandtimeduration" type="abstract operation">
      <h1>
        CombineDateAndTimeDuration (
          _dateDuration_: a Date Duration Record,
          _timeDuration_: a time duration,
        ): either a normal completion containing an Internal Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Let _dateSign_ be DateDurationSign(_dateDuration_).
        1. Let _timeSign_ be TimeDurationSign(_timeDuration_).
        1. If _dateSign_ ‚â† 0 and _timeSign_ ‚â† 0 and _dateSign_ ‚â† _timeSign_, throw a *RangeError* exception.
        1. Return Internal Duration Record {
          [[Date]]: _dateDuration_,
          [[Time]]: _timeDuration_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalduration" type="abstract operation">
      <h1>
        ToTemporalDuration (
          _item_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Converts _item_ to a new Temporal.Duration instance if possible and returns that, and throws otherwise.</dd>
      </dl>
      <emu-alg>
        1. If _item_ is an Object and _item_ has an [[InitializedTemporalDuration]] internal slot, then
          1. Return ! CreateTemporalDuration(_item_.[[Years]], _item_.[[Months]], _item_.[[Weeks]], _item_.[[Days]], _item_.[[Hours]], _item_.[[Minutes]], _item_.[[Seconds]], _item_.[[Milliseconds]], _item_.[[Microseconds]], _item_.[[Nanoseconds]]).
        1. If _item_ is not an Object, then
          1. If _item_ is not a String, throw a *TypeError* exception.
          1. Return ? ParseTemporalDurationString(_item_).
        1. Let _result_ be a new Partial Duration Record with each field set to 0.
        1. Let _partial_ be ? ToTemporalPartialDurationRecord(_item_).
        1. If _partial_.[[Years]] is not *undefined*, set _result_.[[Years]] to _partial_.[[Years]].
        1. If _partial_.[[Months]] is not *undefined*, set _result_.[[Months]] to _partial_.[[Months]].
        1. If _partial_.[[Weeks]] is not *undefined*, set _result_.[[Weeks]] to _partial_.[[Weeks]].
        1. If _partial_.[[Days]] is not *undefined*, set _result_.[[Days]] to _partial_.[[Days]].
        1. If _partial_.[[Hours]] is not *undefined*, set _result_.[[Hours]] to _partial_.[[Hours]].
        1. If _partial_.[[Minutes]] is not *undefined*, set _result_.[[Minutes]] to _partial_.[[Minutes]].
        1. If _partial_.[[Seconds]] is not *undefined*, set _result_.[[Seconds]] to _partial_.[[Seconds]].
        1. If _partial_.[[Milliseconds]] is not *undefined*, set _result_.[[Milliseconds]] to _partial_.[[Milliseconds]].
        1. If _partial_.[[Microseconds]] is not *undefined*, set _result_.[[Microseconds]] to _partial_.[[Microseconds]].
        1. If _partial_.[[Nanoseconds]] is not *undefined*, set _result_.[[Nanoseconds]] to _partial_.[[Nanoseconds]].
        1. Return ? CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-durationsign" type="abstract operation">
      <h1>
        DurationSign (
          _duration_: a Temporal.Duration,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns 1 if the most significant non-zero field in the _duration_ argument is positive, and -1 if the most significant non-zero field is negative. If all of _duration_'s fields are zero, it returns 0.</dd>
      </dl>
      <emu-alg>
        1. For each value _v_ of ¬´ _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]] ¬ª, do
          1. If _v_ &lt; 0, return -1.
          1. If _v_ > 0, return 1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-datedurationsign" type="abstract operation">
      <h1>
        DateDurationSign (
          _dateDuration_: a Date Duration Record,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns 1 if the most significant non-zero field in the _dateDuration_ argument is positive, and -1 if the most significant non-zero field is negative. If all of _dateDuration_'s fields are zero, it returns 0.</dd>
      </dl>
      <emu-alg>
        1. For each value _v_ of ¬´ _dateDuration_.[[Years]], _dateDuration_.[[Months]], _dateDuration_.[[Weeks]], _dateDuration_.[[Days]] ¬ª, do
          1. If _v_ &lt; 0, return -1.
          1. If _v_ > 0, return 1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-internaldurationsign" type="abstract operation">
      <h1>
        InternalDurationSign (
          _internalDuration_: an Internal Duration Record,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns 1 if the most significant non-zero field in the _internalDuration_ argument is positive, and -1 if the most significant non-zero field is negative. If all of _internalDuration_'s fields are zero, it returns 0.</dd>
      </dl>
      <emu-alg>
        1. Let _dateSign_ be DateDurationSign(_internalDuration_.[[Date]]).
        1. If _dateSign_ ‚â† 0, return _dateSign_.
        1. Return TimeDurationSign(_internalDuration_.[[Time]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isvalidduration" type="abstract operation">
      <h1>
        IsValidDuration (
          _years_: an integer,
          _months_: an integer,
          _weeks_: an integer,
          _days_: an integer,
          _hours_: an integer,
          _minutes_: an integer,
          _seconds_: an integer,
          _milliseconds_: an integer,
          _microseconds_: an integer,
          _nanoseconds_: an integer,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns *true* if its arguments form valid input from which to construct a `Temporal.Duration`, and *false* otherwise.</dd>
      </dl>
      <emu-alg>
        1. Let _sign_ be 0.
        1. For each value _v_ of ¬´ _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ ¬ª, do
          1. If ùîΩ(_v_) is not finite, return *false*.
          1. If _v_ &lt; 0, then
            1. If _sign_ > 0, return *false*.
            1. Set _sign_ to -1.
          1. Else if _v_ > 0, then
            1. If _sign_ &lt; 0, return *false*.
            1. Set _sign_ to 1.
        1. If abs(_years_) ‚â• 2<sup>32</sup>, return *false*.
        1. If abs(_months_) ‚â• 2<sup>32</sup>, return *false*.
        1. If abs(_weeks_) ‚â• 2<sup>32</sup>, return *false*.
        1. Let _totalFractionalSeconds_ be _days_ √ó 86,400 + _hours_ √ó 3600 + _minutes_ √ó 60 + _seconds_ + ‚Ñù(ùîΩ(_milliseconds_)) √ó 10<sup>-3</sup> + ‚Ñù(ùîΩ(_microseconds_)) √ó 10<sup>-6</sup> + ‚Ñù(ùîΩ(_nanoseconds_)) √ó 10<sup>-9</sup>.
        1. NOTE: The above step cannot be implemented directly using floating-point arithmetic. Multiplying by 10<sup>-3</sup>, 10<sup>-6</sup>, and 10<sup>-9</sup> respectively may be imprecise when _milliseconds_, _microseconds_, or _nanoseconds_ is an unsafe integer. This multiplication can be implemented in C++ with an implementation of `std::remquo()` with sufficient bits in the quotient. String manipulation will also give an exact result, since the multiplication is by a power of 10.
        1. If abs(_totalFractionalSeconds_) ‚â• 2<sup>53</sup>, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-defaulttemporallargestunit" type="abstract operation">
      <h1>
        DefaultTemporalLargestUnit (
          _duration_: a Temporal.Duration,
        ): a Temporal unit
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It implements the logic used in the `Temporal.Duration.prototype.round()` method and elsewhere, where the `largestUnit` option, if not given explicitly, is set to the largest-magnitude non-zero unit.</dd>
      </dl>
      <emu-alg>
        1. If _duration_.[[Years]] ‚â† 0, return ~year~.
        1. If _duration_.[[Months]] ‚â† 0, return ~month~.
        1. If _duration_.[[Weeks]] ‚â† 0, return ~week~.
        1. If _duration_.[[Days]] ‚â† 0, return ~day~.
        1. If _duration_.[[Hours]] ‚â† 0, return ~hour~.
        1. If _duration_.[[Minutes]] ‚â† 0, return ~minute~.
        1. If _duration_.[[Seconds]] ‚â† 0, return ~second~.
        1. If _duration_.[[Milliseconds]] ‚â† 0, return ~millisecond~.
        1. If _duration_.[[Microseconds]] ‚â† 0, return ~microsecond~.
        1. Return ~nanosecond~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalpartialdurationrecord" type="abstract operation">
      <h1>
        ToTemporalPartialDurationRecord (
          _temporalDurationLike_: an ECMAScript language value,
        ): either a normal completion containing a partial Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned Record has its fields set according to the properties of _temporalDurationLike_.</dd>
      </dl>
      <emu-alg>
        1. If _temporalDurationLike_ is not an Object, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be a new partial Duration Record with each field set to *undefined*.
        1. NOTE: The following steps read properties and perform independent validation in alphabetical order.
        1. Let _days_ be ? Get(_temporalDurationLike_, *"days"*).
        1. If _days_ is not *undefined*, set _result_.[[Days]] to ? ToIntegerIfIntegral(_days_).
        1. Let _hours_ be ? Get(_temporalDurationLike_, *"hours"*).
        1. If _hours_ is not *undefined*, set _result_.[[Hours]] to ? ToIntegerIfIntegral(_hours_).
        1. Let _microseconds_ be ? Get(_temporalDurationLike_, *"microseconds"*).
        1. If _microseconds_ is not *undefined*, set _result_.[[Microseconds]] to ? ToIntegerIfIntegral(_microseconds_).
        1. Let _milliseconds_ be ? Get(_temporalDurationLike_, *"milliseconds"*).
        1. If _milliseconds_ is not *undefined*, set _result_.[[Milliseconds]] to ? ToIntegerIfIntegral(_milliseconds_).
        1. Let _minutes_ be ? Get(_temporalDurationLike_, *"minutes"*).
        1. If _minutes_ is not *undefined*, set _result_.[[Minutes]] to ? ToIntegerIfIntegral(_minutes_).
        1. Let _months_ be ? Get(_temporalDurationLike_, *"months"*).
        1. If _months_ is not *undefined*, set _result_.[[Months]] to ? ToIntegerIfIntegral(_months_).
        1. Let _nanoseconds_ be ? Get(_temporalDurationLike_, *"nanoseconds"*).
        1. If _nanoseconds_ is not *undefined*, set _result_.[[Nanoseconds]] to ? ToIntegerIfIntegral(_nanoseconds_).
        1. Let _seconds_ be ? Get(_temporalDurationLike_, *"seconds"*).
        1. If _seconds_ is not *undefined*, set _result_.[[Seconds]] to ? ToIntegerIfIntegral(_seconds_).
        1. Let _weeks_ be ? Get(_temporalDurationLike_, *"weeks"*).
        1. If _weeks_ is not *undefined*, set _result_.[[Weeks]] to ? ToIntegerIfIntegral(_weeks_).
        1. Let _years_ be ? Get(_temporalDurationLike_, *"years"*).
        1. If _years_ is not *undefined*, set _result_.[[Years]] to ? ToIntegerIfIntegral(_years_).
        1. If _years_ is *undefined*, and _months_ is *undefined*, and _weeks_ is *undefined*, and _days_ is *undefined*, and _hours_ is *undefined*, and _minutes_ is *undefined*, and _seconds_ is *undefined*, and _milliseconds_ is *undefined*, and _microseconds_ is *undefined*, and _nanoseconds_ is *undefined*, throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalduration" type="abstract operation">
      <h1>
        CreateTemporalDuration (
          _years_: an integer,
          _months_: an integer,
          _weeks_: an integer,
          _days_: an integer,
          _hours_: an integer,
          _minutes_: an integer,
          _seconds_: an integer,
          _milliseconds_: an integer,
          _microseconds_: an integer,
          _nanoseconds_: an integer,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.Duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.Duration instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. If IsValidDuration(_years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_) is *false*, throw a *RangeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.Duration%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.Duration.prototype%"*, ¬´ [[InitializedTemporalDuration]], [[Years]], [[Months]], [[Weeks]], [[Days]], [[Hours]], [[Minutes]], [[Seconds]], [[Milliseconds]], [[Microseconds]], [[Nanoseconds]] ¬ª).
        1. Set _object_.[[Years]] to ‚Ñù(ùîΩ(_years_)).
        1. Set _object_.[[Months]] to ‚Ñù(ùîΩ(_months_)).
        1. Set _object_.[[Weeks]] to ‚Ñù(ùîΩ(_weeks_)).
        1. Set _object_.[[Days]] to ‚Ñù(ùîΩ(_days_)).
        1. Set _object_.[[Hours]] to ‚Ñù(ùîΩ(_hours_)).
        1. Set _object_.[[Minutes]] to ‚Ñù(ùîΩ(_minutes_)).
        1. Set _object_.[[Seconds]] to ‚Ñù(ùîΩ(_seconds_)).
        1. Set _object_.[[Milliseconds]] to ‚Ñù(ùîΩ(_milliseconds_)).
        1. Set _object_.[[Microseconds]] to ‚Ñù(ùîΩ(_microseconds_)).
        1. Set _object_.[[Nanoseconds]] to ‚Ñù(ùîΩ(_nanoseconds_)).
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createnegatedtemporalduration" type="abstract operation">
      <h1>
        CreateNegatedTemporalDuration (
          _duration_: a Temporal.Duration,
        ): a Temporal.Duration
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns a new Temporal.Duration instance that is the negation of _duration_.</dd>
      </dl>
      <emu-alg>
        1. Return ! CreateTemporalDuration(-_duration_.[[Years]], -_duration_.[[Months]], -_duration_.[[Weeks]], -_duration_.[[Days]], -_duration_.[[Hours]], -_duration_.[[Minutes]], -_duration_.[[Seconds]], -_duration_.[[Milliseconds]], -_duration_.[[Microseconds]], -_duration_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-timedurationfromcomponents" type="abstract operation">
      <h1>
        TimeDurationFromComponents (
          _hours_: an integer,
          _minutes_: an integer,
          _seconds_: an integer,
          _milliseconds_: an integer,
          _microseconds_: an integer,
          _nanoseconds_: an integer,
        ): a time duration
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          From the given units, it computes a time duration consisting of total nanoseconds.
          The time duration can be stored losslessly in two 64-bit floating point numbers consisting of truncate(_nanoseconds_ / 10<sup>9</sup>) and remainder(_nanoseconds_, 10<sup>9</sup>).
          Alternatively, _nanoseconds_ can be stored as a 96-bit integer.
        </dd>
      </dl>
      <emu-alg>
        1. Set _minutes_ to _minutes_ + _hours_ √ó 60.
        1. Set _seconds_ to _seconds_ + _minutes_ √ó 60.
        1. Set _milliseconds_ to _milliseconds_ + _seconds_ √ó 1000.
        1. Set _microseconds_ to _microseconds_ + _milliseconds_ √ó 1000.
        1. Set _nanoseconds_ to _nanoseconds_ + _microseconds_ √ó 1000.
        1. Assert: abs(_nanoseconds_) ‚â§ maxTimeDuration.
        1. Return _nanoseconds_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addtimeduration" type="abstract operation">
      <h1>
        AddTimeDuration (
          _one_: a time duration,
          _two_: a time duration,
        ): either a normal completion containing a time duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns a time duration that is the sum of _one_ and _two_, throwing an exception if the result is greater than the maximum time duration.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be _one_ + _two_.
        1. If abs(_result_) > maxTimeDuration, throw a *RangeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-add24hourdaystonormalizedtimeduration" type="abstract operation">
      <h1>
        Add24HourDaysToTimeDuration (
          _d_: a time duration,
          _days_: an integer,
        ): either a normal completion containing a time duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns a time duration that is the sum of _d_ and the number of 24-hour days indicated by _days_, throwing an exception if the result is greater than the maximum time duration.
          This operation should not be used when adding days relative to a Temporal.ZonedDateTime, since the days may not be 24 hours long.
        </dd>
      </dl>
      <emu-alg>
        1. Let _result_ be _d_ + _days_ √ó nsPerDay.
        1. If abs(_result_) > maxTimeDuration, throw a *RangeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addtimedurationtoepochnanoseconds" type="abstract operation">
      <h1>
        AddTimeDurationToEpochNanoseconds (
          _d_: a time duration,
          _epochNs_: a BigInt,
        ): a BigInt
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds a time duration _d_ to an exact time in nanoseconds since the epoch, _epochNs_, and returns a new exact time.
          The returned exact time is not required to be valid according to IsValidEpochNanoseconds.
        </dd>
      </dl>
      <emu-alg>
        1. Return _epochNs_ + ‚Ñ§(_d_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetimeduration" type="abstract operation">
      <h1>
        CompareTimeDuration (
          _one_: a time duration,
          _two_: a time duration,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs a comparison of two time durations.</dd>
      </dl>
      <emu-alg>
        1. If _one_ > _two_, return 1.
        1. If _one_ &lt; _two_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-timedurationfromepochnanosecondsdifference" type="abstract operation">
      <h1>
        TimeDurationFromEpochNanosecondsDifference (
          _one_: a BigInt,
          _two_: a BigInt,
        ): a time duration
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned time duration is the difference between two exact times in nanoseconds since the epoch, which must not be greater than the maximum time duration.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be ‚Ñù(_one_) - ‚Ñù(_two_).
        1. Assert: abs(_result_) ‚â§ maxTimeDuration.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundtimedurationtoincrement" type="abstract operation">
      <h1>
        RoundTimeDurationToIncrement (
          _d_: a time duration,
          _increment_: a positive integer,
          _roundingMode_: a rounding mode,
        ): either a normal completion containing a time duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It rounds the total number of nanoseconds in the time duration _d_ to the nearest multiple of _increment_, up or down according to _roundingMode_.</dd>
      </dl>
      <emu-alg>
        1. Let _rounded_ be RoundNumberToIncrement(_d_, _increment_, _roundingMode_).
        1. If abs(_rounded_) > maxTimeDuration, throw a *RangeError* exception.
        1. Return _rounded_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-timedurationsign" type="abstract operation">
      <h1>
        TimeDurationSign (
          _d_: a time duration,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns 0 if the duration is zero, or ¬±1 depending on the sign of the duration.</dd>
      </dl>
      <emu-alg>
        1. If _d_ &lt; 0, return -1.
        1. If _d_ > 0, return 1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-datedurationdays" type="abstract operation">
      <h1>
        DateDurationDays (
          _dateDuration_: a Date Duration Record,
          _plainRelativeTo_: a Temporal.PlainDate,
        ): either a normal completion containing an integer or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It converts the calendar units of a duration into a number of days, and returns the result.</dd>
      </dl>
      <emu-alg>
        1. Let _yearsMonthsWeeksDuration_ be ! AdjustDateDurationRecord(_dateDuration_, 0).
        1. If DateDurationSign(_yearsMonthsWeeksDuration_) = 0, return _dateDuration_.[[Days]].
        1. Let _later_ be ? CalendarDateAdd(_plainRelativeTo_.[[Calendar]], _plainRelativeTo_.[[ISODate]], _yearsMonthsWeeksDuration_, ~constrain~).
        1. Let _epochDays1_ be ISODateToEpochDays(_plainRelativeTo_.[[ISODate]].[[Year]], _plainRelativeTo_.[[ISODate]].[[Month]] - 1, _plainRelativeTo_.[[ISODate]].[[Day]]).
        1. Let _epochDays2_ be ISODateToEpochDays(_later_.[[Year]], _later_.[[Month]] - 1, _later_.[[Day]]).
        1. Let _yearsMonthsWeeksInDays_ be _epochDays2_ - _epochDays1_.
        1. Return _dateDuration_.[[Days]] + _yearsMonthsWeeksInDays_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundtimeduration" type="abstract operation">
      <h1>
        RoundTimeDuration (
          _timeDuration_: a time duration,
          _increment_: a positive integer,
          _unit_: a time unit,
          _roundingMode_: a rounding mode,
        ): either a normal completion containing a time duration, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It rounds a _timeDuration_ according to the rounding parameters _unit_, _increment_, and _roundingMode_, and returns the time duration result.
        </dd>
      </dl>
      <emu-alg>
        1. Let _divisor_ be the value in the "Length in Nanoseconds" column of the row of <emu-xref href="#table-temporal-units"></emu-xref> whose "Value" column contains _unit_.
        1. Return ? RoundTimeDurationToIncrement(_timeDuration_, _divisor_ √ó _increment_, _roundingMode_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totaltimeduration" type="abstract operation">
      <h1>
        TotalTimeDuration (
          _timeDuration_: a time duration,
          _unit_: a time unit or ~day~,
        ): a mathematical value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the total number of _unit_ in _duration_.</dd>
      </dl>
      <emu-alg>
        1. Let _divisor_ be the value in the "Length in Nanoseconds" column of the row of <emu-xref href="#table-temporal-units"></emu-xref> whose "Value" column contains _unit_.
        1. NOTE: The following step cannot be implemented directly using floating-point arithmetic when ùîΩ(_timeDuration_) is not a safe integer. The division can be implemented in C++ with the `__float128` type if the compiler supports it, or with software emulation such as in the <a href="https://bellard.org/softfp/">SoftFP</a> library.
        1. Return _timeDuration_ / _divisor_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-duration-nudge-result-records">
      <h1>Duration Nudge Result Records</h1>
      <p>A <dfn variants="Duration Nudge Result Records">Duration Nudge Result Record</dfn> is a Record value used to represent the result of rounding a duration up or down to an increment relative to a date-time, as in NudgeToCalendarUnit, NudgeToZonedTime, or NudgeToDayOrTime.</p>
      <p>Duration Nudge Result Records have the fields listed in <emu-xref href="#table-temporal-duration-nudge-result-record-fields"></emu-xref>.</p>
      <emu-table id="table-temporal-duration-nudge-result-record-fields" caption="Duration Nudge Result Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Duration]]</td>
            <td>an Internal Duration Record</td>
            <td>
              The resulting duration.
            </td>
          </tr>
          <tr>
            <td>[[NudgedEpochNs]]</td>
            <td>a BigInt</td>
            <td>
              The epoch time corresponding to the rounded duration, relative to the starting point.
            </td>
          </tr>
          <tr>
            <td>[[DidExpandCalendarUnit]]</td>
            <td>a Boolean</td>
            <td>
              Whether the rounding operation caused the duration to expand to the next day or larger unit.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-nudgetocalendarunit" type="abstract operation">
      <h1>
        NudgeToCalendarUnit (
          _sign_: -1 or 1,
          _duration_: an Internal Duration Record,
          _destEpochNs_: a BigInt,
          _isoDateTime_: an ISO Date-Time Record,
          _timeZone_: an available time zone identifier or ~unset~,
          _calendar_: a calendar type,
          _increment_: a positive integer,
          _unit_: a date unit,
          _roundingMode_: a rounding mode,
        ): either a normal completion containing a Record with fields [[NudgeResult]] (a Duration Nudge Result Record) and [[Total]] (a mathematical value), or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It implements rounding a duration to an increment of a calendar unit, relative to a starting point, by calculating the upper and lower bounds of the starting point added to the duration in epoch nanoseconds, and rounding according to which one is closer to _destEpochNs_.
        </dd>
      </dl>
      <emu-alg>
        1. If _unit_ is ~year~, then
          1. Let _years_ be RoundNumberToIncrement(_duration_.[[Date]].[[Years]], _increment_, ~trunc~).
          1. Let _r1_ be _years_.
          1. Let _r2_ be _years_ + _increment_ √ó _sign_.
          1. Let _startDuration_ be ? CreateDateDurationRecord(_r1_, 0, 0, 0).
          1. Let _endDuration_ be ? CreateDateDurationRecord(_r2_, 0, 0, 0).
        1. Else if _unit_ is ~month~, then
          1. Let _months_ be RoundNumberToIncrement(_duration_.[[Date]].[[Months]], _increment_, ~trunc~).
          1. Let _r1_ be _months_.
          1. Let _r2_ be _months_ + _increment_ √ó _sign_.
          1. Let _startDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], 0, 0, _r1_).
          1. Let _endDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], 0, 0, _r2_).
        1. Else if _unit_ is ~week~, then
          1. Let _yearsMonths_ be ! AdjustDateDurationRecord(_duration_.[[Date]], 0, 0).
          1. Let _weeksStart_ be ? CalendarDateAdd(_calendar_, _isoDateTime_.[[ISODate]], _yearsMonths_, ~constrain~).
          1. Let _weeksEnd_ be BalanceISODate(_weeksStart_.[[Year]], _weeksStart_.[[Month]], _weeksStart_.[[Day]] + _duration_.[[Date]].[[Days]]).
          1. Let _untilResult_ be CalendarDateUntil(_calendar_, _weeksStart_, _weeksEnd_, ~week~).
          1. Let _weeks_ be RoundNumberToIncrement(_duration_.[[Date]].[[Weeks]] + _untilResult_.[[Weeks]], _increment_, ~trunc~).
          1. Let _r1_ be _weeks_.
          1. Let _r2_ be _weeks_ + _increment_ √ó _sign_.
          1. Let _startDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], 0, _r1_).
          1. Let _endDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], 0, _r2_).
        1. Else,
          1. Assert: _unit_ is ~day~.
          1. Let _days_ be RoundNumberToIncrement(_duration_.[[Date]].[[Days]], _increment_, ~trunc~).
          1. Let _r1_ be _days_.
          1. Let _r2_ be _days_ + _increment_ √ó _sign_.
          1. Let _startDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], _r1_).
          1. Let _endDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], _r2_).
        1. Assert: If _sign_ is 1, _r1_ ‚â• 0 and _r1_ &lt; _r2_.
        1. Assert: If _sign_ is -1, _r1_ ‚â§ 0 and _r1_ > _r2_.
        1. Let _start_ be ? CalendarDateAdd(_calendar_, _isoDateTime_.[[ISODate]], _startDuration_, ~constrain~).
        1. Let _end_ be ? CalendarDateAdd(_calendar_, _isoDateTime_.[[ISODate]], _endDuration_, ~constrain~).
        1. Let _startDateTime_ be CombineISODateAndTimeRecord(_start_, _isoDateTime_.[[Time]]).
        1. Let _endDateTime_ be CombineISODateAndTimeRecord(_end_, _isoDateTime_.[[Time]]).
        1. If _timeZone_ is ~unset~, then
          1. Let _startEpochNs_ be GetUTCEpochNanoseconds(_startDateTime_).
          1. Let _endEpochNs_ be GetUTCEpochNanoseconds(_endDateTime_).
        1. Else,
          1. Let _startEpochNs_ be ? GetEpochNanosecondsFor(_timeZone_, _startDateTime_, ~compatible~).
          1. Let _endEpochNs_ be ? GetEpochNanosecondsFor(_timeZone_, _endDateTime_, ~compatible~).
        1. If _sign_ is 1, then
          1. Assert: _startEpochNs_ ‚â§ _destEpochNs_ ‚â§ _endEpochNs_.
        1. Else,
          1. Assert: _endEpochNs_ ‚â§ _destEpochNs_ ‚â§ _startEpochNs_.
        1. Assert: _startEpochNs_ ‚â† _endEpochNs_.
        1. Let _progress_ be (_destEpochNs_ - _startEpochNs_) / (_endEpochNs_ - _startEpochNs_).
        1. Let _total_ be _r1_ + _progress_ √ó _increment_ √ó _sign_.
        1. NOTE: The above two steps cannot be implemented directly using floating-point arithmetic. This division can be implemented as if expressing the denominator and numerator of _total_ as two time durations, and performing one division operation with a floating-point result.
        1. Assert: 0 ‚â§ _progress_ ‚â§ 1.
        1. If _sign_ &lt; 0, let _isNegative_ be ~negative~; else let _isNegative_ be ~positive~.
        1. Let _unsignedRoundingMode_ be GetUnsignedRoundingMode(_roundingMode_, _isNegative_).
        1. If _progress_ = 1, then
          1. Let _roundedUnit_ be abs(_r2_).
        1. Else,
          1. Assert: abs(_r1_) ‚â§ abs(_total_) &lt; abs(_r2_).
          1. Let _roundedUnit_ be ApplyUnsignedRoundingMode(abs(_total_), abs(_r1_), abs(_r2_), _unsignedRoundingMode_).
        1. If _roundedUnit_ is abs(_r2_), then
          1. Let _didExpandCalendarUnit_ be *true*.
          1. Let _resultDuration_ be _endDuration_.
          1. Let _nudgedEpochNs_ be _endEpochNs_.
        1. Else,
          1. Let _didExpandCalendarUnit_ be *false*.
          1. Let _resultDuration_ be _startDuration_.
          1. Let _nudgedEpochNs_ be _startEpochNs_.
        1. Set _resultDuration_ to ! CombineDateAndTimeDuration(_resultDuration_, 0).
        1. Let _nudgeResult_ be Duration Nudge Result Record { [[Duration]]: _resultDuration_, [[NudgedEpochNs]]: _nudgedEpochNs_, [[DidExpandCalendarUnit]]: _didExpandCalendarUnit_ }.
        1. Return the Record { [[NudgeResult]]: _nudgeResult_, [[Total]]: _total_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-nudgetozonedtime" type="abstract operation">
      <h1>
        NudgeToZonedTime (
          _sign_: -1 or 1,
          _duration_: an Internal Duration Record,
          _isoDateTime_: an ISO Date-Time Record,
          _timeZone_: an available time zone identifier,
          _calendar_: a calendar type,
          _increment_: a positive integer,
          _unit_: a time unit,
          _roundingMode_: a rounding mode,
        ): either a normal completion containing a Duration Nudge Result Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It implements rounding a duration to an increment of a time unit, relative to a `Temporal.ZonedDateTime` starting point, accounting for the case where the rounding causes the time to exceed the total time within a day, which may be influenced by UTC offset changes in the time zone.
        </dd>
      </dl>
      <emu-alg>
        1. Let _start_ be ? CalendarDateAdd(_calendar_, _isoDateTime_.[[ISODate]], _duration_.[[Date]], ~constrain~).
        1. Let _startDateTime_ be CombineISODateAndTimeRecord(_start_, _isoDateTime_.[[Time]]).
        1. Let _endDate_ be BalanceISODate(_start_.[[Year]], _start_.[[Month]], _start_.[[Day]] + _sign_).
        1. Let _endDateTime_ be CombineISODateAndTimeRecord(_endDate_, _isoDateTime_.[[Time]]).
        1. Let _startEpochNs_ be ? GetEpochNanosecondsFor(_timeZone_, _startDateTime_, ~compatible~).
        1. Let _endEpochNs_ be ? GetEpochNanosecondsFor(_timeZone_, _endDateTime_, ~compatible~).
        1. Let _daySpan_ be TimeDurationFromEpochNanosecondsDifference(_endEpochNs_, _startEpochNs_).
        1. Assert: TimeDurationSign(_daySpan_) = _sign_.
        1. Let _unitLength_ be the value in the "Length in Nanoseconds" column of the row of <emu-xref href="#table-temporal-units"></emu-xref> whose "Value" column contains _unit_.
        1. Let _roundedTimeDuration_ be ? RoundTimeDurationToIncrement(_duration_.[[Time]], _increment_ √ó _unitLength_, _roundingMode_).
        1. Let _beyondDaySpan_ be ? AddTimeDuration(_roundedTimeDuration_, -_daySpan_).
        1. If TimeDurationSign(_beyondDaySpan_) ‚â† -_sign_, then
          1. Let _didRoundBeyondDay_ be *true*.
          1. Let _dayDelta_ be _sign_.
          1. Set _roundedTimeDuration_ to ? RoundTimeDurationToIncrement(_beyondDaySpan_, _increment_ √ó _unitLength_, _roundingMode_).
          1. Let _nudgedEpochNs_ be AddTimeDurationToEpochNanoseconds(_roundedTimeDuration_, _endEpochNs_).
        1. Else,
          1. Let _didRoundBeyondDay_ be *false*.
          1. Let _dayDelta_ be 0.
          1. Let _nudgedEpochNs_ be AddTimeDurationToEpochNanoseconds(_roundedTimeDuration_, _startEpochNs_).
        1. Let _dateDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], _duration_.[[Date]].[[Days]] + _dayDelta_).
        1. Let _resultDuration_ be ? CombineDateAndTimeDuration(_dateDuration_, _roundedTimeDuration_).
        1. Return Duration Nudge Result Record { [[Duration]]: _resultDuration_, [[NudgedEpochNs]]: _nudgedEpochNs_, [[DidExpandCalendarUnit]]: _didRoundBeyondDay_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-nudgetodayortime" type="abstract operation">
      <h1>
        NudgeToDayOrTime (
          _duration_: an Internal Duration Record,
          _destEpochNs_: a BigInt,
          _largestUnit_: a Temporal unit,
          _increment_: a positive integer,
          _smallestUnit_: a time unit or ~day~,
          _roundingMode_: a rounding mode,
        ): either a normal completion containing a Duration Nudge Result Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It implements rounding a duration to an increment of a time unit, in cases unaffected by the calendar or time zone.
        </dd>
      </dl>
      <emu-alg>
        1. Let _timeDuration_ be ! Add24HourDaysToTimeDuration(_duration_.[[Time]], _duration_.[[Date]].[[Days]]).
        1. Let _unitLength_ be the value in the "Length in Nanoseconds" column of the row of <emu-xref href="#table-temporal-units"></emu-xref> whose "Value" column contains _smallestUnit_.
        1. Let _roundedTime_ be ? RoundTimeDurationToIncrement(_timeDuration_, _unitLength_ √ó _increment_, _roundingMode_).
        1. Let _diffTime_ be ! AddTimeDuration(_roundedTime_, -_timeDuration_).
        1. Let _wholeDays_ be truncate(TotalTimeDuration(_timeDuration_, ~day~)).
        1. Let _roundedWholeDays_ be truncate(TotalTimeDuration(_roundedTime_, ~day~)).
        1. Let _dayDelta_ be _roundedWholeDays_ - _wholeDays_.
        1. If _dayDelta_ &lt; 0, let _dayDeltaSign_ be -1; else if _dayDelta_ > 0, let _dayDeltaSign_ be 1; else let _dayDeltaSign_ be 0.
        1. If _dayDeltaSign_ = TimeDurationSign(_timeDuration_), let _didExpandDays_ be *true*; else let _didExpandDays_ be *false*.
        1. Let _nudgedEpochNs_ be AddTimeDurationToEpochNanoseconds(_diffTime_, _destEpochNs_).
        1. Let _days_ be 0.
        1. Let _remainder_ be _roundedTime_.
        1. If TemporalUnitCategory(_largestUnit_) is ~date~, then
          1. Set _days_ to _roundedWholeDays_.
          1. Set _remainder_ to ! AddTimeDuration(_roundedTime_, TimeDurationFromComponents(-_roundedWholeDays_ * HoursPerDay, 0, 0, 0, 0, 0)).
        1. Let _dateDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], _days_).
        1. Let _resultDuration_ be ? CombineDateAndTimeDuration(_dateDuration_, _remainder_).
        1. Return Duration Nudge Result Record { [[Duration]]: _resultDuration_, [[NudgedEpochNs]]: _nudgedEpochNs_, [[DidExpandCalendarUnit]]: _didExpandDays_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-bubblerelativeduration" type="abstract operation">
      <h1>
        BubbleRelativeDuration (
          _sign_: -1 or 1,
          _duration_: an Internal Duration Record,
          _nudgedEpochNs_: a BigInt,
          _isoDateTime_: an ISO Date-Time Record,
          _timeZone_: an available time zone identifier or ~unset~,
          _calendar_: a calendar type,
          _largestUnit_: a date unit,
          _smallestUnit_: a date unit,
        ): either a normal completion containing an Internal Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          Given a duration that has potentially been made bottom-heavy by rounding in NudgeToCalendarUnit, NudgeToZonedTime, or NudgeToDayOrTime, it bubbles up smaller units to larger units.
        </dd>
      </dl>
      <emu-alg>
        1. If _smallestUnit_ is _largestUnit_, return _duration_.
        1. Let _largestUnitIndex_ be the ordinal index of the row of <emu-xref href="#table-temporal-units"></emu-xref> whose "Value" column contains _largestUnit_.
        1. Let _smallestUnitIndex_ be the ordinal index of the row of <emu-xref href="#table-temporal-units"></emu-xref> whose "Value" column contains _smallestUnit_.
        1. Let _unitIndex_ be _smallestUnitIndex_ - 1.
        1. Let _done_ be *false*.
        1. Repeat, while _unitIndex_ ‚â• _largestUnitIndex_ and _done_ is *false*,
          1. Let _unit_ be the value in the "Value" column of <emu-xref href="#table-temporal-units"></emu-xref> in the row whose ordinal index is _unitIndex_.
          1. If _unit_ is not ~week~, or _largestUnit_ is ~week~, then
            1. If _unit_ is ~year~, then
              1. Let _years_ be _duration_.[[Date]].[[Years]] + _sign_.
              1. Let _endDuration_ be ? CreateDateDurationRecord(_years_, 0, 0, 0).
            1. Else if _unit_ is ~month~, then
              1. Let _months_ be _duration_.[[Date]].[[Months]] + _sign_.
              1. Let _endDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], 0, 0, _months_).
            1. Else,
              1. Assert: _unit_ is ~week~.
              1. Let _weeks_ be _duration_.[[Date]].[[Weeks]] + _sign_.
              1. Let _endDuration_ be ? AdjustDateDurationRecord(_duration_.[[Date]], 0, _weeks_).
            1. Let _end_ be ? CalendarDateAdd(_calendar_, _isoDateTime_.[[ISODate]], _endDuration_, ~constrain~).
            1. Let _endDateTime_ be CombineISODateAndTimeRecord(_end_, _isoDateTime_.[[Time]]).
            1. If _timeZone_ is ~unset~, then
              1. Let _endEpochNs_ be GetUTCEpochNanoseconds(_endDateTime_).
            1. Else,
              1. Let _endEpochNs_ be ? GetEpochNanosecondsFor(_timeZone_, _endDateTime_, ~compatible~).
            1. Let _beyondEnd_ be _nudgedEpochNs_ - _endEpochNs_.
            1. If _beyondEnd_ &lt; 0, let _beyondEndSign_ be -1; else if _beyondEnd_ > 0, let _beyondEndSign_ be 1; else let _beyondEndSign_ be 0.
            1. If _beyondEndSign_ ‚â† -_sign_, then
              1. Set _duration_ to ! CombineDateAndTimeDuration(_endDuration_, 0).
            1. Else,
              1. Set _done_ to *true*.
          1. Set _unitIndex_ to _unitIndex_ - 1.
        1. Return _duration_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundrelativeduration" type="abstract operation">
      <h1>
        RoundRelativeDuration (
          _duration_: an Internal Duration Record,
          _destEpochNs_: a BigInt,
          _isoDateTime_: an ISO Date-Time Record,
          _timeZone_: an available time zone identifier or ~unset~,
          _calendar_: a calendar type,
          _largestUnit_: a Temporal unit,
          _increment_: a positive integer,
          _smallestUnit_: a Temporal unit,
          _roundingMode_: a rounding mode,
        ): either a normal completion containing an Internal Duration Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It rounds a duration _duration_ relative to _isoDateTime_ according to the rounding parameters _smallestUnit_, _increment_, and _roundingMode_, bubbles overflows up to the next highest unit until _largestUnit_, and returns the rounded duration.
        </dd>
      </dl>
      <emu-alg>
        1. Let _irregularLengthUnit_ be *false*.
        1. If IsCalendarUnit(_smallestUnit_) is *true*, set _irregularLengthUnit_ to *true*.
        1. If _timeZone_ is not ~unset~ and _smallestUnit_ is ~day~, set _irregularLengthUnit_ to *true*.
        1. If InternalDurationSign(_duration_) &lt; 0, let _sign_ be -1; else let _sign_ be 1.
        1. If _irregularLengthUnit_ is *true*, then
          1. Let _record_ be ? NudgeToCalendarUnit(_sign_, _duration_, _destEpochNs_, _isoDateTime_, _timeZone_, _calendar_, _increment_, _smallestUnit_, _roundingMode_).
          1. Let _nudgeResult_ be _record_.[[NudgeResult]].
        1. Else if _timeZone_ is not ~unset~, then
          1. Let _nudgeResult_ be ? NudgeToZonedTime(_sign_, _duration_, _isoDateTime_, _timeZone_, _calendar_, _increment_, _smallestUnit_, _roundingMode_).
        1. Else,
          1. Let _nudgeResult_ be ? NudgeToDayOrTime(_duration_, _destEpochNs_, _largestUnit_, _increment_, _smallestUnit_, _roundingMode_).
        1. Set _duration_ to _nudgeResult_.[[Duration]].
        1. If _nudgeResult_.[[DidExpandCalendarUnit]] is *true* and _smallestUnit_ is not ~week~, then
          1. Let _startUnit_ be LargerOfTwoTemporalUnits(_smallestUnit_, ~day~).
          1. Set _duration_ to ? BubbleRelativeDuration(_sign_, _duration_, _nudgeResult_.[[NudgedEpochNs]], _isoDateTime_, _timeZone_, _calendar_, _largestUnit_, _startUnit_).
        1. Return _duration_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totalrelativeduration" type="abstract operation">
      <h1>
        TotalRelativeDuration (
          _duration_: an Internal Duration Record,
          _destEpochNs_: a BigInt,
          _isoDateTime_: an ISO Date-Time Record,
          _timeZone_: an available time zone identifier or ~unset~,
          _calendar_: a calendar type,
          _unit_: a Temporal unit,
        ): either a normal completion containing a mathematical value, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the total number of _unit_ in _duration_, relative to _isoDateTime_ if a starting point is necessary for calendar units.</dd>
      </dl>
      <emu-alg>
        1. If IsCalendarUnit(_unit_) is *true*, or _timeZone_ is not ~unset~ and _unit_ is ~day~, then
          1. Let _sign_ be InternalDurationSign(_duration_).
          1. Let _record_ be ? NudgeToCalendarUnit(_sign_, _duration_, _destEpochNs_, _isoDateTime_, _timeZone_, _calendar_, 1, _unit_, ~trunc~).
          1. Return _record_.[[Total]].
        1. Let _timeDuration_ be ! Add24HourDaysToTimeDuration(_duration_.[[Time]], _duration_.[[Date]].[[Days]]).
        1. Return TotalTimeDuration(_timeDuration_, _unit_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldurationtostring" type="abstract operation">
      <h1>
        TemporalDurationToString (
          _duration_: a Temporal.Duration,
          _precision_: an integer between 0 and 9 inclusive, or ~auto~,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns a String which is the ISO 8601 representation of _duration_, with the number of decimal places in the seconds value controlled by _precision_.</dd>
      </dl>
      <emu-alg>
        1. Let _sign_ be DurationSign(_duration_).
        1. Let _datePart_ be the empty String.
        1. If _duration_.[[Years]] ‚â† 0, then
          1. Set _datePart_ to the string concatenation of abs(_duration_.[[Years]]) formatted as a decimal number and the code unit 0x0059 (LATIN CAPITAL LETTER Y).
        1. If _duration_.[[Months]] ‚â† 0, then
          1. Set _datePart_ to the string concatenation of _datePart_, abs(_duration_.[[Months]]) formatted as a decimal number, and the code unit 0x004D (LATIN CAPITAL LETTER M).
        1. If _duration_.[[Weeks]] ‚â† 0, then
          1. Set _datePart_ to the string concatenation of _datePart_, abs(_duration_.[[Weeks]]) formatted as a decimal number, and the code unit 0x0057 (LATIN CAPITAL LETTER W).
        1. If _duration_.[[Days]] ‚â† 0, then
          1. Set _datePart_ to the string concatenation of _datePart_, abs(_duration_.[[Days]]) formatted as a decimal number, and the code unit 0x0044 (LATIN CAPITAL LETTER D).
        1. Let _timePart_ be the empty String.
        1. If _duration_.[[Hours]] ‚â† 0, then
          1. Set _timePart_ to the string concatenation of abs(_duration_.[[Hours]]) formatted as a decimal number and the code unit 0x0048 (LATIN CAPITAL LETTER H).
        1. If _duration_.[[Minutes]] ‚â† 0, then
          1. Set _timePart_ to the string concatenation of _timePart_, abs(_duration_.[[Minutes]]) formatted as a decimal number, and the code unit 0x004D (LATIN CAPITAL LETTER M).
        1. Let _zeroMinutesAndHigher_ be *false*.
        1. If DefaultTemporalLargestUnit(_duration_) is ~second~, ~millisecond~, ~microsecond~, or ~nanosecond~, set _zeroMinutesAndHigher_ to *true*.
        1. Let _secondsDuration_ be TimeDurationFromComponents(0, 0, _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. If _secondsDuration_ ‚â† 0, or _zeroMinutesAndHigher_ is *true*, or _precision_ is not ~auto~, then
          1. Let _secondsPart_ be abs(truncate(_secondsDuration_ / 10<sup>9</sup>)) formatted as a decimal number.
          1. Let _subSecondsPart_ be FormatFractionalSeconds(abs(remainder(_secondsDuration_, 10<sup>9</sup>)), _precision_).
          1. Set _timePart_ to the string concatenation of _timePart_, _secondsPart_, _subSecondsPart_, and the code unit 0x0053 (LATIN CAPITAL LETTER S).
        1. Let _signPart_ be the code unit 0x002D (HYPHEN-MINUS) if _sign_ &lt; 0, and otherwise the empty String.
        1. Let _result_ be the string concatenation of _signPart_, the code unit 0x0050 (LATIN CAPITAL LETTER P) and _datePart_.
        1. If _timePart_ is not the empty String, then
          1. Set _result_ to the string concatenation of _result_, the code unit 0x0054 (LATIN CAPITAL LETTER T), and _timePart_.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddurations" type="abstract operation">
      <h1>
        AddDurations (
          _operation_: ~add~ or ~subtract~,
          _duration_: a Temporal.Duration,
          _other_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds or subtracts the components of a second duration _other_ to or from those of a first duration _duration_, resulting in a longer or shorter duration, unless calendar calculations would be required, in which case it throws an exception.
          It balances the result, ensuring that no mixed signs remain.
        </dd>
      </dl>
      <emu-alg>
        1. Set _other_ to ? ToTemporalDuration(_other_).
        1. If _operation_ is ~subtract~, set _other_ to CreateNegatedTemporalDuration(_other_).
        1. Let _largestUnit1_ be DefaultTemporalLargestUnit(_duration_).
        1. Let _largestUnit2_ be DefaultTemporalLargestUnit(_other_).
        1. Let _largestUnit_ be LargerOfTwoTemporalUnits(_largestUnit1_, _largestUnit2_).
        1. If IsCalendarUnit(_largestUnit_) is *true*, throw a *RangeError* exception.
        1. Let _d1_ be ToInternalDurationRecordWith24HourDays(_duration_).
        1. Let _d2_ be ToInternalDurationRecordWith24HourDays(_other_).
        1. Let _timeResult_ be ? AddTimeDuration(_d1_.[[Time]], _d2_.[[Time]]).
        1. Let _result_ be ! CombineDateAndTimeDuration(ZeroDateDuration(), _timeResult_).
        1. Return ? TemporalDurationFromInternal(_result_, _largestUnit_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
