<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaindate-objects">
  <h1>Temporal.PlainDate Objects</h1>
  <p>A Temporal.PlainDate object is an Object that contains integers corresponding to a
    particular year, month, and day in the ISO8601 calendar, as well as an Object value used to
    interpret those integers in a particular calendar.</p>

  <emu-clause id="sec-temporal-plaindate-constructor">
    <h1>The Temporal.PlainDate Constructor</h1>
    <p>The Temporal.PlainDate constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.PlainDate object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.PlainDate behaviour must
        include a super call to the %Temporal.PlainDate% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.plaindate">
      <h1>Temporal.PlainDate ( _isoYear_, _isoMonth_, _isoDay_ [ , _calendarLike_ ] )</h1>
      <p>
        When the `Temporal.PlainDate` function is called, the following steps are taken:
      </p>
      <emu-note>The value of ! ToIntegerThrowOnInfinity(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _y_ be ? ToIntegerThrowOnInfinity(_isoYear_).
        1. Let _m_ be ? ToIntegerThrowOnInfinity(_isoMonth_).
        1. Let _d_ be ? ToIntegerThrowOnInfinity(_isoDay_).
        1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_calendarLike_).
        1. Return ? CreateTemporalDate(_y_, _m_, _d_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindate-constructor">
    <h1>Properties of the Temporal.PlainDate Constructor</h1>
    <p>The Temporal.PlainDate constructor:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-clause id="sec-temporal.plaindate.prototype">
      <h1>Temporal.PlainDate.prototype</h1>
      <p>The initial value of `Temporal.PlainDate.prototype` is %Temporal.PlainDate.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.from">
      <h1>Temporal.PlainDate.from ( _item_ [ , _options_ ] )</h1>
      <p>
        The `from` method takes two arguments, _item_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalDate]] internal slot, then
          1. Perform ? ToTemporalOverflow(_options_).
          1. Return ? CreateTemporalDate(_item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], _item_.[[Calendar]]).
        1. Return ? ToTemporalDate(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.compare">
      <h1>Temporal.PlainDate.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDate(_one_).
        1. Set _two_ to ? ToTemporalDate(_two_).
        1. Return ùîΩ(! CompareISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindate-prototype-object">
    <h1>Properties of the Temporal.PlainDate Prototype Object</h1>

    <p>The Temporal.PlainDate prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.PlainDate instance and does not have a [[InitializedTemporalDate]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.plaindate.prototype.constructor">
      <h1>Temporal.PlainDate.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainDate.prototype.constructor` is %Temporal.PlainDate%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype-@@tostringtag">
      <h1>Temporal.PlainDate.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.PlainDate"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.calendar">
      <h1>get Temporal.PlainDate.prototype.calendar</h1>
      <p>
        `Temporal.PlainDate.prototype.calendar` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return _temporalDate_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.year">
      <h1>get Temporal.PlainDate.prototype.year</h1>
      <p>
        `Temporal.PlainDate.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.month">
      <h1>get Temporal.PlainDate.prototype.month</h1>
      <p>
        `Temporal.PlainDate.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarMonth(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.monthCode">
      <h1>get Temporal.PlainDate.prototype.monthCode</h1>
      <p>
        `Temporal.PlainDate.prototype.monthCode` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarMonthCode(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.day">
      <h1>get Temporal.PlainDate.prototype.day</h1>
      <p>
        `Temporal.PlainDate.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDay(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.dayofweek">
      <h1>get Temporal.PlainDate.prototype.dayOfWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDayOfWeek(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.dayofyear">
      <h1>get Temporal.PlainDate.prototype.dayOfYear</h1>
      <p>
        `Temporal.PlainDate.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDayOfYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.weekofyear">
      <h1>get Temporal.PlainDate.prototype.weekOfYear</h1>
      <p>
        `Temporal.PlainDate.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarWeekOfYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinweek">
      <h1>get Temporal.PlainDate.prototype.daysInWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDaysInWeek(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinmonth">
      <h1>get Temporal.PlainDate.prototype.daysInMonth</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDaysInMonth(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinyear">
      <h1>get Temporal.PlainDate.prototype.daysInYear</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDaysInYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.monthsinyear">
      <h1>get Temporal.PlainDate.prototype.monthsInYear</h1>
      <p>
        `Temporal.PlainDate.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarMonthsInYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.inleapyear">
      <h1>get Temporal.PlainDate.prototype.inLeapYear</h1>
      <p>
        `Temporal.PlainDate.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarInLeapYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplainyearmonth">
      <h1>Temporal.PlainDate.prototype.toPlainYearMonth ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"monthCode"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDate_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarYearMonthFromFields(_calendar_, _fields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplainmonthday">
      <h1>Temporal.PlainDate.prototype.toPlainMonthDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"monthCode"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDate_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarMonthDayFromFields(_calendar_, _fields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.getisofields">
      <h1>Temporal.PlainDate.prototype.getISOFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _fields_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _temporalDate_.[[Calendar]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, ùîΩ(_temporalDate_.[[ISODay]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, ùîΩ(_temporalDate_.[[ISOMonth]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, ùîΩ(_temporalDate_.[[ISOYear]])).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.add">
      <h1>Temporal.PlainDate.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `add` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _duration_ be ? ToTemporalDuration(_temporalDurationLike_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Return ? CalendarDateAdd(_temporalDate_.[[Calendar]], _temporalDate_, _duration_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.subtract">
      <h1>Temporal.PlainDate.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `subtract` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _duration_ be ? ToTemporalDuration(_temporalDurationLike_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _negatedDuration_ be ! CreateNegatedTemporalDuration(_duration_).
        1. Return ? CalendarDateAdd(_temporalDate_.[[Calendar]], _temporalDate_, _negatedDuration_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.with">
      <h1>Temporal.PlainDate.prototype.with ( _temporalDateLike_ [ , _options_ ] )</h1>
      <p>
        The `with` method takes two arguments, _temporalDateLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If Type(_temporalDateLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Perform ? RejectObjectWithCalendarOrTimeZone(_temporalDateLike_).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª).
        1. Let _partialDate_ be ? PrepareTemporalFields(_temporalDateLike_, _fieldNames_, ~partial~).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDate_, _fieldNames_, ¬´¬ª).
        1. Set _fields_ to ? CalendarMergeFields(_calendar_, _fields_, _partialDate_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarDateFromFields(_calendar_, _fields_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.withcalendar">
      <h1>Temporal.PlainDate.prototype.withCalendar ( _calendarLike_ )</h1>
      <p>
        The `withCalendar` method takes one argument _calendarLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be ? ToTemporalCalendar(_calendarLike_).
        1. Return ! CreateTemporalDate(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.until">
      <h1>Temporal.PlainDate.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        The `until` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? DifferenceTemporalPlainDate(~until~, _temporalDate_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.since">
      <h1>Temporal.PlainDate.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        The `since` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? DifferenceTemporalPlainDate(~since~, _temporalDate_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.equals">
      <h1>Temporal.PlainDate.prototype.equals ( _other_ )</h1>
      <p>
        The `equals` method takes one argument _other_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. If _temporalDate_.[[ISOYear]] &ne; _other_.[[ISOYear]], return *false*.
        1. If _temporalDate_.[[ISOMonth]] &ne; _other_.[[ISOMonth]], return *false*.
        1. If _temporalDate_.[[ISODay]] &ne; _other_.[[ISODay]], return *false*.
        1. Return ? CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplaindatetime">
      <h1>Temporal.PlainDate.prototype.toPlainDateTime ( [ _temporalTime_ ] )</h1>
      <p>
        The `toPlainDateTime` method takes one argument _temporalTime_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If _temporalTime_ is *undefined*, then
          1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
        1. Set _temporalTime_ to ? ToTemporalTime(_temporalTime_).
        1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]],
          _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]],
          _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]],
          _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tozoneddatetime">
      <h1>Temporal.PlainDate.prototype.toZonedDateTime ( _item_ )</h1>
      <p>
        The `toZonedDateTime` method takes one argument _item_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If Type(_item_) is Object, then
          1. Let _timeZoneLike_ be ? Get(_item_, *"timeZone"*).
          1. If _timeZoneLike_ is *undefined*, then
            1. Let _timeZone_ be ? ToTemporalTimeZone(_item_).
            1. Let _temporalTime_ be *undefined*.
          1. Else,
            1. Let _timeZone_ be ? ToTemporalTimeZone(_timeZoneLike_).
            1. Let _temporalTime_ be ? Get(_item_, *"plainTime"*).
        1. Else,
          1. Let _timeZone_ be ? ToTemporalTimeZone(_item_).
          1. Let _temporalTime_ be *undefined*.
        1. If _temporalTime_ is *undefined*, then
          1. Let _temporalDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
        1. Else,
          1. Set _temporalTime_ to ? ToTemporalTime(_temporalTime_).
          1. Let _temporalDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], _temporalDate_.[[Calendar]]).
        1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _temporalDateTime_, *"compatible"*).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tostring">
      <h1>Temporal.PlainDate.prototype.toString ( [ _options_ ] )</h1>
      <p>
        The `toString` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _showCalendar_ be ? ToShowCalendarOption(_options_).
        1. Return ? TemporalDateToString(_temporalDate_, _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tolocalestring">
      <h1>Temporal.PlainDate.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.PlainDate.prototype.toLocaleString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleString` method is used.
      </p>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? TemporalDateToString(_temporalDate_, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tojson">
      <h1>Temporal.PlainDate.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? TemporalDateToString(_temporalDate_, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.valueof">
      <h1>Temporal.PlainDate.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaindate-instances">
    <h1>Properties of Temporal.PlainDate Instances</h1>
    <p>
      Temporal.PlainDate instances are ordinary objects that inherit properties from the %Temporal.PlainDate.prototype% intrinsic object.
      Temporal.PlainDate instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaldate-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaldate-instances" caption="Internal Slots of Temporal.PlainDate Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalDate]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.PlainDate instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOYear]]
            </td>
            <td>
              An integer representing the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMonth]]
            </td>
            <td>
              An integer between 1 and 12, inclusive, representing the month of the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISODay]]
            </td>
            <td>
              An integer between 1 and ISODaysInMonth([[ISOYear]], [[ISOMonth]]), inclusive, representing the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              An Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaindate-abstract-ops">
    <h1>Abstract Operations for Temporal.PlainDate Objects</h1>

    <emu-clause id="sec-temporal-iso-date-records">
      <h1>ISO Date Records</h1>
      <p>
        An <dfn variants="ISO Date Records">ISO Date Record</dfn> is a Record value used to represent a valid calendar date in the ISO 8601 calendar, although the year may be outside of the allowed range for Temporal.
        ISO Date Records are produced by the abstract operation CreateISODateRecord.
      </p>
      <p>
        ISO Date Records have the fields listed in <emu-xref href="#table-temporal-iso-date-record-fields"></emu-xref>.
      </p>
      <emu-table id="table-temporal-iso-date-record-fields" caption="ISO Date Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer</td>
            <td>
              The year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>an integer between 1 and 12, inclusive</td>
            <td>
              The number of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>an integer between 1 and 31, inclusive</td>
            <td>
              The number of the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-create-iso-date-record" type="abstract operation">
      <h1>
        CreateISODateRecord (
          _year_: an integer,
          _month_: an integer between 1 and 12 inclusive,
          _day_: an integer between 1 and 31 inclusive,
        ): an ISO Date Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Return the Record { [[Year]]: _year_, [[Month]]: _month_, [[Day]]: _day_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldate" aoid="CreateTemporalDate">
      <h1>CreateTemporalDate ( _isoYear_, _isoMonth_, _isoDay_, _calendar_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. Assert: _isoYear_ is an integer.
        1. Assert: _isoMonth_ is an integer.
        1. Assert: _isoDay_ is an integer.
        1. Assert: Type(_calendar_) is Object.
        1. If IsValidISODate(_isoYear_, _isoMonth_, _isoDay_) is *false*, throw a *RangeError* exception.
        1. If ISODateTimeWithinLimits(_isoYear_, _isoMonth_, _isoDay_, 12, 0, 0, 0, 0, 0) is *false*, throw a *RangeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.PlainDate%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.PlainDate.prototype%"*, ¬´ [[InitializedTemporalDate]], [[ISOYear]], [[ISOMonth]], [[ISODay]], [[Calendar]] ¬ª).
        1. Set _object_.[[ISOYear]] to _isoYear_.
        1. Set _object_.[[ISOMonth]] to _isoMonth_.
        1. Set _object_.[[ISODay]] to _isoDay_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
      <emu-note>
        <p>Deferring to ISODateTimeWithinLimits with an hour of 12 avoids trouble at the extremes of the representable range of dates, which stop just before midnight on each end.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldate" aoid="ToTemporalDate">
      <h1>ToTemporalDate ( _item_ [ , _options_ ] )</h1>
      <p>
        The abstract operation ToTemporalDate returns its argument _item_ if it is already a Temporal.PlainDate instance, converts _item_ to a new Temporal.PlainDate instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Assert: Type(_options_) is Object or Undefined.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalDate]] internal slot, then
            1. Return _item_.
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Let _instant_ be ! CreateTemporalInstant(_item_.[[Nanoseconds]]).
            1. Let _plainDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_item_.[[TimeZone]], _instant_, _item_.[[Calendar]]).
            1. Return ! CreateTemporalDate(_plainDateTime_.[[ISOYear]], _plainDateTime_.[[ISOMonth]], _plainDateTime_.[[ISODay]], _plainDateTime_.[[Calendar]]).
          1. If _item_ has an [[InitializedTemporalDateTime]] internal slot, then
            1. Return ! CreateTemporalDate(_item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], _item_.[[Calendar]]).
          1. Let _calendar_ be ? GetTemporalCalendarWithISODefault(_item_).
          1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª).
          1. Let _fields_ be ? PrepareTemporalFields(_item_, _fieldNames_, ¬´¬ª).
          1. Return ? CalendarDateFromFields(_calendar_, _fields_, _options_).
        1. Perform ? ToTemporalOverflow(_options_).
        1. Let _string_ be ? ToString(_item_).
        1. Let _result_ be ? ParseTemporalDateString(_string_).
        1. Assert: IsValidISODate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_result_.[[Calendar]]).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differenceisodate" type="abstract operation">
      <h1>
        DifferenceISODate (
          _y1_: an integer,
          _m1_: an integer,
          _d1_: an integer,
          _y2_: an integer,
          _m2_: an integer,
          _d2_: an integer,
          _largestUnit_: *"year"*, *"month"*, *"week"*, or *"day"*,
        ): a Date Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The return value is the elapsed duration from a first date until a second date, according to the reckoning of the ISO 8601 calendar.
          No fields larger than _largestUnit_ will be non-zero in the resulting Date Duration Record.
        </dd>
      </dl>
      <emu-alg>
        1. If _largestUnit_ is *"year"* or *"month"*, then
          1. Let _sign_ be -(! CompareISODate(_y1_, _m1_, _d1_, _y2_, _m2_, _d2_)).
          1. If _sign_ is 0, return ! CreateDateDurationRecord(0, 0, 0, 0).
          1. Let _start_ be the Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
          1. Let _end_ be the Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
          1. Let _years_ be _end_.[[Year]] - _start_.[[Year]].
          1. Let _mid_ be ! AddISODate(_y1_, _m1_, _d1_, _years_, 0, 0, 0, *"constrain"*).
          1. Let _midSign_ be -(! CompareISODate(_mid_.[[Year]], _mid_.[[Month]], _mid_.[[Day]], _y2_, _m2_, _d2_)).
          1. If _midSign_ is 0, then
            1. If _largestUnit_ is *"year"*, return ! CreateDateDurationRecord(_years_, 0, 0, 0).
            1. Return ! CreateDateDurationRecord(0, _years_ &times; 12, 0, 0).
          1. Let _months_ be _end_.[[Month]] - _start_.[[Month]].
          1. If _midSign_ is not equal to _sign_, then
            1. Set _years_ to _years_ - _sign_.
            1. Set _months_ to _months_ + _sign_ &times; 12.
          1. Set _mid_ to ! AddISODate(_y1_, _m1_, _d1_, _years_, _months_, 0, 0, *"constrain"*).
          1. Set _midSign_ to -(! CompareISODate(_mid_.[[Year]], _mid_.[[Month]], _mid_.[[Day]], _y2_, _m2_, _d2_)).
          1. If _midSign_ is 0, then
            1. If _largestUnit_ is *"year"*, return ! CreateDateDurationRecord(_years_, _months_, 0, 0).
            1. Return ! CreateDateDurationRecord(0, _months_ + _years_ &times; 12, 0, 0).
          1. If _midSign_ is not equal to _sign_, then
            1. Set _months_ to _months_ - _sign_.
            1. If _months_ is equal to -_sign_, then
              1. Set _years_ to _years_ - _sign_.
              1. Set _months_ to 11 &times; _sign_.
            1. Set _mid_ to ! AddISODate(_y1_, _m1_, _d1_, _years_, _months_, 0, 0, *"constrain"*).
          1. Let _days_ be 0.
          1. If _mid_.[[Month]] = _end_.[[Month]], then
            1. Assert: _mid_.[[Year]] = _end_.[[Year]].
            1. Set _days_ to _end_.[[Day]] - _mid_.[[Day]].
          1. Else if _sign_ &lt; 0, set _days_ to -_mid_.[[Day]] - (! ISODaysInMonth(_end_.[[Year]], _end_.[[Month]]) - _end_.[[Day]]).
          1. Else, set _days_ to _end_.[[Day]] + (! ISODaysInMonth(_mid_.[[Year]], _mid_.[[Month]]) - _mid_.[[Day]]).
          1. If _largestUnit_ is *"month"*, then
            1. Set _months_ to _months_ + _years_ &times; 12.
            1. Set _years_ to 0.
          1. Return ! CreateDateDurationRecord(_years_, _months_, 0, _days_).
        1. If _largestUnit_ is *"day"* or *"week"*, then
          1. Let _epochDays1_ be MakeDay(ùîΩ(_y1_), ùîΩ(_m1_ - 1), ùîΩ(_d1_)).
          1. Assert: _epochDays1_ is finite.
          1. Let _epochDays2_ be MakeDay(ùîΩ(_y2_), ùîΩ(_m2_ - 1), ùîΩ(_d2_)).
          1. Assert: _epochDays2_ is finite.
          1. Let _days_ be ‚Ñù(_epochDays2_) - ‚Ñù(_epochDays1_).
          1. Let _weeks_ be 0.
          1. If _largestUnit_ is *"week"*, then
            1. Set _weeks_ to RoundTowardsZero(_days_ / 7).
            1. Set _days_ to remainder(_days_, 7).
          1. Return ! CreateDateDurationRecord(0, 0, _weeks_, _days_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-regulateisodate" type="abstract operation">
      <h1>
        RegulateISODate (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
          _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing an ISO Date Record, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs the overflow correction given by _overflow_ on the values _year_, _month_, and _day_, in order to arrive at a valid date in the ISO 8601 calendar, as determined by IsValidISODate.
          For *"reject"*, values that do not form a valid date cause an exception to be thrown.
          For *"constrain"*, values that do not form a valid date are clamped to the correct range.
        </dd>
      </dl>
      <emu-alg>
        1. If _overflow_ is *"reject"*, then
          1. If IsValidISODate(_year_, _month_, _day_) is *false*, throw a *RangeError* exception.
          1. Return CreateISODateRecord(_year_, _month_, _day_).
        1. If _overflow_ is *"constrain"*, then
          1. Set _month_ to the result of clamping _month_ between 1 and 12.
          1. Let _daysInMonth_ be ! ISODaysInMonth(_year_, _month_).
          1. Set _day_ to the result of clamping _day_ between 1 and _daysInMonth_.
          1. Return CreateISODateRecord(_year_, _month_, _day_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isvalidisodate" type="abstract operation">
      <h1>
        IsValidISODate (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The return value is *true* if its arguments form a valid date in the ISO 8601 calendar, and *false* otherwise.
          This includes dates that may fall outside of the allowed range for Temporal.
        </dd>
      </dl>
      <emu-alg>
        1. If _month_ &lt; 1 or _month_ &gt; 12, then
          1. Return *false*.
        1. Let _daysInMonth_ be ! ISODaysInMonth(_year_, _month_).
        1. If _day_ &lt; 1 or _day_ &gt; _daysInMonth_, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balanceisodate" type="abstract operation">
      <h1>BalanceISODate (
        _year_: an integer,
        _month_: an integer,
        _day_: an integer,
      ): an ISO Date Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It converts the given _year_, _month_, and _day_ into a valid calendar date in the ISO 8601 calendar as given by IsValidISODate, by overflowing out-of-range _month_ or _day_ values into the next-highest unit.
          This date may be outside the range given by ISODateTimeWithinLimits.
        </dd>
      </dl>
      <emu-alg>
        1. Let _epochDays_ be MakeDay(ùîΩ(_year_), ùîΩ(_month_ - 1), ùîΩ(_day_)).
        1. Assert: _epochDays_ is finite.
        1. Let _ms_ be MakeDate(_epochDays_, *+0*<sub>ùîΩ</sub>).
        1. Return CreateISODateRecord(‚Ñù(YearFromTime(_ms_)), ‚Ñù(MonthFromTime(_ms_)) + 1, ‚Ñù(DateFromTime(_ms_))).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-padisoyear" aoid="PadISOYear">
      <h1>PadISOYear ( _y_ )</h1>
      <emu-alg>
        1. Assert: _y_ is an integer.
        1. If _y_ &ge; 0 and _y_ &le; 9999, then
          1. Return ToZeroPaddedDecimalString(_y_, 4).
        1. If _y_ &gt; 0, let _yearSign_ be *"+"*; otherwise, let _yearSign_ be *"-"*.
        1. Let _year_ be ToZeroPaddedDecimalString(abs(_y_), 6).
        1. Return the string-concatenation of _yearSign_ and _year_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldatetostring" aoid="TemporalDateToString">
      <h1>TemporalDateToString ( _temporalDate_, _showCalendar_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalDate_) is Object.
        1. Assert: _temporalDate_ has an [[InitializedTemporalDate]] internal slot.
        1. Let _year_ be ! PadISOYear(_temporalDate_.[[ISOYear]]).
        1. Let _month_ be ToZeroPaddedDecimalString(_temporalDate_.[[ISOMonth]], 2).
        1. Let _day_ be ToZeroPaddedDecimalString(_temporalDate_.[[ISODay]], 2).
        1. Let _calendarID_ be ? ToString(_temporalDate_.[[Calendar]]).
        1. Let _calendar_ be ! FormatCalendarAnnotation(_calendarID_, _showCalendar_).
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), _day_, and _calendar_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addisodate" aoid="AddISODate">
      <h1>AddISODate ( _year_, _month_, _day_, _years_, _months_, _weeks_, _days_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _years_, _months_, _weeks_, and _days_ are integers.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. Let _intermediate_ be ! BalanceISOYearMonth(_year_ + _years_, _month_ + _months_).
        1. Let _intermediate_ be ? RegulateISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _day_, _overflow_).
        1. Set _days_ to _days_ + 7 &times; _weeks_.
        1. Let _d_ be _intermediate_.[[Day]] + _days_.
        1. Let _intermediate_ be BalanceISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_).
        1. Return ? RegulateISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _intermediate_.[[Day]], _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-compareisodate" aoid="CompareISODate">
      <h1>CompareISODate ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_ )</h1>
      <emu-alg>
        1. Assert: _y1_, _m1_, _d1_, _y2_, _m2_, and _d2_ are integers.
        1. If _y1_ &gt; _y2_, return 1.
        1. If _y1_ &lt; _y2_, return -1.
        1. If _m1_ &gt; _m2_, return 1.
        1. If _m1_ &lt; _m2_, return -1.
        1. If _d1_ &gt; _d2_, return 1.
        1. If _d1_ &lt; _d2_, return -1.
        1. Return 0.
      </emu-alg>
      </emu-clause>
      <emu-clause id="sec-temporal-differencetemporalplaindate" type="abstract operation">
      <h1>
        DifferenceTemporalPlainDate (
          _operation_: ~since~ or ~until~,
          _temporalDate_: a Temporal.PlainDate,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _temporalDate_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~since~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. If ? CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]) is *false*, throw a *RangeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _disallowedUnits_ be ¬´ *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"* ¬ª.
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, _disallowedUnits_, *"day"*).
        1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalUnits(*"day"*, _smallestUnit_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, _disallowedUnits_, *"auto"*, _defaultLargestUnit_).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. If _operation_ is ~since~, then
          1. Set _roundingMode_ to ! NegateTemporalRoundingMode(_roundingMode_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, *undefined*, *false*).
        1. Let _untilOptions_ be ? MergeLargestUnitOption(_options_, _largestUnit_).
        1. Let _result_ be ? CalendarDateUntil(_temporalDate_.[[Calendar]], _temporalDate_, _other_, _untilOptions_).
        1. If _smallestUnit_ is not *"day"* or _roundingIncrement_ &ne; 1, then
          1. Set _result_ to (? RoundDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0, _roundingIncrement_, _smallestUnit_, _roundingMode_, _temporalDate_)).[[DurationRecord]].
        1. Return ! CreateTemporalDuration(_sign_ &times; _result_.[[Years]], _sign_ &times; _result_.[[Months]], _sign_ &times; _result_.[[Weeks]], _sign_ &times; _result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
