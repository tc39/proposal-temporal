<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaindate-objects">
  <h1>Temporal.PlainDate Objects</h1>
  <p>A Temporal.PlainDate object is an Object that contains integers corresponding to a
    particular year, month, and day in the ISO8601 calendar, as well as an Object value used to
    interpret those integers in a particular calendar.</p>

  <emu-clause id="sec-temporal-plaindate-constructor">
    <h1>The Temporal.PlainDate Constructor</h1>
    <p>The Temporal.PlainDate constructor:</p>
    <ul>
      <li>creates and initializes a new Temporal.PlainDate object when called as a constructor.</li>
      <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Temporal.PlainDate behaviour must include a super call to the %Temporal.PlainDate% constructor to create and initialize subclass instances with the necessary internal slots.</li>
    </ul>

    <emu-clause id="sec-temporal.plaindate">
      <h1>Temporal.PlainDate ( _isoYear_, _isoMonth_, _isoDay_ [ , _calendarLike_ ] )</h1>
      <p>
        When the `Temporal.PlainDate` function is called, the following steps are taken:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _y_ be ? ToIntegerOrInfinity(_isoYear_).
        1. If _y_ is +‚àû or -‚àû, throw a *RangeError* exception.
        1. Let _m_ be ? ToIntegerOrInfinity(_isoMonth_).
        1. If _m_ is +‚àû or -‚àû, throw a *RangeError* exception.
        1. Let _d_ be ? ToIntegerOrInfinity(_isoDay_).
        1. If _d_ is +‚àû or -‚àû, throw a *RangeError* exception.
        1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_calendarLike_).
        1. Return ? CreateTemporalDate(_y_, _m_, _d_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindate-constructor">
    <h1>Properties of the Temporal.PlainDate Constructor</h1>
    <p>The Temporal.PlainDate constructor:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-clause id="sec-temporal-plaindate-prototype">
      <h1>Temporal.PlainDate.prototype</h1>
      <p>The initial value of `Temporal.PlainDate.prototype` is %Temporal.PlainDate.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.from">
      <h1>Temporal.PlainDate.from ( _item_ [ , _options_ ] )</h1>
      <p>
        The `from` method takes two arguments, _item_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalDate]] internal slot, then
          1. Perform ? ToTemporalOverflow(_options_).
          1. Return ? CreateTemporalDate(_item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], _item_.[[Calendar]]).
        1. Return ? ToTemporalDate(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.compare">
      <h1>Temporal.PlainDate.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDate(_one_).
        1. Set _two_ to ? ToTemporalDate(_two_).
        1. Return ùîΩ(! CompareISODate(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindate-prototype-object">
    <h1>Properties of the Temporal.PlainDate Prototype Object</h1>

    <p>The Temporal.PlainDate prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.PlainDate instance and does not have a [[InitializedTemporalDate]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.plaindate.prototype.constructor">
      <h1>Temporal.PlainDate.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainDate.prototype.constructor` is %Temporal.PlainDate%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype-@@tostringtag">
      <h1>Temporal.PlainDate.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.PlainDate"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.calendar">
      <h1>get Temporal.PlainDate.prototype.calendar</h1>
      <p>
        `Temporal.PlainDate.prototype.calendar` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return _temporalDate_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.year">
      <h1>get Temporal.PlainDate.prototype.year</h1>
      <p>
        `Temporal.PlainDate.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.month">
      <h1>get Temporal.PlainDate.prototype.month</h1>
      <p>
        `Temporal.PlainDate.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarMonth(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.monthCode">
      <h1>get Temporal.PlainDate.prototype.monthCode</h1>
      <p>
        `Temporal.PlainDate.prototype.monthCode` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarMonthCode(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.day">
      <h1>get Temporal.PlainDate.prototype.day</h1>
      <p>
        `Temporal.PlainDate.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDay(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.dayofweek">
      <h1>get Temporal.PlainDate.prototype.dayOfWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDayOfWeek(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.dayofyear">
      <h1>get Temporal.PlainDate.prototype.dayOfYear</h1>
      <p>
        `Temporal.PlainDate.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDayOfYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.weekofyear">
      <h1>get Temporal.PlainDate.prototype.weekOfYear</h1>
      <p>
        `Temporal.PlainDate.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarWeekOfYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinweek">
      <h1>get Temporal.PlainDate.prototype.daysInWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDaysInWeek(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinmonth">
      <h1>get Temporal.PlainDate.prototype.daysInMonth</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDaysInMonth(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinyear">
      <h1>get Temporal.PlainDate.prototype.daysInYear</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarDaysInYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.monthsinyear">
      <h1>get Temporal.PlainDate.prototype.monthsInYear</h1>
      <p>
        `Temporal.PlainDate.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarMonthsInYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.inleapyear">
      <h1>get Temporal.PlainDate.prototype.inLeapYear</h1>
      <p>
        `Temporal.PlainDate.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Return ? CalendarInLeapYear(_calendar_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplainyearmonth">
      <h1>Temporal.PlainDate.prototype.toPlainYearMonth ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"monthCode"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDate_, _fieldNames_, ¬´¬ª).
        1. Return ? YearMonthFromFields(_calendar_, _fields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplainmonthday">
      <h1>Temporal.PlainDate.prototype.toPlainMonthDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"monthCode"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDate_, _fieldNames_, ¬´¬ª).
        1. Return ? MonthDayFromFields(_calendar_, _fields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.getisofields">
      <h1>Temporal.PlainDate.prototype.getISOFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _fields_ be ! OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _temporalDate_.[[Calendar]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, ùîΩ(_temporalDate_.[[ISODay]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, ùîΩ(_temporalDate_.[[ISOMonth]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, ùîΩ(_temporalDate_.[[ISOYear]])).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.add">
      <h1>Temporal.PlainDate.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `add` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _balanceResult_ be ? BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"day"*).
        1. Let _balancedDuration_ be ? CreateTemporalDuration(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]], 0, 0, 0, 0, 0, 0).
        1. Return ? CalendarDateAdd(_temporalDate_.[[Calendar]], _temporalDate_, _balancedDuration_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.subtract">
      <h1>Temporal.PlainDate.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `subtract` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _balanceResult_ be ? BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"day"*).
        1. Let _negatedDuration_ be ? CreateTemporalDuration(‚àí_duration_.[[Years]], ‚àí_duration_.[[Months]], ‚àí_duration_.[[Weeks]], ‚àí_balanceResult_.[[Days]], 0, 0, 0, 0, 0, 0).
        1. Return ? CalendarDateAdd(_temporalDate_.[[Calendar]], _temporalDate_, _negatedDuration_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.with">
      <h1>Temporal.PlainDate.prototype.with ( _temporalDateLike_ [ , _options_ ] )</h1>
      <p>
        The `with` method takes two arguments, _temporalDateLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If Type(_temporalDateLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Perform ? RejectTemporalCalendarType(_temporalDateLike_).
        1. Let _calendarProperty_ be ? Get(_temporalDateLike_, *"calendar"*).
        1. If _calendarProperty_ is not *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _timeZoneProperty_ be ? Get(_temporalDateLike_, *"timeZone"*).
        1. If _timeZoneProperty_ is not *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª).
        1. Let _partialDate_ be ? PreparePartialTemporalFields(_temporalDateLike_, _fieldNames_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDate_, _fieldNames_, ¬´¬ª).
        1. Set _fields_ to ? CalendarMergeFields(_calendar_, _fields_, _partialDate_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, ¬´¬ª).
        1. Return ? DateFromFields(_calendar_, _fields_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.withcalendar">
      <h1>Temporal.PlainDate.prototype.withCalendar ( _calendar_ )</h1>
      <p>
        The `withCalendar` method takes one argument _calendar_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be ? ToTemporalCalendar(_calendar_).
        1. Return ? CreateTemporalDate(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.until">
      <h1>Temporal.PlainDate.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        The `until` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. If ? CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]) is *false*, throw a *RangeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _disallowedUnits_ be ¬´ *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"* ¬ª.
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, _disallowedUnits_, *"day"*).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, _disallowedUnits_, *"auto"*, *"day"*).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, *undefined*, *false*).
        1. Let _untilOptions_ be ? MergeLargestUnitOption(_options_, _largestUnit_).
        1. Let _result_ be ? CalendarDateUntil(_temporalDate_.[[Calendar]], _temporalDate_, _other_, _untilOptions_).
        1. If _smallestUnit_ is not *"day"* or _roundingIncrement_ ‚â† 1, then
          1. Let _relativeTo_ be ! CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
          1. Set _result_ to ? RoundDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0, _roundingIncrement_, _smallestUnit_, _roundingMode_, _relativeTo_).
        1. Return ? CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.since">
      <h1>Temporal.PlainDate.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        The `since` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. If ? CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]) is *false*, throw a *RangeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _disallowedUnits_ be ¬´ *"hour"*, *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, *"nanosecond"* ¬ª.
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, _disallowedUnits_, *"day"*).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, _disallowedUnits_, *"auto"*, *"day"*).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Set _roundingMode_ to ! NegateTemporalRoundingMode(_roundingMode_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, *undefined*, *false*).
        1. Let _untilOptions_ be ? MergeLargestUnitOption(_options_, _largestUnit_).
        1. Let _result_ be ? CalendarDateUntil(_temporalDate_.[[Calendar]], _other_, _temporalDate_, _untilOptions_).
        1. If _smallestUnit_ is *"day"* and _roundingIncrement_ = 1, then
          1. Return ? CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
        1. Let _relativeTo_ be ! CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
        1. Set _result_ to ? RoundDuration(‚àí_result_.[[Years]], ‚àí_result_.[[Months]], ‚àí_result_.[[Weeks]], ‚àí_result_.[[Days]], 0, 0, 0, 0, 0, 0, _roundingIncrement_, _smallestUnit_, _roundingMode_, _relativeTo_).
        1. Return ? CreateTemporalDuration(‚àí_result_.[[Years]], ‚àí_result_.[[Months]], ‚àí_result_.[[Weeks]], ‚àí_result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.equals">
      <h1>Temporal.PlainDate.prototype.equals ( _other_ )</h1>
      <p>
        The `equals` method takes one argument _other_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. If _temporalDate_.[[ISOYear]] ‚â† _other_.[[ISOYear]], return *false*.
        1. If _temporalDate_.[[ISOMonth]] ‚â† _other_.[[ISOMonth]], return *false*.
        1. If _temporalDate_.[[ISODay]] ‚â† _other_.[[ISODay]], return *false*.
        1. Return ? CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplaindatetime">
      <h1>Temporal.PlainDate.prototype.toPlainDateTime ( [ _temporalTime_ ] )</h1>
      <p>
        The `toPlainDateTime` method takes one argument _temporalTime_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If _temporalTime_ is *undefined*, then
          1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
        1. Set _temporalTime_ to ? ToTemporalTime(_temporalTime_).
        1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]],
          _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]],
          _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]],
          _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tozoneddatetime">
      <h1>Temporal.PlainDate.prototype.toZonedDateTime ( _item_ )</h1>
      <p>
        The `toZonedDateTime` method takes one argument _item_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If Type(_item_) is Object, then
          1. Let _timeZoneLike_ be ? Get(_item_, *"timeZone"*).
          1. If _timeZoneLike_ is *undefined*, then
            1. Let _timeZone_ be ? ToTemporalTimeZone(_item_).
            1. Let _temporalTime_ be *undefined*.
          1. Else,
            1. Let _timeZone_ be ? ToTemporalTimeZone(_timeZoneLike_).
            1. Let _temporalTime_ be ? Get(_item_, *"plainTime"*).
        1. Else,
          1. Let _timeZone_ be ? ToTemporalTimeZone(_item_).
          1. Let _temporalTime_ be *undefined*.
        1. If _temporalTime_ is *undefined*, then
          1. Let _temporalDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
        1. Else,
          1. Set _temporalTime_ to ? ToTemporalTime(_temporalTime_).
          1. Let _temporalDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], _temporalDate_.[[Calendar]]).
        1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _temporalDateTime_, *"compatible"*).
        1. Return ? CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tostring">
      <h1>Temporal.PlainDate.prototype.toString ( [ _options_ ] )</h1>
      <p>
        The `toString` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _showCalendar_ be ? ToShowCalendarOption(_options_).
        1. Return ? TemporalDateToString(_temporalDate_, _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tolocalestring">
      <h1>Temporal.PlainDate.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.PlainDate.prototype.toLocaleString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleString` method is used.
      </p>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? TemporalDateToString(_temporalDate_, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tojson">
      <h1>Temporal.PlainDate.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? TemporalDateToString(_temporalDate_, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.valueof">
      <h1>Temporal.PlainDate.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaindate-instances">
    <h1>Properties of Temporal.PlainDate Instances</h1>
    <p>
      Temporal.PlainDate instances are ordinary objects that inherit properties from the %Temporal.PlainDate.prototype% intrinsic object.
      Temporal.PlainDate instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaldate-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaldate-instances" caption="Internal Slots of Temporal.PlainDate Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalDate]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.PlainDate instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOYear]]
            </td>
            <td>
              An integer representing the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMonth]]
            </td>
            <td>
              An integer between 1 and 12, inclusive, representing the month of the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISODay]]
            </td>
            <td>
              An integer between 1 and ISODaysInMonth([[ISOYear]], [[ISOMonth]]), inclusive, representing the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              An Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaindate-abstract-ops">
    <h1>Abstract Operations for Temporal.PlainDate Objects</h1>

    <emu-clause id="sec-temporal-createtemporaldate" aoid="CreateTemporalDate">
      <h1>CreateTemporalDate ( _isoYear_, _isoMonth_, _isoDay_, _calendar_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. Assert: _isoYear_ is an integer.
        1. Assert: _isoMonth_ is an integer.
        1. Assert: _isoDay_ is an integer.
        1. Assert: Type(_calendar_) is Object.
        1. If ! IsValidISODate(_isoYear_, _isoMonth_, _isoDay_) is *false*, throw a *RangeError* exception.
        1. If ! ISODateTimeWithinLimits(_isoYear_, _isoMonth_, _isoDay_, 12, 0, 0, 0, 0, 0) is *false*, throw a *RangeError* exception.
        1. If _newTarget_ is not present, set it to %Temporal.PlainDate%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.PlainDate.prototype%"*, ¬´ [[InitializedTemporalDate]], [[ISOYear]], [[ISOMonth]], [[ISODay]], [[Calendar]] ¬ª).
        1. Set _object_.[[ISOYear]] to _isoYear_.
        1. Set _object_.[[ISOMonth]] to _isoMonth_.
        1. Set _object_.[[ISODay]] to _isoDay_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
      <emu-note>
        <p>Deferring to ISODateTimeWithinLimits with an hour of 12 avoids trouble at the extremes of the representable range of dates, which stop just before midnight on each end.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldate" aoid="ToTemporalDate">
      <h1>ToTemporalDate ( _item_ [ , _options_ ] )</h1>
      <p>
        The abstract operation ToTemporalDate returns its argument _item_ if it is already a Temporal.PlainDate instance, converts _item_ to a new Temporal.PlainDate instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _options_ is not present, set _options_ to ! OrdinaryObjectCreate(*null*).
        1. Assert: Type(_options_) is Object.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalDate]] internal slot, then
            1. Return _item_.
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Let _instant_ be ! CreateTemporalInstant(_item_.[[Nanoseconds]]).
            1. Let _plainDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_item_.[[TimeZone]], _instant_, _item_.[[Calendar]]).
            1. Return ! CreateTemporalDate(_plainDateTime_.[[ISOYear]], _plainDateTime_.[[ISOMonth]], _plainDateTime_.[[ISODay]], _plainDateTime_.[[Calendar]]).
          1. If _item_ has an [[InitializedTemporalDateTime]] internal slot, then
            1. Return ! CreateTemporalDate(_item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], _item_.[[Calendar]]).
          1. Let _calendar_ be ? GetTemporalCalendarWithISODefault(_item_).
          1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª).
          1. Let _fields_ be ? PrepareTemporalFields(_item_, _fieldNames_, ¬´¬ª).
          1. Return ? DateFromFields(_calendar_, _fields_, _options_).
        1. Perform ? ToTemporalOverflow(_options_).
        1. Let _string_ be ? ToString(_item_).
        1. Let _result_ be ? ParseTemporalDateString(_string_).
        1. Assert: ! IsValidISODate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_result_.[[Calendar]]).
        1. Return ? CreateTemporalDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differenceisodate" aoid="DifferenceISODate">
      <h1>DifferenceISODate ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_, _largestUnit_ )</h1>
      <emu-alg>
        1. Assert: _largestUnit_ is one of *"year"*, *"month"*, *"week"*, or *"day"*.
        1. If _largestUnit_ is *"year"* or *"month"*, then
          1. Let _sign_ be -(! CompareISODate(_y1_, _m1_, _d1_, _y2_, _m2_, _d2_)).
          1. If _sign_ is 0, return the new Record { [[Years]]: 0, [[Months]]: 0, [[Weeks]]: 0, [[Days]]: 0 }.
          1. Let _start_ be the new Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
          1. Let _end_ be the new Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
          1. Let _years_ be _end_.[[Year]] ‚àí _start_.[[Year]].
          1. Let _mid_ be ! AddISODate(_y1_, _m1_, _d1_, _years_, 0, 0, 0, *"constrain"*).
          1. Let _midSign_ be -(! CompareISODate(_mid_.[[Year]], _mid_.[[Month]], _mid_.[[Day]], _y2_, _m2_, _d2_)).
          1. If _midSign_ is 0, then
            1. If _largestUnit_ is *"year"*, return the new Record { [[Years]]: _years_, [[Months]]: 0, [[Weeks]]: 0, [[Days]]: 0 }.
            1. Return the new Record { [[Years]]: 0, [[Months]]: _years_ √ó 12, [[Weeks]]: 0, [[Days]]: 0 }.
          1. Let _months_ be _end_.[[Month]] ‚àí _start_.[[Month]].
          1. If _midSign_ is not equal to _sign_, then
            1. Set _years_ to _years_ - _sign_.
            1. Set _months_ to _months_ + _sign_ √ó 12.
          1. Set _mid_ be ! AddISODate(_y1_, _m1_, _d1_, _years_, _months_, 0, 0, *"constrain"*).
          1. Let _midSign_ be -(! CompareISODate(_mid_.[[Year]], _mid_.[[Month]], _mid_.[[Day]], _y2_, _m2_, _d2_)).
          1. If _midSign_ is 0, then
            1. If _largestUnit_ is *"year"*, return the new Record { [[Years]]: _years_, [[Months]]: _months_, [[Weeks]]: 0, [[Days]]: 0 }.
            1. Return the new Record { [[Years]]: 0, [[Months]]: _months_ + _years_ √ó 12, [[Weeks]]: 0, [[Days]]: 0 }.
          1. If _midSign_ is not equal to _sign_, then
            1. Set _months_ to _months_ - _sign_.
            1. If _months_ is equal to -_sign_, then
              1. Set _years_ to _years_ - _sign_.
              1. Set _months_ to 11 √ó _sign_.
            1. Set _mid_ be ! AddISODate(_y1_, _m1_, _d1_, _years_, _months_, 0, 0, *"constrain"*).
            1. Let _midSign_ be -(! CompareISODate(_mid_.[[Year]], _mid_.[[Month]], _mid_.[[Day]], _y2_, _m2_, _d2_)).
          1. Let _days_ be 0.
          1. If _mid_.[[Month]] is equal to _end_.[[Month]] and _mid_.[[Year]] is equal to _mid_.[[Year]], set _days_ to _end_.[[Day]] - _mid_.[[Day]].
          1. Else if _sign_ &lt; 0, set _days_ to -_mid_.[[Day]] - (! ISODaysInMonth(_end_.[[Year]], _end_.[[Month]]) - _end_.[[Day]]).
          1. Else, set _days_ to _end_.[[Day]] + (! ISODaysInMonth(_mid_.[[Year]], _mid_.[[Month]]) - _mid_.[[Day]]).
          1. If _largestUnit_ is *"month"*, then
            1. Set _months_ to _months_ + _years_ √ó 12.
            1. Set _years_ to 0.
          1. Return the new Record { [[Years]]: _years_, [[Months]]: _months_, [[Weeks]]: 0, [[Days]]: _days_ }.
        1. If _largestUnit_ is *"day"* or *"week"*, then
          1. If ! CompareISODate(_y1_, _m1_, _d1_, _y2_, _m2_, _d2_) &lt; 0, then
            1. Let _smaller_ be the new Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
            1. Let _greater_ be the new Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
            1. Let _sign_ be 1.
          1. Else,
            1. Let _smaller_ be the new Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
            1. Let _greater_ be the new Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
            1. Let _sign_ be ‚àí1.
          1. Let _days_ be ! ToISODayOfYear(_greater_.[[Year]], _greater_.[[Month]], _greater_.[[Day]]) ‚àí ! ToISODayOfYear(_smaller_.[[Year]], _smaller_.[[Month]], _smaller_.[[Day]]).
          1. Let _year_ be _smaller_.[[Year]].
          1. Repeat, while _year_ &lt; _greater_.[[Year]],
            1. Set _days_ to _days_ + ! ISODaysInYear(_year_).
            1. Set _year_ to _year_ + 1.
          1. Let _weeks_ be 0.
          1. If _largestUnit_ is *"week"*, then
            1. Set _weeks_ to floor(_days_ / 7).
            1. Set _days_ to _days_ mod 7.
          1. Return the Record {
            [[Years]]: 0,
            [[Months]]: 0,
            [[Weeks]]: _weeks_ √ó _sign_,
            [[Days]]: _days_ √ó _sign_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-regulateisodate" aoid="RegulateISODate">
      <h1>RegulateISODate ( _year_, _month_, _day_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If _overflow_ is *"reject"*, then
          1. If ! IsValidISODate(_year_, _month_, _day_) is *false*, throw a *RangeError* exception.
          1. Return the Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_
            }.
        1. If _overflow_ is *"constrain"*, then
          1. Set _month_ to ! ConstrainToRange(_month_, 1, 12).
          1. Set _day_ to ! ConstrainToRange(_day_, 1, ! ISODaysInMonth(_year_, _month_)).
          1. Return the Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_
            }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isvalidisodate" aoid="IsValidISODate">
      <h1>IsValidISODate ( _year_, _month_, _day_ )</h1>
      <p>
        The abstract operation IsValidISODate returns *true* if its arguments form a valid date in the ISO 8601 calendar, and *false* otherwise.
        This includes dates that may fall outside of the allowed range for Temporal.
      </p>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. If _month_ &lt; 1 or _month_ &gt; 12, then
          1. Return *false*.
        1. Let _daysInMonth_ be ! ISODaysInMonth(_year_, _month_).
        1. If _day_ &lt; 1 or _day_ &gt; _daysInMonth_, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balanceisodate" aoid="BalanceISODate">
      <h1>BalanceISODate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. Let _balancedYearMonth_ be ! BalanceISOYearMonth(_year_, _month_).
        1. Set _month_ to _balancedYearMonth_.[[Month]].
        1. Set _year_ to _balancedYearMonth_.[[Year]].
        1. NOTE: To deal with negative numbers of days whose absolute value is greater than the number of days in a year, the following section subtracts years and adds days until the number of days is greater than ‚àí366 or ‚àí365.
        1. If _month_ &gt; 2, then
          1. Let _testYear_ be _year_.
        1. Else,
          1. Let _testYear_ be _year_ ‚àí 1.
        1. Repeat, while _day_ &lt; ‚àí1 √ó ! ISODaysInYear(_testYear_),
          1. Set _day_ to _day_ + ! ISODaysInYear(_testYear_).
          1. Set _year_ to _year_ ‚àí 1.
          1. Set _testYear_ to _testYear_ ‚àí 1.
        1. NOTE: To deal with numbers of days greater than the number of days in a year, the following section adds years and subtracts days until the number of days is less than 366 or 365.
        1. Let _testYear_ be _year_ + 1.
        1. Repeat, while _day_ &gt; ! ISODaysInYear(_testYear_),
          1. Set _day_ to _day_ ‚àí ! ISODaysInYear(_testYear_).
          1. Set _year_ to _year_ + 1.
          1. Set _testYear_ to _testYear_ + 1.
        1. NOTE: To deal with negative numbers of days whose absolute value is greater than the number of days in the current month, the following section subtracts months and adds days until the number of days is greater than 0.
        1. Repeat, while _day_ &lt; 1,
          1. Set _balancedYearMonth_ to ! BalanceISOYearMonth(_year_, _month_ ‚àí 1).
          1. Set _year_ to _balancedYearMonth_.[[Year]].
          1. Set _month_ to _balancedYearMonth_.[[Month]].
          1. Set _day_ to _day_ + ! ISODaysInMonth(_year_, _month_).
        1. NOTE: To deal with numbers of days greater than the number of days in the current month, the following section adds months and subtracts days until the number of days is less than the number of days in the month.
        1. Repeat, while _day_ &gt; ! ISODaysInMonth(_year_, _month_),
          1. Set _day_ to _day_ ‚àí ! ISODaysInMonth(_year_, _month_).
          1. Set _balancedYearMonth_ to ! BalanceISOYearMonth(_year_, _month_ + 1).
          1. Set _year_ to _balancedYearMonth_.[[Year]].
          1. Set _month_ to _balancedYearMonth_.[[Month]].
        1. Return the new Record {
          [[Year]]: _year_,
          [[Month]]: _month_,
          [[Day]]: _day_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-padisoyear" aoid="PadISOYear">
      <h1>PadISOYear ( _y_ )</h1>
      <emu-alg>
        1. Assert: _y_ is an integer.
        1. If _y_ &gt; 999 and _y_ ‚â§ 9999, then
          1. Return _y_ formatted as a four-digit decimal number.
        1. If _y_ ‚â• 0, let _yearSign_ be *"+"*; otherwise, let _yearSign_ be *"-"*.
        1. Let _year_ be abs(_y_), formatted as a six-digit decimal number, padded to the left with zeroes as necessary.
        1. Return the string-concatenation of _yearSign_ and _year_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldatetostring" aoid="TemporalDateToString">
      <h1>TemporalDateToString ( _temporalDate_, _showCalendar_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalDate_) is Object.
        1. Assert: _temporalDate_ has an [[InitializedTemporalDate]] internal slot.
        1. Let _year_ be ! PadISOYear(_temporalDate_.[[ISOYear]]).
        1. Let _month_ be _temporalDate_.[[ISOMonth]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _temporalDate_.[[ISODay]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _calendarID_ be ? ToString(_temporalDate_.[[Calendar]]).
        1. Let _calendar_ be ! FormatCalendarAnnotation(_calendarID_, _showCalendar_).
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), _day_, and _calendar_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addisodate" aoid="AddISODate">
      <h1>AddISODate ( _year_, _month_, _day_, _years_, _months_, _weeks_, _days_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _years_, _months_, _weeks_, and _days_ are integers.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. Let _intermediate_ be ! BalanceISOYearMonth(_year_ + _years_, _month_ + _months_).
        1. Let _intermediate_ be ? RegulateISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _day_, _overflow_).
        1. Set _days_ to _days_ + 7 √ó _weeks_.
        1. Let _d_ be _intermediate_.[[Day]] + _days_.
        1. Let _intermediate_ be ! BalanceISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_).
        1. Return ? RegulateISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _intermediate_.[[Day]], _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-compareisodate" aoid="CompareISODate">
      <h1>CompareISODate ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_ )</h1>
      <emu-alg>
        1. Assert: _y1_, _m1_, _d1_, _y2_, _m2_, and _d2_ are integers.
        1. If _y1_ &gt; _y2_, return 1.
        1. If _y1_ &lt; _y2_, return -1.
        1. If _m1_ &gt; _m2_, return 1.
        1. If _m1_ &lt; _m2_, return -1.
        1. If _d1_ &gt; _d2_, return 1.
        1. If _d1_ &lt; _d2_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
