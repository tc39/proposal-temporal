<!DOCTYPE html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaindate-objects">
  <h1>Temporal.PlainDate Objects</h1>
  <p>
    A Temporal.PlainDate object is an Object that contains integers corresponding to a
    particular year, month, and day in the ISO8601 calendar, as well as an Object value used to
    interpret those integers in a particular calendar.
  </p>

  <emu-clause id="sec-temporal-plaindate-constructor">
    <h1>The Temporal.PlainDate Constructor</h1>
    <p>The Temporal.PlainDate constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.PlainDate object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.PlainDate behaviour must
        include a super call to the %Temporal.PlainDate% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.plaindate">
      <h1>Temporal.PlainDate ( _isoYear_, _isoMonth_, _isoDay_ [ , _calendar_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _y_ be ? ToIntegerWithTruncation(_isoYear_).
        1. Let _m_ be ? ToIntegerWithTruncation(_isoMonth_).
        1. Let _d_ be ? ToIntegerWithTruncation(_isoDay_).
        1. If _calendar_ is *undefined*, set _calendar_ to *"iso8601"*.
        1. If _calendar_ is not a String, throw a *TypeError* exception.
        1. Set _calendar_ to ? CanonicalizeCalendar(_calendar_).
        1. If IsValidISODate(_y_, _m_, _d_) is *false*, throw a *RangeError* exception.
        1. Let _isoDate_ be CreateISODateRecord(_y_, _m_, _d_).
        1. Return ? CreateTemporalDate(_isoDate_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindate-constructor">
    <h1>Properties of the Temporal.PlainDate Constructor</h1>
    <p>The Temporal.PlainDate constructor:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-clause id="sec-temporal.plaindate.prototype">
      <h1>Temporal.PlainDate.prototype</h1>
      <p>The initial value of `Temporal.PlainDate.prototype` is %Temporal.PlainDate.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.from">
      <h1>Temporal.PlainDate.from ( _item_ [ , _options_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Return ? ToTemporalDate(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.compare">
      <h1>Temporal.PlainDate.compare ( _one_, _two_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDate(_one_).
        1. Set _two_ to ? ToTemporalDate(_two_).
        1. Return ùîΩ(CompareISODate(_one_.[[ISODate]], _two_.[[ISODate]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaindate-prototype-object">
    <h1>Properties of the Temporal.PlainDate Prototype Object</h1>

    <p>The Temporal.PlainDate prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.PlainDate instance and does not have a [[InitializedTemporalDate]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-note>
      An ECMAScript implementation that includes the ECMA-402 Internationalization API extends this prototype with additional properties in order to represent calendar data.
    </emu-note>

    <emu-clause id="sec-temporal.plaindate.prototype.constructor">
      <h1>Temporal.PlainDate.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainDate.prototype.constructor` is %Temporal.PlainDate%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype-%symbol.tostringtag%">
      <h1>Temporal.PlainDate.prototype[ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Temporal.PlainDate"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.calendarid">
      <h1>get Temporal.PlainDate.prototype.calendarId</h1>
      <p>
        `Temporal.PlainDate.prototype.calendarId` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return _temporalDate_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.era">
      <h1>get Temporal.PlainDate.prototype.era</h1>
      <p>
        `Temporal.PlainDate.prototype.era` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _plainDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
        1. Return CalendarISOToDate(_plainDate_.[[Calendar]], _plainDate_.[[ISODate]]).[[Era]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.erayear">
      <h1>get Temporal.PlainDate.prototype.eraYear</h1>
      <p>
        `Temporal.PlainDate.prototype.eraYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _plainDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
        1. Let _result_ be CalendarISOToDate(_plainDate_.[[Calendar]], _plainDate_.[[ISODate]]).[[EraYear]].
        1. If _result_ is *undefined*, return *undefined*.
        1. Return ùîΩ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.year">
      <h1>get Temporal.PlainDate.prototype.year</h1>
      <p>
        `Temporal.PlainDate.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[Year]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.month">
      <h1>get Temporal.PlainDate.prototype.month</h1>
      <p>
        `Temporal.PlainDate.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[Month]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.monthcode">
      <h1>get Temporal.PlainDate.prototype.monthCode</h1>
      <p>
        `Temporal.PlainDate.prototype.monthCode` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[MonthCode]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.day">
      <h1>get Temporal.PlainDate.prototype.day</h1>
      <p>
        `Temporal.PlainDate.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.dayofweek">
      <h1>get Temporal.PlainDate.prototype.dayOfWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[DayOfWeek]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.dayofyear">
      <h1>get Temporal.PlainDate.prototype.dayOfYear</h1>
      <p>
        `Temporal.PlainDate.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[DayOfYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.weekofyear">
      <h1>get Temporal.PlainDate.prototype.weekOfYear</h1>
      <p>
        `Temporal.PlainDate.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _result_ be CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[WeekOfYear]].[[Week]].
        1. If _result_ is *undefined*, return *undefined*.
        1. Return ùîΩ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.yearofweek">
      <h1>get Temporal.PlainDate.prototype.yearOfWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.yearOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _result_ be CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[WeekOfYear]].[[Year]].
        1. If _result_ is *undefined*, return *undefined*.
        1. Return ùîΩ(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinweek">
      <h1>get Temporal.PlainDate.prototype.daysInWeek</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[DaysInWeek]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinmonth">
      <h1>get Temporal.PlainDate.prototype.daysInMonth</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[DaysInMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.daysinyear">
      <h1>get Temporal.PlainDate.prototype.daysInYear</h1>
      <p>
        `Temporal.PlainDate.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[DaysInYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.monthsinyear">
      <h1>get Temporal.PlainDate.prototype.monthsInYear</h1>
      <p>
        `Temporal.PlainDate.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ùîΩ(CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[MonthsInYear]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaindate.prototype.inleapyear">
      <h1>get Temporal.PlainDate.prototype.inLeapYear</h1>
      <p>
        `Temporal.PlainDate.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return CalendarISOToDate(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]]).[[InLeapYear]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplainyearmonth">
      <h1>Temporal.PlainDate.prototype.toPlainYearMonth ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fields_ be ISODateToFields(_calendar_, _temporalDate_.[[ISODate]], ~date~).
        1. Let _isoDate_ be ? CalendarYearMonthFromFields(_calendar_, _fields_, ~constrain~).
        1. Return ! CreateTemporalYearMonth(_isoDate_, _calendar_).
        1. NOTE: The call to CalendarYearMonthFromFields is necessary in order to create a PlainYearMonth object with the [[Day]] field of the [[ISODate]] internal slot set correctly.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplainmonthday">
      <h1>Temporal.PlainDate.prototype.toPlainMonthDay ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fields_ be ISODateToFields(_calendar_, _temporalDate_.[[ISODate]], ~date~).
        1. Let _isoDate_ be ? CalendarMonthDayFromFields(_calendar_, _fields_, ~constrain~).
        1. Return ! CreateTemporalMonthDay(_isoDate_, _calendar_).
        1. NOTE: The call to CalendarMonthDayFromFields is necessary in order to create a PlainMonthDay object with the [[Year]] field of the [[ISODate]] internal slot set correctly.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.add">
      <h1>Temporal.PlainDate.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? AddDurationToDate(~add~, _temporalDate_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.subtract">
      <h1>Temporal.PlainDate.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? AddDurationToDate(~subtract~, _temporalDate_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.with">
      <h1>Temporal.PlainDate.prototype.with ( _temporalDateLike_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If ? IsPartialTemporalObject(_temporalDateLike_) is *false*, throw a *TypeError* exception.
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _fields_ be ISODateToFields(_calendar_, _temporalDate_.[[ISODate]], ~date~).
        1. Let _partialDate_ be ? PrepareCalendarFields(_calendar_, _temporalDateLike_, ¬´ ~year~, ~month~, ~month-code~, ~day~ ¬ª, ¬´ ¬ª, ~partial~).
        1. Set _fields_ to CalendarMergeFields(_calendar_, _fields_, _partialDate_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? GetTemporalOverflowOption(_resolvedOptions_).
        1. Let _isoDate_ be ? CalendarDateFromFields(_calendar_, _fields_, _overflow_).
        1. Return ! CreateTemporalDate(_isoDate_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.withcalendar">
      <h1>Temporal.PlainDate.prototype.withCalendar ( _calendarLike_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be ? ToTemporalCalendarIdentifier(_calendarLike_).
        1. Return ! CreateTemporalDate(_temporalDate_.[[ISODate]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.until">
      <h1>Temporal.PlainDate.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? DifferenceTemporalPlainDate(~until~, _temporalDate_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.since">
      <h1>Temporal.PlainDate.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? DifferenceTemporalPlainDate(~since~, _temporalDate_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.equals">
      <h1>Temporal.PlainDate.prototype.equals ( _other_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. If CompareISODate(_temporalDate_.[[ISODate]], _other_.[[ISODate]]) ‚â† 0, return *false*.
        1. Return CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.toplaindatetime">
      <h1>Temporal.PlainDate.prototype.toPlainDateTime ( [ _temporalTime_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _time_ be ? ToTimeRecordOrMidnight(_temporalTime_).
        1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_temporalDate_.[[ISODate]], _time_).
        1. Return ? CreateTemporalDateTime(_isoDateTime_, _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tozoneddatetime">
      <h1>Temporal.PlainDate.prototype.toZonedDateTime ( _item_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If _item_ is an Object, then
          1. Let _timeZoneLike_ be ? Get(_item_, *"timeZone"*).
          1. If _timeZoneLike_ is *undefined*, then
            1. Let _timeZone_ be ? ToTemporalTimeZoneIdentifier(_item_).
            1. Let _temporalTime_ be *undefined*.
          1. Else,
            1. Let _timeZone_ be ? ToTemporalTimeZoneIdentifier(_timeZoneLike_).
            1. Let _temporalTime_ be ? Get(_item_, *"plainTime"*).
        1. Else,
          1. Let _timeZone_ be ? ToTemporalTimeZoneIdentifier(_item_).
          1. Let _temporalTime_ be *undefined*.
        1. If _temporalTime_ is *undefined*, then
          1. Let _epochNs_ be ? GetStartOfDay(_timeZone_, _temporalDate_.[[ISODate]]).
        1. Else,
          1. Set _temporalTime_ to ? ToTemporalTime(_temporalTime_).
          1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_temporalDate_.[[ISODate]], _temporalTime_.[[Time]]).
          1. If ISODateTimeWithinLimits(_isoDateTime_) is *false*, throw a *RangeError* exception.
          1. Let _epochNs_ be ? GetEpochNanosecondsFor(_timeZone_, _isoDateTime_, ~compatible~).
        1. Return ! CreateTemporalZonedDateTime(_epochNs_, _timeZone_, _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tostring">
      <h1>Temporal.PlainDate.prototype.toString ( [ _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _showCalendar_ be ? GetTemporalShowCalendarNameOption(_resolvedOptions_).
        1. Return TemporalDateToString(_temporalDate_, _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tolocalestring">
      <h1>Temporal.PlainDate.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return TemporalDateToString(_temporalDate_, ~auto~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.tojson">
      <h1>Temporal.PlainDate.prototype.toJSON ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return TemporalDateToString(_temporalDate_, ~auto~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaindate.prototype.valueof">
      <h1>Temporal.PlainDate.prototype.valueOf ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-note>
        <p>
          This method always throws, because in the absence of `valueOf()`, expressions with arithmetic operators such as `plainDate1 > plainDate2` would fall back to being equivalent to `plainDate1.toString() > plainDate2.toString()`.
          Lexicographical comparison of serialized strings might not seem obviously wrong, because the result would sometimes be correct.
          Implementations are encouraged to phrase the error message to point users to `Temporal.PlainDate.compare()`, `Temporal.PlainDate.prototype.equals()`, and/or `Temporal.PlainDate.prototype.toString()`.
        </p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaindate-instances">
    <h1>Properties of Temporal.PlainDate Instances</h1>
    <p>
      Temporal.PlainDate instances are ordinary objects that inherit properties from the %Temporal.PlainDate.prototype% intrinsic object.
      Temporal.PlainDate instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaldate-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaldate-instances" caption="Internal Slots of Temporal.PlainDate Instances">
      <table>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[InitializedTemporalDate]]
          </td>
          <td>
            The only specified use of this slot is for distinguishing Temporal.PlainDate instances from other objects.
          </td>
        </tr>
        <tr>
          <td>
            [[ISODate]]
          </td>
          <td>
            An ISO Date Record.
          </td>
        </tr>
        <tr>
          <td>
            [[Calendar]]
          </td>
          <td>
            A calendar type.
          </td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaindate-abstract-ops">
    <h1>Abstract Operations for Temporal.PlainDate Objects</h1>

    <emu-clause id="sec-temporal-iso-date-records">
      <h1>ISO Date Records</h1>
      <p>
        An <dfn variants="ISO Date Records">ISO Date Record</dfn> is a Record value used to represent a valid calendar date in the ISO 8601 calendar, although the year may be outside of the allowed range for Temporal.
        ISO Date Records are produced by the abstract operation CreateISODateRecord.
      </p>
      <p>ISO Date Records have the fields listed in <emu-xref href="#table-temporal-iso-date-record-fields"></emu-xref>.</p>
      <emu-table id="table-temporal-iso-date-record-fields" caption="ISO Date Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer</td>
            <td>
              The year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>an integer between 1 and 12, inclusive</td>
            <td>
              The number of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>an integer between 1 and 31, inclusive</td>
            <td>
              The number of the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-create-iso-date-record" type="abstract operation">
      <h1>
        CreateISODateRecord (
          _year_: an integer,
          _month_: an integer between 1 and 12 inclusive,
          _day_: an integer between 1 and 31 inclusive,
        ): an ISO Date Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Return ISO Date Record { [[Year]]: _year_, [[Month]]: _month_, [[Day]]: _day_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldate" type="abstract operation">
      <h1>
        CreateTemporalDate (
          _isoDate_: an ISO Date Record,
          _calendar_: a calendar type,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.PlainDate or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.PlainDate instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. If ISODateWithinLimits(_isoDate_) is *false*, throw a *RangeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.PlainDate%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.PlainDate.prototype%"*, ¬´ [[InitializedTemporalDate]], [[ISODate]], [[Calendar]] ¬ª).
        1. Set _object_.[[ISODate]] to _isoDate_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldate" type="abstract operation">
      <h1>
        ToTemporalDate (
          _item_: an ECMAScript language value,
          optional _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.PlainDate or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Converts _item_ to a new Temporal.PlainDate instance if possible, and throws otherwise.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. If _item_ is an Object, then
          1. If _item_ has an [[InitializedTemporalDate]] internal slot, then
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Return ! CreateTemporalDate(_item_.[[ISODate]], _item_.[[Calendar]]).
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Let _isoDateTime_ be GetISODateTimeFor(_item_.[[TimeZone]], _item_.[[EpochNanoseconds]]).
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Return ! CreateTemporalDate(_isoDateTime_.[[ISODate]], _item_.[[Calendar]]).
          1. If _item_ has an [[InitializedTemporalDateTime]] internal slot, then
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Return ! CreateTemporalDate(_item_.[[ISODateTime]].[[ISODate]], _item_.[[Calendar]]).
          1. Let _calendar_ be ? GetTemporalCalendarIdentifierWithISODefault(_item_).
          1. Let _fields_ be ? PrepareCalendarFields(_calendar_, _item_, ¬´ ~year~, ~month~, ~month-code~, ~day~ ¬ª, ¬´¬ª, ¬´¬ª).
          1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
          1. Let _overflow_ be ? GetTemporalOverflowOption(_resolvedOptions_).
          1. Let _isoDate_ be ? CalendarDateFromFields(_calendar_, _fields_, _overflow_).
          1. Return ! CreateTemporalDate(_isoDate_, _calendar_).
        1. If _item_ is not a String, throw a *TypeError* exception.
        1. Let _result_ be ? ParseISODateTime(_item_, ¬´ |TemporalDateTimeString[~Zoned]| ¬ª).
        1. Let _calendar_ be _result_.[[Calendar]].
        1. If _calendar_ is ~empty~, set _calendar_ to *"iso8601"*.
        1. Set _calendar_ to ? CanonicalizeCalendar(_calendar_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
        1. Let _isoDate_ be CreateISODateRecord(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
        1. Return ? CreateTemporalDate(_isoDate_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatesurpasses" type="abstract operation">
      <h1>
        ISODateSurpasses (
          _sign_: -1 or 1,
          _y1_: an integer,
          _m1_: an integer,
          _d1_: an integer,
          _isoDate2_: an ISO Date Record,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The return value indicates whether the date denoted by _y1_, _m1_, _d1_ surpasses that denoted by _isoDate2_ in the direction denoted by _sign_.
          The former date does not have to exist.
          Note that this operation is specific to date difference calculations and is not the same as CompareISODate.
        </dd>
      </dl>
      <emu-alg>
        1. If _y1_ ‚â† _isoDate2_.[[Year]], then
          1. If _sign_ √ó (_y1_ - _isoDate2_.[[Year]]) > 0, return *true*.
        1. Else if _m1_ ‚â† _isoDate2_.[[Month]], then
          1. If _sign_ √ó (_m1_ - _isoDate2_.[[Month]]) > 0, return *true*.
        1. Else if _d1_ ‚â† _isoDate2_.[[Day]], then
          1. If _sign_ √ó (_d1_ - _isoDate2_.[[Day]]) > 0, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-regulateisodate" type="abstract operation">
      <h1>
        RegulateISODate (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs the overflow correction specified by _overflow_ on the values _year_, _month_, and _day_, in order to arrive at a valid date in the ISO 8601 calendar, as determined by IsValidISODate.
          For ~reject~, values that do not form a valid date cause an exception to be thrown.
          For ~constrain~, values that do not form a valid date are independently clamped to their respective valid range in order of descending unit magnitude.
        </dd>
      </dl>
      <emu-alg>
        1. If _overflow_ is ~constrain~, then
          1. Set _month_ to the result of clamping _month_ between 1 and 12.
          1. Let _daysInMonth_ be ISODaysInMonth(_year_, _month_).
          1. Set _day_ to the result of clamping _day_ between 1 and _daysInMonth_.
        1. Else,
          1. Assert: _overflow_ is ~reject~.
          1. If IsValidISODate(_year_, _month_, _day_) is *false*, throw a *RangeError* exception.
        1. Return CreateISODateRecord(_year_, _month_, _day_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isvalidisodate" type="abstract operation">
      <h1>
        IsValidISODate (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The return value is *true* if its arguments form a valid date in the ISO 8601 calendar, and *false* otherwise.
          This includes dates that may fall outside of the allowed range for Temporal.
        </dd>
      </dl>
      <emu-alg>
        1. If _month_ &lt; 1 or _month_ > 12, then
          1. Return *false*.
        1. Let _daysInMonth_ be ISODaysInMonth(_year_, _month_).
        1. If _day_ &lt; 1 or _day_ > _daysInMonth_, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balanceisodate" type="abstract operation">
      <h1>
        BalanceISODate (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
        ): an ISO Date Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It converts the given _year_, _month_, and _day_ into a valid calendar date in the ISO 8601 calendar as given by IsValidISODate, by overflowing out-of-range _month_ or _day_ values into the next-highest unit.
          This date may be outside the range given by ISODateTimeWithinLimits.
        </dd>
      </dl>
      <emu-alg>
        1. Let _epochDays_ be ISODateToEpochDays(_year_, _month_ - 1, _day_).
        1. Let _ms_ be EpochDaysToEpochMs(_epochDays_, 0).
        1. Return CreateISODateRecord(EpochTimeToEpochYear(_ms_), EpochTimeToMonthInYear(_ms_) + 1, EpochTimeToDate(_ms_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-padisoyear" type="abstract operation">
      <h1>
        PadISOYear (
          _y_: an integer,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns a String representation of _y_ suitable for inclusion in an ISO 8601 string, either in 4-digit format or 6-digit format with sign.</dd>
      </dl>
      <emu-alg>
        1. If _y_ ‚â• 0 and _y_ ‚â§ 9999, then
          1. Return ToZeroPaddedDecimalString(_y_, 4).
        1. If _y_ > 0, let _yearSign_ be *"+"*; otherwise, let _yearSign_ be *"-"*.
        1. Let _year_ be ToZeroPaddedDecimalString(abs(_y_), 6).
        1. Return the string-concatenation of _yearSign_ and _year_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldatetostring" type="abstract operation">
      <h1>
        TemporalDateToString (
          _temporalDate_: a Temporal.PlainDate,
          _showCalendar_: ~auto~, ~always~, ~never~, or ~critical~,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It formats _temporalDate_ to an ISO 8601 string.</dd>
      </dl>
      <emu-alg>
        1. Let _year_ be PadISOYear(_temporalDate_.[[ISODate]].[[Year]]).
        1. Let _month_ be ToZeroPaddedDecimalString(_temporalDate_.[[ISODate]].[[Month]], 2).
        1. Let _day_ be ToZeroPaddedDecimalString(_temporalDate_.[[ISODate]].[[Day]], 2).
        1. Let _calendar_ be FormatCalendarAnnotation(_temporalDate_.[[Calendar]], _showCalendar_).
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), _day_, and _calendar_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isodatewithinlimits" type="abstract operation">
      <h1>
        ISODateWithinLimits (
          _isoDate_: an ISO Date Record,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The return value is *true* if the date in the ISO 8601 calendar given by the argument is within the representable range of `Temporal.PlainDate`, and *false* otherwise.</dd>
      </dl>
      <emu-note>
        <p>Deferring to ISODateTimeWithinLimits with an hour of 12 avoids trouble at the extremes of the representable range of Temporal.PlainDateTime, which stops just before midnight on each end.</p>
      </emu-note>
      <emu-alg>
        1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_isoDate_, NoonTimeRecord()).
        1. Return ISODateTimeWithinLimits(_isoDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-compareisodate" type="abstract operation">
      <h1>
        CompareISODate (
          _isoDate1_: an ISO Date Record,
          _isoDate2_: an ISO Date Record,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs a comparison of the two dates denoted by _isoDate1_ and _isoDate2_ according to ISO 8601 calendar arithmetic.
        </dd>
      </dl>
      <emu-alg>
        1. If _isoDate1_.[[Year]] > _isoDate2_.[[Year]], return 1.
        1. If _isoDate1_.[[Year]] &lt; _isoDate2_.[[Year]], return -1.
        1. If _isoDate1_.[[Month]] > _isoDate2_.[[Month]], return 1.
        1. If _isoDate1_.[[Month]] &lt; _isoDate2_.[[Month]], return -1.
        1. If _isoDate1_.[[Day]] > _isoDate2_.[[Day]], return 1.
        1. If _isoDate1_.[[Day]] &lt; _isoDate2_.[[Day]], return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencetemporalplaindate" type="abstract operation">
      <h1>
        DifferenceTemporalPlainDate (
          _operation_: ~since~ or ~until~,
          _temporalDate_: a Temporal.PlainDate,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _temporalDate_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. Set _other_ to ? ToTemporalDate(_other_).
        1. If CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]) is *false*, throw a *RangeError* exception.
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _settings_ be ? GetDifferenceSettings(_operation_, _resolvedOptions_, ~date~, ¬´ ¬ª, ~day~, ~day~).
        1. If CompareISODate(_temporalDate_.[[ISODate]], _other_.[[ISODate]]) = 0, then
          1. Return ! CreateTemporalDuration(0, 0, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _dateDifference_ be CalendarDateUntil(_temporalDate_.[[Calendar]], _temporalDate_.[[ISODate]], _other_.[[ISODate]], _settings_.[[LargestUnit]]).
        1. Let _duration_ be ! CombineDateAndTimeDuration(_dateDifference_, 0).
        1. If _settings_.[[SmallestUnit]] is not ~day~ or _settings_.[[RoundingIncrement]] ‚â† 1, then
          1. Let _isoDateTime_ be CombineISODateAndTimeRecord(_temporalDate_.[[ISODate]], MidnightTimeRecord()).
          1. Let _isoDateTimeOther_ be CombineISODateAndTimeRecord(_other_.[[ISODate]], MidnightTimeRecord()).
          1. Let _destEpochNs_ be GetUTCEpochNanoseconds(_isoDateTimeOther_).
          1. Set _duration_ to ? RoundRelativeDuration(_duration_, _destEpochNs_, _isoDateTime_, ~unset~, _temporalDate_.[[Calendar]], _settings_.[[LargestUnit]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]]).
        1. Let _result_ be ! TemporalDurationFromInternal(_duration_, ~day~).
        1. If _operation_ is ~since~, set _result_ to CreateNegatedTemporalDuration(_result_).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddurationtodate" type="abstract operation">
      <h1>
        AddDurationToDate (
          _operation_: ~add~ or ~subtract~,
          _temporalDate_: a Temporal.PlainDate,
          _temporalDurationLike_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.PlainDate or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds/subtracts _temporalDurationLike_ to/from _temporalDate_, returning a point in time that is in the future/past relative to _temporalDate_.</dd>
      </dl>
      <emu-alg>
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _duration_ be ? ToTemporalDuration(_temporalDurationLike_).
        1. If _operation_ is ~subtract~, set _duration_ to CreateNegatedTemporalDuration(_duration_).
        1. Let _dateDuration_ be ? ToDateDurationRecordWithoutTime(_duration_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? GetTemporalOverflowOption(_resolvedOptions_).
        1. Let _result_ be ? CalendarDateAdd(_calendar_, _temporalDate_.[[ISODate]], _dateDuration_, _overflow_).
        1. Return ! CreateTemporalDate(_result_, _calendar_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
