<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-date-objects">
  <h1>Temporal.Date Objects</h1>
  <p>A Temporal.Date object is an immutable Object that contains integers corresponding to a
    particular year, month, and day in the ISO8601 calendar, as well as an Object value used to
    interpret those integers in a particular calendar.</p>

  <emu-clause id="sec-temporal-date-constructor">
    <h1>The Temporal.Date Constructor</h1>
    <p>The Temporal.Date constructor:</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.Date%</dfn>.</li>
      <li>creates and initializes a new Temporal.Date object when called as a constructor.</li>
      <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Temporal.Date behaviour must include a super call to the %Temporal.Date% constructor to create and initialize subclass instances with the necessary internal slots.</li>
    </ul>

    <emu-clause id="sec-temporal.date">
      <h1>Temporal.Date ( _isoYear_, _isoMonth_, _isoDay_ [ , _calendarLike_ ] )</h1>
      <p>
        When the `Temporal.Date` function is called, the following steps are taken:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _y_ be ? ToInteger(_isoYear_).
        1. Let _m_ be ? ToInteger(_isoMonth_).
        1. Let _d_ be ? ToInteger(_isoDay_).
        1. If _calendarLike_ is *undefined*, then
          1. Set _calendar_ to ? GetISO8601Calendar().
        1. Else,
          1. Set _calendar_ to ? ToTemporalCalendar(_calendarLike_).
        1. Return ? CreateTemporalDate(_y_, _m_, _d_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-date-constructor">
    <h1>Properties of the Temporal.Date Constructor</h1>
    <p>The Temporal.Date constructor:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-clause id="sec-temporal-date-prototype">
      <h1>Temporal.Date.prototype</h1>
      <p>The initial value of `Temporal.Date.prototype` is %Temporal.Date.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date-@@species">
      <h1>get Temporal.Date [ @@species ]</h1>
      <p>
        `Temporal.Date[@@species]` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>

      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.date.from">
      <h1>Temporal.Date.from ( _item_ [ , _options_ ] )</h1>
      <p>
        The `from` method takes two arguments, _item_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _constructor_ be the *this* value.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalDate]] internal slot, then
          1. Return ? CreateTemporalDateFromStatic(_constructor_, _item_.[[ISOYear]], _item_.[[ISOMonth]], _item_.[[ISODay]], _item_.[[Calendar]]).
        1. Return ? ToTemporalDate(_item_, _constructor_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.compare">
      <h1>Temporal.Date.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalDate(_one_).
        1. Set _two_ to ? ToTemporalDate(_two_).
        1. Return ùîΩ(? CompareTemporalDateCalendar(_one_.[[ISOYear]], _one_.[[ISOMonth]], _one_.[[ISODay]], _one_.[[Calendar]],
            _two_.[[ISOYear]], _two_.[[ISOMonth]], _two_.[[ISODay]], _two_.[[Calendar]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-date-prototype-object">
    <h1>Properties of the Temporal.Date Prototype Object</h1>

    <p>The Temporal.Date prototype object</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.Date.prototype%</dfn>.
      <li>is itself an ordinary object.
      <li>is not a Temporal.Date instance and does not have a [[InitializedTemporalDate]] internal slot.
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.
    </ul>

    <emu-clause id="sec-temporal.date.prototype.constructor">
      <h1>Temporal.Date.prototype.constructor</h1>
      <p>The initial value of `Temporal.Date.prototype.constructor` is %Temporal.Date%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype-@@tostringtag">
      <h1>Temporal.Date.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.Date"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.calendar">
      <h1>get Temporal.Date.prototype.calendar</h1>
      <p>
        `Temporal.Date.prototype.calendar` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return _temporalDate_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.year">
      <h1>get Temporal.Date.prototype.year</h1>
      <p>
        `Temporal.Date.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"year"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.month">
      <h1>get Temporal.Date.prototype.month</h1>
      <p>
        `Temporal.Date.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"month"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.day">
      <h1>get Temporal.Date.prototype.day</h1>
      <p>
        `Temporal.Date.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"day"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.dayofweek">
      <h1>get Temporal.Date.prototype.dayOfWeek</h1>
      <p>
        `Temporal.Date.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"dayOfWeek"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.dayofyear">
      <h1>get Temporal.Date.prototype.dayOfYear</h1>
      <p>
        `Temporal.Date.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"dayOfYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.weekofyear">
      <h1>get Temporal.Date.prototype.weekOfYear</h1>
      <p>
        `Temporal.Date.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"weekOfYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.daysinweek">
      <h1>get Temporal.Date.prototype.daysInWeek</h1>
      <p>
        `Temporal.Date.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInWeek"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.daysinmonth">
      <h1>get Temporal.Date.prototype.daysInMonth</h1>
      <p>
        `Temporal.Date.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInMonth"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.daysinyear">
      <h1>get Temporal.Date.prototype.daysInYear</h1>
      <p>
        `Temporal.Date.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"daysInYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.monthsinyear">
      <h1>get Temporal.Date.prototype.monthsInYear</h1>
      <p>
        `Temporal.Date.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"monthsInYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.date.prototype.isleapyear">
      <h1>get Temporal.Date.prototype.isLeapYear</h1>
      <p>
        `Temporal.Date.prototype.isLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _method_ be ? Get(_calendar_, *"isLeapYear"*).
        1. Return ? Call(_method_, _calendar_, ¬´ _temporalDate_ ¬ª).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.toyearmonth">
      <h1>Temporal.Date.prototype.toYearMonth ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? CreateTemporalYearMonth(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.tomonthday">
      <h1>Temporal.Date.prototype.toMonthDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? CreateTemporalMonthDay(_temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.getfields">
      <h1>Temporal.Date.prototype.getFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Let _record_ be ? ToPartialDate(_temporalDate_).
        1. Let _fields_ be ? ObjectCreate(%ObjectPrototype%).
        1. For each row of <emu-xref href="#table-temporal-temporaldatelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _p_ be the Property value of the current row.
          1. Let _v_ be the value of _record_'s field whose name is the Internal Slot value of the current row.
          1. Perform ! CreateDataPropertyOrThrow(_fields_, _p_, _v_).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.getisofields">
      <h1>Temporal.Date.prototype.getISOFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _fields_ be ? ObjectCreate(%ObjectPrototype%).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _temporalDate_.[[Calendar]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, ùîΩ(_temporalDate_.[[ISODay]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, ùîΩ(_temporalDate_.[[ISOMonth]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, ùîΩ(_temporalDate_.[[ISOYear]])).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.add">
      <h1>Temporal.Date.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `add` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _balanceResult_ be ? BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"days"*).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _result_ be ? AddDate(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]], _overflow_).
        1. Assert: ! ValidateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Return ? CreateTemporalDateFromInstance(_temporalDate_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.subtract">
      <h1>Temporal.Date.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `subtract` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _balanceResult_ be ? BalanceDuration(_duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], *"days"*).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _result_ be ? SubtractDate(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _balanceResult_.[[Days]], _overflow_).
        1. Assert: ! ValidateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Return ? CreateTemporalDateFromInstance(_temporalDate_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.with">
      <h1>Temporal.Date.prototype.with ( _temporalDateLike_ [ , _options_ ] )</h1>
      <p>
        The `with` method takes two arguments, _temporalDateLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If Type(_temporalDateLike_) is not Object, then
          1. Let _isoString_ be ? ToString(_temporalDateLike_).
          1. Set _temporalDateLike_ to ? RelevantTemporalObjectFromString(_isoString_).
        1. Let _partialDate_ be ? ToPartialDate(_temporalDateLike_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. If _partialDate_.[[Year]] is not *undefined*, then
          1. Let _y_ be _partialDate_.[[Year]].
        1. Else,
          1. Let _y_ be _temporalDate_.[[ISOYear]].
        1. If _partialDate_.[[Month]] is not *undefined*, then
          1. Let _m_ be _partialDate_.[[Month]].
        1. Else,
          1. Let _m_ be _temporalDate_.[[ISOMonth]].
        1. If _partialDate_.[[Day]] is not *undefined*, then
          1. Let _d_ be _partialDate_.[[Day]].
        1. Else,
          1. Let _d_ be _temporalDate_.[[ISODay]].
        1. Let _result_ be ? RegulateDate(_y_, _m_, _d_, _overflow_).
        1. Assert: ! ValidateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *true*.
        1. Return ? CreateTemporalDateFromInstance(_temporalDate_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.difference">
      <h1>Temporal.Date.prototype.difference ( _other_ [ , _options_ ] )</h1>
      <p>
        The `difference` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Perform ? RequireInternalSlot(_other_, [[InitializedTemporalDate]]).
        1. Let _calendar_ be _temporalDate_.[[Calendar]].
        1. Let _calendarID_ be ? CalendarToString(_calendar_).
        1. Let _otherCalendar_ be _other_.[[Calendar]].
        1. Let _otherCalendarID_ be ? CalendarToString(_otherCalendar_).
        1. If _calendarID_ ‚â† _otherCalendarID_, throw a *RangeError* exception.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _disallowedUnits_ be ¬´ *"hours"*, *"minutes"*, *"seconds"*, *"milliseconds"*, *"microseconds"*, *"nanoseconds"* ¬ª.
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, *"days"*, _disallowedUnits_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, _disallowedUnits_, *"days"*).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, *undefined*, *false*).
        1. Let _result_ be ? CalendarDateDifference(_calendar_, _other_.[[ISOYear]], _other_.[[ISOMonth]], _other_.[[ISODay]], _temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _largestUnit_).
        1. If _smallestUnit_ is not *"days"* or _roundingIncrement_ ‚â† 1, then
          1. Let _relativeTo_ be ! CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0, _temporalDate_.[[Calendar]]).
          1. Set _result_ to ? RoundDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0, _roundingIncrement_, _smallestUnit_, _roundingMode_, _relativeTo_).
        1. Return ? CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], 0, 0, 0, 0, 0, 0).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.equals">
      <h1>Temporal.Date.prototype.equals ( _other_ )</h1>
      <p>
        The `equals` method takes one argument _other_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Perform ? RequireInternalSlot(_other_, [[InitializedTemporalDate]]).
        1. If _temporalDate_.[[ISOYear]] ‚â† _other_.[[ISOYear]], return *false*.
        1. If _temporalDate_.[[ISOMonth]] ‚â† _other_.[[ISOMonth]], return *false*.
        1. If _temporalDate_.[[ISODay]] ‚â† _other_.[[ISODay]], return *false*.
        1. Return ? CalendarEquals(_temporalDate_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.todatetime">
      <h1>Temporal.Date.prototype.toDateTime ( [ _temporalTime_ ] )</h1>
      <p>
        The `toDateTime` method takes one argument _temporalTime_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If _temporalTime_ is *undefined*, then
          1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], 0, 0, 0, 0, 0, 0).
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]],
          _temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]],
          _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.tostring">
      <h1>Temporal.Date.prototype.toString ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? TemporalDateToString(_temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.tolocalestring">
      <h1>Temporal.Date.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. If the implementation does not include the ECMA-402 Internationalization API, then
          1. Return ? TemporalDateToString(_temporalDate_).
        1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, ¬´ _locales_, _options_ ¬ª).
        1. Return ? FormatDateTime(_dateFormat_, _temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.tojson">
      <h1>Temporal.Date.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalDate_, [[InitializedTemporalDate]]).
        1. Return ? TemporalDateToString(_temporalDate_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype.valueof">
      <h1>Temporal.Date.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-date-instances">
    <h1>Properties of Temporal.Date Instances</h1>
    <p>
      Temporal.Date instances are ordinary objects that inherit properties from the %Temporal.Date.prototype% intrinsic object.
      Temporal.Date instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaldate-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaldate-instances" caption="Internal Slots of Temporal.Date Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalDate]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.Date instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOYear]]
            </td>
            <td>
              An integer representing the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMonth]]
            </td>
            <td>
              An integer between 1 and 12, inclusive, representing the month of the year in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[ISODay]]
            </td>
            <td>
              An integer between 1 and DaysInMonth([[ISOYear]], [[ISOMonth]]), inclusive, representing the day of the month in the ISO 8601 calendar.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              An Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-date-abstract-ops">
    <h1>Abstract Operations for Temporal.Date Objects</h1>

    <emu-clause id="sec-temporal-createtemporaldate" aoid="CreateTemporalDate">
      <h1>CreateTemporalDate ( _isoYear_, _isoMonth_, _isoDay_, _calendar_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. Assert: _isoYear_ is an integer.
        1. Assert: _isoMonth_ is an integer.
        1. Assert: _isoDay_ is an integer.
        1. Perform ? RejectDate(_isoYear_, _isoMonth_, _isoDay_).
        1. If ! DateTimeWithinLimits(_isoYear_, _isoMonth_, _isoDay_, 12, 0, 0, 0, 0, 0) is not ~in range~, throw a *RangeError* exception.
        1. If Type(_calendar_) is not Object, throw a *RangeError* exception.
        1. If _newTarget_ is not given, set it to %Temporal.Date%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.Date.prototype%"*, ¬´ [[InitializedTemporalDate]], [[ISOYear]], [[ISOMonth]], [[ISODay]], [[Calendar]] ¬ª).
        1. Set _object_.[[ISOYear]] to _isoYear_.
        1. Set _object_.[[ISOMonth]] to _isoMonth_.
        1. Set _object_.[[ISODay]] to _isoDay_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
      <emu-note>
        <p>Deferring to DateTimeWithinLimits with an hour of 12 avoids trouble at the extremes of the representable range of dates, which stop just before midnight on each end.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatefrominstance" aoid="CreateTemporalDateFromInstance">
      <h1>CreateTemporalDateFromInstance ( _temporalDate_, _isoYear_, _isoMonth_, _isoDay_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalDate_) is Object and _temporalDate_ has an [[InitializedTemporalDate]] internal slot.
        1. Assert: ! ValidateDate(_isoYear_, _isoMonth_, _isoDay_) is *true*.
        1. Let _constructor_ be ? SpeciesConstructor(_temporalDate_, %Temporal.Date%).
        1. Let _result_ be ? Construct(_constructor_, ¬´ _isoYear_, _isoMonth_, _isoDay_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDate]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatefromstatic" aoid="CreateTemporalDateFromStatic">
      <h1>CreateTemporalDateFromStatic ( _constructor_, _isoYear_, _isoMonth_, _isoDay_, _calendar_ )</h1>
      <emu-alg>
        1. Assert: ! ValidateDate(_isoYear_, _isoMonth_, _isoDay_) is *true*.
        1. If ! IsConstructor(_constructor_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? Construct(_constructor_, ¬´ _isoYear_, _isoMonth_, _isoDay_, _calendar_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDate]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldate" aoid="ToTemporalDate">
      <h1>ToTemporalDate ( _item_ [ , _constructor_ [ , _overflow_ ] ] )</h1>
      <p>
        The abstract operation ToTemporalDate returns its argument _item_ if it is already a Temporal.Date instance, converts _item_ to a new Temporal.Date instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _constructor_ is not given, set it to %Temporal.Date%.
        1. If _overflow_ is not given, set it to *"constrain"*.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalDate]] internal slot, then
            1. Return _item_.
          1. Let _result_ be ? ToTemporalDateRecord(_item_).
        1. Else,
          1. Let _string_ be ? ToString(_item_).
          1. Let _result_ be ? ParseTemporalDateString(_string_).
        1. Let _calendar_ be _result_.[[Calendar]].
        1. If _calendar_ is *undefined*, set _calendar_ to ! GetISO8601Calendar().
        1. Set _calendar_ to ? ToTemporalCalendar(_calendar_).
        1. Set _result_ to ? RegulateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _overflow_).
        1. Return ? CreateTemporalDateFromStatic(_constructor_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencedate" aoid="DifferenceDate">
      <h1>DifferenceDate ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_, _largestUnit_ )</h1>
      <emu-alg>
        1. Assert: _largestUnit_ is one of *"years"*, *"months"*, *"weeks"*, *"days"*, *"hours"*, *"minutes"*, or *"seconds"*.
        1. If _largestUnit_ is not *"years"*, *"months"*, or *"weeks"*, then
          1. Set _largestUnit_ to *"days"*.
        1. If ! CompareTemporalDate(_y1_, _m1_, _d1_, _y2_, _m2_, _d2_) &lt; 0, then
          1. Let _smaller_ be the new Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
          1. Let _greater_ be the new Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
          1. Let _sign_ be 1.
        1. Else,
          1. Let _smaller_ be the new Record { [[Year]]: _y2_, [[Month]]: _m2_, [[Day]]: _d2_ }.
          1. Let _greater_ be the new Record { [[Year]]: _y1_, [[Month]]: _m1_, [[Day]]: _d1_ }.
          1. Let _sign_ be ‚àí1.
        1. Let _years_ be _greater_.[[Year]] ‚àí _smaller_.[[Year]].
        1. If _largestUnit_ is *"days"* or *"weeks"*, then
          1. Let _weeks_ be 0.
          1. Let _days_ be ! ToDayOfYear(_greater_.[[Year]], _greater_.[[Month]], _greater_.[[Day]]) ‚àí ! ToDayOfYear(_smaller_.[[Year]], _smaller_.[[Month]], _smaller_.[[Day]]).
          1. Assert: _years_ ‚â• 0.
          1. Repeat, while _years_ &gt; 0,
            1. Set _days_ to _days_ + ! DaysInYear(_smaller_.[[Year]] + _years_ ‚àí 1).
            1. Set _years_ to _years_ ‚àí 1.
          1. If _largestUnit_ is *"weeks"*, then
            1. Set _weeks_ to floor(_days_ / 7).
            1. Set _days_ to _days_ mod 7.
          1. Return the Record {
            [[Years]]: 0,
            [[Months]]: 0,
            [[Weeks]]: _weeks_ √ó _sign_,
            [[Days]]: _days_ √ó _sign_
          }.
        1. Let _months_ be _greater_.[[Month]] ‚àí _smaller_.[[Month]].
        1. Let _balanceResult_ be ? BalanceDurationDate(_years_, _months_, _smaller_.[[Year]], _smaller_.[[Month]], _smaller_.[[Day]]).
        1. Set _years_ to _balanceResult_.[[Years]].
        1. Set _months_ to _balanceResult_.[[Months]].
        1. Let _days_ be ! ToDayOfYear(_greater_.[[Year]], _greater_.[[Month]], _greater_.[[Day]]) ‚àí ! ToDayOfYear(_balanceResult_.[[Year]], _balanceResult_.[[Month]], _smaller_.[[Day]]).
        1. If _days_ &lt; 0, then
          1. Set _months_ to _months_ ‚àí 1.
          1. Set _balanceResult_ to ? BalanceDurationDate(_years_, _months_, _smaller_.[[Year]], _smaller_.[[Month]], _smaller_.[[Day]]).
          1. Set _years_ to _balanceResult_.[[Years]].
          1. Set _months_ to _balanceResult_.[[Months]].
          1. Set _days_ to ! ToDayOfYear(_greater_.[[Year]], _greater_.[[Month]], _greater_.[[Day]]) ‚àí ! ToDayOfYear(_balanceResult_.[[Year]], _balanceResult_.[[Month]], _smaller_.[[Day]]).
          1. If _greater_.[[Year]] &gt; _balanceResult_.[[Year]], then
            1. Set _days_ to _days_ + ! DaysInYear(_balanceResult_.[[Year]]).
        1. If _largestUnit_ is *"months"*, then
          1. Set _months_ to _years_ √ó 12.
          1. Set _years_ to 0.
        1. Return the Record {
          [[Years]]: _years_ √ó _sign_,
          [[Months]]: _months_ √ó _sign_,
          [[Weeks]]: 0,
          [[Days]]: _days_ √ó _sign_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldaterecord" aoid="ToTemporalDateRecord">
      <h1>ToTemporalDateRecord ( _temporalDateLike_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalDateLike_) is Object.
        1. If _temporalDateLike_ has an [[InitializedTemporalDate]] internal slot, then
          1. Return the Record {
              [[Year]]: _temporalDateLike_.[[Year]],
              [[Month]]: _temporalDateLike_.[[Month]],
              [[Day]]: _temporalDateLike_.[[Day]],
            }.
        1. Let _result_ be a new Record with all the internal slots given in the Internal Slot column in <emu-xref href="#table-temporal-temporaldatelike-properties"></emu-xref>.
        1. For each row of <emu-xref href="#table-temporal-temporaldatelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalDateLike_, _property_).
          1. If _value_ is *undefined*, then
            1. Throw a *TypeError* exception.
          1. Let _value_ be ? ToInteger(_value_).
          1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-topartialdate" aoid="ToPartialDate">
      <h1>ToPartialDate ( _temporalDateLike_ )</h1>
      <emu-alg>
        1. If Type(_temporalDateLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be a new Record with all the internal slots given in the Internal Slot column in <emu-xref href="#table-temporal-temporaldatelike-properties"></emu-xref>, all set to *undefined*.
        1. Let _any_ be *false*.
        1. For each row of <emu-xref href="#table-temporal-temporaldatelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalDateLike_, _property_).
          1. If _value_ is not *undefined*, then
            1. Set _any_ to *true*.
            1. Set _value_ to ? ToInteger(_value_).
            1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
        1. If _any_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>

      <emu-table id="table-temporal-temporaldatelike-properties">
        <emu-caption>Properties of a TemporalDateLike</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[[Day]]</td>
              <td>`"day"`</td>
            </tr>
            <tr>
              <td>[[Month]]</td>
              <td>`"month"`</td>
            </tr>
            <tr>
              <td>[[Year]]</td>
              <td>`"year"`</td>
            </tr>
            <tr>
              <td>[[Calendar]]</td>
              <td>`"calendar"`</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-regulatedate" aoid="RegulateDate">
      <h1>RegulateDate ( _year_, _month_, _day_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If _overflow_ is *"reject"*, then
          1. Perform ? RejectDate(_year_, _month_, _day_).
          1. Return the Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_
            }.
        1. If _overflow_ is *"constrain"*, then
          1. Return ! ConstrainDate(_year_, _month_, _day_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-validatedate" aoid="ValidateDate">
      <h1>ValidateDate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. If _month_ &lt; 1 or _month_ &gt; 12, then
          1. Return *false*.
        1. Let _daysInMonth_ be ! DaysInMonth(_year_, _month_).
        1. If _day_ &lt; 1 or _day_ &gt; _daysInMonth_, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-rejectdate" aoid="RejectDate">
      <h1>RejectDate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. If ! ValidateDate(_year_, _month_, _day_) is *false*, then
          1. Throw a *RangeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-constraindate" aoid="ConstrainDate">
      <h1>ConstrainDate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integers.
        1. Set _month_ to ! ConstrainToRange(_month_, 1, 12).
        1. Set _day_ to ! ConstrainToRange(_day_, 1, ! DaysInMonth(_year_, _month_)).
        1. Return the Record {
          [[Year]]: _year_,
          [[Month]]: _month_,
          [[Day]]: _day_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancedate" aoid="BalanceDate">
      <h1>BalanceDate ( _year_, _month_, _day_ )</h1>
      <emu-alg>
        1. If _day_ is *+‚àû* or *‚àí‚àû*, then
          1. Throw a *RangeError* exception.
        1. Let _balancedYearMonth_ be ? BalanceYearMonth(_year_, _month_).
        1. Let _month_ be _balancedYearMonth_.[[Month]].
        1. Let _year_ be _balancedYearMonth_.[[Year]].
        1. NOTE: To deal with negative numbers of days whose absolute value is greater than the number of days in a year, the following section subtracts years and adds days until the number of days is greater than ‚àí366 or ‚àí365.
        1. Let _daysInYear_ be 0.
        1. If _month_ &gt; 2, then
          1. Let _testYear_ be _year_.
        1. Else,
          1. Let _testYear_ be _year_ ‚àí 1.
        1. Repeat, while _day_ &lt; ‚àí1 √ó ! DaysInYear(_testYear_),
          1. Set _day_ to _day_ + ! DaysInYear(_testYear_).
          1. Set _year_ to _year_ ‚àí 1.
          1. Set _testYear_ to _testYear_ ‚àí 1.
        1. NOTE: To deal with numbers of days greater than the number of days in a year, the following section adds years and subtracts days until the number of days is less than 366 or 365.
        1. Let _testYear_ be _year_ + 1.
        1. Repeat, while _day_ &gt; ! DaysInYear(_testYear_),
          1. Set _day_ to _day_ ‚àí ! DaysInYear(_testYear_).
          1. Set _year_ to _year_ + 1.
          1. Set _testYear_ to _testYear_ + 1.
        1. NOTE: To deal with negative numbers of days whose absolute value is greater than the number of days in the current month, the following section subtracts months and adds days until the number of days is greater than 0.
        1. Repeat, while _day_ &lt; 1,
          1. Set _balancedYearMonth_ be ? BalanceYearMonth(_year_, _month_ ‚àí 1).
          1. Set _year_ to _balancedYearMonth_.[[Year]].
          1. Set _month_ to _balancedYearMonth_.[[Month]].
          1. Set _day_ to _day_ + ! DaysInMonth(_year_, _month_).
        1. NOTE: To deal with numbers of days greater than the number of days in the current month, the following section adds months and subtracts days until the number of days is less than the number of days in the month.
        1. Repeat, while _day_ &gt; ! DaysInMonth(_year_, _month_),
          1. Set _day_ to _day_ ‚àí ! DaysInMonth(_year_, _month_).
          1. Set _balancedYearMonth_ be ? BalanceYearMonth(_year_, _month_ + 1).
          1. Set _year_ to _balancedYearMonth_.[[Year]].
          1. Set _month_ to _balancedYearMonth_.[[Month]].
        1. Return the new Record {
          [[Year]]: _year_,
          [[Month]]: _month_,
          [[Day]]: _day_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancedurationdate" aoid="BalanceDurationDate">
      <h1>BalanceDurationDate ( _years_, _months_, _startYear_, _startMonth_, _startDay_ )</h1>
      <emu-alg>
        1. If _months_ &lt; 0, then
          1. Set _years_ to _years_ ‚àí 1.
          1. Set _months_ to _months_ + 12.
        1. Let _balanceResult_ be ? BalanceYearMonth(_startYear_ + _years_, _startMonth_ + _months_).
        1. Repeat, while _startDay_ &gt; ! DaysInMonth(_balanceResult_.[[Year]], _balanceResult_.[[Month]]),
          1. Set _months_ to _months_ ‚àí 1.
          1. If _months_ &lt; 0, then
            1. Set _years_ to _years_ ‚àí 1.
            1. Set _months_ to _months_ + 12.
          1. Set _balanceResult_ to ? BalanceYearMonth(_startYear_ + _years_, _startMonth_ + _months_).
        1. Return the new Record {
          [[Year]]: _balanceResult_.[[Year]],
          [[Month]]: _balanceResult_.[[Month]],
          [[Years]]: _years_,
          [[Months]]: _months_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-padyear" aoid="PadYear">
      <h1>PadYear ( _y_ )</h1>
      <emu-alg>
        1. Assert: _y_ is an integer.
        1. If _y_ &gt; 999 and _y_ ‚â§ 9999, then
          1. Return _y_ formatted as a four-digit decimal number.
        1. If _y_ ‚â• 0, let _yearSign_ be *"+"*; otherwise, let _yearSign_ be *"-"*.
        1. Let _year_ be abs(_y_), formatted as a six-digit decimal number, padded to the left with zeroes as necessary.
        1. Return the string-concatenation of _yearSign_ and _year_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldatetostring" aoid="TemporalDateToString">
      <h1>TemporalDateToString ( _temporalDate_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalDate_) is Object.
        1. Assert: _temporalDate_ has an [[InitializedTemporalDate]] internal slot.
        1. Let _year_ be ! PadYear(_temporalDate_.[[ISOYear]]).
        1. Let _month_ be _temporalDate_.[[ISOMonth]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _temporalDate_.[[ISODay]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _calendar_ be ? FormatCalendarAnnotation(_temporalDate_.[[Calendar]]).
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), _day_, and _calendar_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddate" aoid="AddDate">
      <h1>AddDate ( _year_, _month_, _day_, _years_, _months_, _weeks_, _days_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _years_, _months_, _weeks_, and _days_ are integer Number values.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. Let _y_ be _year_ + _years_.
        1. Let _m_ be _month_ + _months_.
        1. Let _intermediate_ be ? BalanceYearMonth(_y_, _m_).
        1. Let _intermediate_ be ? RegulateDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _day_, _overflow_).
        1. Set _days_ to _days_ + 7 √ó _weeks_.
        1. Let _d_ be _intermediate_.[[Day]] + _days_.
        1. Let _intermediate_ be ? BalanceDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_).
        1. Return ? RegulateDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _intermediate_.[[Day]], _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-subtractdate" aoid="SubtractDate">
      <h1>SubtractDate ( _year_, _month_, _day_, _years_, _months_, _days_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _years_, _months_, and _days_ are integer Number values.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. Set _days_ to _days_ + 7 √ó _weeks_.
        1. Let _intermediate_ be ? BalanceDate(_year_, _month_, _day_ - _days_).
        1. Let _d_ be _intermediate_.[[Day]].
        1. Let _intermediate_ be ? BalanceYearMonth(_intermediate_.[[Year]] - _years_, _intermediate_.[[Month]] - _months_).
        1. Return ? RegulateDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetemporaldate" aoid="CompareTemporalDate">
      <h1>CompareTemporalDate ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_ )</h1>
      <emu-alg>
        1. If _y1_ &gt; _y2_, return 1.
        1. If _y1_ &lt; _y2_, return -1.
        1. If _m1_ &gt; _m2_, return 1.
        1. If _m1_ &lt; _m2_, return -1.
        1. If _d1_ &gt; _d2_, return 1.
        1. If _d1_ &lt; _d2_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetemporaldatecalendar" aoid="CompareTemporalDateCalendar">
      <h1>CompareTemporalDateCalendar ( _y1_, _m1_, _d1_, _y2_, _m2_, _d2_, _c1_, _c2_ )</h1>
      <emu-alg>
        1. Let _result_ be ! CompareTemporalDate(_y1_, _m1_, _d1_, _y2_, _m2_, _d2_).
        1. If _result_ ‚â† 0, then
          1. Return _result_.
        1. Return ? CompareCalendar(_c1_, _c2_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
