<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-legacy-date-objects">
  <h1>Amendments to the ECMAScript® 2023 Language Specification</h1>

  <emu-note type="editor">
    <p>
      This section lists amendments which must be made to <a href="https://tc39.es/ecma262/">ECMA-262, the ECMAScript® 2023 Language Specification</a>, other than the addition of the new sections specifying the Temporal object and everything related to it.
      Text to be added is marked <ins>like this</ins>, and text to be deleted is marked <del>like this</del>.
      Blocks of unmodified text between modified sections are marked by [...].
    </p>
  </emu-note>

  <emu-clause id="sec-ecmascript-language-types-string-type">
    <h1><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type">The String Type</a></h1>

    <emu-note type="editor">
      <p>
        This section intends to move the definitions of ASCII-uppercase, ASCII-lowercase, and ASCII-case-insensitive match from ECMA-402 into ECMA-262, after the definition of the ASCII word characters.
        The definitions include minor editorial changes from ECMA-402 to address feedback from the ECMA-262 editors.
      </p>
    </emu-note>

    <p>[...]</p>

    <ins class="block">
      <p>The <dfn>ASCII-uppercase</dfn> of a String _S_ is the String derived from _S_ by replacing each occurrence of an ASCII lowercase letter code unit (0x0061 through 0x007A, inclusive) with the corresponding ASCII uppercase letter code unit (0x0041 through 0x005A, inclusive) while preserving all other code units.</p>
      <p>The <dfn>ASCII-lowercase</dfn> of a String _S_ is the String derived from _S_ by replacing each occurrence of an ASCII uppercase letter code unit (0x0041 through 0x005A, inclusive) with the corresponding ASCII lowercase letter code unit (0x0061 through 0x007A, inclusive) while preserving all other code units.</p>
      <p>A String _A_ is an <dfn variants="ASCII-case-insensitive matches,ASCII-case-insensitive,ASCII-case-insensitive comparison,ASCII-case-insensitive comparisons">ASCII-case-insensitive match</dfn> for a String _B_ if the ASCII-lowercase of _A_ is the ASCII-lowercase of _B_.</p>
    </ins>
  </emu-clause>

  <ins class="block">
    <emu-clause id="sec-year-week-record-specification-type">
      <h1>The Year-Week Record Specification Type</h1>
      <p>
        The <dfn variants="Year-Week Records">Year-Week Record</dfn> specification type is returned by the week number calculation in ToISOWeekOfYear, and the corresponding calculations for other calendars if applicable.
        It comprises a <em>calendar week of year</em> with the corresponding <em>week calendar year</em>.
      </p>
      <p>Year-Week Records have the fields listed in table <emu-xref href="#table-year-week-record"></emu-xref>.
      </p>
      <emu-table id="table-year-week-record">
        <emu-caption>Year-Week Record Fields</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[[Week]]</td>
              <td>a positive integer</td>
              <td>The calendar week of year.</td>
            </tr>
            <tr>
              <td>[[Year]]</td>
              <td>an integer</td>
              <td>The week calendar year.</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </ins>

  <ins class="block">
    <emu-clause id="sec-temporal-mergelists" type="abstract operation">
      <h1>
        MergeLists (
          _a_: a List,
          _b_: a List,
        ): a List
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the list-concatenation of its arguments, with duplicate elements removed.</dd>
      </dl>
      <emu-alg>
        1. Let _merged_ be a new empty List.
        1. For each element _element_ of _a_, do
          1. If _merged_ does not contain _element_, then
            1. Append _element_ to _merged_.
        1. For each element _element_ of _b_, do
          1. If _merged_ does not contain _element_, then
            1. Append _element_ to _merged_.
        1. Return _merged_.
      </emu-alg>
    </emu-clause>
  </ins>

  <ins class="block">
    <emu-clause id="sec-sortstringlistbycodeunit" type="abstract operation">
      <h1>
        SortStringListByCodeUnit (
          _strings_: a List of Strings,
        ): a List of Strings
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned List contains the same Strings as _strings_, but sorted lexicographically by UTF-16 code unit in ascending order.</dd>
      </dl>
      <emu-alg>
        1. Let _result_ be a copy of _strings_.
        1. [declared="comparefn"] Sort _result_ into the same order as if an Array of the same values had been sorted using %Array.prototype.sort% with *undefined* as _comparefn_.
        1. Return _result_.
      </emu-alg>
    </emu-clause>
  </ins>

  <emu-clause id="sec-literals-numeric-literals">
    <h1><a href="https://tc39.es/ecma262/#sec-literals-numeric-literals">Numeric Literals</a></h1>
    <emu-note type="editor">
      <p>
        No changes, but these productions must be present for symbol references because biblio.json contents are not propagated to grammarkdown.
      </p>
    </emu-note>
    <emu-grammar type="definition">
      NumericLiteralSeparator ::
        `_`

      DecimalDigits[Sep] ::
        DecimalDigit
        DecimalDigits[?Sep] DecimalDigit
        [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

      DecimalDigit :: one of
        `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

      NonZeroDigit :: one of
        `1` `2` `3` `4` `5` `6` `7` `8` `9`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-mathematical-operations">
    <h1>Mathematical Operations</h1>
    <p>[...]</p>
    <p>The notation &ldquo;<emu-eqn id="eqn-modulo" aoid="modulo">_x_ modulo _y_</emu-eqn>&rdquo; (_y_ must be finite and non-zero) computes a value _k_ of the same sign as _y_ (or zero) such that <emu-eqn>abs(_k_) &lt; abs(_y_) and _x_ - _k_ = _q_ &times; _y_</emu-eqn> for some integer _q_.</p>
    <p><ins>The mathematical function <emu-eqn id="eqn-remainder" aoid="remainder">remainder(_x_, _y_)</emu-eqn> produces the mathematical value whose sign is the sign of _x_ and whose magnitude is <emu-eqn>abs(_x_) modulo _y_</emu-eqn>.</ins></p>
    <p>[...]</p>
    <p>Mathematical functions min, max, abs, <ins>remainder,</ins> and floor are not defined for Numbers and BigInts, and any usage of those methods that have non-mathematical value arguments would be an editorial error in this specification.</p>
    <p>[...]</p>
  </emu-clause>

  <emu-clause id="sec-copydataproperties" type="abstract operation">
    <h1>
      CopyDataProperties (
        _target_: an Object,
        _source_: an ECMAScript language value,
        <del>_excludedItems_: a List of property keys,</del>
        <ins>_excludedKeys_: a List of property keys,</ins>
        <ins>optional _excludedValues_: a List of ECMAScript language values,</ins>
      ): either a normal completion containing ~unused~ or a throw completion
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. If _source_ is *undefined* or *null*, return ~unused~.
      1. Let _from_ be ! ToObject(_source_).
      1. Let _keys_ be ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]</emu-meta>().
      1. For each element _nextKey_ of _keys_, do
        1. Let _excluded_ be *false*.
        1. For each element _e_ of <del>_excludedItems_</del><ins>_excludedKeys_</ins>, do
          1. If SameValue(_e_, _nextKey_) is *true*, then
            1. Set _excluded_ to *true*.
        1. If _excluded_ is *false*, then
          1. Let _desc_ be ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_).
          1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then
            1. Let _propValue_ be ? Get(_from_, _nextKey_).
            1. <ins>If _excludedValues_ is present, then</ins>
              1. <ins>For each element _e_ of _excludedValues_, do</ins>
                1. <ins>If SameValue(_e_, _propValue_) is *true*, then</ins>
                  1. <ins>Set _excluded_ to *true*.</ins>
            1. <del>Perform</del><ins>If _excluded_ is *false*, perform</ins> ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_).
      1. Return ~unused~.
    </emu-alg>
    <emu-note>
      <p>The target passed in here is always a newly created object which is not directly accessible in case of an error being thrown.</p>
    </emu-note>
  </emu-clause>

  <ins class="block">
    <emu-clause id="sec-snapshotownproperties" type="abstract operation">
      <h1>
        SnapshotOwnProperties (
          _source_: an Object,
          _proto_: an Object or *null*,
          optional _excludedKeys_: a List of property keys,
          optional _excludedValues_: a List of ECMAScript language values,
        ): either a normal completion containing an Object, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It enumerates the own properties of _source_ and copies them into data properties on a new object with the specified prototype, subject to the specified exclusions.
        </dd>
      </dl>
      <emu-alg>
        1. Let _copy_ be OrdinaryObjectCreate(_proto_).
        1. If _excludedKeys_ is not present, set _excludedKeys_ to « ».
        1. If _excludedValues_ is not present, set _excludedValues_ to « ».
        1. Perform ? CopyDataProperties(_copy_, _source_, _excludedKeys_, _excludedValues_).
        1. Return _copy_.
      </emu-alg>
    </emu-clause>
  </ins>

  <emu-clause id="sec-overview-of-date-objects-and-definitions-of-abstract-operations">
    <h1>Overview of Date Objects and Definitions of Abstract Operations</h1>

    <p>[...]</p>

    <emu-clause id="sec-time-zone-identifiers">
      <h1>Time Zone Identifiers</h1>

      <p>
        Time zones in ECMAScript are represented by <dfn variants="time zone identifier">time zone identifiers</dfn>, which are Strings composed entirely of code units in the inclusive interval from <del>0x0000 to 0x007F</del><ins>0x0021 to 0x007E</ins>.
        Time zones supported by an ECMAScript implementation may be <dfn variants="available named time zone">available named time zones</dfn>, represented by the [[Identifier]] field of the Time Zone Identifier Records returned by AvailableNamedTimeZoneIdentifiers, or <dfn variants="offset time zone">offset time zones</dfn>, represented by Strings for which IsTimeZoneOffsetString returns *true*.
        <ins>Time zone identifiers are compared using ASCII-case-insensitive comparisons.</ins>
      </p>
      <p>
        A <dfn variants="primary time zone identifiers">primary time zone identifier</dfn> is the preferred identifier for an available named time zone.
        A <dfn variants="non-primary time zone identifiers">non-primary time zone identifier</dfn> is an identifier for an available named time zone that is not a primary time zone identifier.
        An <dfn variants="available named time zone identifiers">available named time zone identifier</dfn> is either a primary time zone identifier or a non-primary time zone identifier.
        Each available named time zone identifier is associated with exactly one available named time zone.
        Each available named time zone is associated with exactly one primary time zone identifier and zero or more non-primary time zone identifiers.
      </p>
      <p>
        ECMAScript implementations must support an available named time zone with the identifier *"UTC"*, which must be the primary time zone identifier for the UTC time zone.
        In addition, implementations may support any number of other available named time zones.
      </p>
      <p>
        Implementations that follow the requirements for time zones as described in the ECMA-402 Internationalization API specification are called <dfn>time zone aware</dfn>.
        Time zone aware implementations must support available named time zones corresponding to the Zone and Link names of the IANA Time Zone Database, and only such names.
        In time zone aware implementations, a primary time zone identifier is a Zone name, and a non-primary time zone identifier is a Link name, respectively, in the IANA Time Zone Database except as specifically overridden by AvailableNamedTimeZoneIdentifiers as specified in the ECMA-402 specification.
        Implementations that do not support the entire IANA Time Zone Database are still recommended to use IANA Time Zone Database names as identifiers to represent time zones.
      </p>
    </emu-clause>

    <emu-clause id="sec-availablenamedtimezoneidentifiers" type="implementation-defined abstract operation">
      <h1>AvailableNamedTimeZoneIdentifiers ( ): a List of Time Zone Identifier Records</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          Its result describes all available named time zone identifiers in this implementation, as well as the primary time zone identifier corresponding to each available named time zone identifier.
          The List is ordered according to the [[Identifier]] field of each Time Zone Identifier Record.
        </dd>
      </dl>
      <p>
        Time zone aware implementations, including all implementations that implement the ECMA-402 Internationalization API, must implement the AvailableNamedTimeZoneIdentifiers abstract operation as specified in the ECMA-402 specification.
        For implementations that are not time zone aware, AvailableNamedTimeZoneIdentifiers performs the following steps when called:
      </p>
      <emu-alg>
        1. If the implementation does not include local political rules for any time zones, then
          1. Return « the Time Zone Identifier Record { [[Identifier]]: *"UTC"*, [[PrimaryIdentifier]]: *"UTC"* } ».
        1. Let _identifiers_ be the List of unique available named time zone identifiers.
        1. <del>Sort _identifiers_ into the same order as if an Array of the same values had been sorted using %Array.prototype.sort% with *undefined* as the argument.</del>
        1. <ins>Set _identifiers_ to SortStringListByCodeUnit(_identifiers_).</ins>
        1. Let _result_ be a new empty List.
        1. For each element _identifier_ of _identifiers_, do
          1. Let _primary_ be _identifier_.
          1. If _identifier_ is a non-primary time zone identifier in this implementation and _identifier_ is not *"UTC"*, then
            1. Set _primary_ to the primary time zone identifier associated with _identifier_.
            1. NOTE: An implementation may need to resolve _identifier_ iteratively to obtain the primary time zone identifier.
          1. Let _record_ be the Time Zone Identifier Record { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }.
          1. Append _record_ to _result_.
        1. Assert: _result_ contains a Time Zone Identifier Record _r_ such that _r_.[[Identifier]] is *"UTC"* and _r_.[[PrimaryIdentifier]] is *"UTC"*.
        1. Return _result_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-date-constructor">
    <h1><a href="https://tc39.es/ecma262/#sec-date-constructor">The Date Constructor</a></h1>
    <emu-clause id="sec-temporal-date">
      <h1><a href="https://tc39.es/ecma262/#sec-date">Date ( ..._values_ )</a></h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. <del>If NewTarget is *undefined*, then</del>
          1. <del>Let _now_ be the time value (UTC) identifying the current time.</del>
          1. <del>Return ToDateString(_now_).</del>
        1. <ins>If NewTarget is *undefined*, return ToDateString(SystemUTCEpochMilliseconds()).</ins>
        1. Let _numberOfArgs_ be the number of elements in _values_.
        1. If _numberOfArgs_ = 0, then
          1. Let _dv_ be <del>the time value (UTC) identifying the current time</del> <ins>SystemUTCEpochMilliseconds()</ins>.
        1. Else if _numberOfArgs_ = 1, then
          1. Let _value_ be _values_[0].
          1. If _value_ is an Object and _value_ has a [[DateValue]] internal slot, then
            1. Let _tv_ be ! thisTimeValue(_value_).
          1. Else,
            1. Let _v_ be ? ToPrimitive(_value_).
            1. If _v_ is a String, then
              1. Assert: The next step never returns an abrupt completion because _v_ is a String.
              1. Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href="#sec-date.parse"></emu-xref>).
            1. Else,
              1. Let _tv_ be ? ToNumber(_v_).
          1. Let _dv_ be TimeClip(_tv_).
        1. Else,
          1. Assert: _numberOfArgs_ ≥ 2.
          1. Let _y_ be ? ToNumber(_values_[0]).
          1. Let _m_ be ? ToNumber(_values_[1]).
          1. If _numberOfArgs_ > 2, let _dt_ be ? ToNumber(_values_[2]); else let _dt_ be *1*<sub>𝔽</sub>.
          1. If _numberOfArgs_ > 3, let _h_ be ? ToNumber(_values_[3]); else let _h_ be *+0*<sub>𝔽</sub>.
          1. If _numberOfArgs_ > 4, let _min_ be ? ToNumber(_values_[4]); else let _min_ be *+0*<sub>𝔽</sub>.
          1. If _numberOfArgs_ > 5, let _s_ be ? ToNumber(_values_[5]); else let _s_ be *+0*<sub>𝔽</sub>.
          1. If _numberOfArgs_ > 6, let _milli_ be ? ToNumber(_values_[6]); else let _milli_ be *+0*<sub>𝔽</sub>.
          1. If _y_ is *NaN*, then
            1. Let _yr_ be *NaN*.
          1. Else,
            1. Let _yi_ be ! ToIntegerOrInfinity(_y_).
            1. If 0 ≤ _yi_ ≤ 99, let _yr_ be *1900*<sub>𝔽</sub> + 𝔽(_yi_); otherwise, let _yr_ be _y_.
          1. Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)).
          1. Let _dv_ be TimeClip(UTC(_finalDate_)).
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Date.prototype%"*, « [[DateValue]] »).
        1. Set _O_.[[DateValue]] to _dv_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-properties-of-the-date-constructor">
    <h1><a href="https://tc39.es/ecma262/#sec-properties-of-the-date-constructor">Properties of the Date Constructor</a></h1>

    <emu-clause id="sec-temporal-date.now">
      <h1><a href="https://tc39.es/ecma262/#sec-date.now">Date.now ( )</a></h1>
      <del class="block">
        <p>This function returns the time value designating the UTC date and time of the occurrence of the call to it.</p>
      </del>
      <ins class="block">
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return SystemUTCEpochMilliseconds().
        </emu-alg>
      </ins>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-properties-of-the-legacy-date-prototype-object">
    <h1><a href="https://tc39.es/ecma262/#sec-properties-of-the-date-prototype-object">Properties of the Date Prototype Object</a></h1>

    <ins class="block">
      <emu-clause id="sec-date.prototype.totemporalinstant">
        <h1>Date.prototype.toTemporalInstant ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _t_ be ? thisTimeValue(*this* value).
          1. Let _ns_ be ? NumberToBigInt(_t_) &times; ℤ(10<sup>6</sup>).
          1. Return ! CreateTemporalInstant(_ns_).
        </emu-alg>
      </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>
