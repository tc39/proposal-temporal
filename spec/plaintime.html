<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaintime-objects">
  <h1>Temporal.PlainTime Objects</h1>
  <p>A Temporal.PlainTime object is an immutable Object that contains integers corresponding to a particular hour, minute,
    second, millisecond, microsecond, and nanosecond.</p>

  <emu-clause id="sec-temporal-plaintime-constructor">
    <h1>The Temporal.PlainTime Constructor</h1>
    <p>
      The Temporal.PlainTime constructor is the <dfn>%Temporal.PlainTime%</dfn> intrinsic object.
      When called as a constructor, it creates and initializes a new Temporal.PlainTime object.
    </p>
    <p>
      The Temporal.PlainTime constructor is designed to be subclassable.
      It may be used as the value of an extends clause of a class definition.
      Subclass constructors that intend to inherit the specified Time behaviour must include a super call to the %Temporal.PlainTime% constructor to create and initialize subclass instances with the necessary internal slots.
    </p>

    <emu-clause id="sec-temporal.time">
      <h1>Temporal.PlainTime ( [ _hour_ [ , _minute_ [ , _second_ [ , _millisecond_ [ , _microsecond_ [ , _nanosecond_ ] ] ] ] ] ] )</h1>
      <p>
        When the `Temporal.PlainTime` function is called, the following steps are taken:
      </p>
      <emu-note>The value of ? ToInteger(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _hour_ be ? ToInteger(_hour_).
        1. Let _minute_ be ? ToInteger(_minute_).
        1. Let _second_ be ? ToInteger(_second_).
        1. Let _millisecond_ be ? ToInteger(_millisecond_).
        1. Let _microsecond_ be ? ToInteger(_microsecond_).
        1. Let _nanosecond_ be ? ToInteger(_nanosecond_).
        1. Return ? CreateTemporalTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaintime-constructor">
    <h1>Properties of the Temporal.PlainTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.PlainTime constructor is the intrinsic object
      %Function.prototype%.</p>
    <p>The Temporal.PlainTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal-plaintime-prototype">
      <h1>Temporal.PlainTime.prototype</h1>
      <p>The initial value of `Temporal.PlainTime.prototype` is %Temporal.PlainTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.time-@@species">
      <h1>get Temporal.PlainTime [ @@species ]</h1>
      <p>
        `Temporal.PlainTime[@@species]` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>

      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.time.from">
      <h1>Temporal.PlainTime.from ( _item_ [ , _options_ ] )</h1>
      <p>
        The `from` method takes two arguments, _item_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _constructor_ be the *this* value.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalTime]] internal slot, then
          1. Return ? CreateTemporalTimeFromStatic(_constructor_, _item_.[[Hour]], _item_.[[Minute]], _item_.[[Second]], _item_.[[Millisecond]], _item_.[[Microsecond]], _item_.[[Nanosecond]]).
        1. Return ? ToTemporalTime(_item_, _constructor_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.compare">
      <h1>Temporal.PlainTime.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalTime(_one_).
        1. Set _two_ to ? ToTemporalTime(_two_).
        1. Return ùîΩ(! CompareTemporalTime(_one_.[[Hour]], _one_.[[Minute]], _one_.[[Second]], _one_.[[Millisecond]], _one_.[[Microsecond]], _one_.[[Nanosecond]], _two_.[[Hour]], _two_.[[Minute]], _two_.[[Second]], _two_.[[Millisecond]], _two_.[[Microsecond]], _two_.[[Nanosecond]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaintime-prototype-object">
    <h1>Properties of the Temporal.PlainTime Prototype Object</h1>

    <p>The Temporal.PlainTime prototype object</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.PlainTime.prototype%</dfn>.
      <li>is itself an ordinary object.
      <li>is not a Temporal.PlainTime instance and does not have a [[InitializedTemporalTime]] internal slot.
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.
    </ul>

    <emu-clause id="sec-temporal.time.prototype.constructor">
      <h1>Temporal.PlainTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainTime.prototype.constructor` is %Temporal.PlainTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype-@@tostringtag">
      <h1>Temporal.PlainTime.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value `"Temporal.PlainTime"`.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.time.prototype.calendar">
      <h1>get Temporal.Time.prototype.calendar</h1>
      <p>
        `Temporal.Time.prototype.calendar` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return _temporalTime_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.time.prototype.hour">
      <h1>get Temporal.PlainTime.prototype.hour</h1>
      <p>
        `Temporal.PlainTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Hour]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.time.prototype.minute">
      <h1>get Temporal.PlainTime.prototype.minute</h1>
      <p>
        `Temporal.PlainTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Minute]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.time.prototype.second">
      <h1>get Temporal.PlainTime.prototype.second</h1>
      <p>
        `Temporal.PlainTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Second]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.time.prototype.millisecond">
      <h1>get Temporal.PlainTime.prototype.millisecond</h1>
      <p>
        `Temporal.PlainTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Millisecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.time.prototype.microsecond">
      <h1>get Temporal.PlainTime.prototype.microsecond</h1>
      <p>
        `Temporal.PlainTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Microsecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.time.prototype.nanosecond">
      <h1>get Temporal.PlainTime.prototype.nanosecond</h1>
      <p>
        `Temporal.PlainTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.add">
      <h1>Temporal.PlainTime.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `add` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Perform ? ToTemporalOverflow(_options_).
        1. Let _result_ be ? AddTime(_temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Return ? CreateTemporalTimeFromInstance(_temporalTime_, _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.subtract">
      <h1>Temporal.PlainTime.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `subtract` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Perform ? ToTemporalOverflow(_options_).
        1. Let _sign_ be ! DurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _result_ be ? AddTime(_temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]], ‚àí_duration_.[[Hours]], ‚àí_duration_.[[Minutes]], ‚àí_duration_.[[Seconds]], ‚àí_duration_.[[Milliseconds]], ‚àí_duration_.[[Microseconds]], ‚àí_duration_.[[Nanoseconds]]).
        1. Return ? CreateTemporalTimeFromInstance(_temporalTime_, _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.with">
      <h1>Temporal.PlainTime.prototype.with ( _temporalTimeLike_ [ , _options_ ] )</h1>
      <p>
        The `with` method takes two arguments, _temporalTimeLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. If Type(_temporalTimeLike_) is not Object, then
          1. Let _isoString_ be ? ToString(_temporalTimeLike_).
          1. Set _temporalTimeLike_ to ? RelevantTemporalObjectFromString(_isoString_).
        1. Let _partialTime_ be ? ToPartialTime(_temporalTimeLike_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. If _partialTime_.[[Hour]] is not *undefined*, then
          1. Let _hour_ be _partialTime_.[[Hour]].
        1. Else,
          1. Let _hour_ be _temporalTime_.[[Hour]].
        1. If _partialTime_.[[Minute]] is not *undefined*, then
          1. Let _minute_ be _partialTime_.[[Minute]].
        1. Else,
          1. Let _minute_ be _temporalTime_.[[Minute]].
        1. If _partialTime_.[[Second]] is not *undefined*, then
          1. Let _second_ be _partialTime_.[[Second]].
        1. Else,
          1. Let _second_ be _temporalTime_.[[Second]].
        1. If _partialTime_.[[Millisecond]] is not *undefined*, then
          1. Let _millisecond_ be _partialTime_.[[Millisecond]].
        1. Else,
          1. Let _millisecond_ be _temporalTime_.[[Millisecond]].
        1. If _partialTime_.[[Microsecond]] is not *undefined*, then
          1. Let _microsecond_ be _partialTime_.[[Microsecond]].
        1. Else,
          1. Let _microsecond_ be _temporalTime_.[[Microsecond]].
        1. If _partialTime_.[[Nanosecond]] is not *undefined*, then
          1. Let _nanosecond_ be _partialTime_.[[Nanosecond]].
        1. Else,
          1. Let _nanosecond_ be _temporalTime_.[[Nanosecond]].
        1. Let _result_ be ? RegulateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _overflow_).
        1. Return ? CreateTemporalTimeFromInstance(_temporalTime_, _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.until">
      <h1>Temporal.PlainTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        The `until` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _other_ to ? ToTemporalTime(_other_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª, *"nanoseconds"*).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª, *"hours"*).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. Let _result_ be ! DifferenceTime(_temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]], _other_.[[Hour]], _other_.[[Minute]], _other_.[[Second]], _other_.[[Millisecond]], _other_.[[Microsecond]], _other_.[[Nanosecond]]).
        1. Set _result_ to ? RoundDuration(0, 0, 0, 0, _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Set _result_ to ! BalanceDuration(0, _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]], _largestUnit_).
        1. Return ? CreateTemporalDuration(0, 0, 0, 0, _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.since">
      <h1>Temporal.PlainTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        The `since` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _other_ to ? ToTemporalTime(_other_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª, *"nanoseconds"*).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª, *"hours"*).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. Set _roundingMode_ to ! NegateTemporalRoundingMode(_roundingMode_).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. Let _result_ be ! DifferenceTime(_other_.[[Hour]], _other_.[[Minute]], _other_.[[Second]], _other_.[[Millisecond]], _other_.[[Microsecond]], _other_.[[Nanosecond]], _temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]]).
        1. Set _result_ to ? RoundDuration(0, 0, 0, 0, ‚àí_result_.[[Hours]], ‚àí_result_.[[Minutes]], ‚àí_result_.[[Seconds]], ‚àí_result_.[[Milliseconds]], ‚àí_result_.[[Microseconds]], ‚àí_result_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Set _result_ to ! BalanceDuration(0, ‚àí_result_.[[Hours]], ‚àí_result_.[[Minutes]], ‚àí_result_.[[Seconds]], ‚àí_result_.[[Milliseconds]], ‚àí_result_.[[Microseconds]], ‚àí_result_.[[Nanoseconds]], _largestUnit_).
        1. Return ? CreateTemporalDuration(0, 0, 0, 0, _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.round">
      <h1>Temporal.PlainTime.prototype.round ( _options_ )</h1>
      <p>
        The `round` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. If _options_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, ¬´ *"day"* ¬ª).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. If _smallestUnit_ is *"hour"*, then
          1. Let _maximum_ be 24.
        1. Else if _smallestUnit_ is *"minute"* or *"second"*, then
          1. Let _maximum_ be 60.
        1. Else,
          1. Let _maximum_ be 1000.
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. Let _result_ be ? RoundTime(_temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Return ? CreateTemporalTimeFromInstance(_temporalTime_, _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.equals">
      <h1>Temporal.PlainTime.prototype.equals ( _other_ )</h1>
      <p>
        The `equals` method takes one argument _other_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _other_ to ? ToTemporalTime(_other_).
        1. If _temporalTime_.[[Hour]] ‚â† _other_.[[Hour]], return *false*.
        1. If _temporalTime_.[[Minute]] ‚â† _other_.[[Minute]], return *false*.
        1. If _temporalTime_.[[Second]] ‚â† _other_.[[Second]], return *false*.
        1. If _temporalTime_.[[Millisecond]] ‚â† _other_.[[Millisecond]], return *false*.
        1. If _temporalTime_.[[Microsecond]] ‚â† _other_.[[Microsecond]], return *false*.
        1. If _temporalTime_.[[Nanosecond]] ‚â† _other_.[[Nanosecond]], return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.toplaindatetime">
      <h1>Temporal.PlainTime.prototype.toPlainDateTime ( _temporalDate_ )</h1>
      <p>
        The `toPlainDateTime` method takes one argument _temporalDate_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _temporalDate_ to ? ToTemporalDate(_temporalDate_).
        1. Return ? CreateTemporalDateTime(_temporalDate_.[[Year]], _temporalDate_.[[Month]], _temporalDate_.[[Day]],
          _temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]],
          _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]],
          _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.tozoneddatetime">
      <h1>Temporal.PlainTime.prototype.toZonedDateTime ( _item_ )</h1>
      <p>
        The `toZonedDateTime` method takes one argument _item_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Let _temporalDateLike_ be ? Get(_item_, *"date"*).
        1. If _temporalDateLike_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _temporalDate_ to ? ToTemporalTime(_temporalDateLike_).
        1. Let _temporalTimeZoneLike_ be ? Get(_item_, *"timeZone"*).
        1. If _temporalTimeZoneLike_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _timeZone_ be ? ToTemporalTimeZone(_temporalTimeZoneLike_).
        1. Let _temporalDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]], _temporalDate_.[[Calendar]]).
        1. Let _instant_ be ? GetTemporalInstantFor(_timeZone_, _temporalDateTime_, *"compatible"*).
        1. Return ? CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.getfields">
      <h1>Temporal.PlainTime.prototype.getFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Let _record_ be ? ToPartialTime(_temporalTime_).
        1. Let _fields_ be ? ObjectCreate(%ObjectPrototype%).
        1. For each row of <emu-xref href="#table-temporal-temporaltimelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _p_ be the Property value of the current row.
          1. Let _v_ be the value of _record_'s field whose name is the Internal Slot value of the current row.
          1. Perform ! CreateDataPropertyOrThrow(_fields_, _p_, _v_).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.tostring">
      <h1>Temporal.PlainTime.prototype.toString ( [ _options_ ] )</h1>
      <p>
        The `toString` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _precision_ be ? ToSecondsStringPrecision(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _showCalendar_ be ? ToShowCalendarOption(_options_).
        1. Let _roundResult_ be ? RoundTime(_temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]], _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. Return ? TemporalTimeToString(_roundResult_.[[Hour]], _roundResult_.[[Minute]], _roundResult_.[[Second]], _roundResult_.[[Millisecond]], _roundResult_.[[Microsecond]], _roundResult_.[[Nanosecond]], _temporalTime_.[[Calendar]], _precision_.[[Precision]], _showCalendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.tolocalestring">
      <h1>Temporal.PlainTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. If the implementation does not include the ECMA-402 Internationalization API, then
          1. Return ? TemporalTimeToString(_temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]], _temporalTime_.[[Calendar]], *"auto"*, *"auto"*).
        1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, ¬´ _locales_, _options_ ¬ª).
        1. Return ? FormatDateTime(_dateFormat_, _temporalTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.tojson">
      <h1>Temporal.PlainTime.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? TemporalTimeToString(_temporalTime_.[[Hour]], _temporalTime_.[[Minute]], _temporalTime_.[[Second]], _temporalTime_.[[Millisecond]], _temporalTime_.[[Microsecond]], _temporalTime_.[[Nanosecond]], _temporalTime_.[[Calendar]], *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.time.prototype.valueof">
      <h1>Temporal.PlainTime.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaintime-instances">
    <h1>Properties of Temporal.PlainTime Instances</h1>
    <p>
      Temporal.PlainTime instances are ordinary objects that inherit properties from the %Temporal.PlainTime.prototype% intrinsic object.
      Temporal.PlainTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaltime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaltime-instances" caption="Internal Slots of Temporal.PlainTime Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalTime]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.PlainTime instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[Hour]]
            </td>
            <td>
              An integer between 0 and 23, inclusive, representing the hour of the day.
            </td>
          </tr>
          <tr>
            <td>
              [[Minute]]
            </td>
            <td>
              An integer between 0 and 59, inclusive, representing the minute of the hour.
            </td>
          </tr>
          <tr>
            <td>
              [[Second]]
            </td>
            <td>
              An integer between 0 and 59, inclusive, representing the second within the minute.
            </td>
          </tr>
          <tr>
            <td>
              [[Millisecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the millisecond within the second.
            </td>
          </tr>
          <tr>
            <td>
              [[Microsecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the microsecond within the millisecond.
            </td>
          </tr>
          <tr>
            <td>
              [[Nanosecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the nanosecond within the microsecond.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaintime-abstract-ops">
    <h1>Abstract operations</h1>

    <emu-clause id="sec-temporal-differencetime" aoid="DifferenceTime">
      <h1>DifferenceTime ( _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_ )</h1>
      <emu-alg>
        1. Let _hours_ be _h2_ ‚àí _h1_.
        1. Let _minutes_ be _min2_ ‚àí _min1_.
        1. Let _seconds_ be _s2_ ‚àí _s1_.
        1. Let _milliseconds_ be _ms2_ ‚àí _ms1_.
        1. Let _microseconds_ be _mus2_ ‚àí _mus1_.
        1. Let _nanoseconds_ be _ns2_ ‚àí _ns1_.
        1. Let _sign_ be ! DurationSign(0, 0, 0, 0, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Let _bt_ be ? BalanceTime(_hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Return the new Record {
          [[Days]]: _bt_.[[Days]] √ó _sign_,
          [[Hours]]: _bt_.[[Hour]] √ó _sign_,
          [[Minutes]]: _bt_.[[Minute]] √ó _sign_,
          [[Seconds]]: _bt_.[[Second]] √ó _sign_,
          [[Milliseconds]]: _bt_.[[Millisecond]] √ó _sign_,
          [[Microseconds]]: _bt_.[[Microsecond]] √ó _sign_,
          [[Nanoseconds]]: _bt_.[[Nanosecond]] √ó _sign_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltime" aoid="ToTemporalTime">
      <h1>ToTemporalTime ( _item_ [ , _constructor_ [ , _overflow_ ] ] )</h1>
      <p>
        The abstract operation ToTemporalTime returns its argument _item_ if it is already a Temporal.PlainTime instance, converts _item_ to a new Temporal.PlainTime instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _constructor_ is not given, set it to %Temporal.PlainTime%.
        1. If _overflow_ is not given, set it to *"constrain"*.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalTime]] internal slot, then
            1. Return _item_.
          1. Let _result_ be ? ToTemporalTimeRecord(_item_).
        1. Else,
          1. Let _string_ be ? ToString(_item_).
          1. Let _result_ be ? ParseTemporalTimeString(_string_).
        1. Set _result_ to ? RegulateTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _overflow_).
        1. Return ? CreateTemporalTimeFromStatic(_constructor_, _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-topartialtime" aoid="ToPartialTime">
      <h1>ToPartialTime ( _temporalTimeLike_ )</h1>
      <emu-alg>
        1. If Type(_temporalTimeLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be the new Record {
          [[Hour]]: *undefined*,
          [[Minute]]: *undefined*,
          [[Second]]: *undefined*,
          [[Millisecond]]: *undefined*,
          [[Microsecond]]: *undefined*,
          [[Nanosecond]]: *undefined*
          }.
        1. Let _any_ be *false*.
        1. For each row of <emu-xref href="#table-temporal-temporaltimelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalTimeLike_, _property_).
          1. If _value_ is not *undefined*, then
            1. Set _any_ to *true*.
            1. Set _value_ to ? ToInteger(_value_).
            1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
        1. If _any_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>

      <emu-table id="table-temporal-temporaltimelike-properties">
        <emu-caption>Properties of a TemporalTimeLike</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[[Hour]]</td>
              <td>`"hour"`</td>
            </tr>

            <tr>
              <td>[[Microsecond]]</td>
              <td>`"microsecond"`</td>
            </tr>

            <tr>
              <td>[[Millisecond]]</td>
              <td>`"millisecond"`</td>
            </tr>

            <tr>
              <td>[[Minute]]</td>
              <td>`"minute"`</td>
            </tr>

            <tr>
              <td>[[Nanosecond]]</td>
              <td>`"nanosecond"`</td>
            </tr>

            <tr>
              <td>[[Second]]</td>
              <td>`"second"`</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-regulatetime" aoid="RegulateTime">
      <h1>RegulateTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If _overflow_ is *"constrain"*, then
          1. Return ! ConstrainTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. If _overflow_ is *"reject"*, then
          1. If ! ValidateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
            1. Throw a *RangeError* exception.
          1. Return the new Record {
            [[Days]]: 0,
            [[Hour]]: _hour_,
            [[Minute]]: _minute_,
            [[Second]]: _second_,
            [[Millisecond]]: _millisecond_,
            [[Microsecond]]: _microsecond_,
            [[Nanosecond]]: _nanosecond_
            }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-validatetime" aoid="ValidateTime">
      <h1>ValidateTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integers.
        1. If _hour_ &lt; 0 or _hour_ &gt; 23, then
          1. Return *false*.
        1. If _minute_ &lt; 0 or _minute_ &gt; 59, then
          1. Return *false*.
        1. If _second_ &lt; 0 or _second_ &gt; 59, then
          1. Return *false*.
        1. If _millisecond_ &lt; 0 or _millisecond_ &gt; 999, then
          1. Return *false*.
        1. If _microsecond_ &lt; 0 or _microsecond_ &gt; 999, then
          1. Return *false*.
        1. If _nanosecond_ &lt; 0 or _nanosecond_ &gt; 999, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancetime" aoid="BalanceTime">
      <h1>BalanceTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integers.
        1. If _hour_ is *+‚àû* or *‚àí‚àû*, or _minute_ is *+‚àû* or *‚àí‚àû*, or _second_ is *+‚àû* or *‚àí‚àû*, or _millisecond_ is *+‚àû* or *‚àí‚àû*, or _microsecond_ is *+‚àû* or *‚àí‚àû*, or _nanosecond_ is *+‚àû* or *‚àí‚àû*, then
          1. Throw a *RangeError* exception.
        1. Set _microsecond_ to _microsecond_ + floor(_nanosecond_ / 1000).
        1. Set _nanosecond_ to ! NonNegativeModulo(_nanosecond_, 1000).
        1. Set _millisecond_ to _millisecond_ + floor(_microsecond_ / 1000).
        1. Set _microsecond_ to ! NonNegativeModulo(_microsecond_, 1000).
        1. Set _second_ to _second_ + floor(_millisecond_ / 1000).
        1. Set _millisecond_ to ! NonNegativeModulo(_millisecond_, 1000).
        1. Set _minute_ to _minute_ + floor(_second_ / 60).
        1. Set _second_ to ! NonNegativeModulo(_second_, 60).
        1. Set _hour_ to _hour_ + floor(_minute_ / 60).
        1. Set _minute_ to ! NonNegativeModulo(_minute_, 60).
        1. Let _days_ be floor(_hour_ / 24).
        1. Set _hour_ to ! NonNegativeModulo(_hour_, 24).
        1. Return the new Record {
          [[Days]]: _days_,
          [[Hour]]: _hour_,
          [[Minute]]: _minute_,
          [[Second]]: _second_,
          [[Millisecond]]: _millisecond_,
          [[Microsecond]]: _microsecond_,
          [[Nanosecond]]: _nanosecond_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-constraintime" aoid="ConstrainTime">
      <h1>ConstrainTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integers.
        1. Set _hour_ to ! ConstrainToRange(_hour_, 0, 23).
        1. Set _minute_ to ! ConstrainToRange(_minute_, 0, 59).
        1. Set _second_ to ! ConstrainToRange(_second_, 0, 59).
        1. Set _millisecond_ to ! ConstrainToRange(_millisecond_, 0, 999).
        1. Set _microsecond_ to ! ConstrainToRange(_microsecond_, 0, 999).
        1. Set _nanosecond_ to ! ConstrainToRange(_nanosecond_, 0, 999).
        1. Return the Record {
          [[Hour]]: _hour_,
          [[Minute]]: _minute_,
          [[Second]]: _second_,
          [[Millisecond]]: _millisecond_,
          [[Microsecond]]: _microsecond_,
          [[Nanosecond]]: _nanosecond_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaltime" aoid="CreateTemporalTime">
      <h1>CreateTemporalTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. If ! ValidateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
          1. Throw a *RangeError* exception.
        1. If _newTarget_ is not given, set it to %Temporal.PlainTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%Temporal.PlainTime.prototype%"`, ¬´ [[InitializedTemporalTime]], [[Hour]], [[Minute]], [[Second]], [[Millisecond]], [[Microsecond]], [[Nanosecond]] ¬ª).
        1. Set _object_.[[Hour]] to _hour_.
        1. Set _object_.[[Minute]] to _minute_.
        1. Set _object_.[[Second]] to _second_.
        1. Set _object_.[[Millisecond]] to _millisecond_.
        1. Set _object_.[[Microsecond]] to _microsecond_.
        1. Set _object_.[[Nanosecond]] to _nanosecond_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaltimefrominstance" aoid="CreateTemporalTimeFromInstance">
      <h1>CreateTemporalTimeFromInstance ( _temporalTime_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: Type(_temporalTime_) is Object and _temporalTime_ has an [[InitializedTemporalTime]] internal slot.
        1. Assert: ! ValidateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _constructor_ be ? SpeciesConstructor(_temporalTime_, %Temporal.PlainTime%).
        1. Let _result_ be ? Construct(_constructor_, ¬´ _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalTime]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaltimefromstatic" aoid="CreateTemporalTimeFromStatic">
      <h1>CreateTemporalTimeFromStatic ( _constructor_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: ! ValidateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. If ! IsConstructor(_constructor_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? Construct(_constructor_, ¬´ _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalTime]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltimerecord" aoid="ToTemporalTimeRecord">
      <h1>ToTemporalTimeRecord ( _temporalTimeLike_ )</h1>
      <emu-note>The value of ? ToInteger(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. Assert: Type(_temporalTimeLike_) is Object.
        1. If _temporalTimeLike_ has an [[InitializedTemporalTime]] internal slot, then
          1. Return the Record {
              [[Hour]]: _temporalTimeLike_.[[Hour]],
              [[Minute]]: _temporalTimeLike_.[[Minute]],
              [[Second]]: _temporalTimeLike_.[[Second]],
              [[Millisecond]]: _temporalTimeLike_.[[Millisecond]],
              [[Microsecond]]: _temporalTimeLike_.[[Microsecond]],
              [[Nanosecond]]: _temporalTimeLike_.[[Nanosecond]]
            }.
        1. Let _result_ be a new Record with all the internal slots given in the Internal Slot column in <emu-xref href="#table-temporal-temporaltimelike-properties"></emu-xref>.
        1. Let _any_ be *false*.
        1. For each row of <emu-xref href="#table-temporal-temporaltimelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalTimeLike_, _property_).
          1. If _value_ is not *undefined*, then
            1. Set _any_ to *true*.
          1. Let _value_ be ? ToInteger(_value_).
          1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
        1. If _any_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaltimetostring" aoid="TemporalTimeToString">
      <h1>TemporalTimeToString ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_, _precision_, _showCalendar_ )</h1>
      <emu-alg>
        1. Let _hour_ be _hour_ formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _hour_ be _minute_ formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _seconds_ be ! FormatSecondsStringPart(_second_, _millisecond_, _microsecond_, _nanosecond_, _precision_).
        1. Let _calendarString_ be ? FormatCalendarAnnotation(_calendar_, _showCalendar_).
        1. Return the string-concatenation of _hour_, the code unit 0x003A (COLON), _minute_, _seconds_, and _calendarString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetemporaltime" aoid="CompareTemporalTime">
      <h1>CompareTemporalTime ( _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_ )</h1>
      <emu-alg>
        1. If _h1_ &gt; _h2_, return 1.
        1. If _h1_ &lt; _h2_, return -1.
        1. If _min1_ &gt; _min2_, return 1.
        1. If _min1_ &lt; _min2_, return -1.
        1. If _s1_ &gt; _s2_, return 1.
        1. If _s1_ &lt; _s2_, return -1.
        1. If _ms1_ &gt; _ms2_, return 1.
        1. If _ms1_ &lt; _ms2_, return -1.
        1. If _mus1_ &gt; _mus2_, return 1.
        1. If _mus1_ &lt; _mus2_, return -1.
        1. If _ns1_ &gt; _ns2_, return 1.
        1. If _ns1_ &lt; _ns2_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addtime" aoid="AddTime">
      <h1>AddTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ are integers.
        1. Let _hour_ be _hour_ + _hours_.
        1. Let _minute_ be _minute_ + _minutes_.
        1. Let _second_ be _second_ + _seconds_.
        1. Let _millisecond_ be _millisecond_ + _milliseconds_.
        1. Let _microsecond_ be _microsecond_ + _microseconds_.
        1. Let _nanosecond_ be _nanosecond_ + _nanoseconds_.
        1. Return ? BalanceTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundtime" aoid="RoundTime">
      <h1>RoundTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _increment_, _unit_, _roundingMode_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, and _increment_ are integers.
        1. Let _fractionalSecond_ be _nanosecond_ √ó 10<sup>‚àí9</sup> + _microsecond_ √ó 10<sup>‚àí6</sup> + _millisecond_ √ó 10<sup>‚àí3</sup> + _second_.
        1. If _unit_ is *"day"*, then
          1. Let _quantity_ be ((_fractionalSecond_ / 60 + _minute_) / 60 + _hour_) / 24.
        1. Else if _unit_ is *"hour"*, then
          1. Let _quantity_ be (_fractionalSecond_ / 60 + _minute_) / 60 + _hour_.
        1. Else if _unit_ is *"minute"*, then
          1. Let _quantity_ be _fractionalSecond_ / 60 + _minute_.
        1. Else if _unit_ is *"second"*, then
          1. Let _quantity_ be _fractionalSecond_.
        1. Else if _unit_ is *"millisecond"*, then
          1. Let _quantity_ be _nanosecond_ √ó 10<sup>‚àí6</sup> + _microsecond_ √ó 10<sup>‚àí3</sup> + _millisecond_.
        1. Else if _unit_ is *"microsecond"*, then
          1. Let _quantity_ be _nanosecond_ √ó 10<sup>‚àí3</sup> + _microsecond_.
        1. Else,
          1. Assert: _unit_ is *"nanosecond"*.
          1. Let _quantity_ be _nanosecond_.
        1. Let _result_ be ! RoundNumberToIncrement(_quantity_, _increment_, _roundingMode_).
        1. If _unit_ is *"day"*, then
          1. Return the new Record {
            [[Days]]: _result_,
            [[Hour]]: 0,
            [[Minute]]: 0,
            [[Second]]: 0,
            [[Millisecond]]: 0,
            [[Microsecond]]: 0,
            [[Nanosecond]]: 0
          }.
        1. If _unit_ is *"hour"*, then
          1. Return ? BalanceTime(_result_, 0, 0, 0, 0, 0).
        1. If _unit_ is *"minute"*, then
          1. Return ? BalanceTime(_hour_, _result_, 0, 0, 0, 0).
        1. If _unit_ is *"second"*, then
          1. Return ? BalanceTime(_hour_, _minute_, _result_, 0, 0, 0).
        1. If _unit_ is *"millisecond"*, then
          1. Return ? BalanceTime(_hour_, _minute_, _second_, _result_, 0, 0).
        1. If _unit_ is *"microsecond"*, then
          1. Return ? BalanceTime(_hour_, _minute_, _second_, _millisecond_, _result_, 0).
        1. Assert: _unit_ is *"nanosecond"*.
        1. Return ? BalanceTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _result_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
