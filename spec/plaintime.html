<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaintime-objects">
  <h1>Temporal.PlainTime Objects</h1>
  <p>A Temporal.PlainTime object is an Object that contains integers corresponding to a particular hour, minute,
    second, millisecond, microsecond, and nanosecond.</p>

  <emu-clause id="sec-temporal-plaintime-constructor">
    <h1>The Temporal.PlainTime Constructor</h1>
    <p>The Temporal.PlainTime constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.PlainTime object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.PlainTime behaviour must
        include a super call to the %Temporal.PlainTime% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.plaintime">
      <h1>Temporal.PlainTime ( [ _hour_ [ , _minute_ [ , _second_ [ , _millisecond_ [ , _microsecond_ [ , _nanosecond_ ] ] ] ] ] ] )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If _hour_ is *undefined*, set _hour_ to 0; else set _hour_ to ? ToIntegerWithTruncation(_hour_).
        1. If _minute_ is *undefined*, set _minute_ to 0; else set _minute_ to ? ToIntegerWithTruncation(_minute_).
        1. If _second_ is *undefined*, set _second_ to 0; else set _second_ to ? ToIntegerWithTruncation(_second_).
        1. If _millisecond_ is *undefined*, set _millisecond_ to 0; else set _millisecond_ to ? ToIntegerWithTruncation(_millisecond_).
        1. If _microsecond_ is *undefined*, set _microsecond_ to 0; else set _microsecond_ to ? ToIntegerWithTruncation(_microsecond_).
        1. If _nanosecond_ is *undefined*, set _nanosecond_ to 0; else set _nanosecond_ to ? ToIntegerWithTruncation(_nanosecond_).
        1. Return ? CreateTemporalTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaintime-constructor">
    <h1>Properties of the Temporal.PlainTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.PlainTime constructor is the intrinsic object
      %Function.prototype%.</p>
    <p>The Temporal.PlainTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal.plaintime.prototype">
      <h1>Temporal.PlainTime.prototype</h1>
      <p>The initial value of `Temporal.PlainTime.prototype` is %Temporal.PlainTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.from">
      <h1>Temporal.PlainTime.from ( _item_ [ , _options_ ] )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalTime]] internal slot, then
          1. Return ! CreateTemporalTime(_item_.[[ISOHour]], _item_.[[ISOMinute]], _item_.[[ISOSecond]], _item_.[[ISOMillisecond]], _item_.[[ISOMicrosecond]], _item_.[[ISONanosecond]]).
        1. Return ? ToTemporalTime(_item_, _overflow_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.compare">
      <h1>Temporal.PlainTime.compare ( _one_, _two_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalTime(_one_).
        1. Set _two_ to ? ToTemporalTime(_two_).
        1. Return ùîΩ(! CompareTemporalTime(_one_.[[ISOHour]], _one_.[[ISOMinute]], _one_.[[ISOSecond]], _one_.[[ISOMillisecond]], _one_.[[ISOMicrosecond]], _one_.[[ISONanosecond]], _two_.[[ISOHour]], _two_.[[ISOMinute]], _two_.[[ISOSecond]], _two_.[[ISOMillisecond]], _two_.[[ISOMicrosecond]], _two_.[[ISONanosecond]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaintime-prototype-object">
    <h1>Properties of the Temporal.PlainTime Prototype Object</h1>

    <p>The Temporal.PlainTime prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.PlainTime instance and does not have a [[InitializedTemporalTime]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.plaintime.prototype.constructor">
      <h1>Temporal.PlainTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainTime.prototype.constructor` is %Temporal.PlainTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype-@@tostringtag">
      <h1>Temporal.PlainTime.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.PlainTime"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.hour">
      <h1>get Temporal.PlainTime.prototype.hour</h1>
      <p>
        `Temporal.PlainTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[ISOHour]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.minute">
      <h1>get Temporal.PlainTime.prototype.minute</h1>
      <p>
        `Temporal.PlainTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[ISOMinute]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.second">
      <h1>get Temporal.PlainTime.prototype.second</h1>
      <p>
        `Temporal.PlainTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[ISOSecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.millisecond">
      <h1>get Temporal.PlainTime.prototype.millisecond</h1>
      <p>
        `Temporal.PlainTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[ISOMillisecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.microsecond">
      <h1>get Temporal.PlainTime.prototype.microsecond</h1>
      <p>
        `Temporal.PlainTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[ISOMicrosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.nanosecond">
      <h1>get Temporal.PlainTime.prototype.nanosecond</h1>
      <p>
        `Temporal.PlainTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.add">
      <h1>Temporal.PlainTime.prototype.add ( _temporalDurationLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? AddDurationToOrSubtractDurationFromPlainTime(~add~, _temporalTime_, _temporalDurationLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.subtract">
      <h1>Temporal.PlainTime.prototype.subtract ( _temporalDurationLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? AddDurationToOrSubtractDurationFromPlainTime(~subtract~, _temporalTime_, _temporalDurationLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.with">
      <h1>Temporal.PlainTime.prototype.with ( _temporalTimeLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. If Type(_temporalTimeLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Perform ? RejectTemporalObject(_temporalTimeLike_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? ToTemporalOverflow(_options_).
        1. Let _partialTime_ be ? ToTemporalTimeRecord(_temporalTimeLike_, ~partial~).
        1. If _partialTime_.[[Hour]] is not *undefined*, then
          1. Let _hour_ be _partialTime_.[[Hour]].
        1. Else,
          1. Let _hour_ be _temporalTime_.[[ISOHour]].
        1. If _partialTime_.[[Minute]] is not *undefined*, then
          1. Let _minute_ be _partialTime_.[[Minute]].
        1. Else,
          1. Let _minute_ be _temporalTime_.[[ISOMinute]].
        1. If _partialTime_.[[Second]] is not *undefined*, then
          1. Let _second_ be _partialTime_.[[Second]].
        1. Else,
          1. Let _second_ be _temporalTime_.[[ISOSecond]].
        1. If _partialTime_.[[Millisecond]] is not *undefined*, then
          1. Let _millisecond_ be _partialTime_.[[Millisecond]].
        1. Else,
          1. Let _millisecond_ be _temporalTime_.[[ISOMillisecond]].
        1. If _partialTime_.[[Microsecond]] is not *undefined*, then
          1. Let _microsecond_ be _partialTime_.[[Microsecond]].
        1. Else,
          1. Let _microsecond_ be _temporalTime_.[[ISOMicrosecond]].
        1. If _partialTime_.[[Nanosecond]] is not *undefined*, then
          1. Let _nanosecond_ be _partialTime_.[[Nanosecond]].
        1. Else,
          1. Let _nanosecond_ be _temporalTime_.[[ISONanosecond]].
        1. Let _result_ be ? RegulateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _overflow_).
        1. Return ! CreateTemporalTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.until">
      <h1>Temporal.PlainTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? DifferenceTemporalPlainTime(~until~, _temporalTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.since">
      <h1>Temporal.PlainTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? DifferenceTemporalPlainTime(~since~, _temporalTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.round">
      <h1>Temporal.PlainTime.prototype.round ( _roundTo_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. If _roundTo_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If Type(_roundTo_) is String, then
          1. Let _paramString_ be _roundTo_.
          1. Set _roundTo_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_roundTo_, *"smallestUnit"*, _paramString_).
        1. Else,
          1. Set _roundTo_ to ? GetOptionsObject(_roundTo_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalRoundingIncrement reads *"roundingIncrement"* and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_roundTo_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_roundTo_, *"halfExpand"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_roundTo_, *"smallestUnit"*, ~time~, ~required~).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Assert: _maximum_ is not *undefined*.
        1. Perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, *false*).
        1. Let _result_ be ! RoundTime(_temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Return ! CreateTemporalTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.equals">
      <h1>Temporal.PlainTime.prototype.equals ( _other_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _other_ to ? ToTemporalTime(_other_).
        1. If _temporalTime_.[[ISOHour]] &ne; _other_.[[ISOHour]], return *false*.
        1. If _temporalTime_.[[ISOMinute]] &ne; _other_.[[ISOMinute]], return *false*.
        1. If _temporalTime_.[[ISOSecond]] &ne; _other_.[[ISOSecond]], return *false*.
        1. If _temporalTime_.[[ISOMillisecond]] &ne; _other_.[[ISOMillisecond]], return *false*.
        1. If _temporalTime_.[[ISOMicrosecond]] &ne; _other_.[[ISOMicrosecond]], return *false*.
        1. If _temporalTime_.[[ISONanosecond]] &ne; _other_.[[ISONanosecond]], return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.toplaindatetime">
      <h1>Temporal.PlainTime.prototype.toPlainDateTime ( _temporalDate_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _temporalDate_ to ? ToTemporalDate(_temporalDate_).
        1. Return ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]],
          _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]],
          _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]],
          _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.tozoneddatetime">
      <h1>Temporal.PlainTime.prototype.toZonedDateTime ( _item_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. If Type(_item_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _temporalDateLike_ be ? Get(_item_, *"plainDate"*).
        1. If _temporalDateLike_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _temporalDate_ be ? ToTemporalDate(_temporalDateLike_).
        1. Let _temporalTimeZoneLike_ be ? Get(_item_, *"timeZone"*).
        1. If _temporalTimeZoneLike_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _timeZone_ be ? ToTemporalTimeZoneSlotValue(_temporalTimeZoneLike_).
        1. Let _temporalDateTime_ be ? CreateTemporalDateTime(_temporalDate_.[[ISOYear]], _temporalDate_.[[ISOMonth]], _temporalDate_.[[ISODay]], _temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], _temporalDate_.[[Calendar]]).
        1. Let _instant_ be ? GetInstantFor(_timeZone_, _temporalDateTime_, *"compatible"*).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _temporalDate_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.getisofields">
      <h1>Temporal.PlainTime.prototype.getISOFields ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Let _fields_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoHour"*, ùîΩ(_temporalTime_.[[ISOHour]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMicrosecond"*, ùîΩ(_temporalTime_.[[ISOMicrosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMillisecond"*, ùîΩ(_temporalTime_.[[ISOMillisecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMinute"*, ùîΩ(_temporalTime_.[[ISOMinute]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoNanosecond"*, ùîΩ(_temporalTime_.[[ISONanosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoSecond"*, ùîΩ(_temporalTime_.[[ISOSecond]])).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.tostring">
      <h1>Temporal.PlainTime.prototype.toString ( [ _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToFractionalSecondDigits reads *"fractionalSecondDigits"* and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _digits_ be ? ToFractionalSecondDigits(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_options_, *"smallestUnit"*, ~time~, *undefined*).
        1. If _smallestUnit_ is *"hour"*, throw a *RangeError* exception.
        1. Let _precision_ be ToSecondsStringPrecisionRecord(_smallestUnit_, _digits_).
        1. Let _roundResult_ be ! RoundTime(_temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. Return ! TemporalTimeToString(_roundResult_.[[Hour]], _roundResult_.[[Minute]], _roundResult_.[[Second]], _roundResult_.[[Millisecond]], _roundResult_.[[Microsecond]], _roundResult_.[[Nanosecond]], _precision_.[[Precision]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.tolocalestring">
      <h1>Temporal.PlainTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>
        The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
      </p>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ! TemporalTimeToString(_temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.tojson">
      <h1>Temporal.PlainTime.prototype.toJSON ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ! TemporalTimeToString(_temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.valueof">
      <h1>Temporal.PlainTime.prototype.valueOf ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaintime-instances">
    <h1>Properties of Temporal.PlainTime Instances</h1>
    <p>
      Temporal.PlainTime instances are ordinary objects that inherit properties from the %Temporal.PlainTime.prototype% intrinsic object.
      Temporal.PlainTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaltime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaltime-instances" caption="Internal Slots of Temporal.PlainTime Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalTime]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.PlainTime instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOHour]]
            </td>
            <td>
              An integer between 0 and 23, inclusive, representing the hour of the day.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMinute]]
            </td>
            <td>
              An integer between 0 and 59, inclusive, representing the minute of the hour.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOSecond]]
            </td>
            <td>
              An integer between 0 and 59, inclusive, representing the second within the minute.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMillisecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the millisecond within the second.
            </td>
          </tr>
          <tr>
            <td>
              [[ISOMicrosecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the microsecond within the millisecond.
            </td>
          </tr>
          <tr>
            <td>
              [[ISONanosecond]]
            </td>
            <td>
              An integer between 0 and 999, inclusive, representing the nanosecond within the microsecond.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaintime-abstract-ops">
    <h1>Abstract operations</h1>

    <emu-clause id="sec-temporal-differencetime" type="abstract operation">
      <h1>
        DifferenceTime (
          _h1_: an integer between 0 and 23 inclusive,
          _min1_: an integer between 0 and 59 inclusive,
          _s1_: an integer between 0 and 59 inclusive,
          _ms1_: an integer between 0 and 999 inclusive,
          _mus1_: an integer between 0 and 999 inclusive,
          _ns1_: an integer between 0 and 999 inclusive,
          _h2_: an integer between 0 and 23 inclusive,
          _min2_: an integer between 0 and 59 inclusive,
          _s2_: an integer between 0 and 59 inclusive,
          _ms2_: an integer between 0 and 999 inclusive,
          _mus2_: an integer between 0 and 999 inclusive,
          _ns2_: an integer between 0 and 999 inclusive,
        )
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns a Time Duration Record with the elapsed duration from a first wall-clock time, until a second wall-clock time.</dd>
      </dl>
      <emu-alg>
        1. Let _hours_ be _h2_ - _h1_.
        1. Let _minutes_ be _min2_ - _min1_.
        1. Let _seconds_ be _s2_ - _s1_.
        1. Let _milliseconds_ be _ms2_ - _ms1_.
        1. Let _microseconds_ be _mus2_ - _mus1_.
        1. Let _nanoseconds_ be _ns2_ - _ns1_.
        1. Let _sign_ be ! DurationSign(0, 0, 0, 0, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Let _bt_ be ! BalanceTime(_hours_ &times; _sign_, _minutes_ &times; _sign_, _seconds_ &times; _sign_, _milliseconds_ &times; _sign_, _microseconds_ &times; _sign_, _nanoseconds_ &times; _sign_).
        1. Assert: _bt_.[[Days]] is 0.
        1. Return ! CreateTimeDurationRecord(0, _bt_.[[Hour]] &times; _sign_, _bt_.[[Minute]] &times; _sign_, _bt_.[[Second]] &times; _sign_, _bt_.[[Millisecond]] &times; _sign_, _bt_.[[Microsecond]] &times; _sign_, _bt_.[[Nanosecond]] &times; _sign_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltime" aoid="ToTemporalTime">
      <h1>ToTemporalTime ( _item_ [ , _overflow_ ] )</h1>
      <p>
        The abstract operation ToTemporalTime returns its argument _item_ if it is already a Temporal.PlainTime instance, converts _item_ to a new Temporal.PlainTime instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _overflow_ is not present, set _overflow_ to *"constrain"*.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalTime]] internal slot, then
            1. Return _item_.
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Let _instant_ be ! CreateTemporalInstant(_item_.[[Nanoseconds]]).
            1. Let _plainDateTime_ be ? GetPlainDateTimeFor(_item_.[[TimeZone]], _instant_, _item_.[[Calendar]]).
            1. Return ! CreateTemporalTime(_plainDateTime_.[[ISOHour]], _plainDateTime_.[[ISOMinute]], _plainDateTime_.[[ISOSecond]], _plainDateTime_.[[ISOMillisecond]], _plainDateTime_.[[ISOMicrosecond]], _plainDateTime_.[[ISONanosecond]]).
          1. If _item_ has an [[InitializedTemporalDateTime]] internal slot, then
            1. Return ! CreateTemporalTime(_item_.[[ISOHour]], _item_.[[ISOMinute]], _item_.[[ISOSecond]], _item_.[[ISOMillisecond]], _item_.[[ISOMicrosecond]], _item_.[[ISONanosecond]]).
          1. Let _result_ be ? ToTemporalTimeRecord(_item_).
          1. Set _result_ to ? RegulateTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _overflow_).
        1. Else,
          1. Let _string_ be ? ToString(_item_).
          1. Let _result_ be ? ParseTemporalTimeString(_string_).
          1. Assert: IsValidTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ! CreateTemporalTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-regulatetime" aoid="RegulateTime">
      <h1>RegulateTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _overflow_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_ and _nanosecond_ are integers.
        1. Assert: _overflow_ is either *"constrain"* or *"reject"*.
        1. If _overflow_ is *"constrain"*, then
          1. Return ! ConstrainTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Else,
          1. Assert: _overflow_ is *"reject"*.
          1. If IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, throw a *RangeError* exception.
          1. Return the Record {
            [[Hour]]: _hour_,
            [[Minute]]: _minute_,
            [[Second]]: _second_,
            [[Millisecond]]: _millisecond_,
            [[Microsecond]]: _microsecond_,
            [[Nanosecond]]: _nanosecond_
            }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isvalidtime" type="abstract operation">
      <h1>
        IsValidTime (
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The return value is *true* if its arguments form a valid time of day, and *false* otherwise.
          Leap seconds are not taken into account.
        </dd>
      </dl>
      <emu-alg>
        1. If _hour_ &lt; 0 or _hour_ &gt; 23, then
          1. Return *false*.
        1. If _minute_ &lt; 0 or _minute_ &gt; 59, then
          1. Return *false*.
        1. If _second_ &lt; 0 or _second_ &gt; 59, then
          1. Return *false*.
        1. If _millisecond_ &lt; 0 or _millisecond_ &gt; 999, then
          1. Return *false*.
        1. If _microsecond_ &lt; 0 or _microsecond_ &gt; 999, then
          1. Return *false*.
        1. If _nanosecond_ &lt; 0 or _nanosecond_ &gt; 999, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancetime" aoid="BalanceTime">
      <h1>BalanceTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integers.
        1. Set _microsecond_ to _microsecond_ + floor(_nanosecond_ / 1000).
        1. Set _nanosecond_ to _nanosecond_ modulo 1000.
        1. Set _millisecond_ to _millisecond_ + floor(_microsecond_ / 1000).
        1. Set _microsecond_ to _microsecond_ modulo 1000.
        1. Set _second_ to _second_ + floor(_millisecond_ / 1000).
        1. Set _millisecond_ to _millisecond_ modulo 1000.
        1. Set _minute_ to _minute_ + floor(_second_ / 60).
        1. Set _second_ to _second_ modulo 60.
        1. Set _hour_ to _hour_ + floor(_minute_ / 60).
        1. Set _minute_ to _minute_ modulo 60.
        1. Let _days_ be floor(_hour_ / 24).
        1. Set _hour_ to _hour_ modulo 24.
        1. Return the Record {
          [[Days]]: _days_,
          [[Hour]]: _hour_,
          [[Minute]]: _minute_,
          [[Second]]: _second_,
          [[Millisecond]]: _millisecond_,
          [[Microsecond]]: _microsecond_,
          [[Nanosecond]]: _nanosecond_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-constraintime" aoid="ConstrainTime">
      <h1>ConstrainTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integers.
        1. Set _hour_ to the result of clamping _hour_ between 0 and 23.
        1. Set _minute_ to the result of clamping _minute_ between 0 and 59.
        1. Set _second_ to the result of clamping _second_ between 0 and 59.
        1. Set _millisecond_ to the result of clamping _millisecond_ between 0 and 999.
        1. Set _microsecond_ to the result of clamping _microsecond_ between 0 and 999.
        1. Set _nanosecond_ to the result of clamping _nanosecond_ between 0 and 999.
        1. Return the Record {
          [[Hour]]: _hour_,
          [[Minute]]: _minute_,
          [[Second]]: _second_,
          [[Millisecond]]: _millisecond_,
          [[Microsecond]]: _microsecond_,
          [[Nanosecond]]: _nanosecond_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaltime" type="abstract operation">
      <h1>
        CreateTemporalTime (
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.PlainTime, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a new Temporal.PlainTime instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. If IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, throw a *RangeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.PlainTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.PlainTime.prototype%"*, ¬´ [[InitializedTemporalTime]], [[ISOHour]], [[ISOMinute]], [[ISOSecond]], [[ISOMillisecond]], [[ISOMicrosecond]], [[ISONanosecond]] ¬ª).
        1. Set _object_.[[ISOHour]] to _hour_.
        1. Set _object_.[[ISOMinute]] to _minute_.
        1. Set _object_.[[ISOSecond]] to _second_.
        1. Set _object_.[[ISOMillisecond]] to _millisecond_.
        1. Set _object_.[[ISOMicrosecond]] to _microsecond_.
        1. Set _object_.[[ISONanosecond]] to _nanosecond_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltimerecord" type="abstract operation">
      <h1>
        ToTemporalTimeRecord (
          _temporalTimeLike_: an Object,
          optional _completeness_: ~partial~ or ~complete~,
        ): either a normal completion containing a TemporalTimeLike Record, or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _completeness_ is not present, set _completeness_ to ~complete~.
        1. Let _partial_ be ? PrepareTemporalFields(_temporalTimeLike_, ¬´ *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"nanosecond"*, *"second"* ¬ª, ~partial~).
        1. If _completeness_ is ~complete~, then
          1. Let _result_ be a new TemporalTimeLike Record with each field set to 0.
        1. Else,
          1. Let _result_ be a new TemporalTimeLike Record with each field set to *undefined*.
        1. Let _hourDesc_ be OrdinaryGetOwnProperty(_partial_, *"hour"*).
        1. If _hourDesc_ is not *undefined*, then
          1. Assert: _hourDesc_ is a data Property Descriptor.
          1. Set _result_.[[Hour]] to ‚Ñù(_hourDesc_.[[Value]]).
        1. Let _minuteDesc_ be OrdinaryGetOwnProperty(_partial_, *"minute"*).
        1. If _minuteDesc_ is not *undefined*, then
          1. Assert: _minuteDesc_ is a data Property Descriptor.
          1. Set _result_.[[Minute]] to ‚Ñù(_minuteDesc_.[[Value]]).
        1. Let _secondDesc_ be OrdinaryGetOwnProperty(_partial_, *"second"*).
        1. If _secondDesc_ is not *undefined*, then
          1. Assert: _secondDesc_ is a data Property Descriptor.
          1. Set _result_.[[Second]] to ‚Ñù(_secondDesc_.[[Value]]).
        1. Let _millisecondDesc_ be OrdinaryGetOwnProperty(_partial_, *"millisecond"*).
        1. If _millisecondDesc_ is not *undefined*, then
          1. Assert: _millisecondDesc_ is a data Property Descriptor.
          1. Set _result_.[[Millisecond]] to ‚Ñù(_millisecondDesc_.[[Value]]).
        1. Let _microsecondDesc_ be OrdinaryGetOwnProperty(_partial_, *"microsecond"*).
        1. If _microsecondDesc_ is not *undefined*, then
          1. Assert: _microsecondDesc_ is a data Property Descriptor.
          1. Set _result_.[[Microsecond]] to ‚Ñù(_microsecondDesc_.[[Value]]).
        1. Let _nanosecondDesc_ be OrdinaryGetOwnProperty(_partial_, *"nanosecond"*).
        1. If _nanosecondDesc_ is not *undefined*, then
          1. Assert: _nanosecondDesc_ is a data Property Descriptor.
          1. Set _result_.[[Nanosecond]] to ‚Ñù(_nanosecondDesc_.[[Value]]).
        1. Return _result_.
      </emu-alg>

      <emu-table id="table-temporal-temporaltimelike-record-fields">
        <emu-caption>TemporalTimeLike Record Fields</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Property Name</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[[Hour]]</td>
              <td>*"hour"*</td>
            </tr>

            <tr>
              <td>[[Minute]]</td>
              <td>*"minute"*</td>
            </tr>

            <tr>
              <td>[[Second]]</td>
              <td>*"second"*</td>
            </tr>

            <tr>
              <td>[[Millisecond]]</td>
              <td>*"millisecond"*</td>
            </tr>

            <tr>
              <td>[[Microsecond]]</td>
              <td>*"microsecond"*</td>
            </tr>

            <tr>
              <td>[[Nanosecond]]</td>
              <td>*"nanosecond"*</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaltimetostring" aoid="TemporalTimeToString">
      <h1>TemporalTimeToString ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _precision_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_ and _nanosecond_ are integers.
        1. Let _hour_ be ToZeroPaddedDecimalString(_hour_, 2).
        1. Let _minute_ be ToZeroPaddedDecimalString(_minute_, 2).
        1. Let _seconds_ be ! FormatSecondsStringPart(_second_, _millisecond_, _microsecond_, _nanosecond_, _precision_).
        1. Return the string-concatenation of _hour_, the code unit 0x003A (COLON), _minute_, and _seconds_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetemporaltime" aoid="CompareTemporalTime">
      <h1>CompareTemporalTime ( _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _h2_, _min2_, _s2_, _ms2_, _mus2_, _ns2_ )</h1>
      <emu-alg>
        1. Assert: _h1_, _min1_, _s1_, _ms1_, _mus1_, _ns1_, _h2_, _min2_, _s2_, _ms2_, _mus2_, and _ns2_ are integers.
        1. If _h1_ &gt; _h2_, return 1.
        1. If _h1_ &lt; _h2_, return -1.
        1. If _min1_ &gt; _min2_, return 1.
        1. If _min1_ &lt; _min2_, return -1.
        1. If _s1_ &gt; _s2_, return 1.
        1. If _s1_ &lt; _s2_, return -1.
        1. If _ms1_ &gt; _ms2_, return 1.
        1. If _ms1_ &lt; _ms2_, return -1.
        1. If _mus1_ &gt; _mus2_, return 1.
        1. If _mus1_ &lt; _mus2_, return -1.
        1. If _ns1_ &gt; _ns2_, return 1.
        1. If _ns1_ &lt; _ns2_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addtime" aoid="AddTime">
      <h1>AddTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ )</h1>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, and _nanoseconds_ are integers.
        1. Assert: IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _hour_ be _hour_ + _hours_.
        1. Let _minute_ be _minute_ + _minutes_.
        1. Let _second_ be _second_ + _seconds_.
        1. Let _millisecond_ be _millisecond_ + _milliseconds_.
        1. Let _microsecond_ be _microsecond_ + _microseconds_.
        1. Let _nanosecond_ be _nanosecond_ + _nanoseconds_.
        1. Return ! BalanceTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundtime" aoid="RoundTime">
      <h1>RoundTime ( _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _increment_, _unit_, _roundingMode_ [ , _dayLengthNs_ ] )</h1>
      <p>
        The abstract operation RoundTime rounds a time to the given increment, optionally adjusting for a non-24-hour day.
      </p>
      <emu-alg>
        1. Assert: _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, and _increment_ are integers.
        1. Assert: IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _fractionalSecond_ be _nanosecond_ &times; 10<sup>-9</sup> + _microsecond_ &times; 10<sup>-6</sup> + _millisecond_ &times; 10<sup>-3</sup> + _second_.
        1. If _unit_ is *"day"*, then
          1. If _dayLengthNs_ is not present, set _dayLengthNs_ to nsPerDay.
          1. Let _quantity_ be (((((_hour_ &times; 60 + _minute_) &times; 60 + _second_) &times; 1000 + _millisecond_) &times; 1000 + _microsecond_) &times; 1000 + _nanosecond_) / _dayLengthNs_.
        1. Else if _unit_ is *"hour"*, then
          1. Let _quantity_ be (_fractionalSecond_ / 60 + _minute_) / 60 + _hour_.
        1. Else if _unit_ is *"minute"*, then
          1. Let _quantity_ be _fractionalSecond_ / 60 + _minute_.
        1. Else if _unit_ is *"second"*, then
          1. Let _quantity_ be _fractionalSecond_.
        1. Else if _unit_ is *"millisecond"*, then
          1. Let _quantity_ be _nanosecond_ &times; 10<sup>-6</sup> + _microsecond_ &times; 10<sup>-3</sup> + _millisecond_.
        1. Else if _unit_ is *"microsecond"*, then
          1. Let _quantity_ be _nanosecond_ &times; 10<sup>-3</sup> + _microsecond_.
        1. Else,
          1. Assert: _unit_ is *"nanosecond"*.
          1. Let _quantity_ be _nanosecond_.
        1. Let _result_ be RoundNumberToIncrement(_quantity_, _increment_, _roundingMode_).
        1. If _unit_ is *"day"*, then
          1. Return the Record {
            [[Days]]: _result_,
            [[Hour]]: 0,
            [[Minute]]: 0,
            [[Second]]: 0,
            [[Millisecond]]: 0,
            [[Microsecond]]: 0,
            [[Nanosecond]]: 0
          }.
        1. If _unit_ is *"hour"*, then
          1. Return ! BalanceTime(_result_, 0, 0, 0, 0, 0).
        1. If _unit_ is *"minute"*, then
          1. Return ! BalanceTime(_hour_, _result_, 0, 0, 0, 0).
        1. If _unit_ is *"second"*, then
          1. Return ! BalanceTime(_hour_, _minute_, _result_, 0, 0, 0).
        1. If _unit_ is *"millisecond"*, then
          1. Return ! BalanceTime(_hour_, _minute_, _second_, _result_, 0, 0).
        1. If _unit_ is *"microsecond"*, then
          1. Return ! BalanceTime(_hour_, _minute_, _second_, _millisecond_, _result_, 0).
        1. Assert: _unit_ is *"nanosecond"*.
        1. Return ! BalanceTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _result_).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-differencetemporalplaintime" type="abstract operation">
      <h1>
        DifferenceTemporalPlainTime (
          _operation_: ~since~ or ~until~,
          _temporalTime_: a Temporal.PlainTime,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _temporalTime_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~since~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Set _other_ to ? ToTemporalTime(_other_).
        1. Let _resolvedOptions_ be OrdinaryObjectCreate(*null*).
        1. Perform ? CopyDataProperties(_resolvedOptions_, ? GetOptionsObject(_options_), ¬´ ¬ª).
        1. Let _settings_ be ? GetDifferenceSettings(_operation_, _resolvedOptions_, ~time~, &laquo; &raquo;, *"nanosecond"*, *"hour"*).
        1. Let _result_ be ! DifferenceTime(_temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], _other_.[[ISOHour]], _other_.[[ISOMinute]], _other_.[[ISOSecond]], _other_.[[ISOMillisecond]], _other_.[[ISOMicrosecond]], _other_.[[ISONanosecond]]).
        1. Set _result_ to (! RoundDuration(0, 0, 0, 0, _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]])).[[DurationRecord]].
        1. Set _result_ to ! BalanceDuration(0, _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]], _settings_.[[LargestUnit]]).
        1. Return ! CreateTemporalDuration(0, 0, 0, 0, _sign_ &times; _result_.[[Hours]], _sign_ &times; _result_.[[Minutes]], _sign_ &times; _result_.[[Seconds]], _sign_ &times; _result_.[[Milliseconds]], _sign_ &times; _result_.[[Microseconds]], _sign_ &times; _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-adddurationtoorsubtractdurationfromplaintime" type="abstract operation">
      <h1>
        AddDurationToOrSubtractDurationFromPlainTime (
          _operation_: ~add~ or ~subtract~,
          _temporalTime_: a Temporal.PlainTime,
          _temporalDurationLike_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.PlainTime or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds/subtracts _temporalDurationLike_ to/from _temporalTime_, returning a point in time that is in the future/past relative to _temporalTime_.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~subtract~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Let _duration_ be ? ToTemporalDurationRecord(_temporalDurationLike_).
        1. Let _result_ be ! AddTime(_temporalTime_.[[ISOHour]], _temporalTime_.[[ISOMinute]], _temporalTime_.[[ISOSecond]], _temporalTime_.[[ISOMillisecond]], _temporalTime_.[[ISOMicrosecond]], _temporalTime_.[[ISONanosecond]], _sign_ &times; _duration_.[[Hours]], _sign_ &times; _duration_.[[Minutes]], _sign_ &times; _duration_.[[Seconds]], _sign_ &times; _duration_.[[Milliseconds]], _sign_ &times; _duration_.[[Microseconds]], _sign_ &times; _duration_.[[Nanoseconds]]).
        1. Assert: IsValidTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ! CreateTemporalTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
