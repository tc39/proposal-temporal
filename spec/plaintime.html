<!DOCTYPE html>
<meta charset="utf8">

<emu-clause id="sec-temporal-plaintime-objects">
  <h1>Temporal.PlainTime Objects</h1>
  <p>
    A Temporal.PlainTime object is an Object that contains integers corresponding to a particular hour, minute,
    second, millisecond, microsecond, and nanosecond.
  </p>

  <emu-clause id="sec-temporal-plaintime-constructor">
    <h1>The Temporal.PlainTime Constructor</h1>
    <p>The Temporal.PlainTime constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.PlainTime object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.PlainTime behaviour must
        include a super call to the %Temporal.PlainTime% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.plaintime">
      <h1>Temporal.PlainTime ( [ _hour_ [ , _minute_ [ , _second_ [ , _millisecond_ [ , _microsecond_ [ , _nanosecond_ ] ] ] ] ] ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If _hour_ is *undefined*, set _hour_ to 0; else set _hour_ to ? ToIntegerWithTruncation(_hour_).
        1. If _minute_ is *undefined*, set _minute_ to 0; else set _minute_ to ? ToIntegerWithTruncation(_minute_).
        1. If _second_ is *undefined*, set _second_ to 0; else set _second_ to ? ToIntegerWithTruncation(_second_).
        1. If _millisecond_ is *undefined*, set _millisecond_ to 0; else set _millisecond_ to ? ToIntegerWithTruncation(_millisecond_).
        1. If _microsecond_ is *undefined*, set _microsecond_ to 0; else set _microsecond_ to ? ToIntegerWithTruncation(_microsecond_).
        1. If _nanosecond_ is *undefined*, set _nanosecond_ to 0; else set _nanosecond_ to ? ToIntegerWithTruncation(_nanosecond_).
        1. If IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, throw a *RangeError* exception.
        1. Let _time_ be CreateTimeRecord(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Return ? CreateTemporalTime(_time_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaintime-constructor">
    <h1>Properties of the Temporal.PlainTime Constructor</h1>
    <p>
      The value of the [[Prototype]] internal slot of the Temporal.PlainTime constructor is the intrinsic object
      %Function.prototype%.
    </p>
    <p>The Temporal.PlainTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal.plaintime.prototype">
      <h1>Temporal.PlainTime.prototype</h1>
      <p>The initial value of `Temporal.PlainTime.prototype` is %Temporal.PlainTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.from">
      <h1>Temporal.PlainTime.from ( _item_ [ , _options_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Return ? ToTemporalTime(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.compare">
      <h1>Temporal.PlainTime.compare ( _one_, _two_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalTime(_one_).
        1. Set _two_ to ? ToTemporalTime(_two_).
        1. Return ùîΩ(CompareTimeRecord(_one_.[[Time]], _two_.[[Time]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-plaintime-prototype-object">
    <h1>Properties of the Temporal.PlainTime Prototype Object</h1>

    <p>The Temporal.PlainTime prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.PlainTime instance and does not have a [[InitializedTemporalTime]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.plaintime.prototype.constructor">
      <h1>Temporal.PlainTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.PlainTime.prototype.constructor` is %Temporal.PlainTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype-%symbol.tostringtag%">
      <h1>Temporal.PlainTime.prototype[ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Temporal.PlainTime"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.hour">
      <h1>get Temporal.PlainTime.prototype.hour</h1>
      <p>
        `Temporal.PlainTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Time]].[[Hour]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.minute">
      <h1>get Temporal.PlainTime.prototype.minute</h1>
      <p>
        `Temporal.PlainTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Time]].[[Minute]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.second">
      <h1>get Temporal.PlainTime.prototype.second</h1>
      <p>
        `Temporal.PlainTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Time]].[[Second]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.millisecond">
      <h1>get Temporal.PlainTime.prototype.millisecond</h1>
      <p>
        `Temporal.PlainTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Time]].[[Millisecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.microsecond">
      <h1>get Temporal.PlainTime.prototype.microsecond</h1>
      <p>
        `Temporal.PlainTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Time]].[[Microsecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.plaintime.prototype.nanosecond">
      <h1>get Temporal.PlainTime.prototype.nanosecond</h1>
      <p>
        `Temporal.PlainTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ùîΩ(_temporalTime_.[[Time]].[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.add">
      <h1>Temporal.PlainTime.prototype.add ( _temporalDurationLike_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? AddDurationToTime(~add~, _temporalTime_, _temporalDurationLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.subtract">
      <h1>Temporal.PlainTime.prototype.subtract ( _temporalDurationLike_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? AddDurationToTime(~subtract~, _temporalTime_, _temporalDurationLike_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.with">
      <h1>Temporal.PlainTime.prototype.with ( _temporalTimeLike_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. If ? IsPartialTemporalObject(_temporalTimeLike_) is *false*, throw a *TypeError* exception.
        1. Let _partialTime_ be ? ToTemporalTimeRecord(_temporalTimeLike_, ~partial~).
        1. If _partialTime_.[[Hour]] is not *undefined*, then
          1. Let _hour_ be _partialTime_.[[Hour]].
        1. Else,
          1. Let _hour_ be _temporalTime_.[[Time]].[[Hour]].
        1. If _partialTime_.[[Minute]] is not *undefined*, then
          1. Let _minute_ be _partialTime_.[[Minute]].
        1. Else,
          1. Let _minute_ be _temporalTime_.[[Time]].[[Minute]].
        1. If _partialTime_.[[Second]] is not *undefined*, then
          1. Let _second_ be _partialTime_.[[Second]].
        1. Else,
          1. Let _second_ be _temporalTime_.[[Time]].[[Second]].
        1. If _partialTime_.[[Millisecond]] is not *undefined*, then
          1. Let _millisecond_ be _partialTime_.[[Millisecond]].
        1. Else,
          1. Let _millisecond_ be _temporalTime_.[[Time]].[[Millisecond]].
        1. If _partialTime_.[[Microsecond]] is not *undefined*, then
          1. Let _microsecond_ be _partialTime_.[[Microsecond]].
        1. Else,
          1. Let _microsecond_ be _temporalTime_.[[Time]].[[Microsecond]].
        1. If _partialTime_.[[Nanosecond]] is not *undefined*, then
          1. Let _nanosecond_ be _partialTime_.[[Nanosecond]].
        1. Else,
          1. Let _nanosecond_ be _temporalTime_.[[Time]].[[Nanosecond]].
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _overflow_ be ? GetTemporalOverflowOption(_resolvedOptions_).
        1. Let _result_ be ? RegulateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _overflow_).
        1. Return ! CreateTemporalTime(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.until">
      <h1>Temporal.PlainTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? DifferenceTemporalPlainTime(~until~, _temporalTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.since">
      <h1>Temporal.PlainTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return ? DifferenceTemporalPlainTime(~since~, _temporalTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.round">
      <h1>Temporal.PlainTime.prototype.round ( _roundTo_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. If _roundTo_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If _roundTo_ is a String, then
          1. Let _paramString_ be _roundTo_.
          1. Set _roundTo_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_roundTo_, *"smallestUnit"*, _paramString_).
        1. Else,
          1. Set _roundTo_ to ? GetOptionsObject(_roundTo_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (GetRoundingIncrementOption reads *"roundingIncrement"* and GetRoundingModeOption reads *"roundingMode"*).
        1. Let _roundingIncrement_ be ? GetRoundingIncrementOption(_roundTo_).
        1. Let _roundingMode_ be ? GetRoundingModeOption(_roundTo_, ~half-expand~).
        1. Let _smallestUnit_ be ? GetTemporalUnitValuedOption(_roundTo_, *"smallestUnit"*, ~time~, ~required~).
        1. Let _maximum_ be MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Assert: _maximum_ is not ~unset~.
        1. Perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, *false*).
        1. Let _result_ be RoundTime(_temporalTime_.[[Time]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Return ! CreateTemporalTime(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.equals">
      <h1>Temporal.PlainTime.prototype.equals ( _other_ )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Set _other_ to ? ToTemporalTime(_other_).
        1. If CompareTimeRecord(_temporalTime_.[[Time]], _other_.[[Time]]) = 0, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.tostring">
      <h1>Temporal.PlainTime.prototype.toString ( [ _options_ ] )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (GetTemporalFractionalSecondDigitsOption reads *"fractionalSecondDigits"* and GetRoundingModeOption reads *"roundingMode"*).
        1. Let _digits_ be ? GetTemporalFractionalSecondDigitsOption(_resolvedOptions_).
        1. Let _roundingMode_ be ? GetRoundingModeOption(_resolvedOptions_, ~trunc~).
        1. Let _smallestUnit_ be ? GetTemporalUnitValuedOption(_resolvedOptions_, *"smallestUnit"*, ~time~, ~unset~).
        1. If _smallestUnit_ is ~hour~, throw a *RangeError* exception.
        1. Let _precision_ be ToSecondsStringPrecisionRecord(_smallestUnit_, _digits_).
        1. Let _roundResult_ be RoundTime(_temporalTime_.[[Time]], _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. Return TimeRecordToString(_roundResult_, _precision_.[[Precision]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.tolocalestring">
      <h1>Temporal.PlainTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return TimeRecordToString(_temporalTime_.[[Time]], ~auto~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.tojson">
      <h1>Temporal.PlainTime.prototype.toJSON ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _temporalTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_temporalTime_, [[InitializedTemporalTime]]).
        1. Return TimeRecordToString(_temporalTime_.[[Time]], ~auto~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.plaintime.prototype.valueof">
      <h1>Temporal.PlainTime.prototype.valueOf ( )</h1>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-note>
        <p>
          This method always throws, because in the absence of `valueOf()`, expressions with arithmetic operators such as `plainTime1 > plainTime2` would fall back to being equivalent to `plainTime1.toString() > plainTime2.toString()`.
          Lexicographical comparison of serialized strings might not seem obviously wrong, because the result would sometimes be correct.
          Implementations are encouraged to phrase the error message to point users to `Temporal.PlainTime.compare()`, `Temporal.PlainTime.prototype.equals()`, and/or `Temporal.PlainTime.prototype.toString()`.
        </p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-plaintime-instances">
    <h1>Properties of Temporal.PlainTime Instances</h1>
    <p>
      Temporal.PlainTime instances are ordinary objects that inherit properties from the %Temporal.PlainTime.prototype% intrinsic object.
      Temporal.PlainTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporaltime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporaltime-instances" caption="Internal Slots of Temporal.PlainTime Instances">
      <table>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[InitializedTemporalTime]]
          </td>
          <td>
            The only specified use of this slot is for distinguishing Temporal.PlainTime instances from other objects.
          </td>
        </tr>
        <tr>
          <td>
            [[Time]]
          </td>
          <td>
            A Time Record.
          </td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-plaintime-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-temporal-time-records">
      <h1>Time Records</h1>
      <p>
        A <dfn variants="Time Records">Time Record</dfn> is a Record value used to represent a valid clock time, together with a number of overflow days such as might occur in BalanceTime.
        For any Time Record _t_, IsValidTime(_t_.[[Hour]], _t_.[[Minute]], _t_.[[Second]], _t_.[[Millisecond]], _t_.[[Microsecond]], _t_.[[Nanosecond]]) must return *true*.
      </p>
      <p>Time Records have the fields listed in <emu-xref href="#table-temporal-time-record-fields"></emu-xref>.</p>
      <emu-table id="table-temporal-time-record-fields" caption="Time Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Days]]</td>
            <td>an integer ‚â• 0</td>
            <td>A number of overflow days.</td>
          </tr>
          <tr>
            <td>[[Hour]]</td>
            <td>an integer in the inclusive interval from 0 to 23</td>
            <td>The number of the hour.</td>
          </tr>
          <tr>
            <td>[[Minute]]</td>
            <td>an integer in the inclusive interval from 0 to 59</td>
            <td>The number of the minute.</td>
          </tr>
          <tr>
            <td>[[Second]]</td>
            <td>an integer in the inclusive interval from 0 to 59</td>
            <td>The number of the second.</td>
          </tr>
          <tr>
            <td>[[Millisecond]]</td>
            <td>an integer in the inclusive interval from 0 to 999</td>
            <td>The number of the millisecond.</td>
          </tr>
          <tr>
            <td>[[Microsecond]]</td>
            <td>an integer in the inclusive interval from 0 to 999</td>
            <td>The number of the microsecond.</td>
          </tr>
          <tr>
            <td>[[Nanosecond]]</td>
            <td>an integer in the inclusive interval from 0 to 999</td>
            <td>The number of the nanosecond.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-createtimerecord" type="abstract operation">
      <h1>
        CreateTimeRecord (
          _hour_: an integer in the inclusive interval from 0 to 23,
          _minute_: an integer in the inclusive interval from 0 to 59,
          _second_: an integer in the inclusive interval from 0 to 59,
          _millisecond_: an integer in the inclusive interval from 0 to 999,
          _microsecond_: an integer in the inclusive interval from 0 to 999,
          _nanosecond_: an integer in the inclusive interval from 0 to 999,
          optional _deltaDays_: a non-negative integer,
        ): a Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Most uses of Time Records do not require the _deltaDays_ parameter.</dd>
      </dl>
      <emu-alg>
        1. If _deltaDays_ is not present, set _deltaDays_ to 0.
        1. Assert: IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Return Time Record {
            [[Days]]: _deltaDays_,
            [[Hour]]: _hour_,
            [[Minute]]: _minute_,
            [[Second]]: _second_,
            [[Millisecond]]: _millisecond_,
            [[Microsecond]]: _microsecond_,
            [[Nanosecond]]: _nanosecond_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-midnighttimerecord" type="abstract operation">
      <h1>MidnightTimeRecord ( ): a Time Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned Record denotes the wall-clock time of midnight.</dd>
      </dl>
      <emu-alg>
        1. Return Time Record {
            [[Days]]: 0,
            [[Hour]]: 0,
            [[Minute]]: 0,
            [[Second]]: 0,
            [[Millisecond]]: 0,
            [[Microsecond]]: 0,
            [[Nanosecond]]: 0
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-noontimerecord" type="abstract operation">
      <h1>NoonTimeRecord ( ): a Time Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned Record denotes the wall-clock time of noon.</dd>
      </dl>
      <emu-alg>
        1. Return Time Record {
            [[Days]]: 0,
            [[Hour]]: 12,
            [[Minute]]: 0,
            [[Second]]: 0,
            [[Millisecond]]: 0,
            [[Microsecond]]: 0,
            [[Nanosecond]]: 0
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencetime" type="abstract operation">
      <h1>
        DifferenceTime (
          _time1_: a Time Record,
          _time2_: a Time Record,
        ): a time duration
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns the elapsed duration from a first wall-clock time, until a second wall-clock time.</dd>
      </dl>
      <emu-alg>
        1. Let _hours_ be _time2_.[[Hour]] - _time1_.[[Hour]].
        1. Let _minutes_ be _time2_.[[Minute]] - _time1_.[[Minute]].
        1. Let _seconds_ be _time2_.[[Second]] - _time1_.[[Second]].
        1. Let _milliseconds_ be _time2_.[[Millisecond]] - _time1_.[[Millisecond]].
        1. Let _microseconds_ be _time2_.[[Microsecond]] - _time1_.[[Microsecond]].
        1. Let _nanoseconds_ be _time2_.[[Nanosecond]] - _time1_.[[Nanosecond]].
        1. Let _timeDuration_ be TimeDurationFromComponents(_hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Assert: abs(_timeDuration_) &lt; nsPerDay.
        1. Return _timeDuration_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltime" type="abstract operation">
      <h1>
        ToTemporalTime (
          _item_: an ECMAScript language value,
          optional _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.PlainTime or a throw Completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Converts _item_ to a new Temporal.PlainTime instance if possible, and throws otherwise.</dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. If _item_ is an Object, then
          1. If _item_ has an [[InitializedTemporalTime]] internal slot, then
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Return ! CreateTemporalTime(_item_.[[Time]]).
          1. If _item_ has an [[InitializedTemporalDateTime]] internal slot, then
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Return ! CreateTemporalTime(_item_.[[ISODateTime]].[[Time]]).
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Let _isoDateTime_ be GetISODateTimeFor(_item_.[[TimeZone]], _item_.[[EpochNanoseconds]]).
            1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
            1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
            1. Return ! CreateTemporalTime(_isoDateTime_.[[Time]]).
          1. Let _result_ be ? ToTemporalTimeRecord(_item_).
          1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
          1. Let _overflow_ be ? GetTemporalOverflowOption(_resolvedOptions_).
          1. Set _result_ to ? RegulateTime(_result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _overflow_).
        1. Else,
          1. If _item_ is not a String, throw a *TypeError* exception.
          1. Let _parseResult_ be ? ParseISODateTime(_item_, ¬´ |TemporalTimeString| ¬ª).
          1. Assert: _parseResult_.[[Time]] is not ~start-of-day~.
          1. Set _result_ to _parseResult_.[[Time]].
          1. NOTE: A successful parse using |TemporalTimeString| guarantees absence of ambiguity with respect to any ISO 8601 date-only, year-month, or month-day representation.
          1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
          1. Perform ? GetTemporalOverflowOption(_resolvedOptions_).
        1. Return ! CreateTemporalTime(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totimerecordormidnight" type="abstract operation">
      <h1>
        ToTimeRecordOrMidnight (
          _item_: an ECMAScript language value,
        ): either a normal completion containing a Time Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Converts _item_ to a Time Record if possible, considering *undefined* to be the same as midnight, and throws otherwise.</dd>
      </dl>
      <emu-alg>
        1. If _item_ is *undefined*, return MidnightTimeRecord().
        1. Let _plainTime_ be ? ToTemporalTime(_item_).
        1. Return _plainTime_.[[Time]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-regulatetime" type="abstract operation">
      <h1>
        RegulateTime (
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing a Time Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It applies the correction given by _overflow_ to the given time.
          If _overflow_ is ~constrain~, out-of-range values are clamped.
          If _overflow_ is ~reject~, a *RangeError* is thrown if any values are out of range.
        </dd>
      </dl>
      <emu-alg>
        1. If _overflow_ is ~constrain~, then
          1. Set _hour_ to the result of clamping _hour_ between 0 and 23.
          1. Set _minute_ to the result of clamping _minute_ between 0 and 59.
          1. Set _second_ to the result of clamping _second_ between 0 and 59.
          1. Set _millisecond_ to the result of clamping _millisecond_ between 0 and 999.
          1. Set _microsecond_ to the result of clamping _microsecond_ between 0 and 999.
          1. Set _nanosecond_ to the result of clamping _nanosecond_ between 0 and 999.
        1. Else,
          1. Assert: _overflow_ is ~reject~.
          1. If IsValidTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, throw a *RangeError* exception.
        1. Return CreateTimeRecord(_hour_, _minute_, _second_, _millisecond_, _microsecond_,_nanosecond_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isvalidtime" type="abstract operation">
      <h1>
        IsValidTime (
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The return value is *true* if its arguments form a valid time of day, and *false* otherwise.
          Leap seconds are not taken into account.
        </dd>
      </dl>
      <emu-alg>
        1. If _hour_ &lt; 0 or _hour_ > 23, then
          1. Return *false*.
        1. If _minute_ &lt; 0 or _minute_ > 59, then
          1. Return *false*.
        1. If _second_ &lt; 0 or _second_ > 59, then
          1. Return *false*.
        1. If _millisecond_ &lt; 0 or _millisecond_ > 999, then
          1. Return *false*.
        1. If _microsecond_ &lt; 0 or _microsecond_ > 999, then
          1. Return *false*.
        1. If _nanosecond_ &lt; 0 or _nanosecond_ > 999, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancetime" type="abstract operation">
      <h1>
        BalanceTime (
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
        ): a Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Set _microsecond_ to _microsecond_ + floor(_nanosecond_ / 1000).
        1. Set _nanosecond_ to _nanosecond_ modulo 1000.
        1. Set _millisecond_ to _millisecond_ + floor(_microsecond_ / 1000).
        1. Set _microsecond_ to _microsecond_ modulo 1000.
        1. Set _second_ to _second_ + floor(_millisecond_ / 1000).
        1. Set _millisecond_ to _millisecond_ modulo 1000.
        1. Set _minute_ to _minute_ + floor(_second_ / 60).
        1. Set _second_ to _second_ modulo 60.
        1. Set _hour_ to _hour_ + floor(_minute_ / 60).
        1. Set _minute_ to _minute_ modulo 60.
        1. Let _deltaDays_ be floor(_hour_ / 24).
        1. Set _hour_ to _hour_ modulo 24.
        1. Return CreateTimeRecord(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _deltaDays_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaltime" type="abstract operation">
      <h1>
        CreateTemporalTime (
          _time_: a Time Record,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.PlainTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a new Temporal.PlainTime instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.PlainTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.PlainTime.prototype%"*, ¬´ [[InitializedTemporalTime]], [[Time]] ¬ª).
        1. Set _object_.[[Time]] to _time_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaltimerecord" type="abstract operation">
      <h1>
        ToTemporalTimeRecord (
          _temporalTimeLike_: an Object,
          optional _completeness_: ~partial~ or ~complete~,
        ): either a normal completion containing a TemporalTimeLike Record or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _completeness_ is not present, set _completeness_ to ~complete~.
        1. If _completeness_ is ~complete~, then
          1. Let _result_ be a new TemporalTimeLike Record with each field set to 0.
        1. Else,
          1. Let _result_ be a new TemporalTimeLike Record with each field set to ~unset~.
        1. Let _any_ be *false*.
        1. Let _hour_ be ? Get(_temporalTimeLike_, *"hour"*).
        1. If _hour_ is not *undefined*, then
          1. Set _result_.[[Hour]] to ? ToIntegerWithTruncation(_hour_).
          1. Set _any_ to *true*.
        1. Let _microsecond_ be ? Get(_temporalTimeLike_, *"microsecond"*).
        1. If _microsecond_ is not *undefined*, then
          1. Set _result_.[[Microsecond]] to ? ToIntegerWithTruncation(_microsecond_).
          1. Set _any_ to *true*.
        1. Let _millisecond_ be ? Get(_temporalTimeLike_, *"millisecond"*).
        1. If _millisecond_ is not *undefined*, then
          1. Set _result_.[[Millisecond]] to ? ToIntegerWithTruncation(_millisecond_).
          1. Set _any_ to *true*.
        1. Let _minute_ be ? Get(_temporalTimeLike_, *"minute"*).
        1. If _minute_ is not *undefined*, then
          1. Set _result_.[[Minute]] to ? ToIntegerWithTruncation(_minute_).
          1. Set _any_ to *true*.
        1. Let _nanosecond_ be ? Get(_temporalTimeLike_, *"nanosecond"*).
        1. If _nanosecond_ is not *undefined*, then
          1. Set _result_.[[Nanosecond]] to ? ToIntegerWithTruncation(_nanosecond_).
          1. Set _any_ to *true*.
        1. Let _second_ be ? Get(_temporalTimeLike_, *"second"*).
        1. If _second_ is not *undefined*, then
          1. Set _result_.[[Second]] to ? ToIntegerWithTruncation(_second_).
          1. Set _any_ to *true*.
        1. If _any_ is *false*, throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>

      <emu-table id="table-temporal-temporaltimelike-record-fields">
        <emu-caption>TemporalTimeLike Record Fields</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Property Name</th>
            </tr>
          </thead>
          <tr>
            <td>[[Hour]]</td>
            <td>*"hour"*</td>
          </tr>

          <tr>
            <td>[[Minute]]</td>
            <td>*"minute"*</td>
          </tr>

          <tr>
            <td>[[Second]]</td>
            <td>*"second"*</td>
          </tr>

          <tr>
            <td>[[Millisecond]]</td>
            <td>*"millisecond"*</td>
          </tr>

          <tr>
            <td>[[Microsecond]]</td>
            <td>*"microsecond"*</td>
          </tr>

          <tr>
            <td>[[Nanosecond]]</td>
            <td>*"nanosecond"*</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-timerecordtostring" type="abstract operation">
      <h1>
        TimeRecordToString (
          _time_: a Time Record,
          _precision_: an integer in the inclusive interval from 0 to 9, ~minute~, or ~auto~,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It formats the given time as an ISO 8601 string, to the precision specified by _precision_.</dd>
      </dl>
      <emu-alg>
        1. Let _subSecondNanoseconds_ be _time_.[[Millisecond]] √ó 10<sup>6</sup> + _time_.[[Microsecond]] √ó 10<sup>3</sup> + _time_.[[Nanosecond]].
        1. Return FormatTimeString(_time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]], _subSecondNanoseconds_, _precision_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetimerecord" type="abstract operation">
      <h1>
        CompareTimeRecord (
          _time1_: a Time Record,
          _time2_: a Time Record,
        ): -1, 0, or 1
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It compares the two given times and returns -1 if the second comes earlier in the day than the first, 1 if the first comes earlier in the day than the second, and 0 if they are the same.</dd>
      </dl>
      <emu-alg>
        1. If _time1_.[[Hour]] > _time2_.[[Hour]], return 1.
        1. If _time1_.[[Hour]] &lt; _time2_.[[Hour]], return -1.
        1. If _time1_.[[Minute]] > _time2_.[[Minute]], return 1.
        1. If _time1_.[[Minute]] &lt; _time2_.[[Minute]], return -1.
        1. If _time1_.[[Second]] > _time2_.[[Second]], return 1.
        1. If _time1_.[[Second]] &lt; _time2_.[[Second]], return -1.
        1. If _time1_.[[Millisecond]] > _time2_.[[Millisecond]], return 1.
        1. If _time1_.[[Millisecond]] &lt; _time2_.[[Millisecond]], return -1.
        1. If _time1_.[[Microsecond]] > _time2_.[[Microsecond]], return 1.
        1. If _time1_.[[Microsecond]] &lt; _time2_.[[Microsecond]], return -1.
        1. If _time1_.[[Nanosecond]] > _time2_.[[Nanosecond]], return 1.
        1. If _time1_.[[Nanosecond]] &lt; _time2_.[[Nanosecond]], return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addtime" type="abstract operation">
      <h1>
        AddTime (
          _time_: a Time Record,
          _timeDuration_: a time duration,
        ): a Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>
      <emu-alg>
        1. Return BalanceTime(_time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]], _time_.[[Millisecond]], _time_.[[Microsecond]], _time_.[[Nanosecond]] + _timeDuration_).
        1. NOTE: If using floating points to implement this operation, add the time components separately before balancing to avoid errors with unsafe integers.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundtime" type="abstract operation">
      <h1>
        RoundTime (
          _time_: a Time Record,
          _increment_: a positive integer,
          _unit_: a time unit or ~day~,
          _roundingMode_: a rounding mode,
        ): a Time Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It rounds a time to the given increment.</dd>
      </dl>
      <emu-alg>
        1. If _unit_ is ~day~ or ~hour~, then
          1. Let _quantity_ be ((((_time_.[[Hour]] √ó 60 + _time_.[[Minute]]) √ó 60 + _time_.[[Second]]) √ó 1000 + _time_.[[Millisecond]]) √ó 1000 + _time_.[[Microsecond]]) √ó 1000 + _time_.[[Nanosecond]].
        1. Else if _unit_ is ~minute~, then
          1. Let _quantity_ be (((_time_.[[Minute]] √ó 60 + _time_.[[Second]]) √ó 1000 + _time_.[[Millisecond]]) √ó 1000 + _time_.[[Microsecond]]) √ó 1000 + _time_.[[Nanosecond]].
        1. Else if _unit_ is ~second~, then
          1. Let _quantity_ be ((_time_.[[Second]] √ó 1000 + _time_.[[Millisecond]]) √ó 1000 + _time_.[[Microsecond]]) √ó 1000 + _time_.[[Nanosecond]].
        1. Else if _unit_ is ~millisecond~, then
          1. Let _quantity_ be (_time_.[[Millisecond]] √ó 1000 + _time_.[[Microsecond]]) √ó 1000 + _time_.[[Nanosecond]].
        1. Else if _unit_ is ~microsecond~, then
          1. Let _quantity_ be _time_.[[Microsecond]] √ó 1000 + _time_.[[Nanosecond]].
        1. Else,
          1. Assert: _unit_ is ~nanosecond~.
          1. Let _quantity_ be _time_.[[Nanosecond]].
        1. Let _unitLength_ be the value in the "Length in Nanoseconds" column of the row of <emu-xref href="#table-temporal-units"></emu-xref> whose "Value" column contains _unit_.
        1. Let _result_ be RoundNumberToIncrement(_quantity_, _increment_ √ó _unitLength_, _roundingMode_) / _unitLength_.
        1. If _unit_ is ~day~, then
          1. Return CreateTimeRecord(0, 0, 0, 0, 0, 0, _result_).
        1. If _unit_ is ~hour~, then
          1. Return BalanceTime(_result_, 0, 0, 0, 0, 0).
        1. If _unit_ is ~minute~, then
          1. Return BalanceTime(_time_.[[Hour]], _result_, 0, 0, 0, 0).
        1. If _unit_ is ~second~, then
          1. Return BalanceTime(_time_.[[Hour]], _time_.[[Minute]], _result_, 0, 0, 0).
        1. If _unit_ is ~millisecond~, then
          1. Return BalanceTime(_time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]], _result_, 0, 0).
        1. If _unit_ is ~microsecond~, then
          1. Return BalanceTime(_time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]], _time_.[[Millisecond]], _result_, 0).
        1. Assert: _unit_ is ~nanosecond~.
        1. Return BalanceTime(_time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]], _time_.[[Millisecond]], _time_.[[Microsecond]], _result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencetemporalplaintime" type="abstract operation">
      <h1>
        DifferenceTemporalPlainTime (
          _operation_: ~since~ or ~until~,
          _temporalTime_: a Temporal.PlainTime,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _temporalTime_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. Set _other_ to ? ToTemporalTime(_other_).
        1. Let _resolvedOptions_ be ? GetOptionsObject(_options_).
        1. Let _settings_ be ? GetDifferenceSettings(_operation_, _resolvedOptions_, ~time~, ¬´ ¬ª, ~nanosecond~, ~hour~).
        1. Let _timeDuration_ be DifferenceTime(_temporalTime_.[[Time]], _other_.[[Time]]).
        1. Set _timeDuration_ to ! RoundTimeDuration(_timeDuration_, _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]]).
        1. Let _duration_ be ! CombineDateAndTimeDuration(ZeroDateDuration(), _timeDuration_).
        1. Let _result_ be ! TemporalDurationFromInternal(_duration_, _settings_.[[LargestUnit]]).
        1. If _operation_ is ~since~, set _result_ to CreateNegatedTemporalDuration(_result_).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddurationtotime" type="abstract operation">
      <h1>
        AddDurationToTime (
          _operation_: ~add~ or ~subtract~,
          _temporalTime_: a Temporal.PlainTime,
          _temporalDurationLike_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.PlainTime or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds/subtracts _temporalDurationLike_ to/from _temporalTime_, returning a point in time that is in the future/past relative to _temporalTime_.</dd>
      </dl>
      <emu-alg>
        1. Let _duration_ be ? ToTemporalDuration(_temporalDurationLike_).
        1. If _operation_ is ~subtract~, set _duration_ to CreateNegatedTemporalDuration(_duration_).
        1. Let _internalDuration_ be ToInternalDurationRecord(_duration_).
        1. Let _result_ be AddTime(_temporalTime_.[[Time]], _internalDuration_.[[Time]]).
        1. Return ! CreateTemporalTime(_result_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
