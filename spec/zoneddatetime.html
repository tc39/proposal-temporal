<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-zoneddatetime-objects">
  <h1>Temporal.ZonedDateTime Objects</h1>
  <p>
    A Temporal.ZonedDateTime object is an Object referencing a fixed point in time with nanoseconds precision, and containing Object values corresponding to a particular time zone and calendar system.
  </p>

  <emu-clause id="sec-temporal-zoneddatetime-constructor">
    <h1>The Temporal.ZonedDateTime Constructor</h1>
    <p>The Temporal.ZonedDateTime constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.ZonedDateTime object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.ZonedDateTime behaviour must
        include a super call to the %Temporal.ZonedDateTime% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.zoneddatetime">
      <h1>Temporal.ZonedDateTime ( _epochNanoseconds_, _timeZoneLike_ [ , _calendarLike_ ] )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _epochNanoseconds_ to ? ToBigInt(_epochNanoseconds_).
        1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Let _timeZone_ be ? ToTemporalTimeZoneSlotValue(_timeZoneLike_).
        1. Let _calendar_ be ? ToTemporalCalendarSlotValue(_calendarLike_, *"iso8601"*).
        1. Return ? CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-zoneddatetime-constructor">
    <h1>Properties of the Temporal.ZonedDateTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.ZonedDateTime constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.ZonedDateTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal.zoneddatetime.prototype">
      <h1>Temporal.ZonedDateTime.prototype</h1>
      <p>The initial value of `Temporal.ZonedDateTime.prototype` is %Temporal.ZonedDateTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.from">
      <h1>Temporal.ZonedDateTime.from ( _item_ [ , _options_ ] )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
          1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalDisambiguation reads *"disambiguation"*, ToTemporalOffset reads *"offset"*, and ToTemporalOverflow reads *"overflow"*).
          1. Perform ? ToTemporalDisambiguation(_options_).
          1. Perform ? ToTemporalOffset(_options_, *"reject"*).
          1. Perform ? ToTemporalOverflow(_options_).
          1. Return ! CreateTemporalZonedDateTime(_item_.[[Nanoseconds]], _item_.[[TimeZone]], _item_.[[Calendar]]).
        1. Return ? ToTemporalZonedDateTime(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.compare">
      <h1>Temporal.ZonedDateTime.compare ( _one_, _two_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalZonedDateTime(_one_).
        1. Set _two_ to ? ToTemporalZonedDateTime(_two_).
        1. Return ùîΩ(CompareEpochNanoseconds(_one_.[[Nanoseconds]], _two_.[[Nanoseconds]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-zoneddatetime-prototype-object">
    <h1>Properties of the Temporal.ZonedDateTime Prototype Object</h1>

    <p>The Temporal.ZonedDateTime prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.ZonedDateTime instance and does not have a [[InitializedTemporalZonedDateTime]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-note>
      An ECMAScript implementation that includes the ECMA-402 Internationalization API extends this prototype with additional properties in order to represent calendar data.
    </emu-note>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.constructor">
      <h1>Temporal.ZonedDateTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.ZonedDateTime.prototype.constructor` is %Temporal.ZonedDateTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype-@@tostringtag">
      <h1>Temporal.ZonedDateTime.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the String value *"Temporal.ZonedDateTime"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.calendarid">
      <h1>get Temporal.ZonedDateTime.prototype.calendarId</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.calendarId` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? ToTemporalCalendarIdentifier(_zonedDateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.timezoneid">
      <h1>get Temporal.ZonedDateTime.prototype.timeZoneId</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.timeZoneId` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? ToTemporalTimeZoneIdentifier(_zonedDateTime_.[[TimeZone]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.year">
      <h1>get Temporal.ZonedDateTime.prototype.year</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.month">
      <h1>get Temporal.ZonedDateTime.prototype.month</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarMonth(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.monthcode">
      <h1>get Temporal.ZonedDateTime.prototype.monthCode</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.monthCode` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ? CalendarMonthCode(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.day">
      <h1>get Temporal.ZonedDateTime.prototype.day</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_zonedDateTime_.[[Calendar]], ¬´ ~day~ ¬ª).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendarRec_.[[Receiver]]).
        1. Return ùîΩ(? CalendarDay(_calendarRec_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.hour">
      <h1>get Temporal.ZonedDateTime.prototype.hour</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOHour]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.minute">
      <h1>get Temporal.ZonedDateTime.prototype.minute</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMinute]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.second">
      <h1>get Temporal.ZonedDateTime.prototype.second</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOSecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.millisecond">
      <h1>get Temporal.ZonedDateTime.prototype.millisecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMillisecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.microsecond">
      <h1>get Temporal.ZonedDateTime.prototype.microsecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMicrosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.nanosecond">
      <h1>get Temporal.ZonedDateTime.prototype.nanosecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochSeconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochSeconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _s_ be floor(‚Ñù(_ns_) / 10<sup>9</sup>).
        1. Return ùîΩ(_s_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochmilliseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochMilliseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochMilliseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _ms_ be floor(‚Ñù(_ns_) / 10<sup>6</sup>).
        1. Return ùîΩ(_ms_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochmicroseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochMicroseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochMicroseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _¬µs_ be floor(‚Ñù(_ns_) / 10<sup>3</sup>).
        1. Return ‚Ñ§(_¬µs_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochnanoseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochNanoseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochNanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return _zonedDateTime_.[[Nanoseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.dayofweek">
      <h1>get Temporal.ZonedDateTime.prototype.dayOfWeek</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDayOfWeek(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.dayofyear">
      <h1>get Temporal.ZonedDateTime.prototype.dayOfYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDayOfYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.weekofyear">
      <h1>get Temporal.ZonedDateTime.prototype.weekOfYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarWeekOfYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.yearofweek">
      <h1>get Temporal.ZonedDateTime.prototype.yearOfWeek</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.yearOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarYearOfWeek(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.hoursinday">
      <h1>get Temporal.ZonedDateTime.prototype.hoursInDay</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.hoursInDay` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, *"iso8601"*).
        1. Let _year_ be _temporalDateTime_.[[ISOYear]].
        1. Let _month_ be _temporalDateTime_.[[ISOMonth]].
        1. Let _day_ be _temporalDateTime_.[[ISODay]].
        1. Let _today_ be ? CreateTemporalDateTime(_year_, _month_, _day_, 0, 0, 0, 0, 0, 0, *"iso8601"*).
        1. Let _tomorrowFields_ be BalanceISODate(_year_, _month_, _day_ + 1).
        1. Let _tomorrow_ be ? CreateTemporalDateTime(_tomorrowFields_.[[Year]], _tomorrowFields_.[[Month]], _tomorrowFields_.[[Day]], 0, 0, 0, 0, 0, 0, *"iso8601"*).
        1. Let _todayInstant_ be ? GetInstantFor(_timeZoneRec_, _today_, *"compatible"*).
        1. Let _tomorrowInstant_ be ? GetInstantFor(_timeZoneRec_, _tomorrow_, *"compatible"*).
        1. Let _diff_ be NormalizedTimeDurationFromEpochNanosecondsDifference(_tomorrowInstant_.[[Nanoseconds]], _todayInstant_.[[Nanoseconds]]).
        1. Return ùîΩ(DivideNormalizedTimeDuration(_diff_, 3.6 &times; 10<sup>12</sup>)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinweek">
      <h1>get Temporal.ZonedDateTime.prototype.daysInWeek</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDaysInWeek(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinmonth">
      <h1>get Temporal.ZonedDateTime.prototype.daysInMonth</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDaysInMonth(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinyear">
      <h1>get Temporal.ZonedDateTime.prototype.daysInYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDaysInYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.monthsinyear">
      <h1>get Temporal.ZonedDateTime.prototype.monthsInYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarMonthsInYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.inleapyear">
      <h1>get Temporal.ZonedDateTime.prototype.inLeapYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ? CalendarInLeapYear(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.offsetnanoseconds">
      <h1>get Temporal.ZonedDateTime.prototype.offsetNanoseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.offsetNanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Return ùîΩ(? GetOffsetNanosecondsFor(_timeZoneRec_, _instant_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.offset">
      <h1>get Temporal.ZonedDateTime.prototype.offset</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.offset` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Return ? GetOffsetStringFor(_timeZoneRec_, _instant_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.with">
      <h1>Temporal.ZonedDateTime.prototype.with ( _temporalZonedDateTimeLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. If ? IsPartialTemporalObject(_temporalZonedDateTimeLike_) is *false*, throw a *TypeError* exception.
        1. Let _resolvedOptions_ be ? SnapshotOwnProperties(? GetOptionsObject(_options_), *null*).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_zonedDateTime_.[[Calendar]], ¬´ ~date-from-fields~, ~fields~, ~merge-fields~ ¬ª).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _instant_).
        1. Let _dateTime_ be ! GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendarRec_.[[Receiver]], _offsetNanoseconds_).
        1. Let _fieldNames_ be ? CalendarFields(_calendarRec_, ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_dateTime_, _fieldNames_, ¬´ ¬ª).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"hour"*, _dateTime_.[[ISOHour]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"minute"*, _dateTime_.[[ISOMinute]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"second"*, _dateTime_.[[ISOSecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"millisecond"*, _dateTime_.[[ISOMillisecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"microsecond"*, _dateTime_.[[ISOMicrosecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"nanosecond"*, _dateTime_.[[ISONanosecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"offset"*, FormatUTCOffsetNanoseconds(_offsetNanoseconds_)).
        1. Append *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"nanosecond"*, *"offset"*, and *"second"* to _fieldNames_.
        1. Let _partialZonedDateTime_ be ? PrepareTemporalFields(_temporalZonedDateTimeLike_, _fieldNames_, ~partial~).
        1. Set _fields_ to ? CalendarMergeFields(_calendarRec_, _fields_, _partialZonedDateTime_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, ¬´ *"offset"* ¬ª).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalDisambiguation reads *"disambiguation"*, ToTemporalOffset reads *"offset"*, and InterpretTemporalDateTimeFields reads *"overflow"*).
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_resolvedOptions_).
        1. Let _offset_ be ? ToTemporalOffset(_resolvedOptions_, *"prefer"*).
        1. Let _dateTimeResult_ be ? InterpretTemporalDateTimeFields(_calendarRec_, _fields_, _resolvedOptions_).
        1. Let _offsetString_ be ! Get(_fields_, *"offset"*).
        1. Assert: Type(_offsetString_) is String.
        1. Let _newOffsetNanoseconds_ be ? ParseDateTimeUTCOffset(_offsetString_).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_dateTimeResult_.[[Year]], _dateTimeResult_.[[Month]], _dateTimeResult_.[[Day]], _dateTimeResult_.[[Hour]], _dateTimeResult_.[[Minute]], _dateTimeResult_.[[Second]], _dateTimeResult_.[[Millisecond]], _dateTimeResult_.[[Microsecond]], _dateTimeResult_.[[Nanosecond]], ~option~, _newOffsetNanoseconds_, _timeZoneRec_, _disambiguation_, _offset_, ~match-exactly~).
        1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZoneRec_.[[Receiver]], _calendarRec_.[[Receiver]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withplaintime">
      <h1>Temporal.ZonedDateTime.prototype.withPlainTime ( [ _plainTimeLike_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _plainTime_ be ? ToTemporalTimeOrMidnight(_plainTimeLike_).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _plainDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Let _resultPlainDateTime_ be ? CreateTemporalDateTime(_plainDateTime_.[[ISOYear]], _plainDateTime_.[[ISOMonth]], _plainDateTime_.[[ISODay]], _plainTime_.[[ISOHour]], _plainTime_.[[ISOMinute]], _plainTime_.[[ISOSecond]], _plainTime_.[[ISOMillisecond]], _plainTime_.[[ISOMicrosecond]], _plainTime_.[[ISONanosecond]], _calendar_).
        1. Set _instant_ to ? GetInstantFor(_timeZoneRec_, _resultPlainDateTime_, *"compatible"*).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZoneRec_.[[Receiver]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withplaindate">
      <h1>Temporal.ZonedDateTime.prototype.withPlainDate ( _plainDateLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _plainDate_ be ? ToTemporalDate(_plainDateLike_).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _plainDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _zonedDateTime_.[[Calendar]]).
        1. Let _calendar_ be ? ConsolidateCalendars(_zonedDateTime_.[[Calendar]], _plainDate_.[[Calendar]]).
        1. Let _resultPlainDateTime_ be ? CreateTemporalDateTime(_plainDate_.[[ISOYear]], _plainDate_.[[ISOMonth]], _plainDate_.[[ISODay]], _plainDateTime_.[[ISOHour]], _plainDateTime_.[[ISOMinute]], _plainDateTime_.[[ISOSecond]], _plainDateTime_.[[ISOMillisecond]], _plainDateTime_.[[ISOMicrosecond]], _plainDateTime_.[[ISONanosecond]], _calendar_).
        1. Set _instant_ to ? GetInstantFor(_timeZoneRec_, _resultPlainDateTime_, *"compatible"*).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZoneRec_.[[Receiver]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withtimezone">
      <h1>Temporal.ZonedDateTime.prototype.withTimeZone ( _timeZoneLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be ? ToTemporalTimeZoneSlotValue(_timeZoneLike_).
        1. Return ! CreateTemporalZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _timeZone_, _zonedDateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withcalendar">
      <h1>Temporal.ZonedDateTime.prototype.withCalendar ( _calendarLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _calendar_ be ? ToTemporalCalendarSlotValue(_calendarLike_).
        1. Return ! CreateTemporalZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _zonedDateTime_.[[TimeZone]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.add">
      <h1>Temporal.ZonedDateTime.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? AddDurationToOrSubtractDurationFromZonedDateTime(~add~, _zonedDateTime_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.subtract">
      <h1>Temporal.ZonedDateTime.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? AddDurationToOrSubtractDurationFromZonedDateTime(~subtract~, _zonedDateTime_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.until">
      <h1>Temporal.ZonedDateTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? DifferenceTemporalZonedDateTime(~until~, _zonedDateTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.since">
      <h1>Temporal.ZonedDateTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? DifferenceTemporalZonedDateTime(~since~, _zonedDateTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.round">
      <h1>Temporal.ZonedDateTime.prototype.round ( _roundTo_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. If _roundTo_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If Type(_roundTo_) is String, then
          1. Let _paramString_ be _roundTo_.
          1. Set _roundTo_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_roundTo_, *"smallestUnit"*, _paramString_).
        1. Else,
          1. Set _roundTo_ to ? GetOptionsObject(_roundTo_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalRoundingIncrement reads *"roundingIncrement"* and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_roundTo_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_roundTo_, *"halfExpand"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_roundTo_, *"smallestUnit"*, ~time~, ~required~, ¬´ *"day"* ¬ª).
        1. If _smallestUnit_ is *"day"*, then
          1. Let _maximum_ be 1.
          1. Let _inclusive_ be *true*.
        1. Else,
          1. Let _maximum_ be MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
          1. Assert: _maximum_ is not *undefined*.
          1. Let _inclusive_ be *false*.
        1. Perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, _inclusive_).
        1. If _smallestUnit_ is *"nanosecond"* and _roundingIncrement_ is 1, then
          1. Return ! CreateTemporalZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _zonedDateTime_.[[TimeZone]], _zonedDateTime_.[[Calendar]]).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _instant_).
        1. Let _temporalDateTime_ be ! GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_, _offsetNanoseconds_).
        1. Let _dtStart_ be ? CreateTemporalDateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], 0, 0, 0, 0, 0, 0, *"iso8601"*).
        1. Let _instantStart_ be ? GetInstantFor(_timeZoneRec_, _dtStart_, *"compatible"*).
        1. Let _startNs_ be _instantStart_.[[Nanoseconds]].
        1. Let _endNs_ be ? AddDaysToZonedDateTime(_instantStart_, _dtStart_, _timeZoneRec_, _calendar_, 1).[[EpochNanoseconds]].
        1. Let _dayLengthNs_ be ‚Ñù(_endNs_ - _startNs_).
        1. If _dayLengthNs_ &le; 0, then
          1. Throw a *RangeError* exception.
        1. Let _roundResult_ be RoundISODateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _dayLengthNs_).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_roundResult_.[[Year]], _roundResult_.[[Month]], _roundResult_.[[Day]], _roundResult_.[[Hour]], _roundResult_.[[Minute]], _roundResult_.[[Second]], _roundResult_.[[Millisecond]], _roundResult_.[[Microsecond]], _roundResult_.[[Nanosecond]], ~option~, _offsetNanoseconds_, _timeZoneRec_, *"compatible"*, *"prefer"*, ~match-exactly~).
        1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZoneRec_.[[Receiver]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.equals">
      <h1>Temporal.ZonedDateTime.prototype.equals ( _other_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Set _other_ to ? ToTemporalZonedDateTime(_other_).
        1. If _zonedDateTime_.[[Nanoseconds]] &ne; _other_.[[Nanoseconds]], return *false*.
        1. If ? TimeZoneEquals(_zonedDateTime_.[[TimeZone]], _other_.[[TimeZone]]) is *false*, return *false*.
        1. Return ? CalendarEquals(_zonedDateTime_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tostring">
      <h1>Temporal.ZonedDateTime.prototype.toString ( [ _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToCalendarNameOption reads *"calendarName"*, ToFractionalSecondDigits reads *"fractionalSecondDigits"*, ToShowOffsetOption reads *"offset"*, and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _showCalendar_ be ? ToCalendarNameOption(_options_).
        1. Let _digits_ be ? ToFractionalSecondDigits(_options_).
        1. Let _showOffset_ be ? ToShowOffsetOption(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_options_, *"smallestUnit"*, ~time~, *undefined*).
        1. If _smallestUnit_ is *"hour"*, throw a *RangeError* exception.
        1. Let _showTimeZone_ be ? ToTimeZoneNameOption(_options_).
        1. Let _precision_ be ToSecondsStringPrecisionRecord(_smallestUnit_, _digits_).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, _precision_.[[Precision]], _showCalendar_, _showTimeZone_, _showOffset_, _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tolocalestring">
      <h1>Temporal.ZonedDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>
        The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
      </p>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, *"auto"*, *"auto"*, *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tojson">
      <h1>Temporal.ZonedDateTime.prototype.toJSON ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, *"auto"*, *"auto"*, *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.valueof">
      <h1>Temporal.ZonedDateTime.prototype.valueOf ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-note>
        <p>
          This method always throws, because in the absence of `valueOf()`, expressions with arithmetic operators such as `zonedDateTime1 > zonedDateTime2` would fall back to being equivalent to `zonedDateTime1.toString() > zonedDateTime2.toString()`.
          Lexicographical comparison of serialized strings might not seem obviously wrong, because the result would sometimes be correct.
          Implementations are encouraged to phrase the error message to point users to `Temporal.ZonedDateTime.compare()`, `Temporal.ZonedDateTime.prototype.equals()`, and/or `Temporal.ZonedDateTime.prototype.toString()`.
        </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.startofday">
      <h1>Temporal.ZonedDateTime.prototype.startOfDay ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Let _startDateTime_ be ? CreateTemporalDateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], 0, 0, 0, 0, 0, 0, _calendar_).
        1. Let _startInstant_ be ? GetInstantFor(_timeZoneRec_, _startDateTime_, *"compatible"*).
        1. Return ! CreateTemporalZonedDateTime(_startInstant_.[[Nanoseconds]], _timeZoneRec_,[[Receiver]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toinstant">
      <h1>Temporal.ZonedDateTime.prototype.toInstant ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaindate">
      <h1>Temporal.ZonedDateTime.prototype.toPlainDate ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ! CreateTemporalDate(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaintime">
      <h1>Temporal.ZonedDateTime.prototype.toPlainTime ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. Return ! CreateTemporalTime(_temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaindatetime">
      <h1>Temporal.ZonedDateTime.prototype.toPlainDateTime ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Return ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _zonedDateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplainyearmonth">
      <h1>Temporal.ZonedDateTime.prototype.toPlainYearMonth ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_zonedDateTime_.[[Calendar]], ¬´ ~fields~, ~year-month-from-fields~ ¬ª).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendarRec_.[[Receiver]]).
        1. Let _fieldNames_ be ? CalendarFields(_calendarRec_, ¬´ *"monthCode"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDateTime_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarYearMonthFromFields(_calendarRec_, _fields_).
        1. NOTE: The call to CalendarYearMonthFromFields is necessary in order to create a PlainYearMonth object with the [[ISOYear]], [[ISOMonth]], and [[ISODay]] internal slots set correctly.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplainmonthday">
      <h1>Temporal.ZonedDateTime.prototype.toPlainMonthDay ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_zonedDateTime_.[[Calendar]], ¬´ ~fields~, ~month-day-from-fields~ ¬ª).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendarRec_.[[Receiver]]).
        1. Let _fieldNames_ be ? CalendarFields(_calendarRec_, ¬´ *"day"*, *"monthCode"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDateTime_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarMonthDayFromFields(_calendarRec_, _fields_).
        1. NOTE: The call to CalendarMonthDayFromFields is necessary in order to create a PlainMonthDay object with the [[ISOYear]], [[ISOMonth]], and [[ISODay]] internal slots set correctly.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.getisofields">
      <h1>Temporal.ZonedDateTime.prototype.getISOFields ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _fields_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _instant_).
        1. Let _dateTime_ be ! GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_, _offsetNanoseconds_).
        1. Let _offset_ be FormatUTCOffsetNanoseconds(_offsetNanoseconds_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _calendar_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, ùîΩ(_dateTime_.[[ISODay]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoHour"*, ùîΩ(_dateTime_.[[ISOHour]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMicrosecond"*, ùîΩ(_dateTime_.[[ISOMicrosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMillisecond"*, ùîΩ(_dateTime_.[[ISOMillisecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMinute"*, ùîΩ(_dateTime_.[[ISOMinute]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, ùîΩ(_dateTime_.[[ISOMonth]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoNanosecond"*, ùîΩ(_dateTime_.[[ISONanosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoSecond"*, ùîΩ(_dateTime_.[[ISOSecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, ùîΩ(_dateTime_.[[ISOYear]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"offset"*, _offset_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"timeZone"*, _timeZoneRec_.[[Receiver]]).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.getcalendar">
      <h1>Temporal.ZonedDateTime.prototype.getCalendar ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ToTemporalCalendarObject(_zonedDateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.gettimezone">
      <h1>Temporal.ZonedDateTime.prototype.getTimeZone ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ToTemporalTimeZoneObject(_zonedDateTime_.[[TimeZone]]).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-zoneddatetime-instances">
    <h1>Properties of Temporal.ZonedDateTime Instances</h1>
    <p>
      Temporal.ZonedDateTime instances are ordinary objects that inherit properties from the %Temporal.ZonedDateTime.prototype% intrinsic object.
      Temporal.ZonedDateTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporalzoneddatetime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporalzoneddatetime-instances" caption="Internal Slots of Temporal.ZonedDateTime Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalZonedDateTime]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.ZonedDateTime instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[Nanoseconds]]
            </td>
            <td>
              A BigInt value representing the number of nanoseconds since the epoch.
            </td>
          </tr>
          <tr>
            <td>
              [[TimeZone]]
            </td>
            <td>
              A String or Object representing the time zone.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              A String or Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-zoneddatetime-abstract-ops">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-temporal-interpretisodatetimeoffset" type="abstract operation">
      <h1>
        InterpretISODateTimeOffset (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
          _offsetBehaviour_: one of ~option~, ~exact~, or ~wall~,
          _offsetNanoseconds_: an integer,
          _timeZoneRec_: a Time Zone Methods Record,
          _disambiguation_: one of *"earlier"*, *"later"*, *"compatible"*, or *"reject"*,
          _offsetOption_: one of *"ignore"*, *"use"*, *"prefer"*, or *"reject"*,
          _matchBehaviour_: one of ~match-exactly~ or ~match-minutes~,
        ): either a normal completion containing a BigInt or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          <p>
            It determines the exact time in _timeZone_ corresponding to the given calendar date and time, and the given UTC offset in nanoseconds.
            In the case of more than one possible exact time, or no possible exact time, an answer is determined using _offsetBehaviour_, _disambiguation_ and _offsetOption_.
          </p>
          <p>
            As a special case when parsing ISO 8601 strings which are only required to specify time zone offsets to minutes precision, if _matchBehaviour_ is ~match minutes~, then a value for _offsetNanoseconds_ that is rounded to the nearest minute will be accepted in those cases where _offsetNanoseconds_ is compared against _timeZone_'s offset.
            If _matchBehaviour_ is ~match exactly~, then this does not happen.
          </p>
        </dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Assert: TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-offset-nanoseconds-for~) is *true*.
        1. Assert: TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-possible-instants-for~) is *true*.
        1. Let _dateTime_ be ? CreateTemporalDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, *"iso8601"*).
        1. If _offsetBehaviour_ is ~wall~, or _offsetBehaviour_ is ~option~ and _offsetOption_ is *"ignore"*, then
          1. Let _instant_ be ? GetInstantFor(_timeZoneRec_, _dateTime_, _disambiguation_).
          1. Return _instant_.[[Nanoseconds]].
        1. If _offsetBehaviour_ is ~exact~, or _offsetBehaviour_ is ~option~ and _offsetOption_ is *"use"*, then
          1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _offsetNanoseconds_).
          1. If IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
          1. Return _epochNanoseconds_.
        1. Assert: _offsetBehaviour_ is ~option~.
        1. Assert: _offsetOption_ is *"prefer"* or *"reject"*.
        1. Let _possibleInstants_ be ? GetPossibleInstantsFor(_timeZoneRec_, _dateTime_).
        1. If _possibleInstants_ is not empty, then
          1. For each element _candidate_ of _possibleInstants_, do
            1. Let _candidateNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _candidate_).
            1. If _candidateNanoseconds_ = _offsetNanoseconds_, then
              1. Return _candidate_.[[Nanoseconds]].
            1. If _matchBehaviour_ is ~match-minutes~, then
              1. Let _roundedCandidateNanoseconds_ be RoundNumberToIncrement(_candidateNanoseconds_, 60 &times; 10<sup>9</sup>, *"halfExpand"*).
              1. If _roundedCandidateNanoseconds_ = _offsetNanoseconds_, then
                1. Return _candidate_.[[Nanoseconds]].
        1. If _offsetOption_ is *"reject"*, throw a *RangeError* exception.
        1. Let _instant_ be ? DisambiguatePossibleInstants(_possibleInstants_, _timeZoneRec_, _dateTime_, _disambiguation_).
        1. Return _instant_.[[Nanoseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalzoneddatetime" type="abstract operation">
      <h1>
        ToTemporalZonedDateTime (
          _item_: an ECMAScript language value,
          optional _options_: an Object,
        ): either a normal completion containing a Temporal.ZonedDateTime, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns its argument _item_ if it is already a Temporal.ZonedDateTime instance, converts _item_ to a new Temporal.ZonedDateTime instance if possible, and throws otherwise.
        </dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Let _resolvedOptions_ be ? SnapshotOwnProperties(! GetOptionsObject(_options_), *null*).
        1. Let _offsetBehaviour_ be ~option~.
        1. Let _matchBehaviour_ be ~match-exactly~.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _item_.
          1. Let _calendar_ be ? GetTemporalCalendarSlotValueWithISODefault(_item_).
          1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_calendar_, ¬´ ~date-from-fields~, ~fields~ ¬ª).
          1. Let _fieldNames_ be ? CalendarFields(_calendarRec_, ¬´ *"day"*, *"month"*, *"monthCode"*, *"year"* ¬ª).
          1. Append *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"nanosecond"*, *"offset"*, *"second"*, and *"timeZone"* to _fieldNames_.
          1. Let _fields_ be ? PrepareTemporalFields(_item_, _fieldNames_, ¬´ *"timeZone"* ¬ª).
          1. Let _timeZone_ be ! Get(_fields_, *"timeZone"*).
          1. Set _timeZone_ to ? ToTemporalTimeZoneSlotValue(_timeZone_).
          1. Let _offsetString_ be ! Get(_fields_, *"offset"*).
          1. Assert: _offsetString_ is a String or *undefined*.
          1. If _offsetString_ is *undefined*, then
            1. Set _offsetBehaviour_ to ~wall~.
          1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalDisambiguation reads *"disambiguation"*, ToTemporalOffset reads *"offset"*, and InterpretTemporalDateTimeFields reads *"overflow"*).
          1. Let _disambiguation_ be ? ToTemporalDisambiguation(_resolvedOptions_).
          1. Let _offsetOption_ be ? ToTemporalOffset(_resolvedOptions_, *"reject"*).
          1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendarRec_, _fields_, _resolvedOptions_).
        1. Else,
          1. If _item_ is not a String, throw a *TypeError* exception.
          1. Let _result_ be ? ParseTemporalZonedDateTimeString(_item_).
          1. Let _annotation_ be _result_.[[TimeZone]].[[TimeZoneAnnotation]].
          1. Assert: _annotation_ is not *undefined*.
          1. Let _timeZone_ be ? ToTemporalTimeZoneSlotValue(_annotation_).
          1. Let _offsetString_ be _result_.[[TimeZone]].[[OffsetString]].
          1. If _result_.[[TimeZone]].[[Z]] is *true*, then
            1. Set _offsetBehaviour_ to ~exact~.
          1. Else if _offsetString_ is *undefined*, then
            1. Set _offsetBehaviour_ to ~wall~.
          1. Let _calendar_ be _result_.[[Calendar]].
          1. If _calendar_ is *undefined*, set _calendar_ to *"iso8601"*.
          1. If IsBuiltinCalendar(_calendar_) is *false*, throw a *RangeError* exception.
          1. Set _calendar_ to the ASCII-lowercase of _calendar_.
          1. Set _matchBehaviour_ to ~match-minutes~.
          1. Let _disambiguation_ be ? ToTemporalDisambiguation(_resolvedOptions_).
          1. Let _offsetOption_ be ? ToTemporalOffset(_resolvedOptions_, *"reject"*).
          1. Perform ? ToTemporalOverflow(_resolvedOptions_).
        1. Let _offsetNanoseconds_ be 0.
        1. If _offsetBehaviour_ is ~option~, then
          1. Set _offsetNanoseconds_ to ? ParseDateTimeUTCOffset(_offsetString_).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_timeZone_, ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _offsetBehaviour_, _offsetNanoseconds_, _timeZoneRec_, _disambiguation_, _offsetOption_, _matchBehaviour_).
        1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalzoneddatetime" type="abstract operation">
      <h1>
        CreateTemporalZonedDateTime (
          _epochNanoseconds_: a BigInt,
          _timeZone_: a String or Object,
          _calendar_: a String or Object,
          optional _newTarget_: a constructor,
        ): either a normal completion containing a Temporal.ZonedDateTime, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Temporal.ZonedDateTime instance and fills the internal slots with valid values.</dd>
      </dl>
      <emu-alg>
        1. Assert: ! IsValidEpochNanoseconds(_epochNanoseconds_) is *true*.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.ZonedDateTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.ZonedDateTime.prototype%"*, ¬´ [[InitializedTemporalZonedDateTime]], [[Nanoseconds]], [[TimeZone]], [[Calendar]] ¬ª).
        1. Set _object_.[[Nanoseconds]] to _epochNanoseconds_.
        1. Set _object_.[[TimeZone]] to _timeZone_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporalzoneddatetimetostring" type="abstract operation">
      <h1>
        TemporalZonedDateTimeToString (
          _zonedDateTime_: a Temporal.ZonedDateTime,
          _precision_: one of *"auto"*, *"minute"*, or an integer between 0 and 9 inclusive,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
          _showTimeZone_: one of *"auto"*, *"never"*, or *"critical"*,
          _showOffset_: one of *"auto"* or *"never"*,
          optional _increment_: an integer,
          optional _unit_: one of *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, or *"nanosecond"*,
          optional _roundingMode_: a String from the Identifier column of <emu-xref href="#table-temporal-rounding-modes"></emu-xref>,
        ): either a normal completion containing a String or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns an ISO 8601 string representation of its argument, including a time zone name annotation and calendar annotation, which are extensions to the ISO 8601 format.
        </dd>
      </dl>
      <emu-alg>
        1. If _increment_ is not present, set _increment_ to 1.
        1. If _unit_ is not present, set _unit_ to *"nanosecond"*.
        1. If _roundingMode_ is not present, set _roundingMode_ to *"trunc"*.
        1. Let _ns_ be RoundTemporalInstant(_zonedDateTime_.[[Nanoseconds]], _increment_, _unit_, _roundingMode_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_ns_).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_timeZone_, ¬´ ~get-offset-nanoseconds-for~ ¬ª).
        1. Let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZoneRec_, _instant_).
        1. Let _temporalDateTime_ be ! GetPlainDateTimeFor(_timeZoneRec_, _instant_, *"iso8601"*, _offsetNanoseconds_).
        1. Let _dateTimeString_ be ! TemporalDateTimeToString(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], *"iso8601"*, _precision_, *"never"*).
        1. If _showOffset_ is *"never"*, then
          1. Let _offsetString_ be the empty String.
        1. Else,
          1. Let _offsetString_ be FormatDateTimeUTCOffsetRounded(_offsetNanoseconds_).
        1. If _showTimeZone_ is *"never"*, then
          1. Let _timeZoneString_ be the empty String.
        1. Else,
          1. Let _timeZoneIdentifier_ be ? ToTemporalTimeZoneIdentifier(_timeZone_).
          1. If _showTimeZone_ is *"critical"*, let _flag_ be *"!"*; else let _flag_ be the empty String.
          1. Let _timeZoneString_ be the string-concatenation of the code unit 0x005B (LEFT SQUARE BRACKET), _flag_, _timeZoneIdentifier_, and the code unit 0x005D (RIGHT SQUARE BRACKET).
        1. Let _calendarString_ be ? MaybeFormatCalendarAnnotation(_zonedDateTime_.[[Calendar]], _showCalendar_).
        1. Return the string-concatenation of _dateTimeString_, _offsetString_, _timeZoneString_, and _calendarString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addzoneddatetime" type="abstract operation">
      <h1>
        AddZonedDateTime (
          _epochNanoseconds_: a BigInt,
          _timeZoneRec_: a Time Zone Methods Record,
          _calendarRec_: a Calendar Methods Record,
          _years_: an integer,
          _months_: an integer,
          _weeks_: an integer,
          _days_: an integer,
          _norm_: a Normalized Time Duration Record,
          optional _precalculatedPlainDateTime_: a Temporal.PlainDateTime or *undefined*,
          optional _options_: an Object,
        ): either a normal completion containing a BigInt or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds a duration in various units to a number of nanoseconds _epochNanoseconds_ since the epoch, subject to the rules of the time zone and calendar, and returns the result as a BigInt value.
          As specified in <a href="https://tools.ietf.org/html/rfc5545">RFC 5545</a>, the date portion of the duration is added in calendar days, and the time portion is added in exact time.
        </dd>
      </dl>
      <p>Unless _precalculatedPlainDateTime_ is supplied, the given _timeZone_'s `getOffsetNanosecondsFor` method will be called to convert _epochNanoseconds_ to a wall-clock time, and _timeZoneRec_ must have looked up `getOffsetNanosecondsFor`. `getPossibleInstantsFor` will always be called and must have been looked up.</p>
      <emu-alg>
        1. Assert: TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-possible-instants-for~) is *true*.
        1. If _precalculatedPlainDateTime_ is not present, set _precalculatedPlainDateTime_ to *undefined*.
        1. Assert: If _precalculatedPlainDateTime_ is *undefined*, TimeZoneMethodsRecordHasLookedUp(_timeZoneRec_, ~get-offset-nanoseconds-for~) is *true*.
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Assert: Type(_options_) is Object or Undefined.
        1. If _years_ = 0, _months_ = 0, _weeks_ = 0, and _days_ = 0, then
          1. Return ? AddInstant(_epochNanoseconds_, _norm_).
        1. Let _instant_ be ! CreateTemporalInstant(_epochNanoseconds_).
        1. If _precalculatedPlainDateTime_ is not *undefined*, then
          1. Let _temporalDateTime_ be _precalculatedPlainDateTime_.
        1. Else,
          1. Let _temporalDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendarRec_.[[Receiver]]).
        1. If _years_ = 0, and _months_ = 0, and _weeks_ = 0, then
          1. Let _overflow_ be ? ToTemporalOverflow(_options_).
          1. Let _intermediate_ be ? AddDaysToZonedDateTime(_instant_, _temporalDateTime_, _timeZoneRec_, _calendarRec_.[[Receiver]], _days_, _overflow_).[[EpochNanoseconds]].
          1. Return ? AddInstant(_intermediate_, _norm_).
        1. Assert: CalendarMethodsRecordHasLookedUp(_calendarRec_, ~date-add~) is *true*.
        1. Let _datePart_ be ! CreateTemporalDate(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _calendarRec_.[[Receiver]]).
        1. Let _dateDuration_ be ! CreateTemporalDuration(_years_, _months_, _weeks_, _days_, 0, 0, 0, 0, 0, 0).
        1. Let _addedDate_ be ? CalendarDateAdd(_calendarRec_, _datePart_, _dateDuration_, _options_).
        1. Let _intermediateDateTime_ be ? CreateTemporalDateTime(_addedDate_.[[ISOYear]], _addedDate_.[[ISOMonth]], _addedDate_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], _calendarRec_.[[Receiver]]).
        1. Let _intermediateInstant_ be ? GetInstantFor(_timeZoneRec_, _intermediateDateTime_, *"compatible"*).
        1. Return ? AddInstant(_intermediateInstant_.[[Nanoseconds]], _norm_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-adddaystozoneddatetime" type="abstract operation">
      <h1>
        AddDaysToZonedDateTime (
          _instant_: a Temporal.Instant,
          _dateTime_: a Temporal.PlainDateTime,
          _timeZoneRec_: a Time Zone Methods Record,
          _calendar_: a String or Object,
          _days_: an integer,
          optional _overflow_: *"constrain"* or *"reject"*,
        ): either a normal completion containing a Record, or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The returned Record has fields [[EpochNanoseconds]] (a BigInt), [[Instant]] (a Temporal.Instant), and [[DateTime]] (a Temporal.PlainDateTime).
        </dd>
      </dl>
      <p>
        This operation is similar to AddZonedDateTime, but adds only a number of days instead of a full duration, which allows performing fewer observable operations.
      </p>
      <emu-alg>
        1. Assert: If TimeZoneMethodsRecordIsBuiltin(_timeZoneRec_) is *true*, _dateTime_'s internal slots are the same as those of the Object returned from ! GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendar_).
        1. If _overflow_ is not present, set _overflow_ to *"constrain"*.
        1. If _days_ = 0, then
          1. Return the Record {
              [[EpochNanoseconds]]: _instant_.[[Nanoseconds]],
              [[Instant]]: _instant_,
              [[DateTime]]: _dateTime_
            }.
        1. Let _addedDate_ be ? AddISODate(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], 0, 0, 0, _days_, _overflow_).
        1. Let _dateTimeResult_ be ? CreateTemporalDateTime(_addedDate_.[[Year]], _addedDate_.[[Month]], _addedDate_.[[Day]], _dateTime_.[[ISOHour]], _dateTime_.[[ISOMinute]], _dateTime_.[[ISOSecond]], _dateTime_.[[ISOMillisecond]], _dateTime_.[[ISOMicrosecond]], _dateTime_.[[ISONanosecond]], _calendar_).
        1. Let _instantResult_ be ? GetInstantFor(_timeZoneRec_, _dateTimeResult_, *"compatible"*).
        1. Return the Record {
            [[EpochNanoseconds]]: _instantResult_.[[Nanoseconds]],
            [[Instant]]: _instantResult_,
            [[DateTime]]: _dateTimeResult_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencezoneddatetime" type="abstract operation">
      <h1>
        DifferenceZonedDateTime (
          _ns1_: a BigInt,
          _ns2_: a BigInt,
          _timeZoneRec_: a Time Zone Methods Record,
          _calendarRec_: a Calendar Methods Record,
          _largestUnit_: a String,
          _options_: an ordinary Object for which the value of the [[Prototype]] internal slot is *null* and every property is a data property,
          _precalculatedPlainDateTime_: a Temporal.PlainDateTime or *undefined*,
        ): either a normal completion containing a Normalized Duration Record, or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It computes the difference between two exact times expressed in nanoseconds since the epoch, and balances the result so that there is no non-zero unit larger than _largestUnit_ in the result, taking calendar reckoning and time zone offset changes into account.
        </dd>
      </dl>
      <p>Unless _ns1_ and _ns2_ are equal, _timeZoneRec_ must have looked up both `getOffsetNanosecondsFor` and `getPossibleInstantsFor`.</p>
      <emu-alg>
        1. If _ns1_ is _ns2_, then
          1. Return ! CreateNormalizedDurationRecord(0, 0, 0, 0, ZeroTimeDuration()).
        1. If _precalculatedPlainDateTime_ is *undefined*, then
          1. Let _startInstant_ be ! CreateTemporalInstant(_ns1_).
          1. Let _startDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _startInstant_, _calendarRec_.[[Receiver]]).
        1. Else,
          1. Let _startDateTime_ be _precalculatedPlainDateTime_.
        1. Let _endInstant_ be ! CreateTemporalInstant(_ns2_).
        1. Let _endDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _endInstant_, _calendarRec_.[[Receiver]]).
        1. If _ns2_ - _ns1_ &lt; 0, let _sign_ be -1; else let _sign_ be 1.
        1. If _sign_ = 1, let _maxTries_ be 3; else let _maxTries_ be 2.
        1. Let _dayCorrection_ be 0.
        1. Repeat _maxTries_ times:
          1. Let _correctedEndDate_ be BalanceISODate(_endDateTime_.[[ISOYear]], _endDateTime_.[[ISOMonth]], _endDateTime_.[[ISODay]] - _dayCorrection_ &times; _sign_).
          1. Let _intermediateDateTime_ be ! CreateTemporalDateTime(_correctedEndDate_.[[Year]], _correctedEndDate_.[[Month]], _correctedEndDate_.[[Day]], _startDateTime_.[[ISOHour]], _startDateTime_.[[ISOMinute]], _startDateTime_.[[ISOSecond]], _startDateTime_.[[ISOMillisecond]], _startDateTime_.[[ISOMicrosecond]], _startDateTime_.[[ISONanosecond]], _calendarRec_.[[Receiver]]).
          1. Let _intermediate_ be ? GetInstantFor(_timeZoneRec_, _intermediateDateTime_, *"compatible"*).
          1. Let _intermediateNs_ be _intermediate_.[[Nanoseconds]].
          1. Let _norm_ be NormalizedTimeDurationFromEpochNanosecondsDifference(_ns2_, _intermediateNs_).
          1. Let _timeSign_ be NormalizedTimeDurationSign(_norm_).
          1. If _sign_ = 0, or _timeSign_ = 0, or _sign_ = _timeSign_, then
            1. Let _date1_ be ! CreateTemporalDate(_startDateTime_.[[ISOYear]], _startDateTime_.[[ISOMonth]], _startDateTime_.[[ISODay]], _calendarRec_.[[Receiver]]).
            1. Let _date2_ be ! CreateTemporalDate(_correctedEndDate_.[[Year]], _correctedEndDate_.[[Month]], _correctedEndDate_.[[Day]], _calendarRec_.[[Receiver]]).
            1. Let _dateLargestUnit_ be LargerOfTwoTemporalUnits(_largestUnit_, *"day"*).
            1. Let _untilOptions_ be ? SnapshotOwnProperties(_options_, *null*).
            1. Perform ! CreateDataPropertyOrThrow(_untilOptions_, *"largestUnit"*, _dateLargestUnit_).
            1. Let _dateDifference_ be ? DifferenceDate(_calendarRec_, _date1_, _date2_, _untilOptions_).
            1. Return ? CreateNormalizedDurationRecord(_dateDifference_.[[Years]], _dateDifference_.[[Months]], _dateDifference_.[[Weeks]], _dateDifference_.[[Days]], _norm_).
          1. Set _dayCorrection_ to _dayCorrection_ + 1.
        1. NOTE: This step is only reached when custom calendar or time zone methods return inconsistent values.
        1. Throw a *RangeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-normalizedtimedurationtodays" type="abstract operation">
      <h1>
        NormalizedTimeDurationToDays (
          _norm_: a Normalized Time Duration Record,
          _zonedRelativeTo_: a Temporal.ZonedDateTime,
          _timeZoneRec_: a Time Zone Methods Record,
          optional _precalculatedPlainDateTime_: a Temporal.PlainDateTime,
        ): either a normal completion containing a Record with fields [[Days]] (an integer), [[Remainder]] (a Normalized Time Duration Record), and [[DayLength]] (an integer), or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It converts a normalized time duration _norm_ relative to a Temporal.ZonedDateTime _zonedRelativeTo_ into a number of days and a remainder normalized time duration, taking into account any offset changes in the time zone of _zonedRelativeTo_.
          It also returns the length of the last day in nanoseconds, for rounding purposes.
        </dd>
      </dl>
      <p>Unless _nanoseconds_ = 0, _timeZoneRec_ must have looked up both `getOffsetNanosecondsFor` and `getPossibleInstantsFor`.</p>
      <emu-alg>
        1. Let _sign_ be NormalizedTimeDurationSign(_norm_).
        1. If _sign_ = 0, then
          1. Return the Record { [[Days]]: 0, [[Remainder]]: _norm_, [[DayLength]]: nsPerDay }.
        1. Let _startNs_ be _zonedRelativeTo_.[[Nanoseconds]].
        1. Let _startInstant_ be ! CreateTemporalInstant(_startNs_).
        1. Let _endNs_ be ? AddInstant(_startNs_, _norm_).
        1. Let _endInstant_ be ! CreateTemporalInstant(_endNs_).
        1. If _precalculatedPlainDateTime_ is present, let _startDateTime_ be _precalculatedPlainDateTime_; else let _startDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _startInstant_, *"iso8601"*).
        1. Let _endDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _endInstant_, *"iso8601"*).
        1. Let _date1_ be ! CreateTemporalDate(_startDateTime_.[[ISOYear]], _startDateTime_.[[ISOMonth]], _startDateTime_.[[ISODay]], *"iso8601"*).
        1. Let _date2_ be ! CreateTemporalDate(_endDateTime_.[[ISOYear]], _endDateTime_.[[ISOMonth]], _endDateTime_.[[ISODay]], *"iso8601"*).
        1. Let _days_ be DaysUntil(_date1_, _date2_).
        1. Let _timeSign_ be CompareTemporalTime(_startDateTime_.[[ISOHour]], _startDateTime_.[[ISOMinute]], _startDateTime_.[[ISOSecond]], _startDateTime_.[[ISOMillisecond]], _startDateTime_.[[ISOMicrosecond]], _startDateTime_.[[ISONanosecond]], _endDateTime_.[[ISOHour]], _endDateTime_.[[ISOMinute]], _endDateTime_.[[ISOSecond]], _endDateTime_.[[ISOMillisecond]], _endDateTime_.[[ISOMicrosecond]], _endDateTime_.[[ISONanosecond]]).
        1. If _days_ &gt; 0 and _timeSign_ &gt; 0, then
          1. Set _days_ to _days_ - 1.
        1. Else if _days_ &lt; 0 and _timeSign_ &lt; 0, then
          1. Set _days_ to _days_ + 1.
        1. Let _relativeResult_ be ? AddDaysToZonedDateTime(_startInstant_, _startDateTime_, _timeZoneRec_, _zonedRelativeTo_.[[Calendar]], _days_).
        1. If _sign_ = 1, and _days_ &gt; 0, and ‚Ñù(_relativeResult_.[[EpochNanoseconds]]) &gt; _endNs_, then
          1. Set _days_ to _days_ - 1.
          1. Set _relativeResult_ to ? AddDaysToZonedDateTime(_startInstant_, _startDateTime_, _timeZoneRec_, _zonedRelativeTo_.[[Calendar]], _days_).
          1. If _days_ &gt; 0 and ‚Ñù(_relativeResult_.[[EpochNanoseconds]]) &gt; _endNs_, throw a *RangeError* exception.
        1. Set _norm_ to NormalizedTimeDurationFromEpochNanosecondsDifference(_endNs_, _relativeResult_.[[EpochNanoseconds]]).
        1. Let _oneDayFarther_ be ? AddDaysToZonedDateTime(_relativeResult_.[[Instant]], _relativeResult_.[[DateTime]], _timeZoneRec_, _zonedRelativeTo_.[[Calendar]], _sign_).
        1. Let _dayLengthNs_ be NormalizedTimeDurationFromEpochNanosecondsDifference(_oneDayFarther_.[[EpochNanoseconds]], _relativeResult_.[[EpochNanoseconds]]).
        1. Let _oneDayLess_ be ! SubtractNormalizedTimeDuration(_norm_, _dayLengthNs_).
        1. If NormalizedTimeDurationSign(_oneDayLess_) &times; _sign_ &ge; 0, then
          1. Set _norm_ to _oneDayLess_.
          1. Set _relativeResult_ to _oneDayFarther_.
          1. Set _days_ to _days_ + _sign_.
          1. Set _oneDayFarther_ to ? AddDaysToZonedDateTime(_relativeResult_.[[Instant]], _relativeResult_.[[DateTime]], _timeZoneRec_, _zonedRelativeTo_.[[Calendar]], _sign_).
          1. Set _dayLengthNs_ to NormalizedTimeDurationFromEpochNanosecondsDifference(_oneDayFarther_.[[EpochNanoseconds]], _relativeResult_.[[EpochNanoseconds]]).
          1. If NormalizedTimeDurationSign(! SubtractNormalizedTimeDuration(_norm_, _dayLengthNs_)) &times; _sign_ &ge; 0, then
            1. Throw a *RangeError* exception.
        1. If _days_ &lt; 0 and _sign_ = 1, throw a *RangeError* exception.
        1. If _days_ &gt; 0 and _sign_ = -1, throw a *RangeError* exception.
        1. If _sign_ = -1, then
          1. If NormalizedTimeDurationSign(_norm_) = 1, throw a *RangeError* exception.
        1. Else,
          1. Assert: NormalizedTimeDurationSign(_norm_) &geq; 0.
        1. Assert: CompareNormalizedTimeDuration(NormalizedTimeDurationAbs(_norm_), NormalizedTimeDurationAbs(_dayLengthNs_)) = -1.
        1. Let _dayLength_ be abs(‚Ñù(_dayLengthNs_.[[TotalNanoseconds]])).
        1. If _dayLength_ &ge; 2<sup>53</sup>, throw a *RangeError* exception.
        1. Assert: abs(_days_) &lt; 2<sup>53</sup> / (HoursPerDay &times; MinutesPerHour &times; SecondsPerMinute).
        1. Return the Record {
          [[Days]]: _days_,
          [[Remainder]]: _norm_,
          [[DayLength]]: _dayLength_
          }.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-differencetemporalzoneddatetime" type="abstract operation">
      <h1>
        DifferenceTemporalZonedDateTime (
          _operation_: ~until~ or ~since~,
          _zonedDateTime_: a Temporal.ZonedDateTime,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _zonedDateTime_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~since~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Set _other_ to ? ToTemporalZonedDateTime(_other_).
        1. If ? CalendarEquals(_zonedDateTime_.[[Calendar]], _other_.[[Calendar]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. Let _resolvedOptions_ be ? SnapshotOwnProperties(? GetOptionsObject(_options_), *null*).
        1. Let _settings_ be ? GetDifferenceSettings(_operation_, _resolvedOptions_, ~datetime~, &laquo; &raquo;, *"nanosecond"*, *"hour"*).
        1. If _settings_.[[LargestUnit]] is not one of *"year"*, *"month"*, *"week"*, or *"day"*, then
          1. Let _norm_ be DifferenceInstant(_zonedDateTime_.[[Nanoseconds]], _other_.[[Nanoseconds]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]]).
          1. Let _result_ be BalanceTimeDuration(_norm_, _settings_.[[LargestUnit]]).
          1. Return ! CreateTemporalDuration(0, 0, 0, 0, _sign_ &times; _result_.[[Hours]], _sign_ &times; _result_.[[Minutes]], _sign_ &times; _result_.[[Seconds]], _sign_ &times; _result_.[[Milliseconds]], _sign_ &times; _result_.[[Microseconds]], _sign_ &times; _result_.[[Nanoseconds]]).
        1. NOTE: To calculate differences in two different time zones, _settings_.[[LargestUnit]] must be *"hour"* or smaller, because day lengths can vary between time zones due to DST and other UTC offset shifts.
        1. If ? TimeZoneEquals(_zonedDateTime_.[[TimeZone]], _other_.[[TimeZone]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. If _zonedDateTime_.[[Nanoseconds]] = _other_.[[Nanoseconds]], then
          1. Return ! CreateTemporalDuration(0, 0, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_zonedDateTime_.[[Calendar]], ¬´ ~date-add~, ~date-until~ ¬ª).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _precalculatedPlainDateTime_ be ? GetPlainDateTimeFor(_timeZoneRec_, _instant_, _calendarRec_.[[Receiver]]).
        1. Let _plainRelativeTo_ be ! CreateTemporalDate(_precalculatedPlainDateTime_.[[ISOYear]], _precalculatedPlainDateTime_.[[ISOMonth]], _precalculatedPlainDateTime_.[[ISODay]], _calendarRec_.[[Receiver]]).
        1. Let _result_ be ? DifferenceZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _other_.[[Nanoseconds]], _timeZoneRec_, _calendarRec_, _settings_.[[LargestUnit]], _resolvedOptions_, _precalculatedPlainDateTime_).
        1. If _settings_.[[SmallestUnit]] is *"nanosecond"* and _settings_.[[RoundingIncrement]] is 1, let _roundingGranularityIsNoop_ be *true*; else let _roundingGranularityIsNoop_ be *false*.
        1. If _roundingGranularityIsNoop_ is *false*, then
          1. Let _roundRecord_ be ? RoundDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], _result_.[[NormalizedTime]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]], _plainRelativeTo_, _calendarRec_, _zonedDateTime_, _timeZoneRec_, _precalculatedPlainDateTime_).
          1. Let _roundResult_ be _roundRecord_.[[NormalizedDuration]].
          1. Let _daysResult_ be ! NormalizedTimeDurationToDays(_roundResult_.[[NormalizedTime]], _zonedDateTime_, _timeZoneRec_).
          1. Let _days_ be _roundResult_.[[Days]] + _daysResult_.[[Days]].
          1. Let _adjustResult_ be ? AdjustRoundedDurationDays(_roundResult_.[[Years]], _roundResult_.[[Months]], _roundResult_.[[Weeks]], _days_, _daysResult_.[[NormalizedTime]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]], _zonedDateTime_, _calendarRec_, _timeZoneRec_, _precalculatedPlainDateTime_).
          1. Let _balanceResult_ be ? BalanceDateDurationRelative(_adjustResult_.[[Years]], _adjustResult_.[[Months]], _adjustResult_.[[Weeks]], _adjustResult_.[[Days]], _settings_.[[LargestUnit]], _settings_.[[SmallestUnit]], _plainRelativeTo_, _calendarRec_).
          1. Set _result_ to ? CombineDateAndNormalizedTimeDuration(_balanceResult_, _adjustResult_.[[NormalizedTime]]).
        1. Let _timeResult_ be BalanceTimeDuration(_result_.[[NormalizedTime]], *"hour"*).
        1. Return ! CreateTemporalDuration(_sign_ &times; _result_.[[Years]], _sign_ &times; _result_.[[Months]], _sign_ &times; _result_.[[Weeks]], _sign_ &times; _result_.[[Days]], _sign_ &times; _timeResult_.[[Hours]], _sign_ &times; _timeResult_.[[Minutes]], _sign_ &times; _timeResult_.[[Seconds]], _sign_ &times; _timeResult_.[[Milliseconds]], _sign_ &times; _timeResult_.[[Microseconds]], _sign_ &times; _timeResult_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-adddurationtoOrsubtractdurationfromzoneddatetime" type="abstract operation">
     <h1>
        AddDurationToOrSubtractDurationFromZonedDateTime (
          _operation_: ~add~ or ~subtract~,
          _zonedDateTime_: a Temporal.ZonedDateTime,
          _temporalDurationLike_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.ZonedDateTime or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds/subtracts _temporalDurationLike_ to/from _zonedDateTime_.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~subtract~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Let _duration_ be ? ToTemporalDurationRecord(_temporalDurationLike_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _timeZoneRec_ be ? CreateTimeZoneMethodsRecord(_zonedDateTime_.[[TimeZone]], ¬´ ~get-offset-nanoseconds-for~, ~get-possible-instants-for~ ¬ª).
        1. Let _calendarRec_ be ? CreateCalendarMethodsRecord(_zonedDateTime_.[[Calendar]], ¬´ ~date-add~ ¬ª).
        1. Let _norm_ be NormalizeTimeDuration(_sign_ &times; _duration_.[[Hours]], _sign_ &times; _duration_.[[Minutes]], _sign_ &times; _duration_.[[Seconds]], _sign_ &times; _duration_.[[Milliseconds]], _sign_ &times; _duration_.[[Microseconds]], _sign_ &times; _duration_.[[Nanoseconds]]).
        1. Let _epochNanoseconds_ be ? AddZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _timeZoneRec_, _calendarRec_, _sign_ &times; _duration_.[[Years]], _sign_ &times; _duration_.[[Months]], _sign_ &times; _duration_.[[Weeks]], _sign_ &times; _duration_.[[Days]], _norm_, *undefined*, _options_).
        1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZoneRec_.[[Receiver]], _calendarRec_.[[Receiver]]).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
