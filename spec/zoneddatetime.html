<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-zoneddatetime-objects">
  <h1>Temporal.ZonedDateTime Objects</h1>
  <p>
    A Temporal.ZonedDateTime object is an Object referencing a fixed point in time with nanoseconds precision, and containing Object values corresponding to a particular time zone and calendar system.
  </p>

  <emu-clause id="sec-temporal-zoneddatetime-constructor">
    <h1>The Temporal.ZonedDateTime Constructor</h1>
    <p>The Temporal.ZonedDateTime constructor:</p>
    <ul>
      <li>
        creates and initializes a new Temporal.ZonedDateTime object when called as a constructor.
      </li>
      <li>
        is not intended to be called as a function and will throw an exception when called in that manner.
      </li>
      <li>
        may be used as the value of an `extends` clause of a class definition.
        Subclass constructors that intend to inherit the specified Temporal.ZonedDateTime behaviour must
        include a super call to the %Temporal.ZonedDateTime% constructor to create and initialize subclass
        instances with the necessary internal slots.
      </li>
    </ul>

    <emu-clause id="sec-temporal.zoneddatetime">
      <h1>Temporal.ZonedDateTime ( _epochNanoseconds_, _timeZoneLike_ [ , _calendarLike_ ] )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _epochNanoseconds_ to ? ToBigInt(_epochNanoseconds_).
        1. If ! IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Let _timeZone_ be ? ToTemporalTimeZone(_timeZoneLike_).
        1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_calendarLike_).
        1. Return ? CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-zoneddatetime-constructor">
    <h1>Properties of the Temporal.ZonedDateTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.ZonedDateTime constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.ZonedDateTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal.zoneddatetime.prototype">
      <h1>Temporal.ZonedDateTime.prototype</h1>
      <p>The initial value of `Temporal.ZonedDateTime.prototype` is %Temporal.ZonedDateTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.from">
      <h1>Temporal.ZonedDateTime.from ( _item_ [ , _options_ ] )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
          1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalDisambiguation reads *"disambiguation"*, ToTemporalOffset reads *"offset"*, and ToTemporalOverflow reads *"overflow"*).
          1. Perform ? ToTemporalDisambiguation(_options_).
          1. Perform ? ToTemporalOffset(_options_, *"reject"*).
          1. Perform ? ToTemporalOverflow(_options_).
          1. Return ! CreateTemporalZonedDateTime(_item_.[[Nanoseconds]], _item_.[[TimeZone]], _item_.[[Calendar]]).
        1. Return ? ToTemporalZonedDateTime(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.compare">
      <h1>Temporal.ZonedDateTime.compare ( _one_, _two_ )</h1>
      <p>
        This function performs the following steps when called:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalZonedDateTime(_one_).
        1. Set _two_ to ? ToTemporalZonedDateTime(_two_).
        1. Return ùîΩ(! CompareEpochNanoseconds(_one_.[[Nanoseconds]], _two_.[[Nanoseconds]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-zoneddatetime-prototype-object">
    <h1>Properties of the Temporal.ZonedDateTime Prototype Object</h1>

    <p>The Temporal.ZonedDateTime prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.ZonedDateTime instance and does not have a [[InitializedTemporalZonedDateTime]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.constructor">
      <h1>Temporal.ZonedDateTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.ZonedDateTime.prototype.constructor` is %Temporal.ZonedDateTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype-@@tostringtag">
      <h1>Temporal.ZonedDateTime.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.ZonedDateTime"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.calendar">
      <h1>get Temporal.ZonedDateTime.prototype.calendar</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.calendar` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return _zonedDateTime_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.timezone">
      <h1>get Temporal.ZonedDateTime.prototype.timeZone</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.timeZone` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return _zonedDateTime_.[[TimeZone]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.year">
      <h1>get Temporal.ZonedDateTime.prototype.year</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.month">
      <h1>get Temporal.ZonedDateTime.prototype.month</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarMonth(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.monthcode">
      <h1>get Temporal.ZonedDateTime.prototype.monthCode</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.monthCode` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarMonthCode(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.day">
      <h1>get Temporal.ZonedDateTime.prototype.day</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDay(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.hour">
      <h1>get Temporal.ZonedDateTime.prototype.hour</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOHour]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.minute">
      <h1>get Temporal.ZonedDateTime.prototype.minute</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMinute]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.second">
      <h1>get Temporal.ZonedDateTime.prototype.second</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOSecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.millisecond">
      <h1>get Temporal.ZonedDateTime.prototype.millisecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMillisecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.microsecond">
      <h1>get Temporal.ZonedDateTime.prototype.microsecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMicrosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.nanosecond">
      <h1>get Temporal.ZonedDateTime.prototype.nanosecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochSeconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochSeconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _s_ be floor(‚Ñù(_ns_) / 10<sup>9</sup>).
        1. Return ùîΩ(_s_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochmilliseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochMilliseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochMilliseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _ms_ be floor(‚Ñù(_ns_) / 10<sup>6</sup>).
        1. Return ùîΩ(_ms_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochmicroseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochMicroseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochMicroseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _¬µs_ be floor(‚Ñù(_ns_) / 10<sup>3</sup>).
        1. Return ‚Ñ§(_¬µs_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochnanoseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochNanoseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochNanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return _zonedDateTime_.[[Nanoseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.dayofweek">
      <h1>get Temporal.ZonedDateTime.prototype.dayOfWeek</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDayOfWeek(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.dayofyear">
      <h1>get Temporal.ZonedDateTime.prototype.dayOfYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDayOfYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.weekofyear">
      <h1>get Temporal.ZonedDateTime.prototype.weekOfYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarWeekOfYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.yearofweek">
      <h1>get Temporal.ZonedDateTime.prototype.yearOfWeek</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.yearOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarYearOfWeek(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.hoursinday">
      <h1>get Temporal.ZonedDateTime.prototype.hoursInDay</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.hoursInDay` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _isoCalendar_ be ! GetISO8601Calendar().
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _isoCalendar_).
        1. Let _year_ be _temporalDateTime_.[[ISOYear]].
        1. Let _month_ be _temporalDateTime_.[[ISOMonth]].
        1. Let _day_ be _temporalDateTime_.[[ISODay]].
        1. Let _today_ be ? CreateTemporalDateTime(_year_, _month_, _day_, 0, 0, 0, 0, 0, 0, _isoCalendar_).
        1. Let _tomorrowFields_ be BalanceISODate(_year_, _month_, _day_ + 1).
        1. Let _tomorrow_ be ? CreateTemporalDateTime(_tomorrowFields_.[[Year]], _tomorrowFields_.[[Month]], _tomorrowFields_.[[Day]], 0, 0, 0, 0, 0, 0, _isoCalendar_).
        1. Let _todayInstant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _today_, *"compatible"*).
        1. Let _tomorrowInstant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _tomorrow_, *"compatible"*).
        1. Let _diffNs_ be _tomorrowInstant_.[[Nanoseconds]] - _todayInstant_.[[Nanoseconds]].
        1. Return ùîΩ(_diffNs_ / (3.6 &times; 10<sup>12</sup>)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinweek">
      <h1>get Temporal.ZonedDateTime.prototype.daysInWeek</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDaysInWeek(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinmonth">
      <h1>get Temporal.ZonedDateTime.prototype.daysInMonth</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDaysInMonth(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinyear">
      <h1>get Temporal.ZonedDateTime.prototype.daysInYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarDaysInYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.monthsinyear">
      <h1>get Temporal.ZonedDateTime.prototype.monthsInYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(? CalendarMonthsInYear(_calendar_, _temporalDateTime_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.inleapyear">
      <h1>get Temporal.ZonedDateTime.prototype.inLeapYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarInLeapYear(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.offsetnanoseconds">
      <h1>get Temporal.ZonedDateTime.prototype.offsetNanoseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.offsetNanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Return ùîΩ(? GetOffsetNanosecondsFor(_timeZone_, _instant_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.offset">
      <h1>get Temporal.ZonedDateTime.prototype.offset</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.offset` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Return ? BuiltinTimeZoneGetOffsetStringFor(_zonedDateTime_.[[TimeZone]], _instant_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.with">
      <h1>Temporal.ZonedDateTime.prototype.with ( _temporalZonedDateTimeLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. If Type(_temporalZonedDateTimeLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Perform ? RejectObjectWithCalendarOrTimeZone(_temporalZonedDateTimeLike_).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"monthCode"*, *"nanosecond"*, *"second"*, *"year"* ¬ª).
        1. Append *"offset"* to _fieldNames_.
        1. Let _partialZonedDateTime_ be ? PrepareTemporalFields(_temporalZonedDateTimeLike_, _fieldNames_, ~partial~).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Append *"timeZone"* to _fieldNames_.
        1. Let _fields_ be ? PrepareTemporalFields(_zonedDateTime_, _fieldNames_, ¬´ *"timeZone"*, *"offset"* ¬ª).
        1. Set _fields_ to ? CalendarMergeFields(_calendar_, _fields_, _partialZonedDateTime_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, ¬´ *"timeZone"*, *"offset"* ¬ª).
        1. Let _offsetString_ be ! Get(_fields_, *"offset"*).
        1. Assert: Type(_offsetString_) is String.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalDisambiguation reads *"disambiguation"*, ToTemporalOffset reads *"offset"*, and InterpretTemporalDateTimeFields reads *"overflow"*).
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
        1. Let _offset_ be ? ToTemporalOffset(_options_, *"prefer"*).
        1. Let _dateTimeResult_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _options_).
        1. If IsTimeZoneOffsetString(_offsetString_) is *false*, throw a *RangeError* exception.
        1. Let _offsetNanoseconds_ be ParseTimeZoneOffsetString(_offsetString_).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_dateTimeResult_.[[Year]], _dateTimeResult_.[[Month]], _dateTimeResult_.[[Day]], _dateTimeResult_.[[Hour]], _dateTimeResult_.[[Minute]], _dateTimeResult_.[[Second]], _dateTimeResult_.[[Millisecond]], _dateTimeResult_.[[Microsecond]], _dateTimeResult_.[[Nanosecond]], ~option~, _offsetNanoseconds_, _timeZone_, _disambiguation_, _offset_, ~match exactly~).
        1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withplaintime">
      <h1>Temporal.ZonedDateTime.prototype.withPlainTime ( [ _plainTimeLike_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. If _plainTimeLike_ is *undefined*, then
          1. Let _plainTime_ be ! CreateTemporalTime(0, 0, 0, 0, 0, 0).
        1. Else,
          1. Let _plainTime_ be ? ToTemporalTime(_plainTimeLike_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _plainDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _resultPlainDateTime_ be ? CreateTemporalDateTime(_plainDateTime_.[[ISOYear]], _plainDateTime_.[[ISOMonth]], _plainDateTime_.[[ISODay]], _plainTime_.[[ISOHour]], _plainTime_.[[ISOMinute]], _plainTime_.[[ISOSecond]], _plainTime_.[[ISOMillisecond]], _plainTime_.[[ISOMicrosecond]], _plainTime_.[[ISONanosecond]], _calendar_).
        1. Set _instant_ to ? BuiltinTimeZoneGetInstantFor(_timeZone_, _resultPlainDateTime_, *"compatible"*).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withplaindate">
      <h1>Temporal.ZonedDateTime.prototype.withPlainDate ( _plainDateLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _plainDate_ be ? ToTemporalDate(_plainDateLike_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _plainDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _zonedDateTime_.[[Calendar]]).
        1. Let _calendar_ be ? ConsolidateCalendars(_zonedDateTime_.[[Calendar]], _plainDate_.[[Calendar]]).
        1. Let _resultPlainDateTime_ be ? CreateTemporalDateTime(_plainDate_.[[ISOYear]], _plainDate_.[[ISOMonth]], _plainDate_.[[ISODay]], _plainDateTime_.[[ISOHour]], _plainDateTime_.[[ISOMinute]], _plainDateTime_.[[ISOSecond]], _plainDateTime_.[[ISOMillisecond]], _plainDateTime_.[[ISOMicrosecond]], _plainDateTime_.[[ISONanosecond]], _calendar_).
        1. Set _instant_ to ? BuiltinTimeZoneGetInstantFor(_timeZone_, _resultPlainDateTime_, *"compatible"*).
        1. Return ! CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withtimezone">
      <h1>Temporal.ZonedDateTime.prototype.withTimeZone ( _timeZoneLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be ? ToTemporalTimeZone(_timeZoneLike_).
        1. Return ! CreateTemporalZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _timeZone_, _zonedDateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withcalendar">
      <h1>Temporal.ZonedDateTime.prototype.withCalendar ( _calendarLike_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _calendar_ be ? ToTemporalCalendar(_calendarLike_).
        1. Return ! CreateTemporalZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _zonedDateTime_.[[TimeZone]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.add">
      <h1>Temporal.ZonedDateTime.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? AddDurationToOrSubtractDurationFromZonedDateTime(~add~, _zonedDateTime_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.subtract">
      <h1>Temporal.ZonedDateTime.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? AddDurationToOrSubtractDurationFromZonedDateTime(~subtract~, _zonedDateTime_, _temporalDurationLike_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.until">
      <h1>Temporal.ZonedDateTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? DifferenceTemporalZonedDateTime(~until~, _zonedDateTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.since">
      <h1>Temporal.ZonedDateTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? DifferenceTemporalZonedDateTime(~since~, _zonedDateTime_, _other_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.round">
      <h1>Temporal.ZonedDateTime.prototype.round ( _roundTo_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. If _roundTo_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. If Type(_roundTo_) is String, then
          1. Let _paramString_ be _roundTo_.
          1. Set _roundTo_ to OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_roundTo_, *"smallestUnit"*, _paramString_).
        1. Else,
          1. Set _roundTo_ to ? GetOptionsObject(_roundTo_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalRoundingIncrement reads *"roundingIncrement"* and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_roundTo_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_roundTo_, *"halfExpand"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_roundTo_, *"smallestUnit"*, ~time~, ~required~, ¬´ *"day"* ¬ª).
        1. If _smallestUnit_ is *"day"*, then
          1. Let _maximum_ be 1.
          1. Let _inclusive_ be *true*.
        1. Else,
          1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
          1. Assert: _maximum_ is not *undefined*.
          1. Let _inclusive_ be *false*.
        1. Perform ? ValidateTemporalRoundingIncrement(_roundingIncrement_, _maximum_, _inclusive_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _isoCalendar_ be ! GetISO8601Calendar().
        1. Let _dtStart_ be ? CreateTemporalDateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], 0, 0, 0, 0, 0, 0, _isoCalendar_).
        1. Let _instantStart_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _dtStart_, *"compatible"*).
        1. Let _startNs_ be _instantStart_.[[Nanoseconds]].
        1. Let _endNs_ be ? AddZonedDateTime(_startNs_, _timeZone_, _calendar_, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0).
        1. Let _dayLengthNs_ be ‚Ñù(_endNs_ - _startNs_).
        1. If _dayLengthNs_ &le; 0, then
          1. Throw a *RangeError* exception.
        1. Let _roundResult_ be ! RoundISODateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _dayLengthNs_).
        1. Let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZone_, _instant_).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_roundResult_.[[Year]], _roundResult_.[[Month]], _roundResult_.[[Day]], _roundResult_.[[Hour]], _roundResult_.[[Minute]], _roundResult_.[[Second]], _roundResult_.[[Millisecond]], _roundResult_.[[Microsecond]], _roundResult_.[[Nanosecond]], ~option~, _offsetNanoseconds_, _timeZone_, *"compatible"*, *"prefer"*, ~match exactly~).
        1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.equals">
      <h1>Temporal.ZonedDateTime.prototype.equals ( _other_ )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Set _other_ to ? ToTemporalZonedDateTime(_other_).
        1. If _zonedDateTime_.[[Nanoseconds]] &ne; _other_.[[Nanoseconds]], return *false*.
        1. If ? TimeZoneEquals(_zonedDateTime_.[[TimeZone]], _other_.[[TimeZone]]) is *false*, return *false*.
        1. Return ? CalendarEquals(_zonedDateTime_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tostring">
      <h1>Temporal.ZonedDateTime.prototype.toString ( [ _options_ ] )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToCalendarNameOption reads *"calendarName"*, ToFractionalSecondDigits reads *"fractionalSecondDigits"*, ToShowOffsetOption reads *"offset"*, and ToTemporalRoundingMode reads *"roundingMode"*).
        1. Let _showCalendar_ be ? ToCalendarNameOption(_options_).
        1. Let _digits_ be ? ToFractionalSecondDigits(_options_).
        1. Let _showOffset_ be ? ToShowOffsetOption(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _smallestUnit_ be ? GetTemporalUnit(_options_, *"smallestUnit"*, ~time~, *undefined*).
        1. If _smallestUnit_ is *"hour"*, throw a *RangeError* exception.
        1. Let _showTimeZone_ be ? ToTimeZoneNameOption(_options_).
        1. Let _precision_ be ToSecondsStringPrecisionRecord(_smallestUnit_, _digits_).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, _precision_.[[Precision]], _showCalendar_, _showTimeZone_, _showOffset_, _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tolocalestring">
      <h1>Temporal.ZonedDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification.
        If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
      </p>
      <p>
        The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
      </p>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, *"auto"*, *"auto"*, *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tojson">
      <h1>Temporal.ZonedDateTime.prototype.toJSON ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, *"auto"*, *"auto"*, *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.valueof">
      <h1>Temporal.ZonedDateTime.prototype.valueOf ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.startofday">
      <h1>Temporal.ZonedDateTime.prototype.startOfDay ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _startDateTime_ be ? CreateTemporalDateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], 0, 0, 0, 0, 0, 0, _calendar_).
        1. Let _startInstant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _startDateTime_, *"compatible"*).
        1. Return ! CreateTemporalZonedDateTime(_startInstant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toinstant">
      <h1>Temporal.ZonedDateTime.prototype.toInstant ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaindate">
      <h1>Temporal.ZonedDateTime.prototype.toPlainDate ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ! CreateTemporalDate(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaintime">
      <h1>Temporal.ZonedDateTime.prototype.toPlainTime ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ! CreateTemporalTime(_temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaindatetime">
      <h1>Temporal.ZonedDateTime.prototype.toPlainDateTime ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Return ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _zonedDateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplainyearmonth">
      <h1>Temporal.ZonedDateTime.prototype.toPlainYearMonth ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"monthCode"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDateTime_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarYearMonthFromFields(_calendar_, _fields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplainmonthday">
      <h1>Temporal.ZonedDateTime.prototype.toPlainMonthDay ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"monthCode"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDateTime_, _fieldNames_, ¬´¬ª).
        1. Return ? CalendarMonthDayFromFields(_calendar_, _fields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.getisofields">
      <h1>Temporal.ZonedDateTime.prototype.getISOFields ( )</h1>
      <p>
        This method performs the following steps when called:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _fields_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _dateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _offset_ be ? BuiltinTimeZoneGetOffsetStringFor(_timeZone_, _instant_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _calendar_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, ùîΩ(_dateTime_.[[ISODay]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoHour"*, ùîΩ(_dateTime_.[[ISOHour]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMicrosecond"*, ùîΩ(_dateTime_.[[ISOMicrosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMillisecond"*, ùîΩ(_dateTime_.[[ISOMillisecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMinute"*, ùîΩ(_dateTime_.[[ISOMinute]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, ùîΩ(_dateTime_.[[ISOMonth]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoNanosecond"*, ùîΩ(_dateTime_.[[ISONanosecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoSecond"*, ùîΩ(_dateTime_.[[ISOSecond]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, ùîΩ(_dateTime_.[[ISOYear]])).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"offset"*, _offset_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"timeZone"*, _timeZone_).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-zoneddatetime-instances">
    <h1>Properties of Temporal.ZonedDateTime Instances</h1>
    <p>
      Temporal.ZonedDateTime instances are ordinary objects that inherit properties from the %Temporal.ZonedDateTime.prototype% intrinsic object.
      Temporal.ZonedDateTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporalzoneddatetime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporalzoneddatetime-instances" caption="Internal Slots of Temporal.ZonedDateTime Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalZonedDateTime]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.ZonedDateTime instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[Nanoseconds]]
            </td>
            <td>
              A BigInt value representing the number of nanoseconds since the Unix epoch.
            </td>
          </tr>
          <tr>
            <td>
              [[TimeZone]]
            </td>
            <td>
              An Object representing the time zone.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              An Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-zoneddatetime-abstract-ops">
    <h1>Abstract operations</h1>

    <emu-clause id="sec-temporal-interpretisodatetimeoffset" type="abstract operation">
      <h1>
        InterpretISODateTimeOffset (
          _year_: an integer,
          _month_: an integer,
          _day_: an integer,
          _hour_: an integer,
          _minute_: an integer,
          _second_: an integer,
          _millisecond_: an integer,
          _microsecond_: an integer,
          _nanosecond_: an integer,
          _offsetBehaviour_: one of ~option~, ~exact~, or ~wall~,
          _offsetNanoseconds_: an integer,
          _timeZone_: an Object,
          _disambiguation_: one of *"earlier"*, *"later"*, *"compatible"*, or *"reject"*,
          _offsetOption_: one of *"ignore"*, *"use"*, *"prefer"*, or *"reject"*,
          _matchBehaviour_: one of ~match exactly~ or ~match minutes~,
        ): either a normal completion containing a BigInt or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          <p>
            It determines the exact time in _timeZone_ corresponding to the given calendar date and time, and the given UTC offset in nanoseconds.
            In the case of more than one possible exact time, or no possible exact time, an answer is determined using _offsetBehaviour_, _disambiguation_ and _offsetOption_.
          </p>
          <p>
            As a special case when parsing ISO 8601 strings which are only required to specify time zone offsets to minutes precision, if _matchBehaviour_ is ~match minutes~, then a value for _offsetNanoseconds_ that is rounded to the nearest minute will be accepted in those cases where _offsetNanoseconds_ is compared against _timeZone_'s offset.
            If _matchBehaviour_ is ~match exactly~, then this does not happen.
          </p>
        </dd>
      </dl>
      <emu-alg>
        1. Assert: IsValidISODate(_year_, _month_, _day_) is *true*.
        1. Let _calendar_ be ! GetISO8601Calendar().
        1. Let _dateTime_ be ? CreateTemporalDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_).
        1. If _offsetBehaviour_ is ~wall~ or _offsetOption_ is *"ignore"*, then
          1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _dateTime_, _disambiguation_).
          1. Return _instant_.[[Nanoseconds]].
        1. If _offsetBehaviour_ is ~exact~ or _offsetOption_ is *"use"*, then
          1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
          1. Set _epochNanoseconds_ to _epochNanoseconds_ - ‚Ñ§(_offsetNanoseconds_).
          1. If ! IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
          1. Return _epochNanoseconds_.
        1. Assert: _offsetBehaviour_ is ~option~.
        1. Assert: _offsetOption_ is *"prefer"* or *"reject"*.
        1. Let _possibleInstants_ be ? GetPossibleInstantsFor(_timeZone_, _dateTime_).
        1. For each element _candidate_ of _possibleInstants_, do
          1. Let _candidateNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZone_, _candidate_).
          1. If _candidateNanoseconds_ = _offsetNanoseconds_, then
            1. Return _candidate_.[[Nanoseconds]].
          1. If _matchBehaviour_ is ~match minutes~, then
            1. Let _roundedCandidateNanoseconds_ be RoundNumberToIncrement(_candidateNanoseconds_, 60 &times; 10<sup>9</sup>, *"halfExpand"*).
            1. If _roundedCandidateNanoseconds_ = _offsetNanoseconds_, then
              1. Return _candidate_.[[Nanoseconds]].
        1. If _offsetOption_ is *"reject"*, throw a *RangeError* exception.
        1. Let _instant_ be ? DisambiguatePossibleInstants(_possibleInstants_, _timeZone_, _dateTime_, _disambiguation_).
        1. Return _instant_.[[Nanoseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalzoneddatetime" type="abstract operation">
      <h1>
        ToTemporalZonedDateTime (
          _item_: an ECMAScript language value,
          optional _options_: an Object,
        ): either a normal completion containing a `Temporal.ZonedDateTime` or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns its argument _item_ if it is already a Temporal.ZonedDateTime instance, converts _item_ to a new Temporal.ZonedDateTime instance if possible, and throws otherwise.
        </dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Assert: Type(_options_) is Object or Undefined.
        1. Let _offsetBehaviour_ be ~option~.
        1. Let _matchBehaviour_ be ~match exactly~.
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _item_.
          1. Let _calendar_ be ? GetTemporalCalendarWithISODefault(_item_).
          1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"monthCode"*, *"nanosecond"*, *"second"*, *"year"* ¬ª).
          1. Append *"timeZone"* to _fieldNames_.
          1. Append *"offset"* to _fieldNames_.
          1. Let _fields_ be ? PrepareTemporalFields(_item_, _fieldNames_, ¬´ *"timeZone"* ¬ª).
          1. Let _timeZone_ be ! Get(_fields_, *"timeZone"*).
          1. Set _timeZone_ to ? ToTemporalTimeZone(_timeZone_).
          1. Let _offsetString_ be ! Get(_fields_, *"offset"*).
          1. Assert: _offsetString_ is a String or *undefined*.
          1. If _offsetString_ is *undefined*, then
            1. Set _offsetBehaviour_ to ~wall~.
          1. NOTE: The following steps read options and perform independent validation in alphabetical order (ToTemporalDisambiguation reads *"disambiguation"*, ToTemporalOffset reads *"offset"*, and InterpretTemporalDateTimeFields reads *"overflow"*).
          1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
          1. Let _offsetOption_ be ? ToTemporalOffset(_options_, *"reject"*).
          1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _options_).
        1. Else,
          1. Let _string_ be ? ToString(_item_).
          1. Let _result_ be ? ParseTemporalZonedDateTimeString(_string_).
          1. Let _timeZoneName_ be _result_.[[TimeZone]].[[Name]].
          1. Assert: _timeZoneName_ is not *undefined*.
          1. If IsTimeZoneOffsetString(_timeZoneName_) is *false*, then
            1. If IsAvailableTimeZoneName(_timeZoneName_) is *false*, throw a *RangeError* exception.
            1. Set _timeZoneName_ to ! CanonicalizeTimeZoneName(_timeZoneName_).
          1. Let _offsetString_ be _result_.[[TimeZone]].[[OffsetString]].
          1. If _result_.[[TimeZone]].[[Z]] is *true*, then
            1. Set _offsetBehaviour_ to ~exact~.
          1. Else if _offsetString_ is *undefined*, then
            1. Set _offsetBehaviour_ to ~wall~.
          1. Let _timeZone_ be ! CreateTemporalTimeZone(_timeZoneName_).
          1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_result_.[[Calendar]]).
          1. Set _matchBehaviour_ to ~match minutes~.
          1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
          1. Let _offsetOption_ be ? ToTemporalOffset(_options_, *"reject"*).
          1. Perform ? ToTemporalOverflow(_options_).
        1. Let _offsetNanoseconds_ be 0.
        1. If _offsetBehaviour_ is ~option~, then
          1. If IsTimeZoneOffsetString(_offsetString_) is *false*, throw a *RangeError* exception.
          1. Set _offsetNanoseconds_ to ParseTimeZoneOffsetString(_offsetString_).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _offsetBehaviour_, _offsetNanoseconds_, _timeZone_, _disambiguation_, _offsetOption_, _matchBehaviour_).
        1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalzoneddatetime" type="abstract operation">
      <h1>
        CreateTemporalZonedDateTime (
          _epochNanoseconds_: a BigInt,
          _timeZone_: an Object,
          _calendar_: an Object,
          optional _newTarget_: a function object,
        ): either a normal completion containing a `Temporal.ZonedDateTime` or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It is used to specify the creation of a new `Temporal.ZonedDateTime` object.</dd>
      </dl>
      <emu-alg>
        1. Assert: ! IsValidEpochNanoseconds(_epochNanoseconds_) is *true*.
        1. If _newTarget_ is not present, set _newTarget_ to %Temporal.ZonedDateTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.ZonedDateTime.prototype%"*, ¬´ [[InitializedTemporalZonedDateTime]], [[Nanoseconds]], [[TimeZone]], [[Calendar]] ¬ª).
        1. Set _object_.[[Nanoseconds]] to _epochNanoseconds_.
        1. Set _object_.[[TimeZone]] to _timeZone_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporalzoneddatetimetostring" type="abstract operation">
      <h1>
        TemporalZonedDateTimeToString (
          _zonedDateTime_: a Temporal.ZonedDateTime,
          _precision_: one of *"auto"*, *"minute"*, or an integer between 0 and 9 inclusive,
          _showCalendar_: one of *"auto"*, *"always"*, *"never"*, or *"critical"*,
          _showTimeZone_: one of *"auto"*, *"never"*, or *"critical"*,
          _showOffset_: one of *"auto"* or *"never"*,
          optional _increment_: an integer,
          optional _unit_: one of *"minute"*, *"second"*, *"millisecond"*, *"microsecond"*, or *"nanosecond"*,
          optional _roundingMode_: one of *"ceil"*, *"floor"*, *"expand"*, *"trunc"*, *"halfCeil"*, *"halfFloor"*, *"halfExpand"*, *"halfTrunc"*, or *"halfEven"*,
        ): either a normal completion containing a String or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns an ISO 8601 string representation of its argument, including a time zone name annotation and calendar annotation, which are extensions to the ISO 8601 format.
        </dd>
      </dl>
      <emu-alg>
        1. If _increment_ is not present, set _increment_ to 1.
        1. If _unit_ is not present, set _unit_ to *"nanosecond"*.
        1. If _roundingMode_ is not present, set _roundingMode_ to *"trunc"*.
        1. Let _ns_ be ! RoundTemporalInstant(_zonedDateTime_.[[Nanoseconds]], _increment_, _unit_, _roundingMode_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_ns_).
        1. Let _isoCalendar_ be ! GetISO8601Calendar().
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _isoCalendar_).
        1. Let _dateTimeString_ be ! TemporalDateTimeToString(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], _isoCalendar_, _precision_, *"never"*).
        1. If _showOffset_ is *"never"*, then
          1. Let _offsetString_ be the empty String.
        1. Else,
          1. Let _offsetNs_ be ? GetOffsetNanosecondsFor(_timeZone_, _instant_).
          1. Let _offsetString_ be ! FormatISOTimeZoneOffsetString(_offsetNs_).
        1. If _showTimeZone_ is *"never"*, then
          1. Let _timeZoneString_ be the empty String.
        1. Else,
          1. Let _timeZoneID_ be ? ToString(_timeZone_).
          1. If _showTimeZone_ is *"critical"*, let _flag_ be *"!"*; else let _flag_ be the empty String.
          1. Let _timeZoneString_ be the string-concatenation of the code unit 0x005B (LEFT SQUARE BRACKET), _flag_, _timeZoneID_, and the code unit 0x005D (RIGHT SQUARE BRACKET).
        1. Let _calendarString_ be ? MaybeFormatCalendarAnnotation(_zonedDateTime_.[[Calendar]], _showCalendar_).
        1. Return the string-concatenation of _dateTimeString_, _offsetString_, _timeZoneString_, and _calendarString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addzoneddatetime" type="abstract operation">
      <h1>
        AddZonedDateTime (
          _epochNanoseconds_: a BigInt,
          _timeZone_: an Object,
          _calendar_: an Object,
          _years_: an integer,
          _months_: an integer,
          _weeks_: an integer,
          _days_: an integer,
          _hours_: an integer,
          _minutes_: an integer,
          _seconds_: an integer,
          _milliseconds_: an integer,
          _microseconds_: an integer,
          _nanoseconds_: an integer,
          optional _options_: an Object,
        ): either a normal completion containing a BigInt or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds a duration in various units to a number of nanoseconds _epochNanoseconds_ since the Unix epoch, subject to the rules of _timeZone_ and _calendar_, and returns the result as a BigInt value.
          As specified in <a href="https://tools.ietf.org/html/rfc5545">RFC 5545</a>, the date portion of the duration is added in calendar days, and the time portion is added in exact time.
        </dd>
      </dl>
      <emu-alg>
        1. If _options_ is not present, set _options_ to *undefined*.
        1. Assert: Type(_options_) is Object or Undefined.
        1. If all of _years_, _months_, _weeks_, and _days_ are 0, then
          1. Return ? AddInstant(_epochNanoseconds_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Let _instant_ be ! CreateTemporalInstant(_epochNanoseconds_).
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _datePart_ be ! CreateTemporalDate(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _calendar_).
        1. Let _dateDuration_ be ! CreateTemporalDuration(_years_, _months_, _weeks_, _days_, 0, 0, 0, 0, 0, 0).
        1. Let _addedDate_ be ? CalendarDateAdd(_calendar_, _datePart_, _dateDuration_, _options_).
        1. Let _intermediateDateTime_ be ? CreateTemporalDateTime(_addedDate_.[[ISOYear]], _addedDate_.[[ISOMonth]], _addedDate_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], _calendar_).
        1. Let _intermediateInstant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _intermediateDateTime_, *"compatible"*).
        1. Return ? AddInstant(_intermediateInstant_.[[Nanoseconds]], _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencezoneddatetime" type="abstract operation">
      <h1>
        DifferenceZonedDateTime (
          _ns1_: a BigInt,
          _ns2_: a BigInt,
          _timeZone_: an Object,
          _calendar_: an Object,
          _largestUnit_: a String,
          _options_: an Object,
        ): either a normal completion containing a Duration Record or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It computes the difference between two exact times expressed in nanoseconds since the Unix epoch, and balances the result so that there is no non-zero unit larger than _largestUnit_ in the result, taking calendar reckoning and time zone offset changes into account.
        </dd>
      </dl>
      <emu-alg>
        1. If _ns1_ is _ns2_, then
          1. Return ! CreateDurationRecord(0, 0, 0, 0, 0, 0, 0, 0, 0, 0).
        1. Let _startInstant_ be ! CreateTemporalInstant(_ns1_).
        1. Let _startDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _startInstant_, _calendar_).
        1. Let _endInstant_ be ! CreateTemporalInstant(_ns2_).
        1. Let _endDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _endInstant_, _calendar_).
        1. Let _dateDifference_ be ? DifferenceISODateTime(_startDateTime_.[[ISOYear]], _startDateTime_.[[ISOMonth]], _startDateTime_.[[ISODay]], _startDateTime_.[[ISOHour]], _startDateTime_.[[ISOMinute]], _startDateTime_.[[ISOSecond]], _startDateTime_.[[ISOMillisecond]], _startDateTime_.[[ISOMicrosecond]], _startDateTime_.[[ISONanosecond]], _endDateTime_.[[ISOYear]], _endDateTime_.[[ISOMonth]], _endDateTime_.[[ISODay]], _endDateTime_.[[ISOHour]], _endDateTime_.[[ISOMinute]], _endDateTime_.[[ISOSecond]], _endDateTime_.[[ISOMillisecond]], _endDateTime_.[[ISOMicrosecond]], _endDateTime_.[[ISONanosecond]], _calendar_, _largestUnit_, _options_).
        1. Let _intermediateNs_ be ? AddZonedDateTime(_ns1_, _timeZone_, _calendar_, _dateDifference_.[[Years]], _dateDifference_.[[Months]], _dateDifference_.[[Weeks]], 0, 0, 0, 0, 0, 0, 0).
        1. Let _timeRemainderNs_ be _ns2_ - _intermediateNs_.
        1. Let _intermediate_ be ! CreateTemporalZonedDateTime(_intermediateNs_, _timeZone_, _calendar_).
        1. Let _result_ be ? NanosecondsToDays(‚Ñù(_timeRemainderNs_), _intermediate_).
        1. Let _timeDifference_ be ! BalanceDuration(0, 0, 0, 0, 0, 0, _result_.[[Nanoseconds]], *"hour"*).
        1. Return ! CreateDurationRecord(_dateDifference_.[[Years]], _dateDifference_.[[Months]], _dateDifference_.[[Weeks]], _result_.[[Days]], _timeDifference_.[[Hours]], _timeDifference_.[[Minutes]], _timeDifference_.[[Seconds]], _timeDifference_.[[Milliseconds]], _timeDifference_.[[Microseconds]], _timeDifference_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-nanosecondstodays" type="abstract operation">
      <h1>
        NanosecondsToDays (
          _nanoseconds_: an integer,
          _relativeTo_: *undefined*, a Temporal.PlainDate, or a Temporal.ZonedDateTime,
        ): either a normal completion containing a Record with fields [[Days]] (an integer), [[Nanoseconds]] (an integer), and [[DayLength]] (an integer), or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It converts a number of _nanoseconds_ relative to a Temporal.ZonedDateTime _relativeTo_, and converts it into a number of days and remainder of nanoseconds, taking into account any offset changes in the time zone of _relativeTo_.
          It also returns the length of the last day in nanoseconds, for rounding purposes.
        </dd>
      </dl>
      <emu-alg>
        1. Let _dayLengthNs_ be nsPerDay.
        1. If _nanoseconds_ = 0, then
          1. Return the Record { [[Days]]: 0, [[Nanoseconds]]: 0, [[DayLength]]: _dayLengthNs_ }.
        1. If _nanoseconds_ &lt; 0, let _sign_ be -1; else, let _sign_ be 1.
        1. If Type(_relativeTo_) is not Object or _relativeTo_ does not have an [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return the Record {
            [[Days]]: truncate(_nanoseconds_ / _dayLengthNs_),
            [[Nanoseconds]]: (abs(_nanoseconds_) modulo _dayLengthNs_) &times; _sign_,
            [[DayLength]]: _dayLengthNs_
            }.
        1. Let _startNs_ be ‚Ñù(_relativeTo_.[[Nanoseconds]]).
        1. Let _startInstant_ be ! CreateTemporalInstant(‚Ñ§(_startNs_)).
        1. Let _startDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_relativeTo_.[[TimeZone]], _startInstant_, _relativeTo_.[[Calendar]]).
        1. Let _endNs_ be _startNs_ + _nanoseconds_.
        1. If ! IsValidEpochNanoseconds(‚Ñ§(_endNs_)) is *false*, throw a *RangeError* exception.
        1. Let _endInstant_ be ! CreateTemporalInstant(‚Ñ§(_endNs_)).
        1. Let _endDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_relativeTo_.[[TimeZone]], _endInstant_, _relativeTo_.[[Calendar]]).
        1. Let _dateDifference_ be ? DifferenceISODateTime(_startDateTime_.[[ISOYear]], _startDateTime_.[[ISOMonth]], _startDateTime_.[[ISODay]], _startDateTime_.[[ISOHour]], _startDateTime_.[[ISOMinute]], _startDateTime_.[[ISOSecond]], _startDateTime_.[[ISOMillisecond]], _startDateTime_.[[ISOMicrosecond]], _startDateTime_.[[ISONanosecond]], _endDateTime_.[[ISOYear]], _endDateTime_.[[ISOMonth]], _endDateTime_.[[ISODay]], _endDateTime_.[[ISOHour]], _endDateTime_.[[ISOMinute]], _endDateTime_.[[ISOSecond]], _endDateTime_.[[ISOMillisecond]], _endDateTime_.[[ISOMicrosecond]], _endDateTime_.[[ISONanosecond]], _relativeTo_.[[Calendar]], *"day"*, OrdinaryObjectCreate(*null*)).
        1. Let _days_ be _dateDifference_.[[Days]].
        1. Let _intermediateNs_ be ‚Ñù(? AddZonedDateTime(‚Ñ§(_startNs_), _relativeTo_.[[TimeZone]], _relativeTo_.[[Calendar]], 0, 0, 0, _days_, 0, 0, 0, 0, 0, 0)).
        1. If _sign_ is 1, then
          1. Repeat, while _days_ &gt; 0 and _intermediateNs_ &gt; _endNs_,
            1. Set _days_ to _days_ - 1.
            1. Set _intermediateNs_ to ‚Ñù(? AddZonedDateTime(‚Ñ§(_startNs_), _relativeTo_.[[TimeZone]], _relativeTo_.[[Calendar]], 0, 0, 0, _days_, 0, 0, 0, 0, 0, 0)).
        1. Set _nanoseconds_ to _endNs_ - _intermediateNs_.
        1. Let _done_ be *false*.
        1. Repeat, while _done_ is *false*,
          1. Let _oneDayFartherNs_ be ‚Ñù(? AddZonedDateTime(‚Ñ§(_intermediateNs_), _relativeTo_.[[TimeZone]], _relativeTo_.[[Calendar]], 0, 0, 0, _sign_, 0, 0, 0, 0, 0, 0)).
          1. Set _dayLengthNs_ to _oneDayFartherNs_ - _intermediateNs_.
          1. If (_nanoseconds_ - _dayLengthNs_) &times; _sign_ &ge; 0, then
            1. Set _nanoseconds_ to _nanoseconds_ - _dayLengthNs_.
            1. Set _intermediateNs_ to _oneDayFartherNs_.
            1. Set _days_ to _days_ + _sign_.
          1. Else,
            1. Set _done_ to *true*.
        1. If _days_ &lt; 0 and _sign_ = 1, throw a *RangeError* exception.
        1. If _days_ &gt; 0 and _sign_ = -1, throw a *RangeError* exception.
        1. If _nanoseconds_ &lt; 0 and _sign_ = 1, throw a *RangeError* exception.
        1. If _nanoseconds_ &gt; 0 and _sign_ = -1, throw a *RangeError* exception.
        1. If abs(_nanoseconds_) &ge; abs(_dayLengthNs_), throw a *RangeError* exception.
        1. Return the Record {
          [[Days]]: _days_,
          [[Nanoseconds]]: _nanoseconds_,
          [[DayLength]]: abs(_dayLengthNs_)
          }.
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-differencetemporalzoneddatetime" type="abstract operation">
      <h1>
        DifferenceTemporalZonedDateTime (
          _operation_: ~until~ or ~since~,
          _zonedDateTime_: a Temporal.ZonedDateTime,
          _other_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.Duration or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the difference between the two times represented by _zonedDateTime_ and _other_, optionally rounds it, and returns it as a Temporal.Duration object.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~since~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Set _other_ to ? ToTemporalZonedDateTime(_other_).
        1. If ? CalendarEquals(_zonedDateTime_.[[Calendar]], _other_.[[Calendar]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. Let _settings_ be ? GetDifferenceSettings(_operation_, _options_, ~datetime~, &laquo; &raquo;, *"nanosecond"*, *"hour"*).
        1. If _settings_.[[LargestUnit]] is not one of *"year"*, *"month"*, *"week"*, or *"day"*, then
          1. Let _result_ be ! DifferenceInstant(_zonedDateTime_.[[Nanoseconds]], _other_.[[Nanoseconds]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[LargestUnit]], _settings_.[[RoundingMode]]).
          1. Return ! CreateTemporalDuration(0, 0, 0, 0, _sign_ &times; _result_.[[Hours]], _sign_ &times; _result_.[[Minutes]], _sign_ &times; _result_.[[Seconds]], _sign_ &times; _result_.[[Milliseconds]], _sign_ &times; _result_.[[Microseconds]], _sign_ &times; _result_.[[Nanoseconds]]).
        1. If ? TimeZoneEquals(_zonedDateTime_.[[TimeZone]], _other_.[[TimeZone]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. Let _untilOptions_ be OrdinaryObjectCreate(*null*).
        1. Perform ? CopyDataProperties(_untilOptions_, _settings_.[[Options]], ¬´ ¬ª).
        1. Perform ! CreateDataPropertyOrThrow(_untilOptions_, *"largestUnit"*, _settings_.[[LargestUnit]]).
        1. Let _difference_ be ? DifferenceZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _other_.[[Nanoseconds]], _zonedDateTime_.[[TimeZone]], _zonedDateTime_.[[Calendar]], _settings_.[[LargestUnit]], _untilOptions_).
        1. Let _roundResult_ be (? RoundDuration(_difference_.[[Years]], _difference_.[[Months]], _difference_.[[Weeks]], _difference_.[[Days]], _difference_.[[Hours]], _difference_.[[Minutes]], _difference_.[[Seconds]], _difference_.[[Milliseconds]], _difference_.[[Microseconds]], _difference_.[[Nanoseconds]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]], _zonedDateTime_)).[[DurationRecord]].
        1. Let _result_ be ? AdjustRoundedDurationDays(_roundResult_.[[Years]], _roundResult_.[[Months]], _roundResult_.[[Weeks]], _roundResult_.[[Days]], _roundResult_.[[Hours]], _roundResult_.[[Minutes]], _roundResult_.[[Seconds]], _roundResult_.[[Milliseconds]], _roundResult_.[[Microseconds]], _roundResult_.[[Nanoseconds]], _settings_.[[RoundingIncrement]], _settings_.[[SmallestUnit]], _settings_.[[RoundingMode]], _zonedDateTime_).
        1. Return ! CreateTemporalDuration(_sign_ &times; _result_.[[Years]], _sign_ &times; _result_.[[Months]], _sign_ &times; _result_.[[Weeks]], _sign_ &times; _result_.[[Days]], _sign_ &times; _result_.[[Hours]], _sign_ &times; _result_.[[Minutes]], _sign_ &times; _result_.[[Seconds]], _sign_ &times; _result_.[[Milliseconds]], _sign_ &times; _result_.[[Microseconds]], _sign_ &times; _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>
    <emu-clause id="sec-temporal-adddurationtoOrsubtractdurationfromzoneddatetime" type="abstract operation">
     <h1>
        AddDurationToOrSubtractDurationFromZonedDateTime (
          _operation_: ~add~ or ~subtract~,
          _zonedDateTime_: a Temporal.ZonedDateTime,
          _temporalDurationLike_: an ECMAScript language value,
          _options_: an ECMAScript language value,
        ): either a normal completion containing a Temporal.ZonedDateTime or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It adds/subtracts _temporalDurationLike_ to/from _zonedDateTime_.</dd>
      </dl>
      <emu-alg>
        1. If _operation_ is ~subtract~, let _sign_ be -1. Otherwise, let _sign_ be 1.
        1. Let _duration_ be ? ToTemporalDurationRecord(_temporalDurationLike_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _epochNanoseconds_ be ? AddZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _timeZone_, _calendar_, _sign_ &times; _duration_.[[Years]], _sign_ &times; _duration_.[[Months]], _sign_ &times; _duration_.[[Weeks]], _sign_ &times; _duration_.[[Days]], _sign_ &times; _duration_.[[Hours]], _sign_ &times; _duration_.[[Minutes]], _sign_ &times; _duration_.[[Seconds]], _sign_ &times; _duration_.[[Milliseconds]], _sign_ &times; _duration_.[[Microseconds]], _sign_ &times; _duration_.[[Nanoseconds]], _options_).
        1. Return ! CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
