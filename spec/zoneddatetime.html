<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-zoneddatetime-objects">
  <h1>Temporal.ZonedDateTime Objects</h1>
  <p>
    A Temporal.ZonedDateTime object is an Object referencing a fixed point in time with nanoseconds precision, and containing Object values corresponding to a particular time zone and calendar system.
  </p>

  <emu-clause id="sec-temporal-zoneddatetime-constructor">
    <h1>The Temporal.ZonedDateTime Constructor</h1>
    <p>
      The Temporal.ZonedDateTime constructor creates and initializes a new Temporal.ZonedDateTime object when called as a constructor.
    </p>
    <p>
      The Temporal.ZonedDateTime constructor is designed to be subclassable.
      It may be used as the value of an extends clause of a class definition.
      Subclass constructors that intend to inherit the specified ZonedDateTime behaviour must include a super call to the %Temporal.ZonedDateTime% constructor to create and initialize subclass instances with the necessary internal slots.
    </p>

    <emu-clause id="sec-temporal.zoneddatetime">
      <h1>Temporal.ZonedDateTime ( _epochNanoseconds_, _timeZoneLike_ [ , _calendarLike_ ] )</h1>
      <p>
        When the `Temporal.ZonedDateTime` function is called, the following steps are taken:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _epochNanoseconds_ to ? ToBigInt(_epochNanoseconds_).
        1. If ! IsValidEpochNanoseconds(_epochNanoseconds_) is *false*, throw a *RangeError* exception.
        1. Let _timeZone_ be ? ToTemporalTimeZone(_timeZoneLike_).
        1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_calendarLike_).
        1. Return ? CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-zoneddatetime-constructor">
    <h1>Properties of the Temporal.ZonedDateTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.ZonedDateTime constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.ZonedDateTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal-zoneddatetime-prototype">
      <h1>Temporal.ZonedDateTime.prototype</h1>
      <p>The initial value of `Temporal.ZonedDateTime.prototype` is %Temporal.ZonedDateTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.from">
      <h1>Temporal.ZonedDateTime.from ( _item_ [ , _options_ ] )</h1>
      <p>
        The `from` method takes two arguments, _item_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Perform ? ToTemporalOverflow(_options_).
          1. Perform ? ToTemporalDisambiguation(_options_).
          1. Perform ? ToTemporalOffset(_options_, *"reject"*).
          1. Return ? CreateTemporalZonedDateTime(_item_.[[Nanoseconds]], _item_.[[TimeZone]], _item_.[[Calendar]]).
        1. Return ? ToTemporalZonedDateTime(_item_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.compare">
      <h1>Temporal.ZonedDateTime.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalZonedDateTime(_one_).
        1. Set _two_ to ? ToTemporalZonedDateTime(_two_).
        1. Return ùîΩ(! CompareEpochNanoseconds(_one_.[[Nanoseconds]], _two_.[[Nanoseconds]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-zoneddatetime-prototype-object">
    <h1>Properties of the Temporal.ZonedDateTime Prototype Object</h1>

    <p>The Temporal.ZonedDateTime prototype object</p>
    <ul>
      <li>is itself an ordinary object.</li>
      <li>is not a Temporal.ZonedDateTime instance and does not have a [[InitializedTemporalZonedDateTime]] internal slot.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    </ul>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.constructor">
      <h1>Temporal.ZonedDateTime.prototype.constructor</h1>
      <p>The initial value of `Temporal.ZonedDateTime.prototype.constructor` is %Temporal.ZonedDateTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype-@@tostringtag">
      <h1>Temporal.ZonedDateTime.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value *"Temporal.ZonedDateTime"*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.calendar">
      <h1>get Temporal.ZonedDateTime.prototype.calendar</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.calendar` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return _zonedDateTime_.[[Calendar]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.timezone">
      <h1>get Temporal.ZonedDateTime.prototype.timeZone</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.timeZone` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return _zonedDateTime_.[[TimeZone]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.year">
      <h1>get Temporal.ZonedDateTime.prototype.year</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.year` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarYear(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.month">
      <h1>get Temporal.ZonedDateTime.prototype.month</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.month` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarMonth(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.monthcode">
      <h1>get Temporal.ZonedDateTime.prototype.monthCode</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.monthCode` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarMonthCode(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.day">
      <h1>get Temporal.ZonedDateTime.prototype.day</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.day` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarDay(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.hour">
      <h1>get Temporal.ZonedDateTime.prototype.hour</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.hour` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOHour]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.minute">
      <h1>get Temporal.ZonedDateTime.prototype.minute</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.minute` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMinute]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.second">
      <h1>get Temporal.ZonedDateTime.prototype.second</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.second` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOSecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.millisecond">
      <h1>get Temporal.ZonedDateTime.prototype.millisecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.millisecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMillisecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.microsecond">
      <h1>get Temporal.ZonedDateTime.prototype.microsecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.microsecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISOMicrosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.nanosecond">
      <h1>get Temporal.ZonedDateTime.prototype.nanosecond</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.nanosecond` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ùîΩ(_temporalDateTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochSeconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochSeconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _s_ be RoundTowardsZero(‚Ñù(_ns_) / 10<sup>9</sup>).
        1. Return ùîΩ(_s_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochmilliseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochMilliseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochMilliseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _ms_ be RoundTowardsZero(‚Ñù(_ns_) / 10<sup>6</sup>).
        1. Return ùîΩ(_ms_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochmicroseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochMicroseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochMicroseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _ns_ be _zonedDateTime_.[[Nanoseconds]].
        1. Let _¬µs_ be RoundTowardsZero(‚Ñù(_ns_) / 10<sup>3</sup>).
        1. Return ‚Ñ§(_¬µs_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.epochnanoseconds">
      <h1>get Temporal.ZonedDateTime.prototype.epochNanoseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.epochNanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return _zonedDateTime_.[[Nanoseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.dayofweek">
      <h1>get Temporal.ZonedDateTime.prototype.dayOfWeek</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.dayOfWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarDayOfWeek(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.dayofyear">
      <h1>get Temporal.ZonedDateTime.prototype.dayOfYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.dayOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarDayOfYear(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.weekofyear">
      <h1>get Temporal.ZonedDateTime.prototype.weekOfYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.weekOfYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarWeekOfYear(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.hoursinday">
      <h1>get Temporal.ZonedDateTime.prototype.hoursInDay</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.hoursInDay` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _isoCalendar_ be ? GetISO8601Calendar().
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _isoCalendar_).
        1. Let _year_ be _temporalDateTime_.[[ISOYear]].
        1. Let _month_ be _temporalDateTime_.[[ISOMonth]].
        1. Let _day_ be _temporalDateTime_.[[ISODay]].
        1. Let _today_ be ? CreateTemporalDateTime(_year_, _month_, _day_, 0, 0, 0, 0, 0, 0, _isoCalendar_).
        1. Let _tomorrowFields_ be ? AddISODate(_year_, _month_, _day_, 0, 0, 0, 1, *"reject"*).
        1. Let _tomorrow_ be ? CreateTemporalDateTime(_tomorrowFields_.[[Year]], _tomorrowFields_.[[Month]], _tomorrowFields_.[[Day]], 0, 0, 0, 0, 0, 0, _isoCalendar_).
        1. Let _todayInstant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _today_, *"compatible"*).
        1. Let _tomorrowInstant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _tomorrow_, *"compatible"*).
        1. Let _diffNs_ be _tomorrowInstant_.[[Nanoseconds]] ‚àí _todayInstant_.[[Nanoseconds]].
        1. Return ùîΩ(_diffNs_ / (3.6 √ó 10<sup>12</sup>)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinweek">
      <h1>get Temporal.ZonedDateTime.prototype.daysInWeek</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInWeek` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarDaysInWeek(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinmonth">
      <h1>get Temporal.ZonedDateTime.prototype.daysInMonth</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInMonth` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarDaysInMonth(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.daysinyear">
      <h1>get Temporal.ZonedDateTime.prototype.daysInYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.daysInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarDaysInYear(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.monthsinyear">
      <h1>get Temporal.ZonedDateTime.prototype.monthsInYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.monthsInYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarMonthsInYear(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.inleapyear">
      <h1>get Temporal.ZonedDateTime.prototype.inLeapYear</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.inLeapYear` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CalendarInLeapYear(_calendar_, _temporalDateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.offsetnanoseconds">
      <h1>get Temporal.ZonedDateTime.prototype.offsetNanoseconds</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.offsetNanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Return ùîΩ(? GetOffsetNanosecondsFor(_timeZone_, _instant_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.zoneddatetime.prototype.offset">
      <h1>get Temporal.ZonedDateTime.prototype.offset</h1>
      <p>
        `Temporal.ZonedDateTime.prototype.offset` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Return ? BuiltinTimeZoneGetOffsetStringFor(_zonedDateTime_.[[TimeZone]], _instant_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.with">
      <h1>Temporal.ZonedDateTime.prototype.with ( _temporalZonedDateTimeLike_ [ , _options_ ] )</h1>
      <p>
        The `with` method takes two arguments, _temporalZonedDateTimeLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. If Type(_temporalZonedDateTimeLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Perform ? RejectTemporalCalendarType(_temporalZonedDateTimeLike_).
        1. Let _calendarProperty_ be ? Get(_temporalZonedDateTimeLike_, *"calendar"*).
        1. If _calendarProperty_ is not *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _timeZoneProperty_ be ? Get(_temporalZonedDateTimeLike_, *"timeZone"*).
        1. If _timeZoneProperty_ is not *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"monthCode"*, *"nanosecond"*, *"second"*, *"year"* ¬ª).
        1. Append *"offset"* to _fieldNames_.
        1. Let _partialZonedDateTime_ be ? PreparePartialTemporalFields(_temporalZonedDateTimeLike_, _fieldNames_).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
        1. Let _offset_ be ? ToTemporalOffset(_options_, *"prefer"*).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Append *"timeZone"* to _fieldNames_.
        1. Let _fields_ be ? PrepareTemporalFields(_zonedDateTime_, _fieldNames_, ¬´ *"timeZone"* ¬ª).
        1. Set _fields_ to ? CalendarMergeFields(_calendar_, _fields_, _partialZonedDateTime_).
        1. Set _fields_ to ? PrepareTemporalFields(_fields_, _fieldNames_, ¬´ *"timeZone"* ¬ª).
        1. Let _offsetString_ be ? Get(_partialZonedDateTime_, *"offset"*).
        1. If _offsetString_ is not *undefined*, then
          1. Perform ? Set(_fields_, *"offset"*, _offsetString_).
        1. Else,
          1. Set _offsetString_ to ? Get(_fields_, *"offset"*).
        1. Let _dateTimeResult_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _options_).
        1. Let _offsetNanoseconds_ be ? ParseTimeZoneOffsetString(_offsetString_).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_dateTimeResult_.[[Year]], _dateTimeResult_.[[Month]], _dateTimeResult_.[[Day]], _dateTimeResult_.[[Hour]], _dateTimeResult_.[[Minute]], _dateTimeResult_.[[Second]], _dateTimeResult_.[[Millisecond]], _dateTimeResult_.[[Microsecond]], _dateTimeResult_.[[Nanosecond]], _offsetNanoseconds_, _timeZone_, _disambiguation_, _offset_).
        1. Return ? CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withplaintime">
      <h1>Temporal.ZonedDateTime.prototype.withPlainTime ( [ _plainTimeLike_ ] )</h1>
      <p>
        The `withPlainTime` method takes one argument _plainTimeLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. If _plainTimeLike_ is *undefined*, then
          1. Let _plainTime_ be ? CreateTemporalTime(0, 0, 0, 0, 0, 0).
        1. Else,
          1. Let _plainTime_ be ? ToTemporalTime(_plainTimeLike_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _plainDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _resultPlainDateTime_ be ? CreateTemporalDateTime(_plainDateTime_.[[ISOYear]], _plainDateTime_.[[ISOMonth]], _plainDateTime_.[[ISODay]], _plainTime_.[[ISOHour]], _plainTime_.[[ISOMinute]], _plainTime_.[[ISOSecond]], _plainTime_.[[ISOMillisecond]], _plainTime_.[[ISOMicrosecond]], _plainTime_.[[ISONanosecond]], _calendar_).
        1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _resultPlainDateTime_, *"compatible"*).
        1. Return ? CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withplaindate">
      <h1>Temporal.ZonedDateTime.prototype.withPlainDate ( _plainDateLike_ )</h1>
      <p>
        The `withPlainDate` method takes one argument _plainDateLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _plainDate_ be ? ToTemporalDate(_plainDateLike_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _plainDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _zonedDateTime_.[[Calendar]]).
        1. Let _calendar_ be ? ConsolidateCalendars(_zonedDateTime_.[[Calendar]], _plainDate_.[[Calendar]]).
        1. Let _resultPlainDateTime_ be ? CreateTemporalDateTime(_plainDate_.[[ISOYear]], _plainDate_.[[ISOMonth]], _plainDate_.[[ISODay]], _plainDateTime_.[[ISOHour]], _plainDateTime_.[[ISOMinute]], _plainDateTime_.[[ISOSecond]], _plainDateTime_.[[ISOMillisecond]], _plainDateTime_.[[ISOMicrosecond]], _plainDateTime_.[[ISONanosecond]], _calendar_).
        1. Set _instant_ to ? BuiltinTimeZoneGetInstantFor(_timeZone_, _resultPlainDateTime_, *"compatible"*).
        1. Return ? CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withtimezone">
      <h1>Temporal.ZonedDateTime.prototype.withTimeZone ( _timeZoneLike_ )</h1>
      <p>
        The `withTimeZone` method takes one argument _timeZoneLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be ? ToTemporalTimeZone(_timeZoneLike_).
        1. Return ? CreateTemporalZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _timeZone_, _zonedDateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.withcalendar">
      <h1>Temporal.ZonedDateTime.prototype.withCalendar ( _calendarLike_ )</h1>
      <p>
        The `withCalendar` method takes one argument _calendarLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _calendar_ be ? ToTemporalCalendar(_calendarLike_).
        1. Return ? CreateTemporalZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _zonedDateTime_.[[TimeZone]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.add">
      <h1>Temporal.ZonedDateTime.prototype.add ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `add` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _epochNanoseconds_ be ? AddZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _timeZone_, _calendar_, _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]], _options_).
        1. Return ? CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.subtract">
      <h1>Temporal.ZonedDateTime.prototype.subtract ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `subtract` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ ¬ª).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _epochNanoseconds_ be ? AddZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _timeZone_, _calendar_, ‚àí_duration_.[[Years]], ‚àí_duration_.[[Months]], ‚àí_duration_.[[Weeks]], ‚àí_duration_.[[Days]], ‚àí_duration_.[[Hours]], ‚àí_duration_.[[Minutes]], ‚àí_duration_.[[Seconds]], ‚àí_duration_.[[Milliseconds]], ‚àí_duration_.[[Microseconds]], ‚àí_duration_.[[Nanoseconds]], _options_).
        1. Return ? CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.until">
      <h1>Temporal.ZonedDateTime.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        The `until` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Set _other_ to ? ToTemporalZonedDateTime(_other_).
        1. If ? CalendarEquals(_zonedDateTime_.[[Calendar]], _other_.[[Calendar]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, ¬´ ¬ª, *"nanosecond"*).
        1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalUnits(*"hour"*, _smallestUnit_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, ¬´ ¬ª, *"auto"*, _defaultLargestUnit_).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. If _largestUnit_ is not one of *"year"*, *"month"*, *"week"*, or *"day"*, then
          1. Let _differenceNs_ be ! DifferenceInstant(_zonedDateTime_.[[Nanoseconds]], _other_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
          1. Let _balanceResult_ be ! BalanceDuration(0, 0, 0, 0, 0, 0, _differenceNs_, _largestUnit_).
          1. Return ? CreateTemporalDuration(0, 0, 0, 0, _balanceResult_.[[Hours]], _balanceResult_.[[Minutes]], _balanceResult_.[[Seconds]], _balanceResult_.[[Milliseconds]], _balanceResult_.[[Microseconds]], _balanceResult_.[[Nanoseconds]]).
        1. If ? TimeZoneEquals(_zonedDateTime_.[[TimeZone]], _other_.[[TimeZone]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. Let _difference_ be ? DifferenceZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _other_.[[Nanoseconds]], _zonedDateTime_.[[TimeZone]], _zonedDateTime_.[[Calendar]], _largestUnit_).
        1. Let _roundResult_ be ? RoundDuration(_difference_.[[Years]], _difference_.[[Months]], _difference_.[[Weeks]], _difference_.[[Days]], _difference_.[[Hours]], _difference_.[[Minutes]], _difference_.[[Seconds]], _difference_.[[Milliseconds]], _difference_.[[Microseconds]], _difference_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _zonedDateTime_).
        1. Let _result_ be ? AdjustRoundedDurationDays(_roundResult_.[[Years]], _roundResult_.[[Months]], _roundResult_.[[Weeks]], _roundResult_.[[Days]], _roundResult_.[[Hours]], _roundResult_.[[Minutes]], _roundResult_.[[Seconds]], _roundResult_.[[Milliseconds]], _roundResult_.[[Microseconds]], _roundResult_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _zonedDateTime_).
        1. Return ? CreateTemporalDuration(_result_.[[Years]], _result_.[[Months]], _result_.[[Weeks]], _result_.[[Days]], _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.since">
      <h1>Temporal.ZonedDateTime.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        The `since` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Set _other_ to ? ToTemporalZonedDateTime(_other_).
        1. If ? CalendarEquals(_zonedDateTime_.[[Calendar]], _other_.[[Calendar]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, ¬´ ¬ª, *"nanosecond"*).
        1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalUnits(*"hour"*, _smallestUnit_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, ¬´ ¬ª, *"auto"*, _defaultLargestUnit_).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Set _roundingMode_ to ! NegateTemporalRoundingMode(_roundingMode_).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. If _largestUnit_ is not one of *"year"*, *"month"*, *"week"*, or *"day"*, then
          1. Let _differenceNs_ be ! DifferenceInstant(_zonedDateTime_.[[Nanoseconds]], _other_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
          1. Let _balanceResult_ be ! BalanceDuration(0, 0, 0, 0, 0, 0, _differenceNs_, _largestUnit_).
          1. Return ? CreateTemporalDuration(0, 0, 0, 0, ‚àí_balanceResult_.[[Hours]], ‚àí_balanceResult_.[[Minutes]], ‚àí_balanceResult_.[[Seconds]], ‚àí_balanceResult_.[[Milliseconds]], ‚àí_balanceResult_.[[Microseconds]], ‚àí_balanceResult_.[[Nanoseconds]]).
        1. If ? TimeZoneEquals(_zonedDateTime_.[[TimeZone]], _other_.[[TimeZone]]) is *false*, then
          1. Throw a *RangeError* exception.
        1. Let _difference_ be ? DifferenceZonedDateTime(_zonedDateTime_.[[Nanoseconds]], _other_.[[Nanoseconds]], _zonedDateTime_.[[TimeZone]], _zonedDateTime_.[[Calendar]], _largestUnit_).
        1. Let _roundResult_ be ? RoundDuration(_difference_.[[Years]], _difference_.[[Months]], _difference_.[[Weeks]], _difference_.[[Days]], _difference_.[[Hours]], _difference_.[[Minutes]], _difference_.[[Seconds]], _difference_.[[Milliseconds]], _difference_.[[Microseconds]], _difference_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _zonedDateTime_).
        1. Let _result_ be ? AdjustRoundedDurationDays(_roundResult_.[[Years]], _roundResult_.[[Months]], _roundResult_.[[Weeks]], _roundResult_.[[Days]], _roundResult_.[[Hours]], _roundResult_.[[Minutes]], _roundResult_.[[Seconds]], _roundResult_.[[Milliseconds]], _roundResult_.[[Microseconds]], _roundResult_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _zonedDateTime_).
        1. Return ? CreateTemporalDuration(‚àí_result_.[[Years]], ‚àí_result_.[[Months]], ‚àí_result_.[[Weeks]], ‚àí_result_.[[Days]], ‚àí_result_.[[Hours]], ‚àí_result_.[[Minutes]], ‚àí_result_.[[Seconds]], ‚àí_result_.[[Milliseconds]], ‚àí_result_.[[Microseconds]], ‚àí_result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.round">
      <h1>Temporal.ZonedDateTime.prototype.round ( _options_ )</h1>
      <p>
        The `round` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. If _options_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, ¬´ *"year"*, *"month"*, *"week"* ¬ª, *undefined*).
        1. If _smallestUnit_ is *undefined*, throw a *RangeError* exception.
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"halfExpand"*).
        1. Let _roundingIncrement_ be ? ToTemporalDateTimeRoundingIncrement(_options_, _smallestUnit_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _isoCalendar_ be ? GetISO8601Calendar().
        1. Let _dtStart_ be ? CreateTemporalDateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], 0, 0, 0, 0, 0, 0, _isoCalendar_).
        1. Let _instantStart_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _dtStart_, *"compatible"*).
        1. Let _startNs_ be _instantStart_.[[Nanoseconds]].
        1. Let _endNs_ be ? AddZonedDateTime(_startNs_, _timeZone_, _zonedDateTime_.[[Calendar]], 0, 0, 0, 1, 0, 0, 0, 0, 0, 0).
        1. Let _dayLengthNs_ be ‚Ñù(_endNs_ ‚àí _startNs_).
        1. If _dayLengthNs_ is 0, then
          1. Throw a *RangeError* exception.
        1. Let _roundResult_ be ! RoundISODateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], _roundingIncrement_, _smallestUnit_, _roundingMode_, _dayLengthNs_).
        1. Let _offsetNanoseconds_ be ? GetOffsetNanosecondsFor(_timeZone_, _instant_).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_roundResult_.[[Year]], _roundResult_.[[Month]], _roundResult_.[[Day]], _roundResult_.[[Hour]], _roundResult_.[[Minute]], _roundResult_.[[Second]], _roundResult_.[[Millisecond]], _roundResult_.[[Microsecond]], _roundResult_.[[Nanosecond]], _offsetNanoseconds_, _timeZone_, *"compatible"*, *"prefer"*).
        1. Return ? CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.equals">
      <h1>Temporal.ZonedDateTime.prototype.equals ( _other_ )</h1>
      <p>
        The `equals` method takes one argument _other_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Set _other_ to ? ToTemporalZonedDateTime(_other_).
        1. If _zonedDateTime_.[[Nanoseconds]] ‚â† _other_.[[Nanoseconds]], return *false*.
        1. If ? TimeZoneEquals(_zonedDateTime_.[[TimeZone]], _other_.[[TimeZone]]) is *false*, return *false*.
        1. Return ? CalendarEquals(_zonedDateTime_.[[Calendar]], _other_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tostring">
      <h1>Temporal.ZonedDateTime.prototype.toString ( [ _options_ ] )</h1>
      <p>
        The `toString` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Set _options_ to ? GetOptionsObject(_options_).
        1. Let _precision_ be ? ToSecondsStringPrecision(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _showCalendar_ be ? ToShowCalendarOption(_options_).
        1. Let _showTimeZone_ be ? ToShowTimeZoneNameOption(_options_).
        1. Let _showOffset_ be ? ToShowOffsetOption(_options_).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, _precision_.[[Precision]], _showCalendar_, _showTimeZone_, _showOffset_, _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tolocalestring">
      <h1>Temporal.ZonedDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Temporal.ZonedDateTime.prototype.toLocaleString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleString` method is used.
      </p>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, *"auto"*, *"auto"*, *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.tojson">
      <h1>Temporal.ZonedDateTime.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ? TemporalZonedDateTimeToString(_zonedDateTime_, *"auto"*, *"auto"*, *"auto"*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.valueof">
      <h1>Temporal.ZonedDateTime.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.startofday">
      <h1>Temporal.ZonedDateTime.prototype.startOfDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _startDateTime_ be ? CreateTemporalDateTime(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], 0, 0, 0, 0, 0, 0, _calendar_).
        1. Let _startInstant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _startDateTime_, *"compatible"*).
        1. Return ? CreateTemporalZonedDateTime(_startInstant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toinstant">
      <h1>Temporal.ZonedDateTime.prototype.toInstant ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Return ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaindate">
      <h1>Temporal.ZonedDateTime.prototype.toPlainDate ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Return ? CreateTemporalDate(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaintime">
      <h1>Temporal.ZonedDateTime.prototype.toPlainTime ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _zonedDateTime_.[[Calendar]]).
        1. Return ? CreateTemporalTime(_temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplaindatetime">
      <h1>Temporal.ZonedDateTime.prototype.toPlainDateTime ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Return ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _zonedDateTime_.[[Calendar]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplainyearmonth">
      <h1>Temporal.ZonedDateTime.prototype.toPlainYearMonth ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"monthCode"*, *"year"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDateTime_, _fieldNames_, ¬´¬ª).
        1. Return ? YearMonthFromFields(_calendar_, _fields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.toplainmonthday">
      <h1>Temporal.ZonedDateTime.prototype.toPlainMonthDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"monthCode"* ¬ª).
        1. Let _fields_ be ? PrepareTemporalFields(_temporalDateTime_, _fieldNames_, ¬´¬ª).
        1. Return ? MonthDayFromFields(_calendar_, _fields_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.zoneddatetime.prototype.getisofields">
      <h1>Temporal.ZonedDateTime.prototype.getISOFields ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _fields_ be ! OrdinaryObjectCreate(%Object.prototype%).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[Nanoseconds]]).
        1. Let _calendar_ be _zonedDateTime_.[[Calendar]].
        1. Let _dateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _offset_ be ? BuiltinTimeZoneGetOffsetStringFor(_timeZone_, _instant_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"calendar"*, _calendar_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoDay"*, _dateTime_.[[ISODay]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoHour"*, _dateTime_.[[ISOHour]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMicrosecond"*, _dateTime_.[[ISOMicrosecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMillisecond"*, _dateTime_.[[ISOMillisecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMinute"*, _dateTime_.[[ISOMinute]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoMonth"*, _dateTime_.[[ISOMonth]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoNanosecond"*, _dateTime_.[[ISONanosecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoSecond"*, _dateTime_.[[ISOSecond]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"isoYear"*, _dateTime_.[[ISOYear]]).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"offset"*, _offset_).
        1. Perform ! CreateDataPropertyOrThrow(_fields_, *"timeZone"*, _timeZone_).
        1. Return _fields_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-zoneddatetime-instances">
    <h1>Properties of Temporal.ZonedDateTime Instances</h1>
    <p>
      Temporal.ZonedDateTime instances are ordinary objects that inherit properties from the %Temporal.ZonedDateTime.prototype% intrinsic object.
      Temporal.ZonedDateTime instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporalzoneddatetime-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporalzoneddatetime-instances" caption="Internal Slots of Temporal.ZonedDateTime Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalZonedDateTime]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.ZonedDateTime instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[Nanoseconds]]
            </td>
            <td>
              A BigInt value representing the number of nanoseconds since the Unix epoch.
            </td>
          </tr>
          <tr>
            <td>
              [[TimeZone]]
            </td>
            <td>
              An Object representing the time zone.
            </td>
          </tr>
          <tr>
            <td>
              [[Calendar]]
            </td>
            <td>
              An Object representing the calendar.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-zoneddatetime-abstract-ops">
    <h1>Abstract operations</h1>

    <emu-clause id="sec-temporal-interpretisodatetimeoffset" aoid="InterpretISODateTimeOffset">
      <h1>InterpretISODateTimeOffset ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _offsetNanoseconds_, _timeZone_, _disambiguation_, _offset_ )</h1>
      <p>
        The abstract operation InterpretISODateTimeOffset determines the exact time in _timeZone_ corresponding to the given calendar date and time, and the given UTC offset in nanoseconds.
        In the case of more than one possible exact time, or no possible exact time, an answer is determined using _disambiguation_ and _offset_.
      </p>
      <emu-alg>
        1. Assert: _offsetNanoseconds_ is an integer or *null*.
        1. Let _calendar_ be ? GetISO8601Calendar().
        1. Let _dateTime_ be ? CreateTemporalDateTime(_year_, _month_, _day_, _hour_, _minute_. _second_, _millisecond_, _microsecond_, _nanosecond_, _calendar_).
        1. If _offsetNanoseconds_ is *null*, or _offset_ is *"ignore"*, then
          1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _dateTime_, _disambiguation_).
          1. Return _instant_.[[Nanoseconds]].
        1. If _offset_ is *"use"*, then
          1. Let _epochNanoseconds_ be ? GetEpochFromISOParts(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
          1. Return _epochNanoseconds_ ‚àí _offsetNanoseconds_.
        1. Assert: _offset_ is *"prefer"* or *"reject"*.
        1. Let _possibleInstants_ be ? GetPossibleInstantsFor(_timeZone_, _dateTime_).
        1. For each element _candidate_ of _possibleInstants_, do
          1. If ? GetOffsetNanosecondsFor(_timeZone_, _candidate_) = _offsetNanoseconds_, then
            1. Return _candidate_.[[Nanoseconds]].
        1. If _offset_ is *"reject"*, throw a *RangeError* exception.
        1. Let _instant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _dateTime_, _disambiguation_).
        1. Return _instant_.[[Nanoseconds]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalzoneddatetime" aoid="ToTemporalZonedDateTime">
      <h1>ToTemporalZonedDateTime ( _item_ [ , _options_ ] )</h1>
      <p>
        The abstract operation ToTemporalZonedDateTime returns its argument _item_ if it is already a Temporal.ZonedDateTime instance, converts _item_ to a new Temporal.PlainDate instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _options_ is not present, set _options_ to ! OrdinaryObjectCreate(*null*).
        1. If Type(_item_) is Object, then
          1. If _item_ has an [[InitializedTemporalZonedDateTime]] internal slot, then
            1. Return _item_.
          1. Let _calendar_ be ? GetTemporalCalendarWithISODefault(_item_).
          1. Let _fieldNames_ be ? CalendarFields(_calendar_, ¬´ *"day"*, *"hour"*, *"microsecond"*, *"millisecond"*, *"minute"*, *"month"*, *"monthCode"*, *"nanosecond"*, *"second"*, *"year"* ¬ª).
          1. Append *"timeZone"* to _fieldNames_.
          1. Let _fields_ be ? PrepareTemporalFields(_item_, _fieldNames_, ¬´ *"timeZone"* ¬ª).
          1. Let _timeZone_ be ? Get(_fields_, *"timeZone"*).
          1. Set _timeZone_ to ? ToTemporalTimeZone(_timeZone_).
          1. Let _offsetString_ be ? Get(_fields_, *"offset"*).
          1. If _offsetString_ is not *undefined*, set it to ? ToString(_offsetString_).
          1. Let _result_ be ? InterpretTemporalDateTimeFields(_calendar_, _fields_, _options_).
        1. Else,
          1. Perform ? ToTemporalOverflow(_options_).
          1. Let _string_ be ? ToString(_item_).
          1. Let _result_ be ? ParseTemporalZonedDateTimeString(_string_).
          1. If _result_.[[TimeZoneName]] is *undefined*, throw a *RangeError* exception.
          1. Let _timeZone_ be ? CreateTemporalTimeZone(_result_.[[TimeZoneName]]).
          1. Let _offsetString_ be _result_.[[TimeZoneOffsetString]].
          1. Let _calendar_ be ? ToTemporalCalendarWithISODefault(_result_.[[Calendar]]).
        1. Let _offsetNanoseconds_ be ? ParseTimeZoneOffsetString(_offsetString_).
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
        1. Let _offset_ be ? ToTemporalOffset(_options_, *"reject"*).
        1. Let _epochNanoseconds_ be ? InterpretISODateTimeOffset(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _offsetNanoseconds_, _timeZone_, _disambiguation_, _offset_).
        1. Return ? CreateTemporalZonedDateTime(_epochNanoseconds_, _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalzoneddatetime" aoid="CreateTemporalZonedDateTime">
      <h1>CreateTemporalZonedDateTime ( _epochNanoseconds_, _timeZone_, _calendar_ [ , _newTarget_ ] )</h1>
      <p>
        The abstract operation CreateTemporalZonedDateTime is used to specify the creation of a new `Temporal.ZonedDateTime` object.
      </p>
      <emu-alg>
        1. Assert: Type(_epochNanoseconds_) is BigInt.
        1. Assert: ! IsValidEpochNanoseconds(_epochNanoseconds_) is *true*.
        1. Assert: Type(_timeZone_) is Object.
        1. Assert: Type(_calendar_) is Object.
        1. If _newTarget_ is not present, set it to %Temporal.ZonedDateTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Temporal.ZonedDateTime.prototype%"*, ¬´ [[InitializedTemporalZonedDateTime]], [[Nanoseconds]], [[TimeZone]], [[Calendar]] ¬ª).
        1. Set _object_.[[Nanoseconds]] to _epochNanoseconds_.
        1. Set _object_.[[TimeZone]] to _timeZone_.
        1. Set _object_.[[Calendar]] to _calendar_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporalzoneddatetimetostring" aoid="TemporalZonedDateTimeToString">
      <h1>TemporalZonedDateTimeToString ( _zonedDateTime_, _precision_, _showCalendar_, _showTimeZone_, _showOffset_ [ , _increment_, _unit_, _roundingMode_ ] )</h1>
      <p>
        The abstract operation TemporalZonedDateTimeToString returns an ISO 8601 string representation of its argument, including a time zone name annotation and calendar annotation, which are extensions to the ISO 8601 format.
      </p>
      <emu-alg>
        1. Assert: Type(_zonedDateTime_) is Object and _zonedDateTime_ has an [[InitializedTemporalZonedDateTime]] internal slot.
        1. If _increment_ is not present, set it to 1.
        1. If _unit_ is not present, set it to *"nanosecond"*.
        1. If _roundingMode_ is not present, set it to *"trunc"*.
        1. Let _ns_ be ? RoundTemporalInstant(_zonedDateTime_.[[Nanoseconds]], _increment_, _unit_, _roundingMode_).
        1. Let _timeZone_ be _zonedDateTime_.[[TimeZone]].
        1. Let _instant_ be ! CreateTemporalInstant(_ns_).
        1. Let _isoCalendar_ be ? GetISO8601Calendar().
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _isoCalendar_).
        1. Let _dateTimeString_ be ? TemporalDateTimeToString(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], _isoCalendar_, _precision_, *"never"*).
        1. If _showOffset_ is *"never"*, then
          1. Let _offsetString_ be the empty String.
        1. Else,
          1. Let _offsetString_ be ? BuiltinTimeZoneGetOffsetStringFor(_timeZone_, _instant_).
        1. If _showTimeZone_ is *"never"*, then
          1. Let _timeZoneString_ be the empty String.
        1. Else,
          1. Let _timeZoneID_ be ? ToString(_timeZone_).
          1. Let _timeZoneString_ be the string-concatenation of the code unit 0x005B (LEFT SQUARE BRACKET), _timeZoneID_, and the code unit 0x005D (RIGHT SQUARE BRACKET).
        1. Let _calendarID_ be ? ToString(_zonedDateTime_.[[Calendar]]).
        1. Let _calendarString_ be ! FormatCalendarAnnotation(_calendarID_, _showCalendar_).
        1. Return the string-concatenation of _dateTimeString_, _offsetString_, _timeZoneString_, and _calendarString_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addzoneddatetime" aoid="AddZonedDateTime">
      <h1>AddZonedDateTime ( _epochNanoseconds_, _timeZone_, _calendar_, _years_, _months_, _weeks_, _days_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ [ , _options_ ] )</h1>
      <p>
        The abstract operation AddZonedDateTime adds a duration in various units to a number of nanoseconds _epochNanoseconds_ since the Unix epoch, subject to the rules of _timeZone_ and _calendar_.
        As specified in <a href="https://tools.ietf.org/html/rfc5545">RFC 5545</a>, the date portion of the duration is added in calendar days, and the time portion is added in exact time.
      </p>
      <emu-alg>
        1. If _options_ is not present, set _options_ to ! OrdinaryObjectCreate(*null*).
        1. If all of _years_, _months_, _weeks_, and _days_ are 0, then
          1. Return ! AddInstant(_epochNanoseconds_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
        1. Let _instant_ be ! CreateTemporalInstant(_epochNanoseconds_).
        1. Let _temporalDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _instant_, _calendar_).
        1. Let _datePart_ be ? CreateTemporalDate(_temporalDateTime_.[[ISOYear]], _temporalDateTime_.[[ISOMonth]], _temporalDateTime_.[[ISODay]], _calendar_).
        1. Let _dateDuration_ be ? CreateTemporalDuration(_years_, _months_, _weeks_, _days_, 0, 0, 0, 0, 0, 0).
        1. Let _addedDate_ be ? CalendarDateAdd(_calendar_, _datePart_, _dateDuration_, _options_).
        1. Let _intermediateDateTime_ be ? CreateTemporalDateTime(_addedDate_.[[ISOYear]], _addedDate_.[[ISOMonth]], _addedDate_.[[ISODay]], _temporalDateTime_.[[ISOHour]], _temporalDateTime_.[[ISOMinute]], _temporalDateTime_.[[ISOSecond]], _temporalDateTime_.[[ISOMillisecond]], _temporalDateTime_.[[ISOMicrosecond]], _temporalDateTime_.[[ISONanosecond]], _calendar_).
        1. Let _intermediateInstant_ be ? BuiltinTimeZoneGetInstantFor(_timeZone_, _intermediateDateTime_, *"compatible"*).
        1. Return ! AddInstant(_intermediateInstant_.[[Nanoseconds]], _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differencezoneddatetime" aoid="DifferenceZonedDateTime">
      <h1>DifferenceZonedDateTime ( _ns1_, _ns2_, _timeZone_, _calendar_, _largestUnit_ [ , _options_ ] )</h1>
      <p>
        The abstract operation DifferenceZonedDateTime computes the difference between two exact times expressed in nanoseconds since the Unix epoch, and balances the result so that there is no non-zero unit larger than _largestUnit_ in the result, taking calendar reckoning and time zone offset changes into account.
      </p>
      <emu-alg>
        1. Assert: Type(_ns1_) is BigInt.
        1. Assert: Type(_ns2_) is BigInt.
        1. If _ns1_ is _ns2_, then
          1. Return the new Record { [[Years]]: 0, [[Months]]: 0, [[Weeks]]: 0, [[Days]]: 0, [[Hours]]: 0, [[Minutes]]: 0, [[Seconds]]: 0, [[Milliseconds]]: 0, [[Microseconds]]: 0, [[Nanoseconds]]: 0 }.
        1. Let _startInstant_ be ! CreateTemporalInstant(_ns1_).
        1. Let _startDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _startInstant_, _calendar_).
        1. Let _endInstant_ be ! CreateTemporalInstant(_ns2_).
        1. Let _endDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_timeZone_, _endInstant_, _calendar_).
        1. Let _dateDifference_ be ? DifferenceISODateTime(_startDateTime_.[[ISOYear]], _startDateTime_.[[ISOMonth]], _startDateTime_.[[ISODay]], _startDateTime_.[[ISOHour]], _startDateTime_.[[ISOMinute]], _startDateTime_.[[ISOSecond]], _startDateTime_.[[ISOMillisecond]], _startDateTime_.[[ISOMicrosecond]], _startDateTime_.[[ISONanosecond]], _endDateTime_.[[ISOYear]], _endDateTime_.[[ISOMonth]], _endDateTime_.[[ISODay]], _endDateTime_.[[ISOHour]], _endDateTime_.[[ISOMinute]], _endDateTime_.[[ISOSecond]], _endDateTime_.[[ISOMillisecond]], _endDateTime_.[[ISOMicrosecond]], _endDateTime_.[[ISONanosecond]], _calendar_, _largestUnit_, _options_).
        1. Let _intermediateNs_ be ? AddZonedDateTime(_ns1_, _timeZone_, _calendar_, _dateDifference_.[[Years]], _dateDifference_.[[Months]], _dateDifference_.[[Weeks]], 0, 0, 0, 0, 0, 0, 0).
        1. Let _timeRemainderNs_ be _ns2_ ‚àí _intermediateNs_.
        1. Let _intermediate_ be ? CreateTemporalZonedDateTime(_intermediateNs_, _timeZone_, _calendar_).
        1. Let _result_ be ? NanosecondsToDays(_timeRemainderNs_, _intermediate_).
        1. Let _timeDifference_ be ! BalanceDuration(0, 0, 0, 0, 0, 0, _result_.[[Nanoseconds]], *"hour"*).
        1. Return the new Record { [[Years]]: _dateDifference_.[[Years]], [[Months]]: _dateDifference_.[[Months]], [[Weeks]]: _dateDifference_.[[Weeks]], [[Days]]: _result_.[[Days]], [[Hours]]: _timeDifference_.[[Hours]], [[Minutes]]: _timeDifference_.[[Minutes]], [[Seconds]]: _timeDifference_.[[Seconds]], [[Milliseconds]]: _timeDifference_.[[Milliseconds]], [[Microseconds]]: _timeDifference_.[[Microseconds]], [[Nanoseconds]]: _timeDifference_.[[Nanoseconds]] }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-nanosecondstodays" aoid="NanosecondsToDays">
      <h1>NanosecondsToDays ( _nanoseconds_, _relativeTo_ )</h1>
      <p>
        The abstract operation NanosecondsToDays takes a number of nanoseconds relative to a Temporal.ZonedDateTime _relativeTo_, and converts it into a number of days and remainder of nanoseconds, taking into account any offset changes in the time zone of _relativeTo_.
        It also returns the length of the last day in nanoseconds, for rounding purposes.
      </p>
      <emu-alg>
        1. Assert: Type(_nanoseconds_) is BigInt.
        1. Set _nanoseconds_ to ‚Ñù(_nanoseconds_).
        1. Let _sign_ be ! ‚Ñù(Sign(ùîΩ(_nanoseconds_))).
        1. Let _dayLengthNs_ be 8.64 √ó 10<sup>13</sup>.
        1. If _sign_ is 0, then
          1. Return the new Record { [[Days]]: 0, [[Nanoseconds]]: 0, [[DayLength]]: _dayLengthNs_ }.
        1. If Type(_relativeTo_) is not Object or _relativeTo_ does not have an [[InitializedTemporalZonedDateTime]] internal slot, then
          1. Return the new Record {
            [[Days]]: the integral part of _nanoseconds_ / _dayLengthNs_,
            [[Nanoseconds]]: _nanoseconds_ modulo _dayLengthNs_,
            [[DayLength]]: _dayLengthNs_
            }.
        1. Let _startNs_ be ‚Ñù(_relativeTo_.[[Nanoseconds]]).
        1. Let _startInstant_ be ! CreateTemporalInstant(‚Ñ§(_startNs_)).
        1. Let _startDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_relativeTo_.[[TimeZone]], _startInstant_, _relativeTo_.[[Calendar]]).
        1. Let _endNs_ be _startNs_ + _nanoseconds_.
        1. Let _endInstant_ be ! CreateTemporalInstant(‚Ñ§(_endNs_)).
        1. Let _endDateTime_ be ? BuiltinTimeZoneGetPlainDateTimeFor(_relativeTo_.[[TimeZone]], _endInstant_, _relativeTo_.[[Calendar]]).
        1. Let _dateDifference_ be ? DifferenceISODateTime(_startDateTime_.[[ISOYear]], _startDateTime_.[[ISOMonth]], _startDateTime_.[[ISODay]], _startDateTime_.[[ISOHour]], _startDateTime_.[[ISOMinute]], _startDateTime_.[[ISOSecond]], _startDateTime_.[[ISOMillisecond]], _startDateTime_.[[ISOMicrosecond]], _startDateTime_.[[ISONanosecond]], _endDateTime_.[[ISOYear]], _endDateTime_.[[ISOMonth]], _endDateTime_.[[ISODay]], _endDateTime_.[[ISOHour]], _endDateTime_.[[ISOMinute]], _endDateTime_.[[ISOSecond]], _endDateTime_.[[ISOMillisecond]], _endDateTime_.[[ISOMicrosecond]], _endDateTime_.[[ISONanosecond]], _relativeTo_.[[Calendar]], *"day"*).
        1. Let _days_ be _dateDifference_.[[Days]].
        1. Let _intermediateNs_ be ‚Ñù(? AddZonedDateTime(‚Ñ§(_startNs_), _relativeTo_.[[TimeZone]], _relativeTo_.[[Calendar]], 0, 0, 0, _days_, 0, 0, 0, 0, 0, 0)).
        1. If _sign_ is 1, then
          1. Repeat, while _days_ &gt; 0 and _intermediateNs_ &gt; _endNs_,
            1. Set _days_ to _days_ ‚àí 1.
            1. Set _intermediateNs_ to ‚Ñù(? AddZonedDateTime(‚Ñ§(_startNs_), _relativeTo_.[[TimeZone]], _relativeTo_.[[Calendar]], 0, 0, 0, _days_, 0, 0, 0, 0, 0, 0)).
        1. Set _nanoseconds_ to _endNs_ ‚àí _intermediateNs_.
        1. Let _done_ be *false*.
        1. Repeat, while _done_ is *false*,
          1. Let _oneDayFartherNs_ be ‚Ñù(? AddZonedDateTime(‚Ñ§(_intermediateNs_), _relativeTo_.[[TimeZone]], _relativeTo_.[[Calendar]], 0, 0, 0, _sign_, 0, 0, 0, 0, 0, 0)).
          1. Set _dayLengthNs_ to _oneDayFartherNs_ ‚àí _intermediateNs_.
          1. If (_nanoseconds_ ‚àí _dayLengthNs_) √ó _sign_ ‚â• 0, then
            1. Set _nanoseconds_ to _nanoseconds_ ‚àí _dayLengthNs_.
            1. Set _intermediateNs_ to _oneDayFartherNs_.
            1. Set _days_ to _days_ + _sign_.
          1. Else,
            1. Set _done_ to *true*.
        1. Return the new Record {
          [[Days]]: _days_,
          [[Nanoseconds]]: _nanoseconds_,
          [[DayLength]]: abs(_dayLengthNs_)
          }.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
