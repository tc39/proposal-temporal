<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Temporal documentation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <script type="application/javascript" src="../playground.js"></script>
    <link rel="stylesheet" type="text/css" href="../prism.css">
    <script>
      Temporal = { ...temporal.Temporal };
      Object.assign(Intl, temporal.Intl);

      // Customize output of Temporal objects for Chrome DevTools
      if (!window.devtoolsFormatters)
        window.devtoolsFormatters = [];
      window.devtoolsFormatters.push({
        header(x) {
          for (const type of [
            Temporal.Instant,
            Temporal.Calendar,
            Temporal.PlainDate,
            Temporal.PlainDateTime,
            Temporal.Duration,
            Temporal.PlainMonthDay,
            Temporal.PlainTime,
            Temporal.TimeZone,
            Temporal.PlainYearMonth
          ]) {
            if (x instanceof type) return ['span', {}, `${x[Symbol.toStringTag]} <${x}>`];
          }
          return null;
        },
        hasBody(x) {
          return x instanceof Temporal.Duration;
        },
        body(x) {
          const out = ['ol', { style: 'list-style-type: none;' }];
          for (const prop of [
            'years',
            'months',
            'weeks',
            'days',
            'hours',
            'minutes',
            'seconds',
            'milliseconds',
            'microseconds',
            'nanoseconds'
          ]) {
            if (x[prop] !== 0) out.push([
              'li',
              {},
              ['span', { style: 'color: purple;' }, prop],
              `: `,
              ['span', { style: 'color: blue;' }, x[prop]]
            ]);
          }
          return out;
        }
      });
    </script>
    <style>
      /* https://github.com/kognise/water.css/blob/master/src/variables-light.css */
      :root {
        --background: #efefef;
        --text-muted: #999999;
        --text-bright: #000000;
        --text-width: 900px;
        --variable: #39a33c;
      }
      body {
        font-size: 18px;
        max-width: var(--text-width);
        padding-top: 40px;  /* extra padding for banner */
        line-height: 1.5;
      }
      pre { border-left: 4px solid var(--variable); }
      code {
        padding: 1px 5px 2px 5px;
        line-height: 1.1;
        display: inline-block;
      }
      a code { color: inherit; }
      a code:hover { text-decoration: underline; }
      pre code { line-height: 1.4; }
      pre code[class*="language-"] { font-size: 0.85em; }
      pre[class*="language-"] { padding: 0.5em; }
      h1 { margin-top: 13px; }
      h2 { border-bottom: 2px solid var(--text-muted); margin-top: 2em; }
      h3 {
        border-bottom: 1px solid var(--text-muted);
        color: var(--text-muted);
        font-weight: normal;
      }
      h3 em { font-weight: bold; }
      h3 strong { color: var(--text-bright); }
      :not(h2) + h3 { margin-top: 2em; }
      footer {
        border-top: 1px solid var(--background);
        color: var(--text-muted);
        font-size: 0.8em;
        margin-top: 2em;
        padding-top: 10px;
      }
      .heading-link {
        left: calc((100vw - var(--text-width)) / 2 - 1.5em);
        opacity: 0;
        position: absolute;
        transition: opacity 150ms;
      }
      .heading-link:hover { text-decoration: none; }
      .heading-link::before { content: '¶'; }
      h2:hover .heading-link, h3:hover .heading-link, h4:hover .heading-link, h5:hover .heading-link { opacity: 0.75; }
      .banner {
        /* Gradient from https://joshnh.com/weblog/how-to-make-an-alert-bar/ */
        background-color: #fce94f;
        background-image: linear-gradient(135deg,
                                          transparent,
                                          transparent 25%,
                                          rgba(0, 0, 0, .05) 25%,
                                          rgba(0, 0, 0, .05) 50%,
                                          transparent 50%,
                                          transparent 75%,
                                          rgba(0, 0, 0, .05) 75%,
                                          rgba(0, 0, 0, .05));
        background-size: 20px 20px;
        box-shadow: 0 5px 0 rgba(0, 0, 0, .1);
        left: 0;
        padding: 0.4em 0;
        position: absolute;
        text-align: center;
        top: 0;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div class="banner">
      This Stage 3 proposal is <strong><a href="https://blogs.igalia.com/compilers/2020/06/23/dates-and-times-in-javascript/">experimental.</a></strong>
      <strong>Do</strong> try it and <a href="https://github.com/tc39/proposal-temporal/issues">report bugs</a>; <strong>don't</strong> use it in production!
    </div>
<h1 id="temporal-におけるカレンダーシステムのサポート"><a class="heading-link" href="#temporal-におけるカレンダーシステムのサポート"></a>Temporal におけるカレンダーシステムのサポート</h3><p><a href="https://github.com/tc39/proposal-temporal/">ECMAScript Temporal</a>は、ECMAScript における新しい日時 API です。ECMAScript は世界中のユーザーに向けて設計されているため、高品質な国際化サポートを設計目標としています。</p>
<p>このドキュメントでは、Temporal がなぜ / どのようにしてカレンダーシステムをサポートするのか、そして開発者が遭遇するかもしれないカレンダーに関する問題と、それを回避する方法について説明します。前半の節では、Temporal でカレンダーシステムをサポートするに至った経緯を説明します。後半の節では、過去に検討されたカレンダーシステムの設計について説明し、なぜそれらではなく現在のアプローチが選択されたのかを説明します。</p>
<h2 id="背景とモチベーション"><a class="heading-link" href="#背景とモチベーション"></a>背景とモチベーション</h3><p>カレンダーシステムは、「特定の時刻」と「年、月、日といった人間が読みやすい数値」を対応付ける方法を提供します。</p>
<p>世界中で多く使用されているのはグレゴリオ暦です。ここでは太陽暦、月、日が使われ、これらの値は季節に同期します。しかし世界中には、その他のカレンダーシステムを存在しています。有名なものでは、ユダヤ暦、ヒジュラ暦、仏滅紀元、ヒンドゥー暦、中国暦、和暦、そしてエチオピア暦などです。</p>
<p>今日はグレゴリオ暦で&quot;March 4, 2021&quot;ですが、その他のカレンダーでは次のように表されます。</p>
<!-- prettier-ignore-start -->

<ul>
<li>20 Adar 5781（ユダヤ暦）</li>
<li>Rajab 20, 1442 AH（ウンム・アル＝クラーのヒジュラ暦）</li>
<li>March 4, 2564 BE（タイの仏滅紀元）</li>
<li>令和3年3月4日 == March 4, 3 Reiwa（和暦）</li>
</ul>
<!-- prettier-ignore-end -->

<p>グレゴリオ暦以外のカレンダーシステムは、いくつかの国、特にグレゴリオ暦が支配的な西洋諸国との文化的、経済的関係が弱い国において、日常生活ならびに宗教的、文化的、学術的用途で使用されています。例えば、日本、中国、イラン、アフガニスタン、サウジアラビア、台湾を含むいくつかの国では、グレゴリオ暦以外のカレンダーが、少なくとも一部の政府公式の手続きで使用されています。これらの公式な用途以外でも、世界の人口の大多数は、宗教的または文化的な休日の日付を決定するためにグレゴリオ暦以外のカレンダーシステムを使用する国に住んでいます。</p>
<h3 id="カレンダーのビジネスロジック（単なる文字列の地域化ではない）"><a class="heading-link" href="#カレンダーのビジネスロジック（単なる文字列の地域化ではない）"></a>カレンダーのビジネスロジック（単なる文字列の地域化ではない）</h3><p>カレンダーシステムは地域化（l10n：localization）では重要な役割を果たします。これらは、タイムスタンプや日時を人間にわかりやすい文字列へ変換することを可能にします。</p>
<p>しかし、カレンダーシステムはアプリケーションのビジネスロジックについても重要な役割を果たします。人間が関わるアプリケーションでは、日時の演算や操作を必要とする場合が多く、そのような処理にはカレンダーシステムが必要です。カレンダーに依存する処理の例は次のとおりです：</p>
<ul>
<li>今日から 1 ヶ月後の日付を求めたい</li>
<li>ある月の最初の日付を求めたい</li>
<li>誕生日や記念日を扱いたい（訳注：「何月何日」という概念そのものがカレンダーに依存している）</li>
<li>ラマダーン、ペサハ、イースター、春節のような、宗教的または文化的な祝日の日付を求めたい</li>
</ul>
<p>言い換えると、1 日（太陽日）よりも大きな単位をどのように決めるかは、その地域の文化によります。日付計算を最も普遍的に解決する方法は、月と年の概念を排除することですが、そのような日付 API は多くの場合不十分です。</p>
<h3 id="他のプラットフォームに比べて、ecmascript-におけるカレンダーサポートへの優先度が高いのはなぜか"><a class="heading-link" href="#他のプラットフォームに比べて、ecmascript-におけるカレンダーサポートへの優先度が高いのはなぜか"></a>他のプラットフォームに比べて、ECMAScript におけるカレンダーサポートへの優先度が高いのはなぜか</h3><p>カレンダーシステムを Temporal へ統合しようとすると新たな問題へ対処しなければならなくなるのは明らかです。例えば&quot;Unexpected Calendar Problem&quot;（<a href="#the-unexpected-calendar-problem">以下を参照</a>）が考えられます。つまり、あるカレンダーを想定して書かれたコードで、別のカレンダーの日時を処理しようとすると様々な問題を引き起こす可能性があります。</p>
<p>しかし、Temporal にカレンダーシステムを統合することによる利点は、これらの問題を上回る可能性があり、これはそれほど自明では無いかもしれません。これらの利点を理解する 1 つの方法は、カレンダーシステムに対して異なるアプローチを行っている Java や.NET と、ECMAScript エコシステムのニーズの違いを明確にすることです。いくつかの違いを以下に示します：</p>
<ul>
<li><a href="https://github.com/ThreeTen/threeten/wiki/Multi-calendar-system">Java の日付/時刻 API の設計に関する注意事項</a>で説明されているとおり、ほとんどのエンタープライズアプリケーションでは ISO カレンダーが使われています。しかし Java や.NET に比べて、ECMAScript には一般のコンシューマーやブラウザ向けのユースケースが多くあります。このようなケースでは、ISO 以外のカレンダーがより必要になると考えられます。</li>
<li>ISO 以外のカレンダーへの需要が、新興国市場で高まっています。これらの市場でスマートフォンユーザーがさらに 10 億人増加するという予想を考えると、地域化に関する技術への関心が更に高まり、ISO 以外のカレンダーが必要になると考えられます。</li>
<li>ECMAScript の標準ライブラリは Java や.NET のものよりも 1〜2 桁少なく、そのため ECMAScript アプリケーションは 100 以上の OSS ライブラリに依存することも珍しくありません。したがって現状の ECMAScript で国際化（i18n：internationalization）のサポートを実現するためには、プラットフォームと OSS ライブラリの両方の協力が必要であり、ライブラリ開発者に国際化に対応するようコードの修正を依頼することがよくあります。</li>
</ul>
<p>現在の設計を選択することことは容易ではありませんでした。カレンダーシステムを Temporal に統合することは、ISO カレンダーのみを意図してコードを作成するよりも多くのバグを引き起こします。しかし、経済成長や人口増加、テクノロジーの普及に関する世界的な傾向を考慮すれば、現在の設計を採用することは、ECMAScript コミュニティの長期的な成功に繋がる合理的なトレードオフであると私達は考えています。</p>
<h3 id="intl-ファーストな設計"><a class="heading-link" href="#intl-ファーストな設計"></a>&quot;Intl ファースト&quot;な設計</h3><p>ECMAScript には国際化（i18n）をサポートする主要な機能があります。Intl ファーストな設計の 2 つの原則は、「1.言語または地域に固有の操作はデータ駆動であること」、「2.ユーザーの環境が、API へ明示的に入力されること」です。これらの原則は、世界中の幅広いエンドユーザーを対象にしたアプリケーションの開発者が、API を適切に使用するために役立ちます。</p>
<p>Temporal では、これらの原則を「カレンダー固有のロジックを抽象化すること」と「どのカレンダーを使用するかをオブジェクトコンストラクタで選択できるようにすること」によって守っています。その結果、グレゴリオ暦のみを使用する地域と、他のカレンダーを使用する地域のどちらでも利用可能な API を作成できます。</p>
<h3 id="temporal-のコード内でのカレンダーの使用"><a class="heading-link" href="#temporal-のコード内でのカレンダーの使用"></a>Temporal のコード内でのカレンダーの使用</h3><p>以下の節ではカレンダーシステムが Temporal のコード内にどのように現れるかを示します。より詳しい情報は<a href="../calendar.html">ドキュメント</a>を参照してください。</p>
<p>Temporal では、日付のフィールドを持つすべてのオブジェクトは、カレンダーのフィールドも持ちます。例えば、以下の 2 つの実行結果は、どちらもユダヤ暦の「23 Adar I 5779」を表す<code>Temporal.PlainDate</code>インスタンスとなります。</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// bag of fieldsでユダヤ暦の日付オブジェクトを作成する</span>
Temporal<span class="token punctuation">.</span>PlainDate<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">year</span><span class="token operator">:</span> <span class="token number">5779</span><span class="token punctuation">,</span>
  <span class="token literal-property property">monthCode</span><span class="token operator">:</span> <span class="token string">'M05L'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">day</span><span class="token operator">:</span> <span class="token number">23</span><span class="token punctuation">,</span>
  <span class="token literal-property property">calendar</span><span class="token operator">:</span> <span class="token string">'hebrew'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ISOカレンダーの日付オブジェクトを作成し、ユダヤ暦に変換する</span>
Temporal<span class="token punctuation">.</span>PlainDate<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'2019-02-28'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withCalendar</span><span class="token punctuation">(</span><span class="token string">'hebrew'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>内部的には、日付は常に ISO カレンダーによって表されています。つまり、もしインスタンスからカレンダーの情報が失われても、それが示す日付は変化しません。これは、Temporal の内部スロットと文字列表現のどちらにも言えます。したがって、以下のどちらの結果も同じく「23 Adar I 5779」のインスタンスとなります：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// ISO文字列をパースする（IETF RFCはまだ提案中）</span>
Temporal<span class="token punctuation">.</span>PlainDate<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'2019-02-28[u-ca=hebrew]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// コンストラクタによって内部データモデルの値を指定する</span>
<span class="token keyword">new</span> <span class="token class-name">Temporal<span class="token punctuation">.</span>PlainDate</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token string">'hebrew'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Temporal インスタンスに対する操作は、すべてカレンダーシステムのコンテキストで行われます。例：</p>
<pre class="language-javascript"><code class="language-javascript">date <span class="token operator">=</span> Temporal<span class="token punctuation">.</span>PlainDate<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'2019-02-28[u-ca=hebrew]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
date<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">day</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => 2019-02-06[u-ca=hebrew]</span>
date<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">day</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocaleString</span><span class="token punctuation">(</span><span class="token string">'en-US'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">calendar</span><span class="token operator">:</span> <span class="token string">'hebrew'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => '1 Adar I 5779'</span>
date<span class="token punctuation">.</span>year<span class="token punctuation">;</span> <span class="token comment">// => 5779</span>
date<span class="token punctuation">.</span>monthCode<span class="token punctuation">;</span> <span class="token comment">// => 'M05L'</span>
date<span class="token punctuation">.</span>month<span class="token punctuation">;</span> <span class="token comment">// => 6</span>
date<span class="token punctuation">.</span>day<span class="token punctuation">;</span> <span class="token comment">// => 23</span>
date<span class="token punctuation">.</span>inLeapYear<span class="token punctuation">;</span> <span class="token comment">// => true</span>
date<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>id<span class="token punctuation">;</span> <span class="token comment">// => 'hebrew'</span>
inFourMonths <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">months</span><span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
inFourMonths<span class="token punctuation">.</span><span class="token function">toLocaleString</span><span class="token punctuation">(</span><span class="token string">'en-US'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">calendar</span><span class="token operator">:</span> <span class="token string">'hebrew'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => '23 Sivan 5779'</span>
inFourMonths<span class="token punctuation">.</span><span class="token function">withCalendar</span><span class="token punctuation">(</span><span class="token string">'iso8601'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => 2019-06-26</span>
date<span class="token punctuation">.</span><span class="token function">until</span><span class="token punctuation">(</span>inFourMonths<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">largestUnit</span><span class="token operator">:</span> <span class="token string">'month'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => P4M</span></code></pre><p>定義より、年、月、日から bag of fields（訳注：コンストラクタに与える日付の情報を含んだオブジェクトのこと）を生成するにはカレンダーシステムを指定する必要があります。</p>
<p>そのような際にカレンダーシステムが指定されていない場合、Temporal は ISO カレンダーが省略されているものとみなします。これは、Temporal がカレンダーの省略を想定する唯一の場所です。</p>
<pre class="language-javascript"><code class="language-javascript">Temporal<span class="token punctuation">.</span>PlainDate<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">year</span><span class="token operator">:</span> <span class="token number">2019</span><span class="token punctuation">,</span> <span class="token literal-property property">month</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">day</span><span class="token operator">:</span> <span class="token number">28</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>次の Temporal タイプはすべて内部にカレンダーを持っています：<code>Temporal.ZonedDateTime</code>、<code>Temporal.PlainDateTime</code>、<code>Temporal.PlainDate</code>、<code>Temporal.PlainYearMonth</code>、<code>Temporal.PlainMonthDay</code></p>
<h2 id="予期しないカレンダーの問題"><a class="heading-link" href="#予期しないカレンダーの問題"></a>予期しないカレンダーの問題</h3><p>Temporal の多くの日付操作においてカレンダーを意識することは、世界中の多くのアプリケーション利用者にとって重要です。しかし、これは新しい問題を引き起こします：もし、コードが特定のカレンダーを想定して作られている場合、予期していないカレンダーの日付を扱おうとするとバグが発生します。このバグは、悪意を持って利用されてしまうかもしれません。</p>
<p>この節では、私達が「予期しないカレンダーの問題（Unexpected Calendar Problem）」と呼んでいるものについて説明し、それをユーザーランドのコードで軽減する方法も説明します。</p>
<h3 id="問題の定義"><a class="heading-link" href="#問題の定義"></a>問題の定義</h3><p>以下はこの問題の典型的な例です：一年の最後の日かどうかを判定する関数があります。これは、1 年が 12 ヶ月で、1 年の最後の月の長さが 31 日であることを想定しています。</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">isLastDayOfYear</span><span class="token punctuation">(</span><span class="token parameter">date</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Note: これは"良くない"例です！</span>
  <span class="token keyword">return</span> date<span class="token punctuation">.</span>month <span class="token operator">===</span> <span class="token number">12</span> <span class="token operator">&amp;&amp;</span> date<span class="token punctuation">.</span>day <span class="token operator">===</span> <span class="token number">31</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ISOカレンダーでは正常に動作します</span>
<span class="token function">isLastDayOfYear</span><span class="token punctuation">(</span>Temporal<span class="token punctuation">.</span>PlainDate<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'2019-12-31'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => true</span>
<span class="token function">isLastDayOfYear</span><span class="token punctuation">(</span>Temporal<span class="token punctuation">.</span>PlainDate<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'2020-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => false</span>

<span class="token comment">// ISO以外のカレンダーでは動作しません</span>
hebrewNewYearsEve <span class="token operator">=</span> Temporal<span class="token punctuation">.</span>PlainDate<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">year</span><span class="token operator">:</span> <span class="token number">5780</span><span class="token punctuation">,</span>
  <span class="token literal-property property">monthCode</span><span class="token operator">:</span> <span class="token string">'M12'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">day</span><span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
  <span class="token literal-property property">calendar</span><span class="token operator">:</span> <span class="token string">'hebrew'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">isLastDayOfYear</span><span class="token punctuation">(</span>hebrewNewYearsEve<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => false</span>
<span class="token comment">// （trueとなるべき）</span></code></pre><h3 id="予期しないカレンダーの問題を緩和する方法"><a class="heading-link" href="#予期しないカレンダーの問題を緩和する方法"></a>予期しないカレンダーの問題を緩和する方法</h3><p>この問題を回避する方法は 2 つあります。ベストプラクティスは、どのようなカレンダーにも対応できる、カレンダーセーフなコードを書くことです。もう 1 つの方法は、カレンダーのバリデーションや変換処理を実装することです。これにより、対応しているカレンダーの日付のみを処理できるようになります。</p>
<h4 id="カレンダーセーフなコードを書く"><a class="heading-link" href="#カレンダーセーフなコードを書く"></a>カレンダーセーフなコードを書く</h3><p>予期しないカレンダーの問題を回避する最も良い方法は、ビルトインのすべてのカレンダーに対応する、カレンダーセーフなコードを書くことです。例えば上記のコードに関しては、ISO カレンダーの定数をハードコーディングする代わりに<code>monthsInYear</code>や<code>daysInMonth</code>を用いることで、簡単にカレンダーセーフなコードに書き換えられます。開発者は、<a href="https://tc39.es/proposal-temporal/docs/calendar.html#writing-cross-calendar-code">カレンダーセーフな Temporal コードを書くためのベストプラクティス</a>にしたがうことで、すべてのビルトインカレンダーで動作するコードを書くことができます。</p>
<p>ドキュメントに記載がある以外にも、Temporal API そのものが、カレンダーセーフなコードを書きやすいように既に設計されています。例えば：</p>
<ul>
<li>ISO を含むすべてのビルトインカレンダーは、<code>year</code>、<code>month</code>、<code>day</code>、<code>monthCode</code>といった、日付に関する共通したフィールドを持っています。これらのフィールドに関する操作は、すべてのビルトインカレンダーで共通です。</li>
<li><code>month</code>プロパティは、一年を通して連続する（ギャップのない）月のインデックスを表し、これは ISO カレンダーの月の挙動と一致します。太陰太陽暦では、年ごとに月の構造が異なりますが、<code>month</code>プロパティは常に 1 年を通してのインデックスです。年に依存しない月の種類を表す情報は、<code>monthCode</code>文字列フィールドに分離されています。</li>
<li><code>year</code>プロパティは各カレンダーにおける「デフォルトの時代」からの経過を示す符号付きの値です。これは ISO カレンダーの挙動と一致し、例えば「紀元前では年を逆方向に数える」というようなバグを防ぎます。各カレンダーにおけるデフォルトでない時代（訳注：和暦では平成、令和など）に対する年数などの情報は<code>eraYear</code>と<code>era</code>フィールドに分離されています。</li>
<li>カレンダー間の違いは、すべてのカレンダーで利用可能なプロパティによって公開されます。例：<code>monthsInYear</code>、<code>daysInMonth</code>、<code>inLeapYear</code>。これらを用いることで、カレンダー固有の定数（例：1 年間は&quot;12&quot;ヶ月）の使用を回避できます。</li>
<li>暗黙的なデフォルトのカレンダーシステムはありません。開発者はどのカレンダーシステムを用いるのかを明示的に指定しなければならず、ISO に関するショートカットのためのメソッド名には、わかりやすいように接尾辞がついています（例：<code>Temporal.now.zonedDateTimeISO()</code>。</li>
<li>Temporal はユーザーの環境からカレンダーを推測しません。どのカレンダーシステムを使用するかは、アプリケーションやライブラリの開発者、または日付を入力するユーザーによって明示的に決定されます。</li>
</ul>
<h4 id="カレンダーのバリデーションと変更"><a class="heading-link" href="#カレンダーのバリデーションと変更"></a>カレンダーのバリデーションと変更</h3><p>Temporal を用いることでカレンダーセーフなコードを簡単に記述できますが、それでも開発者による作業が必要です。一部の開発者はこの作業を行いません。これは、ISO 以外のカレンダーの存在を知らない、または理解していないことが原因である場合があります。または、ISO カレンダーのみを使用するアプリケーションを書いている場合、わざわざカレンダーセーフのベストプラクティスに従わないかもしれません。あるいは、自身が書くコードではベストプラクティスが守られているが、それが依存するコードではそうでない場合があります。通常、ECMAScript アプリケーションにはたくさんの依存関係があり、時間と労力の関係上、それらと日時データを相互運用する必要があるかもしれません。</p>
<p>このような場合、開発者は入力される日時データについて、「意図したカレンダーシステムであることをバリデートする」か、「カレンダーシステムを意図したものに変更する」必要があります。バリデーションと変更のどちらが望ましいかは、ユースケースによります。</p>
<p>カレンダーシステムを変更する場合:</p>
<pre class="language-javascript"><code class="language-javascript">date <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">withCalendar</span><span class="token punctuation">(</span><span class="token string">'iso8601'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>カレンダーシステムをバリデートする場合:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>date<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>id <span class="token operator">!==</span> <span class="token string">'iso8601'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'invalid calendar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>ここで言う「入力」とは外部データに限らないことに注意してください。例えば、依存している日付ライブラリから返されるデータなども「入力」です。ライブラリや入力ソースが特定のカレンダーシステムをサポートしていると明示しない限り、それらからのデータ（日時オブジェクトやそれに変換される文字列）はすべて「外部」であり、カレンダーシステムのバリデーションや変更のための処理が必要です。それらのデータをそのまま使用するのはカレンダーセーフではありません。</p>
<h2 id="検討されていた代替案"><a class="heading-link" href="#検討されていた代替案"></a>検討されていた代替案</h3><p>カレンダーシステムを Temporal に統合することは、API 設計におけるもっとも挑戦的な部分でした。以下では、私達が現在の設計の前に検討していたカレンダー API の代替案を簡単に説明します。（現在の設計も含めて）検討された設計はどれも理想的なものではないことに注意してください。これらの設計は、場合によっては回避策が必要となる既知の欠陥を持っています。以下の選択肢と比較して、現状の設計が全体を通して最善の選択であると私達は信じています。</p>
<h3 id="代替案-1-データモデルにカレンダーを含めない"><a class="heading-link" href="#代替案-1-データモデルにカレンダーを含めない"></a>代替案 1: データモデルにカレンダーを含めない</h3><p>現状の Temporal の設計に対して、カレンダーの情報を Temporal のインスタンスから分離して管理するという代替案があります。これにより、「予期しないカレンダーの問題」を回避できるという利点がありますが、API の利用者への負担が大きいという問題があります：</p>
<ul>
<li><p>カレンダーに固有のフィールド（<code>month</code>、<code>day</code>、<code>year</code>など）やプロパティ（<code>daysInMonth</code>、<code>inLeapYear</code>）を利用する際に、その都度パラメタが必要になります。つまり、これらの値を参照するのではなく、<code>date.calendarMonth(&#39;chinese&#39;)</code>のように Getter を介して値を取得することになります。</p>
</li>
<li><p>多くのメソッド（<code>add</code>、<code>subtract</code>、<code>round</code>、<code>until</code>、<code>since</code>、<code>with</code>、そしておそらく<code>toPlainMonthDay</code>、<code>compare</code>、<code>equals</code>、またその他いくつかのメソッド）を呼び出すたびにカレンダーを明示しなければなりません。これは、年、月、日などのカレンダーに固有なフィールドを処理するために必要です。メソッドの呼び出しは、たとえば次のようになります：<code>date.add({months: 2}, {calendar: &#39;chinese&#39;})</code></p>
</li>
<li><p>複数の操作をチェインする（例：<code>.add({months: 2}).with({day: 1})</code>）際にもメソッドごとにカレンダーを指定する必要があります。通常、連鎖するすべての操作では同じカレンダーが使用されます。それをメソッドの呼び出しごとに指定するのは開発者の負担になり、バグの原因にもなります。</p>
</li>
<li><p><code>Temporal.PlainMonthDay</code>を扱うのが難しくなります。なぜなら、誕生日や祝日のような月/日の値は本質的にカレンダー固有のものであり、対応する ISO の記法が無いため推論することも難しくなります。特に、ユダヤ暦や中国歴のような太陰太陽暦では年ごとに月の構成が変わります。（現状の Temporal では<a href="../plaindate.html#monthCode"><code>monthCode</code></a>という文字列によって年に固有の月を表せます。）例えば、「ユダヤ暦の 12 Adar I」という誕生日は、現状では次のようにモデル化できます。</p>
<pre class="language-javascript"><code class="language-javascript">Temporal<span class="token punctuation">.</span>PlainMonthDay<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">monthCode</span><span class="token operator">:</span> <span class="token string">'M05L'</span><span class="token punctuation">,</span> <span class="token literal-property property">day</span><span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token literal-property property">calendar</span><span class="token operator">:</span> <span class="token string">'hebrew'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>インスタンスがカレンダーを持たない場合、この誕生日をどのようにモデル化すればいいのかわかりません。</p>
</li>
<li><p>日付を返すコードは、単一の Temporal インスタンスを返せません。代わりに、複合オブジェクトか、シリアライズされた文字列を返す必要があります。例えば、ユーザーの操作の結果日付データを返す DatePicker は、<code>Temporal.PlainDate</code>を返すだけでは不十分であり、代わりにタプルや<code>{date, calendar}</code>といった複合オブジェクトを返す必要があります。このような複合オブジェクトは、カレンダーが必要なすべての Temporal のコードを複雑にしてしまいます。</p>
</li>
</ul>
<p>私達は、この代替案によって生じる負担が、予期しないカレンダーの問題を回避するためのものに比べてとても大きいと考えています。</p>
<h3 id="代替案-2-iso-プロパティとカレンダープロパティを分離する"><a class="heading-link" href="#代替案-2-iso-プロパティとカレンダープロパティを分離する"></a>代替案 2: ISO プロパティとカレンダープロパティを分離する</h3><p>予期しないカレンダーの問題に対して脆弱になることなく、カレンダーを Temporal のデータモデルに統合することが可能です。しかし、これによって Temporal API の数が増加してしまいます。この案を適用した場合の一例を以下に示します。</p>
<ul>
<li><code>.isoMonth</code>と<code>.calendarMonth</code>の 2 つのフィールドを提供します（または、カレンダーの概念に慣れていない開発者のために<code>.isoMonth</code>と<code>.calendarMonth</code>を提供する？）<ul>
<li><code>calendar*</code>のメソッドのうち、どれをサポートしてどのような型を返すかは、各カレンダーに完全に依存します。すべてのカレンダーは<code>calendarDay</code>、<code>calendarMonth</code>、<code>calendarMonthCode</code>、<code>calendarYear</code>を提供しますが、<code>calendarEra</code>や<code>calendarEraYear</code>を提供するかはカレンダーしだいです。</li>
<li>property bag 形式について、ISO フィールドとカレンダーフィールドのいずれかのみが使われている必要があります。両方が&quot;混ぜられている&quot;場合はエラーとなります。例えば、<code>date.with({calendarYear: 5780, isoMonth: 12})</code>は例外を投げる必要があります。しかも、 DX の観点から、これは ESLint や TS で強制されるべきです。</li>
<li>カレンダーが明示されていない場合、<code>calendar*</code>へのアクセスはエラーとなります。</li>
<li><code>dayOfYear</code>や<code>inLeapYear</code>といった、フィールドではないプロパティも複製されます。ここで<code>calendar</code>接頭辞が付かないプロパティは、単に ISO カレンダーでの結果を返すものになります。</li>
</ul>
</li>
<li><code>Temporal.Duration</code>に<code>calendar</code>フィールドを追加します。<ul>
<li>ISO カレンダーを使用するインスタンスは次のフィールドのみをサポートします：<code>days</code>、<code>weeks</code>、<code>months</code>、<code>years</code></li>
<li>ISO 以外のカレンダーを使用するインスタンスは次のフィールドのみをサポートします：<code>calendarDays</code>, <code>calendarWeeks</code>, <code>calendarMonths</code>, and <code>calendarYears</code>.</li>
<li>文字列のパースとシリアル化は、他の Temporal タイプと同様に、カレンダーの接尾辞を使って次のように表します：<code>&#39;P2D[u-ca=chinese]&#39;</code>。なお、接尾辞がついていないものは ISO カレンダーを用いているとみなします。</li>
<li><code>until</code> と<code>since</code>が曖昧なため、出力について ISO カレンダーの Duration なのか、ISO 以外のカレンダーの Duration なのかを指定できるようにする必要があります。
これには次の方法が考えられます：<ul>
<li>メソッドを&quot;iso&quot;と&quot;calender&quot;という接頭辞によって区別します。例：<code>isoUntil</code>と<code>calendarUntil</code>、<code>untilISO</code>と<code>untilCalendar</code></li>
<li>常に両方の結果を返します。例：<code>foo.until(bar).isoDuration</code>または<code>foo.until(bar).calendarDuration</code></li>
<li>オプションを用います。例：<code>{ resultFields: &#39;iso&#39; | &#39;calendar&#39; }</code>。ただし、このオプションがリテラルとして指定されていない場合に（訳注：例えばこのオプションの値が外部から入力されるものである場合に）、TS がメソッドの実行結果の型をうまく処理できるかは疑問です。</li>
</ul>
</li>
<li><code>withCalendar</code>メソッドはありません。代わりに ISO フィールドやカレンダーフィールドがありますが、どちらか一方しかありません。</li>
</ul>
</li>
</ul>
<p>私達はこれらの代替案を検討した結果、この案によってもたらされる複雑さにはあまり価値がないと判断しました。特に、フィールドやプロパティを 2 倍に増やすというアプローチには、余計なバグが増えたり、入力のバリデーションなどが煩雑になるという懸念があります。</p>
<h3 id="代替案-3-サブクラス"><a class="heading-link" href="#代替案-3-サブクラス"></a>代替案 3: サブクラス</h3><p>カレンダーシステムを PlainDate の内部スロットに格納する代わりに、PlainDate を ISO カレンダーのみをサポートするように保ち、PlainHebrewDate や PlainChineseDate といったカレンダー固有のサブクラスを作成する案が検討されました。より詳しくは<a href="https://github.com/tc39/proposal-temporal/blob/main/docs/calendar-subclass.html">サブクラスに関するディスカッション</a>を参照してください。</p>
<p>私達は、サブクラスのアプローチを行わないことにしました。なぜなら：</p>
<ul>
<li>もしサブクラスにカレンダー固有のセットメソッドがある場合、カレンダーをまたいだコードが書きづらくなり、ポリモーフィズムの利点が失われてしまいます。一方、各サブクラスが PlainDate と同じメソッドを持つ場合、それは PlainDate にカレンダーを格納するためのプラガブルなスロットがあるのと同じです。</li>
<li>考えられるカレンダーシステムの数は膨大（かつ、理論的には無制限）であり、たくさんのサブクラスを作らなくてはならなくなります</li>
<li>各サブクラスは独立したデータモデルを定義しなければならず、仕様が膨大になってしまいます</li>
</ul>
<p>私達は最終的に、このアプローチが他のアプローチに比べて高コストであり、かつ明確な利点がないと判断しました。また、カレンダーに固有なすべての操作を Temporal.Calendar に整理することで、より見通しの良いモデルが実現することもわかりました。</p>
<h3 id="代替案-4-カレンダーを持たない日付タイプを新たに作成する"><a class="heading-link" href="#代替案-4-カレンダーを持たない日付タイプを新たに作成する"></a>代替案 4: カレンダーを持たない日付タイプを新たに作成する</h3><p>このアプローチでは、カレンダーシステムを持たずに日時を表す新しいタイプを作成します。そして、カレンダーの情報が必要ない処理においては、カレンダーを持たないクラスをできるだけ使用するようにします。このアプローチについては、<a href="https://github.com/tc39/proposal-temporal/blob/main/docs/calendar-draft.html#new-non-calendar-types-option-5">Option 5 in calendar-draft.md</a>で詳しく説明しています。</p>
<p>私達は、次の理由によってこのアプローチに反対しました：</p>
<ol>
<li>作成するタイプにカレンダーの情報が無いとすると、年や月に関する処理をサポートできませんでした。</li>
<li>作成するタイプが ISO カレンダーのように振る舞うとすると、それは ISO カレンダーを使用した PlainDate と同じことになります。</li>
</ol>
<p>特に(2)については、動的型付け言語である ECMAScript にとってよく当てはまることに注意してください。ただし、静的型付け言語では、ECMAScript では不可能なコンパイル時の型チェックを行えるかもしれません。特に TypeScript のようなクライアントは、カレンダーシステムのコンパイル時の型チェックにおいて、カレンダーシステムに対応する型パラメタを用いることで PlainDate の型を効率的に生成できる可能性があることに注意してください。その場合、個別のデータ型は必要ありません。</p>
    <footer>
      <p>
        This page includes a script which loads an implementation of Temporal in your browser.
        You can open a console in your browser's developer tools and try it out directly!
      </p>
      <p>View this or help contribute on <a href="https://github.com/tc39/proposal-temporal">GitHub</a>.</p>
    </footer>
  </body>
</html>
