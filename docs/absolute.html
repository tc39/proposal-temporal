<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <script type="application/javascript" src="./playground.js"></script>
    <script type="application/javascript" src="./mermaid.js"></script>
    <script type="application/javascript" src="./prism.js"></script>
    <link rel="stylesheet" type="text/css" href="./prism.css">
    <script>mermaid.initialize({startOnLoad:true,flowchart:{useMaxWidth:false}});</script>
    <script>
      Temporal = { ...temporal.Temporal };
      Object.assign(Intl, temporal.Intl);
    </script>
    <style>
      /* https://github.com/kognise/water.css/blob/master/src/variables-light.css */
      :root {
        --background: #efefef;
        --text-muted: #999999;
        --text-bright: #000000;
        --text-width: 900px;
        --variable: #39a33c;
      }
      .mermaid svg { height: 13em; }
      body {
        font-size: 18px;
        max-width: var(--text-width);
        padding-top: 40px;  /* extra padding for banner */
      }
      pre { border-left: 4px solid var(--variable); }
      pre code[class*="language-"] { font-size: 0.85em; }
      pre[class*="language-"] { padding: 0.5em; }
      h2 { border-bottom: 2px solid var(--text-muted); margin-top: 2em; }
      h3 {
        border-bottom: 1px solid var(--text-muted);
        color: var(--text-muted);
        font-weight: normal;
      }
      h3 em { font-weight: bold; }
      h3 strong { color: var(--text-bright); }
      :not(h2) + h3 { margin-top: 2em; }
      footer {
        border-top: 1px solid var(--background);
        color: var(--text-muted);
        font-size: 0.8em;
        margin-top: 2em;
        padding-top: 10px;
      }
      .heading-link {
        left: calc((100vw - var(--text-width)) / 2 - 1.5em);
        opacity: 0;
        position: absolute;
        transition: opacity 150ms;
      }
      .heading-link:hover { text-decoration: none; }
      .heading-link::before { content: '¶'; }
      h3:hover .heading-link { opacity: 1; }
      .banner {
        /* Gradient from https://joshnh.com/weblog/how-to-make-an-alert-bar/ */
        background-color: #fce94f;
        background-image: linear-gradient(135deg,
                                          transparent,
                                          transparent 25%,
                                          rgba(0, 0, 0, .05) 25%,
                                          rgba(0, 0, 0, .05) 50%,
                                          transparent 50%,
                                          transparent 75%,
                                          rgba(0, 0, 0, .05) 75%,
                                          rgba(0, 0, 0, .05));
        background-size: 20px 20px;
        box-shadow: 0 5px 0 rgba(0, 0, 0, .1);
        left: 0;
        padding: 0.4em 0;
        position: absolute;
        text-align: center;
        top: 0;
        width: 100vw;
      }
    </style>
  </head>
  <body>
    <div class="banner">
      <strong>This polyfill is a work in progress.</strong>
      It does not represent the final API of this proposal, nor even the current consensus.
    </div>
<h1 id="temporalabsolute">Temporal.Absolute</h1>
<p>A <code>Temporal.Absolute</code> is an absolute point in time, with a precision in nanoseconds.
No time zone or calendar information is present.
As such <code>Temporal.Absolute</code> has no concept of days, months or even hours.</p>
<p>For convenience of interoperability, it internally uses nanoseconds since the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a> (midnight UTC on January 1, 1970).
However, a <code>Temporal.Absolute</code> can be created from any of several expressions that refer to a single point in time, including an ISO 8601 string with a time zone such as <code>&#39;2020-01-23T17:04:36.491865121-08:00&#39;</code>.</p>
<p>Since <code>Temporal.Absolute</code> doesn&#39;t contain any information about time zones, a <code>Temporal.TimeZone</code> is needed in order to convert it into a <code>Temporal.DateTime</code> (and from there into any of the other <code>Temporal</code> objects.)</p>
<p>Like Unix time, <code>Temporal.Absolute</code> ignores leap seconds.</p>
<h2 id="constructor">Constructor</h2>
<h3 id="new-temporalabsoluteepochnanoseconds--bigint--temporalabsolute"><strong>new Temporal.Absolute</strong>(<em>epochNanoseconds</em> : bigint) : Temporal.Absolute</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>epochNanoseconds</code> (bigint): A number of nanoseconds.</li>
</ul>
<p><strong>Returns:</strong> a new <code>Temporal.Absolute</code> object.</p>
<p>Creates a new <code>Temporal.Absolute</code> object that represents a single point in time.</p>
<p><code>epochNanoseconds</code> is the number of nanoseconds (10<sup>&minus;9</sup> seconds) between the Unix epoch (midnight UTC on January 1, 1970) and the desired point in time.</p>
<p>Use this constructor directly if you know the precise number of nanoseconds already and have it in bigint form, for example from a database.
Otherwise, <code>Temporal.Absolute.from()</code>, which accepts more kinds of input, is probably more convenient.</p>
<p>The range of allowed values for this type is the same as the old-style JavaScript <code>Date</code>, 100 million (10<sup>8</sup>) days before or after the Unix epoch.
This range covers approximately half a million years. If <code>epochNanoseconds</code> is outside of this range, a <code>RangeError</code> will be thrown.</p>
<p>Example usage:</p>
<pre><code class="language-js">abs = new Temporal.Absolute(1553906700000000000n);
// When was the Unix epoch?
epoch = new Temporal.Absolute(0n);  // =&gt; 1970-01-01T00:00Z
// Dates before the Unix epoch are negative
turnOfTheCentury = new Temporal.Absolute(-2208988800000000000n);  // =&gt; 1900-01-01T00:00Z</code></pre>
<h2 id="static-methods">Static methods</h2>
<h3 id="temporalabsolutefromthing-string--temporalabsolute--temporalabsolute">Temporal.Absolute.<strong>from</strong>(<em>thing</em>: string | Temporal.Absolute) : Temporal.Absolute</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>thing</code> (string or <code>Temporal.Absolute</code>): The value representing the desired point in time.</li>
</ul>
<p><strong>Returns:</strong> a new <code>Temporal.Absolute</code> object (or the same object if <code>thing</code> was a <code>Temporal.Absolute</code> object.)</p>
<p>This static method creates a new <code>Temporal.Absolute</code> object from another value.
If the value is a string, it must be in ISO 8601 format, including a date, a time, and a time zone.
If the value is an object, it must be another <code>Temporal.Absolute</code> object, in which case the same object is returned.</p>
<p>If <code>thing</code> is a string, and the point in time cannot be uniquely determined from the string, then this function throws an exception.
This includes the case when <code>thing</code> is a validly-formatted ISO 8601 string denoting a time that doesn&#39;t exist, for example because it was skipped in a daylight saving time transition.</p>
<p>Example usage:</p>
<pre><code class="language-js">abs = Temporal.Absolute.from(&#39;2019-03-30T01:45:00+01:00[Europe/Berlin]&#39;);
abs = Temporal.Absolute.from(&#39;2019-03-30T01:45+01:00&#39;);
abs = Temporal.Absolute.from(&#39;2019-03-30T00:45Z&#39;);
abs === Temporal.Absolute.from(abs);  // =&gt; true

// Not enough information to denote a single point in time:
/* WRONG */ abs = Temporal.Absolute.from(&#39;2019-03-30&#39;);  // no time; throws
/* WRONG */ abs = Temporal.Absolute.from(&#39;2019-03-30T01:45&#39;);  // no time zone; throws
/* WRONG */ abs = Temporal.Absolute.from(&#39;2019-03031T02:45+01:00[Europe/Berlin]&#39;);
    // time skipped in DST transition; throws</code></pre>
<h3 id="temporalabsolutefromepochsecondsepochseconds-number--temporalabsolute">Temporal.Absolute.<strong>fromEpochSeconds</strong>(<em>epochSeconds</em>: number) : Temporal.Absolute</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>epochSeconds</code> (number): A number of seconds.</li>
</ul>
<p><strong>Returns:</strong> a new <code>Temporal.Absolute</code> object.</p>
<p>This static method creates a new <code>Temporal.Absolute</code> object with seconds precision.
<code>epochSeconds</code> is the number of seconds between the Unix epoch (midnight UTC on January 1, 1970) and the desired point in time.</p>
<p>The number of seconds since the Unix epoch is a common measure of time in many computer systems.
Use this method if you need to interface with such a system.</p>
<p>Example usage:</p>
<pre><code class="language-js">// Same examples as in new Temporal.Absolute(), but with seconds precision
abs = Temporal.Absolute.fromEpochSeconds(1553906700);
epoch = Temporal.Absolute.fromEpochSeconds(0);  // =&gt; 1970-01-01T00:00Z
turnOfTheCentury = Temporal.Absolute.fromEpochSeconds(-2208988800);  // =&gt; 1900-01-01T00:00Z</code></pre>
<h3 id="temporalabsolutefromepochmillisecondsepochmilliseconds-number--temporalabsolute">Temporal.Absolute.<strong>fromEpochMilliseconds</strong>(<em>epochMilliseconds</em>: number) : Temporal.Absolute</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>epochMilliseconds</code> (number): A number of milliseconds.</li>
</ul>
<p><strong>Returns:</strong> a new <code>Temporal.Absolute</code> object.</p>
<p>Same as <code>Temporal.Absolute.fromEpochSeconds()</code>, but with millisecond (10<sup>&minus;3</sup> second) precision.</p>
<p>The number of milliseconds since the Unix epoch is also returned from the <code>getTime()</code> and <code>valueOf()</code> methods of old-style JavaScript <code>Date</code> objects, as well as <code>Date.now()</code>.
Use this method to create a <code>Temporal.Absolute</code> object from a <code>Date</code> object, for example:</p>
<pre><code class="language-js">jsdate = new Date(&#39;December 17, 1995 03:24:00 GMT&#39;)
abs = Temporal.Absolute.fromEpochMilliseconds(jsdate.getTime());  // =&gt; 1995-12-17T03:24Z
abs = Temporal.Absolute.fromEpochMilliseconds(+jsdate);  // valueOf() called implicitly

// This is a way to get the current time, but Temporal.now.absolute()
// would give the same with higher accuracy
todayMs = Temporal.Absolute.fromEpochMilliseconds(Date.now());
todayNs = Temporal.now.absolute();</code></pre>
<h3 id="temporalabsolutefromepochmicrosecondsepochmilliseconds--bigint--temporalabsolute">Temporal.Absolute.<strong>fromEpochMicroseconds</strong>(<em>epochMilliseconds</em> : bigint) : Temporal.Absolute</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>epochMicroseconds</code> (bigint): A number of microseconds.</li>
</ul>
<p><strong>Returns:</strong> a new <code>Temporal.Absolute</code> object.</p>
<p>Same as <code>Temporal.Absolute.fromEpochSeconds()</code>, but with microsecond (10<sup>&minus;6</sup> second) precision.</p>
<h3 id="temporalabsolutefromepochnanosecondsepochnanoseconds--bigint--temporalabsolute">Temporal.Absolute.<strong>fromEpochNanoseconds</strong>(<em>epochNanoseconds</em> : bigint) : Temporal.Absolute</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>epochNanoseconds</code> (bigint): A number of nanoseconds.</li>
</ul>
<p><strong>Returns:</strong> a new <code>Temporal.Absolute</code> object.</p>
<p>Same as <code>Temporal.Absolute.fromEpochSeconds()</code>, but with nanosecond (10<sup>&minus;9</sup> second) precision.
Also the same as <code>new Temporal.Absolute(epochNanoseconds)</code>.</p>
<h3 id="temporalabsolutecompareone-temporalabsolute-two-temporalabsolute--number">Temporal.Absolute.<strong>compare</strong>(<em>one</em>: Temporal.Absolute, <em>two</em>: Temporal.Absolute) : number</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>one</code> (<code>Temporal.Absolute</code>): First time to compare.</li>
<li><code>two</code> (<code>Temporal.Absolute</code>): Second time to compare.</li>
</ul>
<p><strong>Returns:</strong> &minus;1, 0, or 1.</p>
<p>Compares two <code>Temporal.Absolute</code> objects.
Returns an integer indicating whether <code>one</code> comes before or after or is equal to <code>two</code>.</p>
<ul>
<li>&minus;1 if <code>one</code> comes before <code>two</code>;</li>
<li>0 if <code>one</code> and <code>two</code> represent the same time;</li>
<li>1 if <code>one</code> comes after <code>two</code>.</li>
</ul>
<p>This function can be used to sort arrays of <code>Temporal.Absolute</code> objects.
For example:</p>
<pre><code class="language-javascript">one = Temporal.Absolute.fromEpochSeconds(1.0e9);
two = Temporal.Absolute.fromEpochSeconds(1.1e9);
three = Temporal.Absolute.fromEpochSeconds(1.2e9);
sorted = [three, one, two].sort(Temporal.Absolute.compare);
sorted.join(&#39; &#39;);
// =&gt; 2001-09-09T01:46:40Z 2004-11-09T11:33:20Z 2008-01-10T21:20Z</code></pre>
<h2 id="methods">Methods</h2>
<h3 id="absolutegetepochseconds--number">absolute.<strong>getEpochSeconds</strong>() : number</h3>
<p><strong>Returns:</strong> an integer number of seconds.</p>
<p>Returns the number of seconds between the Unix epoch (midnight UTC on January 1, 1970) and <code>absolute</code>.
This number will be negative if <code>absolute</code> is before 1970.
The number of seconds is rounded towards zero.</p>
<p>Use this method if you need to interface with some other system that reckons time in seconds since the Unix epoch.</p>
<p>Example usage:</p>
<pre><code class="language-js">abs = Temporal.Absolute.from(&#39;2019-03-30T01:45+01:00&#39;);
abs.getEpochSeconds();  // =&gt; 1554000300</code></pre>
<h3 id="absolutegetepochmilliseconds--number">absolute.<strong>getEpochMilliseconds</strong>() : number</h3>
<p><strong>Returns:</strong> an integer number of milliseconds.</p>
<p>Same as <code>getEpochSeconds()</code>, but with millisecond (10<sup>&minus;3</sup> second) precision.</p>
<p>This method can be useful in particular to create an old-style JavaScript <code>Date</code> object, if one is needed.
An example:</p>
<pre><code class="language-js">abs = Temporal.Absolute.from(&#39;2019-03-30T00:45Z&#39;);
new Date(abs.getEpochMilliseconds());  // =&gt; 2019-03-30T00:45:00.000Z</code></pre>
<h3 id="absolutegetepochmicroseconds--bigint">absolute.<strong>getEpochMicroseconds</strong>() : bigint</h3>
<p><strong>Returns:</strong> a number of microseconds, as a bigint.</p>
<p>Same as <code>getEpochSeconds()</code>, but with microsecond (10<sup>&minus;6</sup> second) precision.</p>
<h3 id="absolutegetepochnanoseconds--bigint">absolute.<strong>getEpochNanoseconds</strong>() : bigint</h3>
<p><strong>Returns:</strong> a number of nanoseconds, as a bigint.</p>
<p>Same as <code>getEpochSeconds()</code>, but with nanosecond (10<sup>&minus;9</sup> second) precision.</p>
<p>The value returned from this method is suitable to be passed to <code>new Temporal.Absolute()</code>.</p>
<h3 id="absoluteintimezonetimezone-temporaltimezone--string--temporaldatetime">absolute.<strong>inTimeZone</strong>(<em>timeZone</em>: Temporal.TimeZone | string) : Temporal.DateTime</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>timeZone</code> (object or string): A <code>Temporal.TimeZone</code> object, or a string description of the time zone; either its IANA name or UTC offset.</li>
</ul>
<p><strong>Returns:</strong> a <code>Temporal.DateTime</code> object indicating the calendar date and wall-clock time in <code>timeZone</code> at the absolute time indicated by <code>absolute</code>.</p>
<p>For a list of IANA time zone names, see the current version of the <a href="https://www.iana.org/time-zones">IANA time zone database</a>.
A convenient list is also available <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">on Wikipedia</a>, although it might not reflect the latest official status.</p>
<p>This method is one way to convert a <code>Temporal.Absolute</code> to a <code>Temporal.DateTime</code>.</p>
<p>Example usage:</p>
<pre><code class="language-js">// Converting a specific absolute time to a calendar date / wall-clock time
timestamp = new Temporal.Absolute(1553993100000000000n);
timestamp.inTimeZone(&#39;Europe/Berlin&#39;);  // =&gt; 2019-03-31T01:45
timestamp.inTimeZone(&#39;UTC&#39;);  // =&gt; 2019-03-31T00:45
timestamp.inTimeZone(&#39;-08:00&#39;);  // =&gt; 2019-02-01T16:45

// What time was the Unix epoch (timestamp 0) in Bell Labs (Murray Hill, New Jersey, USA)?
epoch = new Temporal.Absolute(0n);
tz = new Temporal.TimeZone(&#39;America/New_York&#39;);
epoch.inTimeZone(tz);  // =&gt; 1969-12-31T19:00</code></pre>
<h3 id="absoluteplusduration-object--temporalabsolute">absolute.<strong>plus</strong>(<em>duration</em>: object) : Temporal.Absolute</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>duration</code> (object): A <code>Temporal.Duration</code> object or a duration-like object.</li>
</ul>
<p><strong>Returns:</strong> a new <code>Temporal.Absolute</code> object which is the time indicated by <code>absolute</code> plus <code>duration</code>.</p>
<p>This method adds <code>duration</code> to <code>absolute</code>, returning a point in time that is in the future relative to <code>absolute</code>.</p>
<p>The <code>duration</code> argument is an object with properties denoting a duration, such as <code>{ hours: 5, minutes: 30 }</code>, or a <code>Temporal.Duration</code> object.</p>
<p>The <code>years</code> and <code>months</code> fields of <code>duration</code> must be zero, because adding a year or a month to a <code>Temporal.Absolute</code> is invalid and will throw a <code>RangeError</code>.
<code>Temporal.Absolute</code> is independent of time zones and calendars, and so years and months may be different lengths.
If you need to do this, convert the <code>Temporal.Absolute</code> to a <code>Temporal.DateTime</code> by specifying the desired time zone, add the duration, and then convert it back.</p>
<p>If the result is outside the allowed range for <code>Temporal.Absolute</code>, a <code>RangeError</code> will be thrown.</p>
<p>Example usage:</p>
<pre><code class="language-js">// Temporal.Absolute representing five hours from now
Temporal.now.absolute().plus({ hours: 5 });
fiveHours = new Temporal.Duration(0, 0, 0, 5);
Temporal.now.absolute().plus(fiveHours);</code></pre>
<h3 id="absoluteminusduration-object--temporalabsolute">absolute.<strong>minus</strong>(<em>duration</em>: object) : Temporal.Absolute</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>duration</code> (object): A <code>Temporal.Duration</code> object or a duration-like object.</li>
</ul>
<p><strong>Returns:</strong> a new <code>Temporal.Absolute</code> object which is the time indicated by <code>absolute</code> minus <code>duration</code>.</p>
<p>This method subtracts <code>duration</code> from <code>absolute</code>, returning a point in time that is in the past relative to <code>absolute</code>.</p>
<p>The <code>duration</code> argument is an object with properties denoting a duration, such as <code>{ hours: 5, minutes: 30 }</code>, or a <code>Temporal.Duration</code> object.</p>
<p>The <code>years</code> and <code>months</code> fields of <code>duration</code> must be zero, because subtracting a year or a month from a <code>Temporal.Absolute</code> is invalid and will throw a <code>RangeError</code>.
<code>Temporal.Absolute</code> is independent of time zones and calendars, and so years and months may be different lengths.
If you need to do this, convert the <code>Temporal.Absolute</code> to a <code>Temporal.DateTime</code> by specifying the desired time zone, subtract the duration, and then convert it back.</p>
<p>If the result is outside the allowed range for <code>Temporal.Absolute</code>, a <code>RangeError</code> will be thrown.</p>
<p>Example usage:</p>
<pre><code class="language-js">// Temporal.Absolute representing this time yesterday
Temporal.now.absolute().minus({ days: 1 });
oneDay = new Temporal.Duration(0, 0, 1);
Temporal.now.absolute().minus(oneDay);</code></pre>
<h3 id="absolutedifferenceother-temporalabsolute-options-object--temporalduration">absolute.<strong>difference</strong>(<em>other</em>: Temporal.Absolute, <em>options</em>?: object) : Temporal.Duration</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>other</code> (<code>Temporal.Absolute</code>): Another time with which to compute the difference.</li>
<li><code>options</code> (optional object): An object with properties representing options for the operation.
The following options are recognized:<ul>
<li><code>largestUnit</code> (string): The largest unit of time to allow in the resulting <code>Temporal.Duration</code> object.
Valid values are <code>&#39;days&#39;</code>, <code>&#39;hours&#39;</code>, <code>&#39;minutes&#39;</code>, and <code>&#39;seconds&#39;</code>.
The default is <code>&quot;seconds&quot;</code>.</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> a <code>Temporal.Duration</code> representing the difference between <code>absolute</code> and <code>other</code>.</p>
<p>This method computes the difference between the two times represented by <code>absolute</code> and <code>other</code>, and returns it as a <code>Temporal.Duration</code> object.
The difference is always positive, no matter the order of <code>absolute</code> and <code>other</code>, because <code>Temporal.Duration</code> objects cannot represent negative durations.</p>
<p>The <code>largestUnit</code> option controls how the resulting duration is expressed.
The returned <code>Temporal.Duration</code> object will not have any nonzero fields that are larger than the unit in <code>largestUnit</code>.
A difference of two hours will become 7200 seconds when <code>largestUnit</code> is <code>&quot;seconds&quot;</code>, for example.
However, a difference of 30 seconds will still be 30 seconds even if <code>largestUnit</code> is <code>&quot;hours&quot;</code>.</p>
<p>By default, the largest unit in the result is seconds.
Unlike other Temporal types, months and years are not allowed.
This is because in the ISO calendar, months and years can be different lengths depending on which month is meant and whether the year is a leap year.
<code>Temporal.Absolute</code> is intended to be calendar-independent and therefore free of these ambiguities.</p>
<p>Example usage:</p>
<pre><code class="language-js">startOfMoonMission = Temporal.Absolute.from(&#39;1969-07-16T13:32:00Z&#39;);
endOfMoonMission = Temporal.Absolute.from(&#39;1969-07-24T16:50:35Z&#39;);
missionLength = startOfMoonMission.difference(endOfMoonMission, { largestUnit: &#39;days&#39; });
  // =&gt; P8DT3H18M35S
endOfMoonMission.difference(startOfMoonMission, { largestUnit: &#39;days&#39; });
  // =&gt; P8DT3H18M35S
missionLength.toLocaleString();
  // example output: &#39;8 days 3 hours 18 minutes 35 seconds&#39;

// A billion (10^9) seconds since the epoch in different units
epoch = new Temporal.Absolute(0n);
billion = Temporal.Absolute.fromEpochSeconds(1e9);
epoch.difference(billion);  // =&gt; PT1000000000S
epoch.difference(billion, { largestUnit: &#39;hours&#39; })  // =&gt; PT277777H46M40S
epoch.difference(billion, { largestUnit: &#39;days&#39; })  // =&gt; P11574DT1H46M40S

// If you really need to calculate the difference between two Absolutes
// in years, you can eliminate the ambiguity by choosing your starting
// point explicitly. For example, using the corresponding UTC date:
utc = Temporal.TimeZone.from(&#39;UTC&#39;);
epoch.inTimeZone(utc).difference(billion.inTimeZone(utc), { largestUnit: &#39;years&#39; });
  // =&gt; P31Y8M8DT1H46M40S</code></pre>
<h3 id="absolutetostringtimezone-temporaltimezone--string--string">absolute.<strong>toString</strong>(<em>timeZone</em>?: Temporal.TimeZone | string) : string</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>timeZone</code> (optional string or <code>Temporal.TimeZone</code>): the time zone to express <code>absolute</code> in.
The default is to use UTC.</li>
</ul>
<p><strong>Returns:</strong> a string in the ISO 8601 date format representing <code>absolute</code>.</p>
<p>This method overrides the <code>Object.prototype.toString()</code> method and provides a convenient, unambiguous string representation of <code>absolute</code>.
The string can be passed to <code>Temporal.Absolute.from()</code> to create a new <code>Temporal.Absolute</code> object.</p>
<p>Example usage:</p>
<pre><code class="language-js">abs = new Temporal.Absolute(1574074321816000000n);
abs.toString();  // =&gt; 2019-11-18T10:52:01.816Z
abs.toString(Temporal.TimeZone.from(&#39;UTC&#39;));  // =&gt; 2019-11-18T10:52:01.816Z
abs.toString(&#39;Asia/Seoul&#39;);  // =&gt; 2019-11-18T19:52:01.816+09:00[Asia/Seoul]</code></pre>
<h3 id="absolutetolocalestringlocales-string--arraystring-options-object--string">absolute.<strong>toLocaleString</strong>(<em>locales</em>?: string | array&lt;string&gt;, <em>options</em>?: object) : string</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>locales</code> (optional string or array of strings): A string with a BCP 47 language tag with an optional Unicode extension key, or an array of such strings.</li>
<li><code>options</code> (optional object): An object with properties influencing the formatting.</li>
</ul>
<p><strong>Returns:</strong> a language-sensitive representation of <code>absolute</code>.</p>
<p>This method overrides <code>Object.prototype.toLocaleString()</code> to provide a human-readable, language-sensitive representation of <code>absolute</code>.</p>
<p>The <code>locales</code> and <code>options</code> arguments are the same as in the constructor to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat"><code>Intl.DateTimeFormat</code></a>.</p>
<p>Example usage:</p>
<pre><code class="language-js">abs = Temporal.Absolute.from(&quot;2019-11-18T11:00:00.000Z&quot;);
abs.toLocaleString();  // =&gt; example output: 2019-11-18, 3:00:00 a.m.
abs.toLocaleString(&#39;de-DE&#39;);  // =&gt; example output: 18.11.2019, 03:00:00
abs.toLocaleString(&#39;de-DE&#39;, {
    timeZone: &#39;Europe/Berlin&#39;,
    weekday: &#39;long&#39;,
});  // =&gt; Montag, 18.11.2019, 12:00:00
abs.toLocaleString(&#39;en-US-u-nu-fullwide-hc-h12&#39;, {
    timeZone: &#39;Asia/Kolkata&#39;,
});  // =&gt; １１/１８/２０１９, ４:３０:００ PM</code></pre>
<h3 id="absolutetojson--string">absolute.<strong>toJSON</strong>() : string</h3>
<p><strong>Returns:</strong> a string in the ISO 8601 date format representing <code>absolute</code>, in the UTC time zone.</p>
<p>This method is like <code>absolute.toString()</code> but always produces a string in UTC time.
It is usually not called directly, but it can be called automatically by <code>JSON.stringify()</code>.</p>
<p>The reverse operation, recovering a <code>Temporal.Absolute</code> object from a string, is <code>Temporal.Absolute.from()</code>, but it cannot be called automatically by <code>JSON.parse()</code>.
If you need to rebuild a <code>Temporal.Absolute</code> object from a JSON string, then you need to know the names of the keys that should be interpreted as <code>Temporal.Absolute</code>s.
In that case you can build a custom &quot;reviver&quot; function for your use case.</p>
<p>Example usage:</p>
<pre><code class="language-js">const meeting = {
  id: 355,
  name: &#39;Budget review&#39;,
  location: &#39;https://meet.jit.si/ObjectiveTomatoesJokeSurely&#39;,
  startAbsolute: Temporal.Absolute.from(&#39;2020-03-30T15:00-04:00[America/New_York]&#39;),
  endAbsolute: Temporal.Absolute.from(&#39;2020-03-30T16:00-04:00[America/New_York]&#39;),
};
const str = JSON.stringify(meeting, null, 2);
console.log(str);
// =&gt;
// {
//   &quot;id&quot;: 355,
//   &quot;name&quot;: &quot;Budget review&quot;,
//   &quot;location&quot;: &quot;https://meet.jit.si/ObjectiveTomatoesJokeSurely&quot;,
//   &quot;startAbsolute&quot;: &quot;2020-03-30T19:00Z&quot;,
//   &quot;endAbsolute&quot;: &quot;2020-03-30T20:00Z&quot;
// }

// To rebuild from the string:
function reviver(key, value) {
  if (key.endsWith(&#39;Absolute&#39;))
    return Temporal.Absolute.from(value);
  return value;
}
JSON.parse(str, reviver);</code></pre>
    <footer>
      <p>
        This page includes a script which loads an implementation of Temporal in your browser.
        You can open a console in your browser's developer tools and try it out directly!
      </p>
      <p>View this or help contribute on <a href="https://github.com/tc39/proposal-temporal">GitHub</a>.</p>
    </footer>
    <script>
      // Add permalinks to all <h3> elements (function documentation headings)
      const h3s = document.getElementsByTagName('h3');
      for (let h3 of h3s) {
        const anchor = document.createElement('a');
        anchor.className = 'heading-link';

        // Use the **function name** as the link ID, otherwise fall back to the
        // ID generated by markdown
        let id = h3.getAttribute('id');
        const bold = h3.getElementsByTagName('strong');
        if (bold[0]) {
          id = bold[0].textContent.replace(/[^a-zA-Z]/g, '-');
          h3.setAttribute('id', id);
        }

        anchor.setAttribute('href', `#${id}`);
        h3.prepend(anchor);
      };
    </script>
  </body>
</html>
